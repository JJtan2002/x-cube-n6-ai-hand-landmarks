ARM GAS  /tmp/cczusFlJ.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 4
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"port.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c"
  25              		.section	.rodata.prvTaskExitError.str1.1,"aMS",%progbits,1
  26              	.LC0:
  27 0000 3000     		.ascii	"0\000"
  28              	.LC1:
  29 0002 4C69622F 		.ascii	"Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_s"
  29      46726565 
  29      52544F53 
  29      2F536F75 
  29      7263652F 
  30 0035 65637572 		.ascii	"ecure/port.c\000"
  30      652F706F 
  30      72742E63 
  30      00
  31              		.section	.text.prvTaskExitError,"ax",%progbits
  32              		.align	1
  33              		.syntax unified
  34              		.thumb
  35              		.thumb_func
  37              	prvTaskExitError:
  38              	.LFB1:
   1:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*
   2:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FreeRTOS Kernel V10.6.2
   3:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
   5:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * SPDX-License-Identifier: MIT
   6:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
   7:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * the Software without restriction, including without limitation the rights to
  10:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * subject to the following conditions:
  13:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
ARM GAS  /tmp/cczusFlJ.s 			page 2


  14:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The above copyright notice and this permission notice shall be included in all
  15:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * copies or substantial portions of the Software.
  16:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  17:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  24:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * https://www.FreeRTOS.org
  25:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * https://github.com/FreeRTOS
  26:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  27:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  28:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  29:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  30:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * all the API functions to use the MPU wrappers. That should only be done when
  31:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * task.h is included from an application file. */
  32:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  33:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  34:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Scheduler includes. */
  35:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "FreeRTOS.h"
  36:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "task.h"
  37:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  38:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* MPU includes. */
  39:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "mpu_wrappers.h"
  40:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "mpu_syscall_numbers.h"
  41:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  42:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Portasm includes. */
  43:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "portasm.h"
  44:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  45:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_TRUSTZONE == 1 )
  46:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Secure components includes. */
  47:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #include "secure_context.h"
  48:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #include "secure_init.h"
  49:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_TRUSTZONE */
  50:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  51:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  52:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  53:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  54:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
  55:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * i.e. the processor boots as secure and never jumps to the non-secure side.
  56:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The Trust Zone support in the port must be disabled in order to run FreeRTOS
  57:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * on the secure side. The following are the valid configuration seetings:
  58:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  59:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1. Run FreeRTOS on the Secure Side:
  60:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
  61:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  62:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
  63:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
  64:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  65:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
  66:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
  67:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  68:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
  69:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
  70:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
ARM GAS  /tmp/cczusFlJ.s 			page 3


  71:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  72:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  73:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  74:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the NVIC.
  75:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  76:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CTRL_REG             ( *( ( volatile uint32_t * ) 0xe000e010 ) )
  77:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_LOAD_REG             ( *( ( volatile uint32_t * ) 0xe000e014 ) )
  78:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CURRENT_VALUE_REG    ( *( ( volatile uint32_t * ) 0xe000e018 ) )
  79:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SHPR3_REG                    ( *( ( volatile uint32_t * ) 0xe000ed20 ) )
  80:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_ENABLE_BIT           ( 1UL << 0UL )
  81:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_INT_BIT              ( 1UL << 1UL )
  82:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CLK_BIT              ( 1UL << 2UL )
  83:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_COUNT_FLAG_BIT       ( 1UL << 16UL )
  84:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PEND_SYSTICK_CLEAR_BIT       ( 1UL << 25UL )
  85:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PEND_SYSTICK_SET_BIT         ( 1UL << 26UL )
  86:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMIN_INTERRUPT_PRIORITY            ( 255UL )
  87:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PENDSV_PRI                   ( portMIN_INTERRUPT_PRIORITY << 16UL )
  88:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_PRI                  ( portMIN_INTERRUPT_PRIORITY << 24UL )
  89:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  90:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  91:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  92:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the SCB.
  93:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  94:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portSCB_SYS_HANDLER_CTRL_STATE_REG    ( *( volatile uint32_t * ) 0xe000ed24 )
  95:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portSCB_MEM_FAULT_ENABLE_BIT          ( 1UL << 16UL )
  96:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  97:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  98:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  99:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to check the validity of an interrupt priority.
 100:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SHPR2_REG                 ( *( ( volatile uint32_t * ) 0xE000ED1C ) )
 102:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFIRST_USER_INTERRUPT_NUMBER    ( 16 )
 103:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_IP_REGISTERS_OFFSET_16    ( 0xE000E3F0 )
 104:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portAIRCR_REG                      ( *( ( volatile uint32_t * ) 0xE000ED0C ) )
 105:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portTOP_BIT_OF_BYTE                ( ( uint8_t ) 0x80 )
 106:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMAX_PRIGROUP_BITS              ( ( uint8_t ) 7 )
 107:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRIORITY_GROUP_MASK            ( 0x07UL << 8UL )
 108:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRIGROUP_SHIFT                 ( 8UL )
 109:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 110:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 111:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 112:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants used during system call enter and exit.
 113:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 114:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPSR_STACK_PADDING_MASK                ( 1UL << 9UL )
 115:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXC_RETURN_STACK_FRAME_TYPE_MASK      ( 1UL << 4UL )
 116:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 117:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 118:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 119:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the FPU.
 120:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 121:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR               ( ( volatile uint32_t * ) 0xe000ed88 )              /* Coprocessor 
 122:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP10_VALUE    ( 3UL )
 123:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP11_VALUE    portCPACR_CP10_VALUE
 124:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP10_POS      ( 20UL )
 125:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP11_POS      ( 22UL )
 126:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 127:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR               ( ( volatile uint32_t * ) 0xe000ef34 )              /* Floating Poi
ARM GAS  /tmp/cczusFlJ.s 			page 4


 128:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_ASPEN_POS     ( 31UL )
 129:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_ASPEN_MASK    ( 1UL << portFPCCR_ASPEN_POS )
 130:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_LSPEN_POS     ( 30UL )
 131:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_LSPEN_MASK    ( 1UL << portFPCCR_LSPEN_POS )
 132:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 133:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 134:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 135:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Offsets in the stack to the parameters when inside the SVC handler.
 136:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 137:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_LR                    ( 5 )
 138:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_PC                    ( 6 )
 139:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_PSR                   ( 7 )
 140:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 141:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 142:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 143:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the MPU.
 144:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 145:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_TYPE_REG                      ( *( ( volatile uint32_t * ) 0xe000ed90 ) )
 146:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_CTRL_REG                      ( *( ( volatile uint32_t * ) 0xe000ed94 ) )
 147:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RNR_REG                       ( *( ( volatile uint32_t * ) 0xe000ed98 ) )
 148:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 149:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_REG                      ( *( ( volatile uint32_t * ) 0xe000ed9c ) )
 150:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_REG                      ( *( ( volatile uint32_t * ) 0xe000eda0 ) )
 151:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 152:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A1_REG                   ( *( ( volatile uint32_t * ) 0xe000eda4 ) )
 153:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A1_REG                   ( *( ( volatile uint32_t * ) 0xe000eda8 ) )
 154:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 155:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A2_REG                   ( *( ( volatile uint32_t * ) 0xe000edac ) )
 156:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A2_REG                   ( *( ( volatile uint32_t * ) 0xe000edb0 ) )
 157:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 158:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A3_REG                   ( *( ( volatile uint32_t * ) 0xe000edb4 ) )
 159:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A3_REG                   ( *( ( volatile uint32_t * ) 0xe000edb8 ) )
 160:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 161:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR0_REG                     ( *( ( volatile uint32_t * ) 0xe000edc0 ) )
 162:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR1_REG                     ( *( ( volatile uint32_t * ) 0xe000edc4 ) )
 163:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 164:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_ADDRESS_MASK             ( 0xffffffe0 ) /* Must be 32-byte aligned. */
 165:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ADDRESS_MASK             ( 0xffffffe0 ) /* Must be 32-byte aligned. */
 166:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 167:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_ACCESS_PERMISSIONS_MASK  ( 3UL << 1UL )
 168:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 169:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR0_POS                ( 0UL )
 170:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR0_MASK               ( 0x000000ff )
 171:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 172:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR1_POS                ( 8UL )
 173:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR1_MASK               ( 0x0000ff00 )
 174:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 175:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR2_POS                ( 16UL )
 176:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR2_MASK               ( 0x00ff0000 )
 177:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 178:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR3_POS                ( 24UL )
 179:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR3_MASK               ( 0xff000000 )
 180:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 181:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR4_POS                ( 0UL )
 182:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR4_MASK               ( 0x000000ff )
 183:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 184:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR5_POS                ( 8UL )
ARM GAS  /tmp/cczusFlJ.s 			page 5


 185:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR5_MASK               ( 0x0000ff00 )
 186:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 187:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR6_POS                ( 16UL )
 188:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR6_MASK               ( 0x00ff0000 )
 189:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 190:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR7_POS                ( 24UL )
 191:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR7_MASK               ( 0xff000000 )
 192:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 193:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX0              ( 0UL << 1UL )
 194:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX1              ( 1UL << 1UL )
 195:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX2              ( 2UL << 1UL )
 196:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX3              ( 3UL << 1UL )
 197:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX4              ( 4UL << 1UL )
 198:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX5              ( 5UL << 1UL )
 199:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX6              ( 6UL << 1UL )
 200:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX7              ( 7UL << 1UL )
 201:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 202:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_REGION_ENABLE            ( 1UL )
 203:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 204:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Enable privileged access to unmapped region. */
 205:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_PRIV_BACKGROUND_ENABLE_BIT    ( 1UL << 2UL )
 206:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 207:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Enable MPU. */
 208:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_ENABLE_BIT                    ( 1UL << 0UL )
 209:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 210:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Expected value of the portMPU_TYPE register. */
 211:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXPECTED_MPU_TYPE_VALUE           ( configTOTAL_MPU_REGIONS << 8UL )
 212:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 213:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Extract first address of the MPU region as encoded in the
 214:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * RBAR (Region Base Address Register) value. */
 215:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXTRACT_FIRST_ADDRESS_FROM_RBAR( rbar ) \
 216:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( rbar ) & portMPU_RBAR_ADDRESS_MASK )
 217:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 218:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Extract last address of the MPU region as encoded in the
 219:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * RLAR (Region Limit Address Register) value. */
 220:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXTRACT_LAST_ADDRESS_FROM_RLAR( rlar ) \
 221:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( rlar ) & portMPU_RLAR_ADDRESS_MASK ) | ~portMPU_RLAR_ADDRESS_MASK )
 222:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 223:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Does addr lies within [start, end] address range? */
 224:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portIS_ADDRESS_WITHIN_RANGE( addr, start, end ) \
 225:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( addr ) >= ( start ) ) && ( ( addr ) <= ( end ) ) )
 226:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 227:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Is the access request satisfied by the available permissions? */
 228:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portIS_AUTHORIZED( accessRequest, permissions ) \
 229:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( permissions ) & ( accessRequest ) ) == accessRequest )
 230:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 231:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Max value that fits in a uint32_t type. */
 232:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portUINT32_MAX    ( ~( ( uint32_t ) 0 ) )
 233:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 234:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Check if adding a and b will result in overflow. */
 235:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portADD_UINT32_WILL_OVERFLOW( a, b )    ( ( a ) > ( portUINT32_MAX - ( b ) ) )
 236:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 237:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 238:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 239:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The maximum 24-bit number.
 240:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 241:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * It is needed because the systick is a 24-bit counter.
ARM GAS  /tmp/cczusFlJ.s 			page 6


 242:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 243:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMAX_24_BIT_NUMBER       ( 0xffffffUL )
 244:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 245:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 246:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief A fiddle factor to estimate the number of SysTick counts that would
 247:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * have occurred while the SysTick counter is stopped during tickless idle
 248:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * calculations.
 249:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 250:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMISSED_COUNTS_FACTOR    ( 94UL )
 251:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 252:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 253:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 254:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to set up the initial stack.
 255:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 256:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_XPSR    ( 0x01000000 )
 257:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 258:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configRUN_FREERTOS_SECURE_ONLY == 1 )
 259:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 260:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 261:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial EXC_RETURN value.
 262:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 263:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *     FF         FF         FF         FD
 264:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1111 1111  1111 1111  1111 1111  1111 1101
 265:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 266:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[6] - 1 --> The exception was taken from the Secure state.
 267:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[5] - 1 --> Do not skip stacking of additional state context.
 268:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
 269:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[3] - 1 --> Return to the Thread mode.
 270:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[2] - 1 --> Restore registers from the process stack.
 271:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[1] - 0 --> Reserved, 0.
 272:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] - 1 --> The exception was taken to the Secure state.
 273:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 274:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portINITIAL_EXC_RETURN    ( 0xfffffffd )
 275:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 276:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 277:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 278:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial EXC_RETURN value.
 279:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 280:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *     FF         FF         FF         BC
 281:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1111 1111  1111 1111  1111 1111  1011 1100
 282:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 283:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
 284:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[5] - 1 --> Do not skip stacking of additional state context.
 285:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
 286:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[3] - 1 --> Return to the Thread mode.
 287:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[2] - 1 --> Restore registers from the process stack.
 288:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[1] - 0 --> Reserved, 0.
 289:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
 290:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 291:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portINITIAL_EXC_RETURN    ( 0xffffffbc )
 292:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configRUN_FREERTOS_SECURE_ONLY */
 293:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 294:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 295:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief CONTROL register privileged bit mask.
 296:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 297:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] in CONTROL register tells the privilege:
 298:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *  Bit[0] = 0 ==> The task is privileged.
ARM GAS  /tmp/cczusFlJ.s 			page 7


 299:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *  Bit[0] = 1 ==> The task is not privileged.
 300:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 301:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCONTROL_PRIVILEGED_MASK         ( 1UL << 0UL )
 302:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 303:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 304:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial CONTROL register values.
 305:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 306:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_CONTROL_UNPRIVILEGED    ( 0x3 )
 307:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_CONTROL_PRIVILEGED      ( 0x2 )
 308:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 309:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 310:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Let the user override the default SysTick clock rate.  If defined by the
 311:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * user, this symbol must equal the SysTick clock rate when the CLK bit is 0 in the
 312:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * configuration register.
 313:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 314:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #ifndef configSYSTICK_CLOCK_HZ
 315:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define configSYSTICK_CLOCK_HZ             ( configCPU_CLOCK_HZ )
 316:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Ensure the SysTick is clocked at the same frequency as the core. */
 317:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portNVIC_SYSTICK_CLK_BIT_CONFIG    ( portNVIC_SYSTICK_CLK_BIT )
 318:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 319:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Select the option to clock SysTick not at the same frequency as the core. */
 320:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portNVIC_SYSTICK_CLK_BIT_CONFIG    ( 0 )
 321:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 322:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 323:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 324:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Let the user override the pre-loading of the initial LR with the
 325:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * address of prvTaskExitError() in case it messes up unwinding of the stack
 326:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * in the debugger.
 327:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 328:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #ifdef configTASK_RETURN_ADDRESS
 329:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portTASK_RETURN_ADDRESS    configTASK_RETURN_ADDRESS
 330:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 331:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portTASK_RETURN_ADDRESS    prvTaskExitError
 332:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 333:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 334:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 335:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
 336:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * when a task is created. This helps in debugging at the cost of code size.
 337:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 338:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRELOAD_REGISTERS    1
 339:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 340:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 341:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief A task is created without a secure context, and must call
 342:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
 343:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * any secure calls.
 344:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 345:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNO_SECURE_CONTEXT    0
 346:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 347:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 348:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 349:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Used to catch tasks that attempt to return from their implementing
 350:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * function.
 351:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 352:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** static void prvTaskExitError( void );
 353:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 354:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 355:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/cczusFlJ.s 			page 8


 356:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 357:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Extract MPU region's access permissions from the Region Base Address
 358:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Register (RBAR) value.
 359:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 360:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ulRBARValue RBAR value for the MPU region.
 361:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 362:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @return uint32_t Access permissions.
 363:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 364:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t prvGetRegionAccessPermissions( uint32_t ulRBARValue ) PRIVILEGED_FUNCTION;
 365:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 366:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 367:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 368:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 369:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 370:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the Memory Protection Unit (MPU).
 371:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 372:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
 373:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 374:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 375:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_FPU == 1 )
 376:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 377:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 378:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the Floating Point Unit (FPU).
 379:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 380:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
 381:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_FPU */
 382:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 383:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 384:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the timer to generate the tick interrupts.
 385:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 386:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The implementation in this file is weak to allow application writers to
 387:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * change the timer used to generate the tick interrupt.
 388:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 389:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
 390:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 391:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 392:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Checks whether the current execution context is interrupt.
 393:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 394:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @return pdTRUE if the current execution context is interrupt, pdFALSE
 395:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * otherwise.
 396:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 397:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortIsInsideInterrupt( void );
 398:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 399:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 400:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Yield the processor.
 401:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 402:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortYield( void ) PRIVILEGED_FUNCTION;
 403:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 404:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 405:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Enter critical section.
 406:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 407:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
 408:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 409:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 410:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Exit from critical section.
 411:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 412:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
ARM GAS  /tmp/cczusFlJ.s 			page 9


 413:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 414:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 415:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief SysTick handler.
 416:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 417:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
 418:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 419:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 420:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief C part of SVC handler.
 421:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 422:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress ) PRIVILEGED_FUNCTION;
 423:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 424:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 425:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 426:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 427:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Sets up the system call stack so that upon returning from
 428:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * SVC, the system call stack is used.
 429:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 430:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param pulTaskStack The current SP when the SVC was raised.
 431:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ulLR The value of Link Register (EXC_RETURN) in the SVC handler.
 432:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ucSystemCallNumber The system call number of the system call.
 433:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 434:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallEnter( uint32_t * pulTaskStack,
 435:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint32_t ulLR,
 436:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint8_t ucSystemCallNumber ) PRIVILEGED_FUNCTION;
 437:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 438:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 439:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 440:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 441:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 442:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 443:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Raise SVC for exiting from a system call.
 444:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 445:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vRequestSystemCallExit( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION;
 446:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 447:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 448:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 449:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 450:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 451:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /**
 452:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @brief Sets up the task stack so that upon returning from
 453:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * SVC, the task stack is used again.
 454:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      *
 455:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @param pulSystemCallStack The current SP when the SVC was raised.
 456:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @param ulLR The value of Link Register (EXC_RETURN) in the SVC handler.
 457:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      */
 458:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallExit( uint32_t * pulSystemCallStack,
 459:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                           uint32_t ulLR ) PRIVILEGED_FUNCTION;
 460:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 461:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 462:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 463:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 464:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 465:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /**
 466:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @brief Checks whether or not the calling task is privileged.
 467:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      *
 468:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @return pdTRUE if the calling task is privileged, pdFALSE otherwise.
 469:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      */
ARM GAS  /tmp/cczusFlJ.s 			page 10


 470:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsTaskPrivileged( void ) PRIVILEGED_FUNCTION;
 471:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 472:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU == 1 */
 473:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 474:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 475:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONT
 476:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 477:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 478:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief This variable is set to pdTRUE when the scheduler is started.
 479:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 480:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static BaseType_t xSchedulerRunning = pdFALSE;
 481:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 482:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 483:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 484:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 485:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Each task maintains its own interrupt status in the critical nesting
 486:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * variable.
 487:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 488:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** PRIVILEGED_DATA static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
 489:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 490:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_TRUSTZONE == 1 )
 491:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 492:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 493:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Saved as part of the task context to indicate which context the
 494:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * task is using on the secure side.
 495:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 496:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_
 497:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_TRUSTZONE */
 498:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 499:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 500:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
 501:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FreeRTOS API functions are not called from interrupts that have been assigned
 502:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
 503:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 504:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
 505:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 506:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint8_t ucMaxSysCallPriority = 0;
 507:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t ulMaxPRIGROUPValue = 0;
 508:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t *
 509:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 510:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) ) */
 511:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 512:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configUSE_TICKLESS_IDLE == 1 )
 513:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 514:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 515:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The number of SysTick increments that make up one tick period.
 516:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 517:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t ulTimerCountsForOneTick = 0;
 518:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 519:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 520:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The maximum number of tick periods that can be suppressed is
 521:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * limited by the 24 bit resolution of the SysTick timer.
 522:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 523:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t xMaximumPossibleSuppressedTicks = 0;
 524:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 525:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 526:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Compensate for the CPU cycles that pass while the SysTick is
ARM GAS  /tmp/cczusFlJ.s 			page 11


 527:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * stopped (low power functionality only).
 528:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 529:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t ulStoppedTimerCompensation = 0;
 530:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 531:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 532:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 533:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configUSE_TICKLESS_IDLE == 1 )
 534:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __attribute__( ( weak ) ) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
 535:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 536:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements, ulSysTickDecre
 537:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         TickType_t xModifiableIdleTime;
 538:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 539:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Make sure the SysTick reload value does not overflow the counter. */
 540:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 541:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 542:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
 543:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 544:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 545:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Enter a critical section but don't use the taskENTER_CRITICAL()
 546:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * method as that will mask interrupts that should exit sleep mode. */
 547:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "cpsid i" ::: "memory" );
 548:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "dsb" );
 549:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "isb" );
 550:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 551:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* If a context switch is pending or a task is waiting for the scheduler
 552:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * to be unsuspended then abandon the low power entry. */
 553:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( eTaskConfirmSleepModeStatus() == eAbortSleep )
 554:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 555:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Re-enable interrupts - see comments above the cpsid instruction
 556:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * above. */
 557:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 558:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 559:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
 560:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 561:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Stop the SysTick momentarily.  The time the SysTick is stopped for
 562:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * is accounted for as best it can be, but using the tickless mode will
 563:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * inevitably result in some tiny drift of the time maintained by the
 564:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * kernel with respect to calendar time. */
 565:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BI
 566:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 567:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the SysTick current-value register to determine the number of
 568:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SysTick decrements remaining until the next tick interrupt.  If the
 569:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * current-value register is zero, then there are actually
 570:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * ulTimerCountsForOneTick decrements remaining, not zero, because the
 571:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SysTick requests the interrupt when decrementing from 1 to 0. */
 572:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulSysTickDecrementsLeft = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 573:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 574:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ulSysTickDecrementsLeft == 0 )
 575:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 576:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulSysTickDecrementsLeft = ulTimerCountsForOneTick;
 577:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 578:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 579:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Calculate the reload value required to wait xExpectedIdleTime
 580:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * tick periods.  -1 is used because this code normally executes part
 581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * way through the first tick period.  But if the SysTick IRQ is now
 582:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * pending, then clear the IRQ, suppressing the first tick, and correct
 583:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the reload value to reflect that the second tick period is already
ARM GAS  /tmp/cczusFlJ.s 			page 12


 584:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * underway.  The expected idle time is always at least two ticks. */
 585:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulReloadValue = ulSysTickDecrementsLeft + ( ulTimerCountsForOneTick * ( xExpectedIdleTi
 586:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 587:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( portNVIC_INT_CTRL_REG & portNVIC_PEND_SYSTICK_SET_BIT ) != 0 )
 588:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 589:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_INT_CTRL_REG = portNVIC_PEND_SYSTICK_CLEAR_BIT;
 590:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulReloadValue -= ulTimerCountsForOneTick;
 591:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 592:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 593:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ulReloadValue > ulStoppedTimerCompensation )
 594:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 595:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulReloadValue -= ulStoppedTimerCompensation;
 596:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 597:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 598:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Set the new reload value. */
 599:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 600:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Clear the SysTick count flag and set the count value back to
 602:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * zero. */
 603:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 604:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 605:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restart SysTick. */
 606:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 607:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 608:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
 609:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * set its parameter to 0 to indicate that its implementation contains
 610:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * its own wait for interrupt or wait for event instruction, and so wfi
 611:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * should not be executed again.  However, the original expected idle
 612:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time variable must remain unmodified, so a copy is taken. */
 613:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xModifiableIdleTime = xExpectedIdleTime;
 614:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
 615:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 616:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( xModifiableIdleTime > 0 )
 617:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 618:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "dsb" ::: "memory" );
 619:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "wfi" );
 620:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "isb" );
 621:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 622:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 623:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
 624:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 625:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Re-enable interrupts to allow the interrupt that brought the MCU
 626:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * out of sleep mode to execute immediately.  See comments above
 627:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the cpsid instruction above. */
 628:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 629:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "dsb" );
 630:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "isb" );
 631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 632:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Disable interrupts again because the clock is about to be stopped
 633:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and interrupts that execute while the clock is stopped will increase
 634:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * any slippage between the time maintained by the RTOS and calendar
 635:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time. */
 636:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsid i" ::: "memory" );
 637:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "dsb" );
 638:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "isb" );
 639:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 640:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Disable the SysTick clock without reading the
ARM GAS  /tmp/cczusFlJ.s 			page 13


 641:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * portNVIC_SYSTICK_CTRL_REG register to ensure the
 642:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
 643:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the time the SysTick is stopped for is accounted for as best it can
 644:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * be, but using the tickless mode will inevitably result in some tiny
 645:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * drift of the time maintained by the kernel with respect to calendar
 646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time*/
 647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BI
 648:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 649:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Determine whether the SysTick has already counted to zero. */
 650:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 651:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 652:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 uint32_t ulCalculatedLoadValue;
 653:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 654:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The tick interrupt ended the sleep (or is now pending), and
 655:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * a new tick period has started.  Reset portNVIC_SYSTICK_LOAD_REG
 656:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * with whatever remains of the new tick period. */
 657:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portN
 658:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 659:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Don't allow a tiny value, or values that have somehow
 660:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * underflowed because the post sleep hook did something
 661:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * that took too long or because the SysTick current-value register
 662:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * is zero. */
 663:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulCalculatedLoadValue <= ulStoppedTimerCompensation ) || ( ulCalculatedLoadVa
 664:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 665:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
 666:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
 667:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 668:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
 669:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 670:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* As the pending tick will be processed as soon as this
 671:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * function exits, the tick value maintained by the tick is stepped
 672:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * forward by one less than the time spent waiting. */
 673:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
 674:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 675:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
 676:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 677:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Something other than the tick interrupt ended the sleep. */
 678:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 679:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Use the SysTick current-value register to determine the
 680:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * number of SysTick decrements remaining until the expected idle
 681:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * time would have ended. */
 682:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulSysTickDecrementsLeft = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 683:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #if ( portNVIC_SYSTICK_CLK_BIT_CONFIG != portNVIC_SYSTICK_CLK_BIT )
 684:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 685:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* If the SysTick is not using the core clock, the current-
 686:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * value register might still be zero here.  In that case, the
 687:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * SysTick didn't load from the reload register, and there are
 688:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * ulReloadValue decrements remaining in the expected idle
 689:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * time, not zero. */
 690:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     if( ulSysTickDecrementsLeft == 0 )
 691:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     {
 692:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ulSysTickDecrementsLeft = ulReloadValue;
 693:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     }
 694:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
 695:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #endif /* portNVIC_SYSTICK_CLK_BIT_CONFIG */
 696:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 697:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Work out how long the sleep lasted rounded to complete tick
ARM GAS  /tmp/cczusFlJ.s 			page 14


 698:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * periods (not the ulReload value which accounted for part
 699:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * ticks). */
 700:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - ul
 701:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 702:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* How many complete tick periods passed while the processor
 703:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * was waiting? */
 704:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
 705:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 706:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The reload value is set to whatever fraction of a single tick
 707:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * period remains. */
 708:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOne
 709:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 710:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 711:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG again,
 712:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * then set portNVIC_SYSTICK_LOAD_REG back to its standard value.  If
 713:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the SysTick is not using the core clock, temporarily configure it to
 714:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * use the core clock.  This configuration forces the SysTick to load
 715:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * from portNVIC_SYSTICK_LOAD_REG immediately instead of at the next
 716:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * cycle of the other clock.  Then portNVIC_SYSTICK_LOAD_REG is ready
 717:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to receive the standard value immediately. */
 718:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 719:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portN
 720:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( portNVIC_SYSTICK_CLK_BIT_CONFIG == portNVIC_SYSTICK_CLK_BIT )
 721:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 722:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 723:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 724:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else
 725:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 726:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The temporary usage of the core clock has served its purpose,
 727:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * as described above.  Resume usage of the other clock. */
 728:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
 729:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 730:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 731:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 732:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* The partial tick period already ended.  Be sure the SysTick
 733:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * counts it only once. */
 734:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0;
 735:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
 736:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 737:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 738:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_
 739:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 740:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* portNVIC_SYSTICK_CLK_BIT_CONFIG */
 741:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 742:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Step the tick to account for any tick periods that elapsed. */
 743:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             vTaskStepTick( ulCompleteTickPeriods );
 744:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 745:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Exit with interrupts enabled. */
 746:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 747:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 748:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 749:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 750:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 751:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 752:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** __attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
 753:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 754:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Calculate the constants required to configure the tick interrupt. */
ARM GAS  /tmp/cczusFlJ.s 			page 15


 755:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configUSE_TICKLESS_IDLE == 1 )
 756:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 757:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 758:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 759:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTIC
 760:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 761:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configUSE_TICKLESS_IDLE */
 762:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 763:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Stop and reset the SysTick. */
 764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = 0UL;
 765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 766:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 767:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Configure SysTick to interrupt at the requested rate. */
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 770:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 771:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 772:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 773:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** static void prvTaskExitError( void )
 774:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
  39              		.loc 1 774 1 view -0
  40              		.cfi_startproc
  41              		@ args = 0, pretend = 0, frame = 8
  42              		@ frame_needed = 0, uses_anonymous_args = 0
 775:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     volatile uint32_t ulDummy = 0UL;
  43              		.loc 1 775 5 view .LVU1
  44              		.loc 1 775 23 is_stmt 0 view .LVU2
  45 0000 0023     		movs	r3, #0
 774:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     volatile uint32_t ulDummy = 0UL;
  46              		.loc 1 774 1 view .LVU3
  47 0002 07B5     		push	{r0, r1, r2, lr}
  48              		.cfi_def_cfa_offset 16
  49              		.cfi_offset 14, -4
  50              		.loc 1 775 23 view .LVU4
  51 0004 0193     		str	r3, [sp, #4]
 776:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 777:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* A function that implements a task must not exit or attempt to return to
 778:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * its caller as there is nothing to return to. If a task wants to exit it
 779:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * should instead call vTaskDelete( NULL ). Artificially force an assert()
 780:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * to be triggered if configASSERT() is defined, then stop here so
 781:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * application writers can catch the error. */
 782:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting == ~0UL );
  52              		.loc 1 782 5 is_stmt 1 view .LVU5
  53 0006 0A4B     		ldr	r3, .L6
  54 0008 1B68     		ldr	r3, [r3]
  55 000a 0133     		adds	r3, r3, #1
  56 000c 08D0     		beq	.L2
  57              	.LBB4:
  58              	.LBI4:
 773:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
  59              		.loc 1 773 13 view .LVU6
  60              	.LBB5:
  61              		.loc 1 782 5 discriminator 1 view .LVU7
  62 000e FFF7FEFF 		bl	ulSetInterruptMask
  63              	.LVL0:
  64              		.loc 1 782 5 discriminator 1 view .LVU8
  65 0012 40F20E31 		movw	r1, #782
ARM GAS  /tmp/cczusFlJ.s 			page 16


  66 0016 074B     		ldr	r3, .L6+4
  67 0018 074A     		ldr	r2, .L6+8
  68 001a 0848     		ldr	r0, .L6+12
  69 001c FFF7FEFF 		bl	__assert_func
  70              	.LVL1:
  71              	.L2:
  72              	.LBE5:
  73              	.LBE4:
  74              		.loc 1 782 46 discriminator 2 view .LVU9
 783:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portDISABLE_INTERRUPTS();
  75              		.loc 1 783 5 view .LVU10
  76 0020 FFF7FEFF 		bl	ulSetInterruptMask
  77              	.LVL2:
 784:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 785:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     while( ulDummy == 0 )
  78              		.loc 1 785 5 view .LVU11
  79              	.L3:
 786:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 787:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* This file calls prvTaskExitError() after the scheduler has been
 788:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * started to remove a compiler warning about the function being
 789:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * defined but never called.  ulDummy is used purely to quieten other
 790:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * warnings about code appearing after this function is called - making
 791:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * ulDummy volatile makes the compiler think the function could return
 792:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * and therefore not output an 'unreachable code' warning for code that
 793:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * appears after it. */
 794:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
  80              		.loc 1 794 5 view .LVU12
 785:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
  81              		.loc 1 785 20 discriminator 1 view .LVU13
  82 0024 019B     		ldr	r3, [sp, #4]
  83 0026 002B     		cmp	r3, #0
  84 0028 FCD0     		beq	.L3
 795:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
  85              		.loc 1 795 1 is_stmt 0 view .LVU14
  86 002a 03B0     		add	sp, sp, #12
  87              		.cfi_def_cfa_offset 4
  88              		@ sp needed
  89 002c 5DF804FB 		ldr	pc, [sp], #4
  90              	.L7:
  91              		.align	2
  92              	.L6:
  93 0030 00000000 		.word	ulCriticalNesting
  94 0034 00000000 		.word	.LC0
  95 0038 00000000 		.word	__func__.3
  96 003c 02000000 		.word	.LC1
  97              		.cfi_endproc
  98              	.LFE1:
 100              		.section	.text.vPortSetupTimerInterrupt,"ax",%progbits
 101              		.align	1
 102              		.weak	vPortSetupTimerInterrupt
 103              		.syntax unified
 104              		.thumb
 105              		.thumb_func
 107              	vPortSetupTimerInterrupt:
 108              	.LFB0:
 753:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Calculate the constants required to configure the tick interrupt. */
 109              		.loc 1 753 1 is_stmt 1 view -0
ARM GAS  /tmp/cczusFlJ.s 			page 17


 110              		.cfi_startproc
 111              		@ args = 0, pretend = 0, frame = 0
 112              		@ frame_needed = 0, uses_anonymous_args = 0
 113              		@ link register save eliminated.
 764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 114              		.loc 1 764 5 view .LVU16
 764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 115              		.loc 1 764 31 is_stmt 0 view .LVU17
 116 0000 4FF0E022 		mov	r2, #-536813568
 117 0004 0023     		movs	r3, #0
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 118              		.loc 1 768 58 view .LVU18
 119 0006 4FF47A71 		mov	r1, #1000
 764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 120              		.loc 1 764 31 view .LVU19
 121 000a 1361     		str	r3, [r2, #16]
 765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 122              		.loc 1 765 5 is_stmt 1 view .LVU20
 765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 123              		.loc 1 765 40 is_stmt 0 view .LVU21
 124 000c 9361     		str	r3, [r2, #24]
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 125              		.loc 1 768 5 is_stmt 1 view .LVU22
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 126              		.loc 1 768 58 is_stmt 0 view .LVU23
 127 000e 044B     		ldr	r3, .L9
 128 0010 1B68     		ldr	r3, [r3]
 129 0012 B3FBF1F3 		udiv	r3, r3, r1
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 130              		.loc 1 768 81 view .LVU24
 131 0016 013B     		subs	r3, r3, #1
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
 132              		.loc 1 768 31 view .LVU25
 133 0018 5361     		str	r3, [r2, #20]
 769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 134              		.loc 1 769 5 is_stmt 1 view .LVU26
 769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 135              		.loc 1 769 31 is_stmt 0 view .LVU27
 136 001a 0723     		movs	r3, #7
 137 001c 1361     		str	r3, [r2, #16]
 770:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 138              		.loc 1 770 1 view .LVU28
 139 001e 7047     		bx	lr
 140              	.L10:
 141              		.align	2
 142              	.L9:
 143 0020 00000000 		.word	SystemCoreClock
 144              		.cfi_endproc
 145              	.LFE0:
 147              		.section	.text.vPortYield,"ax",%progbits
 148              		.align	1
 149              		.global	vPortYield
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 154              	vPortYield:
 155              	.LFB3:
ARM GAS  /tmp/cczusFlJ.s 			page 18


 796:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 797:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 798:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 799:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t prvGetRegionAccessPermissions( uint32_t ulRBARValue ) /* PRIVILEGED_FUNCTION */
 800:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 801:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulAccessPermissions = 0;
 802:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 803:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_ONLY )
 804:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 805:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulAccessPermissions = tskMPU_READ_PERMISSION;
 806:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 807:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 808:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_WRITE )
 809:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 810:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulAccessPermissions = ( tskMPU_READ_PERMISSION | tskMPU_WRITE_PERMISSION );
 811:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 812:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 813:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return ulAccessPermissions;
 814:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 815:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 816:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 817:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 818:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 819:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
 820:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 821:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
 822:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
 823:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
 824:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_start__;
 825:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_end__;
 826:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
 827:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
 828:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __unprivileged_flash_start__;
 829:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __unprivileged_flash_end__;
 830:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_start__;
 831:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_end__;
 832:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else /* if defined( __ARMCC_VERSION ) */
 833:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
 834:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_start__[];
 835:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_end__[];
 836:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
 837:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
 838:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __unprivileged_flash_start__[];
 839:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __unprivileged_flash_end__[];
 840:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_start__[];
 841:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_end__[];
 842:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
 843:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 844:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* The only permitted number of regions are 8 or 16. */
 845:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( configTOTAL_MPU_REGIONS == 8 ) || ( configTOTAL_MPU_REGIONS == 16 ) );
 846:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 847:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Ensure that the configTOTAL_MPU_REGIONS is configured correctly. */
 848:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE );
 849:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 850:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the MPU is present. */
 851:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
 852:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
ARM GAS  /tmp/cczusFlJ.s 			page 19


 853:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* MAIR0 - Index 0. */
 854:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATT
 855:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* MAIR0 - Index 1. */
 856:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & port
 857:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 858:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup privileged flash as Read Only so that privileged tasks can
 859:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * read it but not modify. */
 860:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
 861:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADD
 862:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 863:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_PRIVILEGED_READ_ONLY );
 864:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRE
 865:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 866:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 867:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 868:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup unprivileged flash as Read Only by both privileged and
 869:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * unprivileged tasks. All tasks can read it but no-one can modify. */
 870:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
 871:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRE
 872:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 873:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_READ_ONLY );
 874:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS
 875:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 876:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 877:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 878:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup unprivileged syscalls flash as Read Only by both privileged
 879:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and unprivileged tasks. All tasks can read it but no-one can modify. */
 880:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
 881:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_M
 882:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 883:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_READ_ONLY );
 884:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MAS
 885:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 886:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 887:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 888:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup RAM containing kernel data for privileged access only. */
 889:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
 890:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_
 891:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 892:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
 893:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_EXECUTE_NEVER );
 894:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MA
 895:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 896:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 897:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 898:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable mem fault. */
 899:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
 900:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 901:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable MPU with privileged background access i.e. unmapped
 902:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * regions have privileged access. */
 903:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
 904:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 905:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 906:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 907:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 908:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 909:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_FPU == 1 )
ARM GAS  /tmp/cczusFlJ.s 			page 20


 910:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
 911:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 912:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
 913:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 914:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable non-secure access to the FPU. */
 915:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             SecureInit_EnableNSFPUAccess();
 916:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 917:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
 918:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 919:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* CP10 = 11 ==> Full access to FPU i.e. both privileged and
 920:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * unprivileged code should be able to access FPU. CP11 should be
 921:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * programmed to the same value as CP10. */
 922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         *( portCPACR ) |= ( ( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
 923:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             ( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
 924:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             );
 925:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 926:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* ASPEN = 1 ==> Hardware should automatically preserve floating point
 927:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * context on exception entry and restore on exception return.
 928:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * LSPEN = 1 ==> Enable lazy context save of FP state. */
 929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         *( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
 930:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 931:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_FPU */
 932:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 933:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 934:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortYield( void ) /* PRIVILEGED_FUNCTION */
 935:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 156              		.loc 1 935 1 is_stmt 1 view -0
 157              		.cfi_startproc
 158              		@ args = 0, pretend = 0, frame = 0
 159              		@ frame_needed = 0, uses_anonymous_args = 0
 160              		@ link register save eliminated.
 936:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Set a PendSV to request a context switch. */
 937:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 161              		.loc 1 937 5 view .LVU30
 162              		.loc 1 937 27 is_stmt 0 view .LVU31
 163 0000 4FF0E023 		mov	r3, #-536813568
 164 0004 4FF08052 		mov	r2, #268435456
 165 0008 C3F8042D 		str	r2, [r3, #3332]
 938:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 939:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Barriers are normally not required but do ensure the code is
 940:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * completely within the specified behaviour for the architecture. */
 941:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "dsb" ::: "memory" );
 166              		.loc 1 941 5 is_stmt 1 view .LVU32
 167              		.syntax unified
 168              	@ 941 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 169 000c BFF34F8F 		dsb
 170              	@ 0 "" 2
 942:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "isb" );
 171              		.loc 1 942 5 view .LVU33
 172              	@ 942 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 173 0010 BFF36F8F 		isb
 174              	@ 0 "" 2
 943:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 175              		.loc 1 943 1 is_stmt 0 view .LVU34
 176              		.thumb
 177              		.syntax unified
 178 0014 7047     		bx	lr
ARM GAS  /tmp/cczusFlJ.s 			page 21


 179              		.cfi_endproc
 180              	.LFE3:
 182              		.section	.text.vPortEnterCritical,"ax",%progbits
 183              		.align	1
 184              		.global	vPortEnterCritical
 185              		.syntax unified
 186              		.thumb
 187              		.thumb_func
 189              	vPortEnterCritical:
 190              	.LFB4:
 944:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 945:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 946:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
 947:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 191              		.loc 1 947 1 is_stmt 1 view -0
 192              		.cfi_startproc
 193              		@ args = 0, pretend = 0, frame = 0
 194              		@ frame_needed = 0, uses_anonymous_args = 0
 948:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portDISABLE_INTERRUPTS();
 195              		.loc 1 948 5 view .LVU36
 947:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portDISABLE_INTERRUPTS();
 196              		.loc 1 947 1 is_stmt 0 view .LVU37
 197 0000 08B5     		push	{r3, lr}
 198              		.cfi_def_cfa_offset 8
 199              		.cfi_offset 3, -8
 200              		.cfi_offset 14, -4
 201              		.loc 1 948 5 view .LVU38
 202 0002 FFF7FEFF 		bl	ulSetInterruptMask
 203              	.LVL3:
 949:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting++;
 204              		.loc 1 949 5 is_stmt 1 view .LVU39
 205              		.loc 1 949 22 is_stmt 0 view .LVU40
 206 0006 044A     		ldr	r2, .L13
 207 0008 1368     		ldr	r3, [r2]
 208 000a 0133     		adds	r3, r3, #1
 209 000c 1360     		str	r3, [r2]
 950:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 951:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Barriers are normally not required but do ensure the code is
 952:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * completely within the specified behaviour for the architecture. */
 953:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "dsb" ::: "memory" );
 210              		.loc 1 953 5 is_stmt 1 view .LVU41
 211              		.syntax unified
 212              	@ 953 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 213 000e BFF34F8F 		dsb
 214              	@ 0 "" 2
 954:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "isb" );
 215              		.loc 1 954 5 view .LVU42
 216              	@ 954 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 217 0012 BFF36F8F 		isb
 218              	@ 0 "" 2
 955:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 219              		.loc 1 955 1 is_stmt 0 view .LVU43
 220              		.thumb
 221              		.syntax unified
 222 0016 08BD     		pop	{r3, pc}
 223              	.L14:
 224              		.align	2
ARM GAS  /tmp/cczusFlJ.s 			page 22


 225              	.L13:
 226 0018 00000000 		.word	ulCriticalNesting
 227              		.cfi_endproc
 228              	.LFE4:
 230              		.section	.text.vPortExitCritical,"ax",%progbits
 231              		.align	1
 232              		.global	vPortExitCritical
 233              		.syntax unified
 234              		.thumb
 235              		.thumb_func
 237              	vPortExitCritical:
 238              	.LFB5:
 956:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 957:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 958:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
 959:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 239              		.loc 1 959 1 is_stmt 1 view -0
 240              		.cfi_startproc
 241              		@ args = 0, pretend = 0, frame = 0
 242              		@ frame_needed = 0, uses_anonymous_args = 0
 960:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting );
 243              		.loc 1 960 5 view .LVU45
 959:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting );
 244              		.loc 1 959 1 is_stmt 0 view .LVU46
 245 0000 08B5     		push	{r3, lr}
 246              		.cfi_def_cfa_offset 8
 247              		.cfi_offset 3, -8
 248              		.cfi_offset 14, -4
 249              		.loc 1 960 5 view .LVU47
 250 0002 0B4B     		ldr	r3, .L18
 251 0004 1A68     		ldr	r2, [r3]
 252 0006 42B9     		cbnz	r2, .L16
 253              		.loc 1 960 5 is_stmt 1 discriminator 1 view .LVU48
 254 0008 FFF7FEFF 		bl	ulSetInterruptMask
 255              	.LVL4:
 256              		.loc 1 960 5 discriminator 1 view .LVU49
 257 000c 4FF47071 		mov	r1, #960
 258 0010 084B     		ldr	r3, .L18+4
 259 0012 094A     		ldr	r2, .L18+8
 260 0014 0948     		ldr	r0, .L18+12
 261 0016 FFF7FEFF 		bl	__assert_func
 262              	.LVL5:
 263              	.L16:
 264              		.loc 1 960 38 discriminator 2 view .LVU50
 961:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting--;
 265              		.loc 1 961 5 view .LVU51
 266              		.loc 1 961 22 is_stmt 0 view .LVU52
 267 001a 1A68     		ldr	r2, [r3]
 268 001c 013A     		subs	r2, r2, #1
 269 001e 1A60     		str	r2, [r3]
 962:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 963:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     if( ulCriticalNesting == 0 )
 270              		.loc 1 963 5 is_stmt 1 view .LVU53
 271              		.loc 1 963 27 is_stmt 0 view .LVU54
 272 0020 1868     		ldr	r0, [r3]
 273              		.loc 1 963 7 view .LVU55
 274 0022 18B9     		cbnz	r0, .L15
ARM GAS  /tmp/cczusFlJ.s 			page 23


 964:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 965:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portENABLE_INTERRUPTS();
 275              		.loc 1 965 9 is_stmt 1 view .LVU56
 966:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 967:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 276              		.loc 1 967 1 is_stmt 0 view .LVU57
 277 0024 BDE80840 		pop	{r3, lr}
 278              		.cfi_remember_state
 279              		.cfi_restore 14
 280              		.cfi_restore 3
 281              		.cfi_def_cfa_offset 0
 965:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 282              		.loc 1 965 9 view .LVU58
 283 0028 FFF7FEBF 		b	vClearInterruptMask
 284              	.LVL6:
 285              	.L15:
 286              		.cfi_restore_state
 287              		.loc 1 967 1 view .LVU59
 288 002c 08BD     		pop	{r3, pc}
 289              	.L19:
 290 002e 00BF     		.align	2
 291              	.L18:
 292 0030 00000000 		.word	ulCriticalNesting
 293 0034 00000000 		.word	.LC0
 294 0038 00000000 		.word	__func__.5
 295 003c 02000000 		.word	.LC1
 296              		.cfi_endproc
 297              	.LFE5:
 299              		.section	.text.SysTick_Handler,"ax",%progbits
 300              		.align	1
 301              		.global	SysTick_Handler
 302              		.syntax unified
 303              		.thumb
 304              		.thumb_func
 306              	SysTick_Handler:
 307              	.LFB6:
 968:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 969:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 970:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
 971:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 308              		.loc 1 971 1 is_stmt 1 view -0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 0
 311              		@ frame_needed = 0, uses_anonymous_args = 0
 972:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulPreviousMask;
 312              		.loc 1 972 5 view .LVU61
 973:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 974:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 313              		.loc 1 974 5 view .LVU62
 971:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulPreviousMask;
 314              		.loc 1 971 1 is_stmt 0 view .LVU63
 315 0000 10B5     		push	{r4, lr}
 316              		.cfi_def_cfa_offset 8
 317              		.cfi_offset 4, -8
 318              		.cfi_offset 14, -4
 319              		.loc 1 974 22 view .LVU64
 320 0002 FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/cczusFlJ.s 			page 24


 321              	.LVL7:
 322 0006 0446     		mov	r4, r0
 323              	.LVL8:
 975:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 976:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Increment the RTOS tick. */
 977:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xTaskIncrementTick() != pdFALSE )
 324              		.loc 1 977 9 is_stmt 1 view .LVU65
 325              		.loc 1 977 13 is_stmt 0 view .LVU66
 326 0008 FFF7FEFF 		bl	xTaskIncrementTick
 327              	.LVL9:
 328              		.loc 1 977 11 discriminator 1 view .LVU67
 329 000c 28B1     		cbz	r0, .L21
 978:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 979:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Pend a context switch. */
 980:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 330              		.loc 1 980 13 is_stmt 1 view .LVU68
 331              		.loc 1 980 35 is_stmt 0 view .LVU69
 332 000e 4FF0E023 		mov	r3, #-536813568
 333 0012 4FF08052 		mov	r2, #268435456
 334 0016 C3F8042D 		str	r2, [r3, #3332]
 335              	.L21:
 981:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 982:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 983:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 336              		.loc 1 983 5 is_stmt 1 view .LVU70
 337 001a 2046     		mov	r0, r4
 984:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 338              		.loc 1 984 1 is_stmt 0 view .LVU71
 339 001c BDE81040 		pop	{r4, lr}
 340              		.cfi_restore 14
 341              		.cfi_restore 4
 342              		.cfi_def_cfa_offset 0
 343              	.LVL10:
 983:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 344              		.loc 1 983 5 view .LVU72
 345 0020 FFF7FEBF 		b	vClearInterruptMask
 346              	.LVL11:
 983:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 347              		.loc 1 983 5 view .LVU73
 348              		.cfi_endproc
 349              	.LFE6:
 351              		.section	.text.vPortSVCHandler_C,"ax",%progbits
 352              		.align	1
 353              		.global	vPortSVCHandler_C
 354              		.syntax unified
 355              		.thumb
 356              		.thumb_func
 358              	vPortSVCHandler_C:
 359              	.LVL12:
 360              	.LFB7:
 985:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 986:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 987:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortSVCHandler_C( uint32_t * pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD 
 988:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 361              		.loc 1 988 1 is_stmt 1 view -0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cczusFlJ.s 			page 25


 364              		@ frame_needed = 0, uses_anonymous_args = 0
 989:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) )
 990:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
 991:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
 992:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
 993:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
 994:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
 995:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
 996:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
 997:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
 998:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
 999:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
1000:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) */
1001:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1002:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulPC;
 365              		.loc 1 1002 5 view .LVU75
1003:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1004:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configENABLE_TRUSTZONE == 1 )
1005:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulR0, ulR1;
1006:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1007:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_MPU == 1 )
1008:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             uint32_t ulControl, ulIsTaskPrivileged;
1009:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_MPU */
1010:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configENABLE_TRUSTZONE */
1011:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint8_t ucSVCNumber;
 366              		.loc 1 1011 5 view .LVU76
1012:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1013:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Register are stored on the stack in the following order - R0, R1, R2, R3,
1014:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * R12, LR, PC, xPSR. */
1015:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulPC = pulCallerStackAddress[ portOFFSET_TO_PC ];
 367              		.loc 1 1015 5 view .LVU77
1016:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
 368              		.loc 1 1016 5 view .LVU78
1017:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1018:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     switch( ucSVCNumber )
 369              		.loc 1 1018 5 view .LVU79
 988:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) )
 370              		.loc 1 988 1 is_stmt 0 view .LVU80
 371 0000 08B5     		push	{r3, lr}
 372              		.cfi_def_cfa_offset 8
 373              		.cfi_offset 3, -8
 374              		.cfi_offset 14, -4
1016:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
 375              		.loc 1 1016 17 view .LVU81
 376 0002 8369     		ldr	r3, [r0, #24]
 377              		.loc 1 1018 5 view .LVU82
 378 0004 13F8023C 		ldrb	r3, [r3, #-2]	@ zero_extendqisi2
 379 0008 662B     		cmp	r3, #102
 380 000a 11D1     		bne	.L26
1019:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1020:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
1021:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_ALLOCATE_SECURE_CONTEXT:
1022:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1023:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* R0 contains the stack size passed as parameter to the
1024:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * vPortAllocateSecureContext function. */
1025:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR0 = pulCallerStackAddress[ 0 ];
1026:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/cczusFlJ.s 			page 26


1027:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #if ( configENABLE_MPU == 1 )
1028:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1029:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Read the CONTROL register value. */
1030:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
1031:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1032:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* The task that raised the SVC is privileged if Bit[0]
1033:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * in the CONTROL register is 0. */
1034:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
1035:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1036:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Allocate and load a context for the secure task. */
1037:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged, pxCur
1038:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1039:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #else /* if ( configENABLE_MPU == 1 ) */
1040:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1041:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Allocate and load a context for the secure task. */
1042:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xSecureContext = SecureContext_AllocateContext( ulR0, pxCurrentTCB );
1043:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1044:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #endif /* configENABLE_MPU */
1045:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1046:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 configASSERT( xSecureContext != securecontextINVALID_CONTEXT_ID );
1047:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_LoadContext( xSecureContext, pxCurrentTCB );
1048:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1049:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1050:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_FREE_SECURE_CONTEXT:
1051:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1052:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* R0 contains TCB being freed and R1 contains the secure
1053:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * context handle to be freed. */
1054:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR0 = pulCallerStackAddress[ 0 ];
1055:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR1 = pulCallerStackAddress[ 1 ];
1056:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1057:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Free the secure context. */
1058:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_FreeContext( ( SecureContextHandle_t ) ulR1, ( void * ) ulR0 );
1059:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1060:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
1061:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1062:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         case portSVC_START_SCHEDULER:
1063:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1064:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1065:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* De-prioritize the non-secure exceptions so that the
1066:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * non-secure pendSV runs at the lowest priority. */
1067:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureInit_DePrioritizeNSExceptions();
1068:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1069:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Initialize the secure context management system. */
1070:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_Init();
1071:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1072:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1073:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1074:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_FPU == 1 )
1075:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1076:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Setup the Floating Point Unit (FPU). */
1077:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 prvSetupFPU();
 381              		.loc 1 1077 17 is_stmt 1 view .LVU83
 382              	.LBB8:
 383              	.LBI8:
 910:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 384              		.loc 1 910 17 view .LVU84
 385              	.LBB9:
ARM GAS  /tmp/cczusFlJ.s 			page 27


 922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             ( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
 386              		.loc 1 922 9 view .LVU85
 387 000c 4FF0E023 		mov	r3, #-536813568
 388 0010 D3F8882D 		ldr	r2, [r3, #3464]
 922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             ( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
 389              		.loc 1 922 24 is_stmt 0 view .LVU86
 390 0014 42F47002 		orr	r2, r2, #15728640
 391 0018 C3F8882D 		str	r2, [r3, #3464]
 392              	.LVL13:
 929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 393              		.loc 1 929 9 is_stmt 1 view .LVU87
 394 001c D3F8342F 		ldr	r2, [r3, #3892]
 929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 395              		.loc 1 929 24 is_stmt 0 view .LVU88
 396 0020 42F04042 		orr	r2, r2, #-1073741824
 397 0024 C3F8342F 		str	r2, [r3, #3892]
 398              	.LBE9:
 399              	.LBE8:
1078:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1079:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_FPU */
1080:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1081:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup the context of the first task so that the first task starts
1082:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * executing. */
1083:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             vRestoreContextOfFirstTask();
 400              		.loc 1 1083 13 is_stmt 1 view .LVU89
1084:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             break;
1085:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1086:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) )
1087:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_RAISE_PRIVILEGE:
1088:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1089:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Only raise the privilege, if the svc was raised from any of
1090:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * the system calls. */
1091:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
1092:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ( ulPC <= ( uint32_t ) __syscalls_flash_end__ ) )
1093:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1094:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     vRaisePrivilege();
1095:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1096:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1097:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) */
1098:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1099:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         default:
1100:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Incorrect SVC call. */
1101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( pdFALSE );
1102:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1103:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 401              		.loc 1 1103 1 is_stmt 0 view .LVU90
 402 0028 BDE80840 		pop	{r3, lr}
 403              		.cfi_remember_state
 404              		.cfi_restore 14
 405              		.cfi_restore 3
 406              		.cfi_def_cfa_offset 0
1083:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             break;
 407              		.loc 1 1083 13 view .LVU91
 408 002c FFF7FEBF 		b	vRestoreContextOfFirstTask
 409              	.LVL14:
 410              	.L26:
 411              		.cfi_restore_state
ARM GAS  /tmp/cczusFlJ.s 			page 28


1101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 412              		.loc 1 1101 13 is_stmt 1 view .LVU92
1101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 413              		.loc 1 1101 13 discriminator 1 view .LVU93
 414 0030 FFF7FEFF 		bl	ulSetInterruptMask
 415              	.LVL15:
1101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 416              		.loc 1 1101 13 discriminator 1 view .LVU94
 417 0034 40F24D41 		movw	r1, #1101
 418 0038 024B     		ldr	r3, .L27
 419 003a 034A     		ldr	r2, .L27+4
 420 003c 0348     		ldr	r0, .L27+8
 421 003e FFF7FEFF 		bl	__assert_func
 422              	.LVL16:
 423              	.L28:
 424 0042 00BF     		.align	2
 425              	.L27:
 426 0044 00000000 		.word	.LC0
 427 0048 00000000 		.word	__func__.4
 428 004c 02000000 		.word	.LC1
 429              		.cfi_endproc
 430              	.LFE7:
 432              		.section	.text.pxPortInitialiseStack,"ax",%progbits
 433              		.align	1
 434              		.global	pxPortInitialiseStack
 435              		.syntax unified
 436              		.thumb
 437              		.thumb_func
 439              	pxPortInitialiseStack:
 440              	.LVL17:
 441              	.LFB8:
1104:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1105:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1106:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1107:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1108:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallEnter( uint32_t * pulTaskStack,
1109:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint32_t ulLR,
1110:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint8_t ucSystemCallNumber ) /* PRIVILEGED_FUNCTION */
1111:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1112:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1113:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern UBaseType_t uxSystemCallImplementations[ NUM_SYSTEM_CALLS ];
1114:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPU_SETTINGS * pxMpuSettings;
1115:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t * pulSystemCallStack;
1116:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulStackFrameSize, ulSystemCallLocation, i;
1117:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1118:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1119:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1120:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1121:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
1122:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
1123:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1124:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1125:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
1126:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
1127:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* #if defined( __ARMCC_VERSION ) */
1128:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1129:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulSystemCallLocation = pulTaskStack[ portOFFSET_TO_PC ];
ARM GAS  /tmp/cczusFlJ.s 			page 29


1130:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         pxMpuSettings = xTaskGetMPUSettings( pxCurrentTCB );
1131:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1132:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Checks:
1133:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 1. SVC is raised from the system call section (i.e. application is
1134:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    not raising SVC directly).
1135:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 2. pxMpuSettings->xSystemCallStackInfo.pulTaskStack must be NULL as
1136:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    it is non-NULL only during the execution of a system call (i.e.
1137:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    between system call enter and exit).
1138:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 3. System call is not for a kernel API disabled by the configuration
1139:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    in FreeRTOSConfig.h.
1140:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 4. We do not need to check that ucSystemCallNumber is within range
1141:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    because the assembly SVC handler checks that before calling
1142:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    this function.
1143:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          */
1144:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulSystemCallLocation >= ( uint32_t ) __syscalls_flash_start__ ) &&
1145:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( ulSystemCallLocation <= ( uint32_t ) __syscalls_flash_end__ ) &&
1146:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( pxMpuSettings->xSystemCallStackInfo.pulTaskStack == NULL ) &&
1147:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( uxSystemCallImplementations[ ucSystemCallNumber ] != ( UBaseType_t ) 0 ) )
1148:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1149:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack = pxMpuSettings->xSystemCallStackInfo.pulSystemCallStack;
1150:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1151:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) )
1152:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1153:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulLR & portEXC_RETURN_STACK_FRAME_TYPE_MASK ) == 0UL )
1154:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1155:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Extended frame i.e. FPU in use. */
1156:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 26;
1157:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile
1158:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     (
1159:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpush {s0}         \n" /* Trigger lazy stacking. */
1160:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpop  {s0}         \n" /* Nullify the affect of the above instruction. */
1161:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ::: "memory"
1162:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     );
1163:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1164:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1165:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1166:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Standard frame i.e. FPU not in use. */
1167:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 8;
1168:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1169:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1170:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1171:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1172:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulStackFrameSize = 8;
1173:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1174:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1175:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1176:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Make space on the system call stack for the stack frame. */
1177:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack = pulSystemCallStack - ulStackFrameSize;
1178:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1179:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Copy the stack frame. */
1180:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             for( i = 0; i < ulStackFrameSize; i++ )
1181:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1182:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulSystemCallStack[ i ] = pulTaskStack[ i ];
1183:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1184:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1185:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Store the value of the Link Register before the SVC was raised.
1186:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * It contains the address of the caller of the System Call entry
ARM GAS  /tmp/cczusFlJ.s 			page 30


1187:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * point (i.e. the caller of the MPU_<API>). We need to restore it
1188:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * when we exit from the system call. */
1189:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAtSystemCallEntry = pulTaskStack[ por
1190:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1191:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Store the value of the PSPLIM register before the SVC was raised.
1192:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * We need to restore it when we exit from the system call. */
1193:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "mrs %0, psplim" : "=r" ( pxMpuSettings->xSystemCallStackInfo.ulStackL
1194:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1195:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the pulSystemCallStack in thread mode. */
1196:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psp, %0" : : "r" ( pulSystemCallStack ) );
1197:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psplim, %0" : : "r" ( pxMpuSettings->xSystemCallStackInfo.pulSyst
1198:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1199:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Start executing the system call upon returning from this handler. */
1200:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_PC ] = uxSystemCallImplementations[ ucSystemCallNumbe
1201:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1202:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Raise a request to exit from the system call upon finishing the
1203:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * system call. */
1204:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_LR ] = ( uint32_t ) vRequestSystemCallExit;
1205:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1206:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Remember the location where we should copy the stack frame when we exit from
1207:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the system call. */
1208:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.pulTaskStack = pulTaskStack + ulStackFrameSize;
1209:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1210:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Record if the hardware used padding to force the stack pointer
1211:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to be double word aligned. */
1212:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( pulTaskStack[ portOFFSET_TO_PSR ] & portPSR_STACK_PADDING_MASK ) == portPSR_STACK
1213:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1214:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxMpuSettings->ulTaskFlags |= portSTACK_FRAME_HAS_PADDING_FLAG;
1215:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1216:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1217:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1218:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxMpuSettings->ulTaskFlags &= ( ~portSTACK_FRAME_HAS_PADDING_FLAG );
1219:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1220:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1221:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* We ensure in pxPortInitialiseStack that the system call stack is
1222:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * double word aligned and therefore, there is no need of padding.
1223:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Clear the bit[9] of stacked xPSR. */
1224:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_PSR ] &= ( ~portPSR_STACK_PADDING_MASK );
1225:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1226:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Raise the privilege for the duration of the system call. */
1227:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile
1228:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             (
1229:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " mrs r0, control     \n" /* Obtain current control value. */
1230:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " movs r1, #1         \n" /* r1 = 1. */
1231:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " bics r0, r1         \n" /* Clear nPRIV bit. */
1232:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " msr control, r0     \n" /* Write back new control value. */
1233:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ::: "r0", "r1", "memory"
1234:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             );
1235:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1236:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1237:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1238:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1239:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1240:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1241:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1242:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1243:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vRequestSystemCallExit( void ) /* __attribute__( ( naked ) ) PRIVILEGED_FUNCTION */
ARM GAS  /tmp/cczusFlJ.s 			page 31


1244:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1245:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "svc %0 \n" ::"i" ( portSVC_SYSTEM_CALL_EXIT ) : "memory" );
1246:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1247:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1248:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1249:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1250:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1251:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1252:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1253:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallExit( uint32_t * pulSystemCallStack,
1254:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                           uint32_t ulLR ) /* PRIVILEGED_FUNCTION */
1255:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1256:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1257:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPU_SETTINGS * pxMpuSettings;
1258:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t * pulTaskStack;
1259:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulStackFrameSize, ulSystemCallLocation, i;
1260:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1261:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1262:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1263:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1264:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_start__;
1265:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_end__;
1266:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1267:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1268:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_start__[];
1269:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_end__[];
1270:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* #if defined( __ARMCC_VERSION ) */
1271:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1272:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulSystemCallLocation = pulSystemCallStack[ portOFFSET_TO_PC ];
1273:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         pxMpuSettings = xTaskGetMPUSettings( pxCurrentTCB );
1274:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1275:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Checks:
1276:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 1. SVC is raised from the privileged code (i.e. application is not
1277:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    raising SVC directly). This SVC is only raised from
1278:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    vRequestSystemCallExit which is in the privileged code section.
1279:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 2. pxMpuSettings->xSystemCallStackInfo.pulTaskStack must not be NULL -
1280:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    this means that we previously entered a system call and the
1281:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    application is not attempting to exit without entering a system
1282:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    call.
1283:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          */
1284:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulSystemCallLocation >= ( uint32_t ) __privileged_functions_start__ ) &&
1285:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( ulSystemCallLocation <= ( uint32_t ) __privileged_functions_end__ ) &&
1286:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( pxMpuSettings->xSystemCallStackInfo.pulTaskStack != NULL ) )
1287:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1288:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack = pxMpuSettings->xSystemCallStackInfo.pulTaskStack;
1289:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1290:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) )
1291:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1292:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulLR & portEXC_RETURN_STACK_FRAME_TYPE_MASK ) == 0UL )
1293:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1294:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Extended frame i.e. FPU in use. */
1295:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 26;
1296:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile
1297:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     (
1298:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpush {s0}         \n" /* Trigger lazy stacking. */
1299:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpop  {s0}         \n" /* Nullify the affect of the above instruction. */
1300:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ::: "memory"
ARM GAS  /tmp/cczusFlJ.s 			page 32


1301:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     );
1302:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1303:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1304:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1305:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Standard frame i.e. FPU not in use. */
1306:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 8;
1307:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1308:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1309:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1310:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1311:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulStackFrameSize = 8;
1312:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1313:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1314:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1315:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Make space on the task stack for the stack frame. */
1316:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack = pulTaskStack - ulStackFrameSize;
1317:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1318:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Copy the stack frame. */
1319:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             for( i = 0; i < ulStackFrameSize; i++ )
1320:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1321:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ i ] = pulSystemCallStack[ i ];
1322:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1323:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1324:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the pulTaskStack in thread mode. */
1325:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psp, %0" : : "r" ( pulTaskStack ) );
1326:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1327:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Return to the caller of the System Call entry point (i.e. the
1328:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * caller of the MPU_<API>). */
1329:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack[ portOFFSET_TO_PC ] = pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAt
1330:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Ensure that LR has a valid value.*/
1331:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack[ portOFFSET_TO_LR ] = pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAt
1332:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1333:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restore the PSPLIM register to what it was at the time of
1334:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * system call entry. */
1335:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psplim, %0" : : "r" ( pxMpuSettings->xSystemCallStackInfo.ulStack
1336:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1337:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If the hardware used padding to force the stack pointer
1338:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to be double word aligned, set the stacked xPSR bit[9],
1339:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * otherwise clear it. */
1340:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( pxMpuSettings->ulTaskFlags & portSTACK_FRAME_HAS_PADDING_FLAG ) == portSTACK_FRAM
1341:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1342:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ portOFFSET_TO_PSR ] |= portPSR_STACK_PADDING_MASK;
1343:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1344:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1345:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1346:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ portOFFSET_TO_PSR ] &= ( ~portPSR_STACK_PADDING_MASK );
1347:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1348:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1349:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* This is not NULL only for the duration of the system call. */
1350:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.pulTaskStack = NULL;
1351:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1352:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Drop the privilege before returning to the thread mode. */
1353:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile
1354:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             (
1355:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " mrs r0, control     \n" /* Obtain current control value. */
1356:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " movs r1, #1         \n" /* r1 = 1. */
1357:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " orrs r0, r1         \n" /* Set nPRIV bit. */
ARM GAS  /tmp/cczusFlJ.s 			page 33


1358:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " msr control, r0     \n" /* Write back new control value. */
1359:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ::: "r0", "r1", "memory"
1360:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             );
1361:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1362:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1363:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1364:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1365:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1366:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1367:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1368:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1369:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsTaskPrivileged( void ) /* PRIVILEGED_FUNCTION */
1370:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1371:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         BaseType_t xTaskIsPrivileged = pdFALSE;
1372:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU
1373:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1374:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEG
1375:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1376:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xTaskIsPrivileged = pdTRUE;
1377:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1378:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1379:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return xTaskIsPrivileged;
1380:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1381:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1382:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU == 1 */
1383:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1384:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1385:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1386:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1387:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
1388:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          StackType_t * pxEndOfStack,
1389:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          TaskFunction_t pxCode,
1390:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          void * pvParameters,
1391:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          BaseType_t xRunPrivileged,
1392:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          xMPU_SETTINGS * xMPUSettings ) /* PRIVILEGED_FUNCTION */
1393:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1394:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulIndex = 0;
1395:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1396:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x04040404; /* r4. */
1397:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1398:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x05050505; /* r5. */
1399:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1400:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x06060606; /* r6. */
1401:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1402:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x07070707; /* r7. */
1403:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1404:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x08080808; /* r8. */
1405:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1406:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x09090909; /* r9. */
1407:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1408:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x10101010; /* r10. */
1409:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1410:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x11111111; /* r11. */
1411:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1412:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1413:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pvParameters; /* r0. */
1414:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
ARM GAS  /tmp/cczusFlJ.s 			page 34


1415:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x01010101; /* r1. */
1416:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1417:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x02020202; /* r2. */
1418:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1419:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x03030303; /* r3. */
1420:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1421:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x12121212; /* r12. */
1422:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1423:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portTASK_RETURN_ADDRESS; /* LR. */
1424:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1425:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxCode; /* PC. */
1426:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1427:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_XPSR; /* xPSR. */
1428:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1429:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1430:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
1431:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1432:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = portNO_SECURE_CONTEXT; /* xSecureContext. */
1433:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1434:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1435:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
1436:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) ( pxTopOfStack - 8 ); /* PSP with the har
1437:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1438:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxEndOfStack; /* PSPLIM. */
1439:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1440:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xRunPrivileged == pdTRUE )
1441:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1442:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
1443:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_PRIVILEGED; /* CO
1444:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1445:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1446:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1447:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1448:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulTaskFlags &= ( ~portTASK_IS_PRIVILEGED_FLAG );
1449:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_UNPRIVILEGED; /* 
1450:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1451:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1452:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_EXC_RETURN; /* LR (EXC_RETURN). */
1453:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1454:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1455:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configUSE_MPU_WRAPPERS_V1 == 0 )
1456:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1457:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Ensure that the system call stack is double word aligned. */
1458:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStack = &( xMPUSettings->xSystemCallSta
1459:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStack = ( uint32_t * ) ( ( uint32_t ) (
1460:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                      ( uint32_t ) (
1461:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1462:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStackLimit = &( xMPUSettings->xSystemCa
1463:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStackLimit = ( uint32_t * ) ( ( ( uint3
1464:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                             ( uint3
1465:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                           ( uint32_
1466:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1467:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* This is not NULL only for the duration of a system call. */
1468:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulTaskStack = NULL;
1469:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1470:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configUSE_MPU_WRAPPERS_V1 == 0 */
1471:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/cczusFlJ.s 			page 35


1472:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return &( xMPUSettings->ulContext[ ulIndex ] );
1473:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1474:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1475:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else /* configENABLE_MPU */
1476:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1477:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
1478:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          StackType_t * pxEndOfStack,
1479:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          TaskFunction_t pxCode,
1480:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          void * pvParameters ) /* PRIVILEGED_FUNCTION */
1481:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 442              		.loc 1 1481 5 view -0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
1482:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Simulate the stack frame as it would be created by a context switch
1483:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * interrupt. */
1484:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( portPRELOAD_REGISTERS == 0 )
1485:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1486:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/
1487:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR. */
1488:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1489:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC. */
1490:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1491:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
1492:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
1493:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0. */
1494:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack -= 9;                                       /* R11..R4, EXC_RETURN. */
1495:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_EXC_RETURN;
1496:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1497:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxEndOfStack; /* Slot used to hold this task's PSPLIM v
1498:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1499:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1500:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1501:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxTopOfStack--;
1502:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 *pxTopOfStack = portNO_SECURE_CONTEXT; /* Slot used to hold this task's xSecureCont
1503:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1504:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1505:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1506:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else /* portPRELOAD_REGISTERS */
1507:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1508:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/
 446              		.loc 1 1508 13 view .LVU96
1509:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR. */
 447              		.loc 1 1509 13 view .LVU97
1481:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Simulate the stack frame as it would be created by a context switch
 448              		.loc 1 1481 5 is_stmt 0 view .LVU98
 449 0000 10B5     		push	{r4, lr}
 450              		.cfi_def_cfa_offset 8
 451              		.cfi_offset 4, -8
 452              		.cfi_offset 14, -4
 453              		.loc 1 1509 27 view .LVU99
 454 0002 4FF08074 		mov	r4, #16777216
1510:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1511:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC. */
 455              		.loc 1 1511 27 view .LVU100
 456 0006 40E90224 		strd	r2, r4, [r0, #-8]
1512:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
ARM GAS  /tmp/cczusFlJ.s 			page 36


 457              		.loc 1 1512 13 is_stmt 1 view .LVU101
 458              	.LVL18:
1513:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
 459              		.loc 1 1513 13 view .LVU102
 460              		.loc 1 1513 27 is_stmt 0 view .LVU103
 461 000a 184A     		ldr	r2, .L30
 462              	.LVL19:
1514:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1515:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x12121212UL;            /* R12. */
1516:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1517:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x03030303UL;            /* R3. */
 463              		.loc 1 1517 27 view .LVU104
 464 000c 4FF01234 		mov	r4, #303174162
1513:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
 465              		.loc 1 1513 27 view .LVU105
 466 0010 40F80C2C 		str	r2, [r0, #-12]
1514:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 467              		.loc 1 1514 13 is_stmt 1 view .LVU106
 468              	.LVL20:
1515:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 469              		.loc 1 1515 13 view .LVU107
 470              		.loc 1 1517 27 is_stmt 0 view .LVU108
 471 0014 4FF00332 		mov	r2, #50529027
1518:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1519:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x02020202UL;            /* R2. */
1520:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1521:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x01010101UL;            /* R1. */
 472              		.loc 1 1521 27 view .LVU109
 473 0018 4FF0023C 		mov	ip, #33686018
1517:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 474              		.loc 1 1517 27 view .LVU110
 475 001c 40E90524 		strd	r2, r4, [r0, #-20]
1518:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 476              		.loc 1 1518 13 is_stmt 1 view .LVU111
 477              	.LVL21:
1519:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 478              		.loc 1 1519 13 view .LVU112
 479              		.loc 1 1521 27 is_stmt 0 view .LVU113
 480 0020 4FF00132 		mov	r2, #16843009
1522:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1523:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0. */
 481              		.loc 1 1523 27 view .LVU114
 482 0024 40F8203C 		str	r3, [r0, #-32]
1521:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 483              		.loc 1 1521 27 view .LVU115
 484 0028 40E9072C 		strd	r2, ip, [r0, #-28]
1522:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 485              		.loc 1 1522 13 is_stmt 1 view .LVU116
 486              	.LVL22:
 487              		.loc 1 1523 13 view .LVU117
1524:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 488              		.loc 1 1524 13 view .LVU118
1525:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x11111111UL;            /* R11. */
 489              		.loc 1 1525 13 view .LVU119
1526:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1527:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x10101010UL;            /* R10. */
 490              		.loc 1 1527 27 is_stmt 0 view .LVU120
ARM GAS  /tmp/cczusFlJ.s 			page 37


 491 002c 4FF01033 		mov	r3, #269488144
 492              	.LVL23:
 493              		.loc 1 1527 27 view .LVU121
 494 0030 4FF01132 		mov	r2, #286331153
1528:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1529:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x09090909UL;            /* R09. */
1530:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1531:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x08080808UL;            /* R08. */
 495              		.loc 1 1531 27 view .LVU122
 496 0034 4FF00934 		mov	r4, #151587081
1527:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 497              		.loc 1 1527 27 view .LVU123
 498 0038 40E90A32 		strd	r3, r2, [r0, #-40]
1528:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 499              		.loc 1 1528 13 is_stmt 1 view .LVU124
 500              	.LVL24:
1529:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 501              		.loc 1 1529 13 view .LVU125
 502              		.loc 1 1531 27 is_stmt 0 view .LVU126
 503 003c 4FF00833 		mov	r3, #134744072
1532:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1533:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x07070707UL;            /* R07. */
1534:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1535:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x06060606UL;            /* R06. */
 504              		.loc 1 1535 27 view .LVU127
 505 0040 4FF0073C 		mov	ip, #117901063
1531:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 506              		.loc 1 1531 27 view .LVU128
 507 0044 40E90C34 		strd	r3, r4, [r0, #-48]
1532:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 508              		.loc 1 1532 13 is_stmt 1 view .LVU129
 509              	.LVL25:
1533:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 510              		.loc 1 1533 13 view .LVU130
 511              		.loc 1 1535 27 is_stmt 0 view .LVU131
 512 0048 4FF00633 		mov	r3, #101058054
1536:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1537:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x05050505UL;            /* R05. */
1538:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1539:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x04040404UL;            /* R04. */
 513              		.loc 1 1539 27 view .LVU132
 514 004c 4FF00532 		mov	r2, #84215045
1535:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 515              		.loc 1 1535 27 view .LVU133
 516 0050 40E90E3C 		strd	r3, ip, [r0, #-56]
1536:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 517              		.loc 1 1536 13 is_stmt 1 view .LVU134
 518              	.LVL26:
1537:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 519              		.loc 1 1537 13 view .LVU135
 520              		.loc 1 1539 27 is_stmt 0 view .LVU136
 521 0054 4FF00433 		mov	r3, #67372036
 522 0058 40E91032 		strd	r3, r2, [r0, #-64]
1540:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 523              		.loc 1 1540 13 is_stmt 1 view .LVU137
 524              	.LVL27:
1541:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_EXC_RETURN;                  /* EXC_RETURN. */
ARM GAS  /tmp/cczusFlJ.s 			page 38


 525              		.loc 1 1541 13 view .LVU138
 526              		.loc 1 1541 27 is_stmt 0 view .LVU139
 527 005c 6FF00203 		mvn	r3, #2
 528 0060 40F8443C 		str	r3, [r0, #-68]
1542:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 529              		.loc 1 1542 13 is_stmt 1 view .LVU140
 530              	.LVL28:
1543:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxEndOfStack; /* Slot used to hold this task's PSPLIM v
 531              		.loc 1 1543 13 view .LVU141
 532              		.loc 1 1543 27 is_stmt 0 view .LVU142
 533 0064 40F8481D 		str	r1, [r0, #-72]!
 534              	.LVL29:
1544:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1545:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1546:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1547:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxTopOfStack--;
1548:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 *pxTopOfStack = portNO_SECURE_CONTEXT; /* Slot used to hold this task's xSecureCont
1549:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1550:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1551:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1552:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* portPRELOAD_REGISTERS */
1553:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1554:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return pxTopOfStack;
 535              		.loc 1 1554 9 is_stmt 1 view .LVU143
1555:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 536              		.loc 1 1555 5 is_stmt 0 view .LVU144
 537 0068 10BD     		pop	{r4, pc}
 538              	.L31:
 539 006a 00BF     		.align	2
 540              	.L30:
 541 006c 00000000 		.word	prvTaskExitError
 542              		.cfi_endproc
 543              	.LFE8:
 545              		.section	.text.xPortStartScheduler,"ax",%progbits
 546              		.align	1
 547              		.global	xPortStartScheduler
 548              		.syntax unified
 549              		.thumb
 550              		.thumb_func
 552              	xPortStartScheduler:
 553              	.LFB9:
1556:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1557:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1558:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1559:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1560:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
1561:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 554              		.loc 1 1561 1 is_stmt 1 view -0
 555              		.cfi_startproc
 556              		@ args = 0, pretend = 0, frame = 16
 557              		@ frame_needed = 0, uses_anonymous_args = 0
 558              	.LBB10:
1562:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
1563:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1564:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint32_t ulOriginalPriority;
 559              		.loc 1 1564 9 view .LVU146
1565:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint32_t ulImplementedPrioBits = 0;
ARM GAS  /tmp/cczusFlJ.s 			page 39


 560              		.loc 1 1565 9 view .LVU147
 561              	.LBE10:
1561:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
 562              		.loc 1 1561 1 is_stmt 0 view .LVU148
 563 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 564              		.cfi_def_cfa_offset 24
 565              		.cfi_offset 4, -8
 566              		.cfi_offset 14, -4
 567              	.LBB11:
 568              		.loc 1 1565 27 view .LVU149
 569 0002 0023     		movs	r3, #0
 570 0004 0393     		str	r3, [sp, #12]
1566:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint8_t ucMaxPriorityValue;
 571              		.loc 1 1566 9 is_stmt 1 view .LVU150
1567:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1568:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Determine the maximum priority from which ISR safe FreeRTOS API
1569:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * functions can be called.  ISR safe functions are those that end in
1570:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
1571:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * ensure interrupt entry is as fast and simple as possible.
1572:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *
1573:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * Save the interrupt priority value that is about to be clobbered. */
1574:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulOriginalPriority = portNVIC_SHPR2_REG;
 572              		.loc 1 1574 9 view .LVU151
 573              		.loc 1 1574 30 is_stmt 0 view .LVU152
 574 0006 4FF0E023 		mov	r3, #-536813568
 575 000a D3F81C2D 		ldr	r2, [r3, #3356]
 576              		.loc 1 1574 28 view .LVU153
 577 000e 0292     		str	r2, [sp, #8]
1575:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1576:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Determine the number of priority bits available.  First write to all
1577:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * possible bits. */
1578:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portNVIC_SHPR2_REG = 0xFF000000;
 578              		.loc 1 1578 9 is_stmt 1 view .LVU154
 579              		.loc 1 1578 28 is_stmt 0 view .LVU155
 580 0010 4FF07F42 		mov	r2, #-16777216
 581 0014 C3F81C2D 		str	r2, [r3, #3356]
1579:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1580:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Read the value back to see how many bits stuck. */
1581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ucMaxPriorityValue = ( uint8_t ) ( ( portNVIC_SHPR2_REG & 0xFF000000 ) >> 24 );
 582              		.loc 1 1581 9 is_stmt 1 view .LVU156
 583              		.loc 1 1581 46 is_stmt 0 view .LVU157
 584 0018 D3F81C3D 		ldr	r3, [r3, #3356]
1582:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1583:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Use the same mask on the maximum system call priority. */
1584:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 585              		.loc 1 1584 30 view .LVU158
 586 001c 2C4A     		ldr	r2, .L42
1581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 587              		.loc 1 1581 30 view .LVU159
 588 001e 1B0E     		lsrs	r3, r3, #24
1581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 589              		.loc 1 1581 28 view .LVU160
 590 0020 8DF80730 		strb	r3, [sp, #7]
 591              		.loc 1 1584 9 is_stmt 1 view .LVU161
 592              		.loc 1 1584 69 is_stmt 0 view .LVU162
 593 0024 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 594 0028 03F05003 		and	r3, r3, #80
ARM GAS  /tmp/cczusFlJ.s 			page 40


 595              		.loc 1 1584 30 view .LVU163
 596 002c 1370     		strb	r3, [r2]
1585:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1586:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the maximum system call priority is nonzero after
1587:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * accounting for the number of priority bits supported by the
1588:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * hardware. A priority of 0 is invalid because setting the BASEPRI
1589:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * register to 0 unmasks all interrupts, and interrupts with priority 0
1590:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * cannot be masked using BASEPRI.
1591:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1592:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ucMaxSysCallPriority );
 597              		.loc 1 1592 9 is_stmt 1 view .LVU164
 598 002e 43B9     		cbnz	r3, .L33
 599              		.loc 1 1592 9 discriminator 1 view .LVU165
 600 0030 FFF7FEFF 		bl	ulSetInterruptMask
 601              	.LVL30:
 602              		.loc 1 1592 9 discriminator 1 view .LVU166
 603 0034 4FF4C761 		mov	r1, #1592
 604 0038 264B     		ldr	r3, .L42+4
 605 003a 274A     		ldr	r2, .L42+8
 606              	.L41:
1593:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1594:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the bits not implemented in hardware are zero in
1595:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * configMAX_SYSCALL_INTERRUPT_PRIORITY. */
1596:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & ( ~ucMaxPriorityValue ) ) == 0U );
 607              		.loc 1 1596 9 is_stmt 0 discriminator 1 view .LVU167
 608 003c 2748     		ldr	r0, .L42+12
 609 003e FFF7FEFF 		bl	__assert_func
 610              	.LVL31:
 611              	.L33:
1592:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 612              		.loc 1 1592 45 is_stmt 1 discriminator 2 view .LVU168
 613              		.loc 1 1596 9 view .LVU169
 614 0042 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 615 0046 DB43     		mvns	r3, r3
 616 0048 13F0500F 		tst	r3, #80
 617 004c 0ED0     		beq	.L34
 618              		.loc 1 1596 9 discriminator 1 view .LVU170
 619 004e FFF7FEFF 		bl	ulSetInterruptMask
 620              	.LVL32:
 621              		.loc 1 1596 9 discriminator 1 view .LVU171
 622 0052 40F23C61 		movw	r1, #1596
 623 0056 1F4B     		ldr	r3, .L42+4
 624 0058 1F4A     		ldr	r2, .L42+8
 625 005a EFE7     		b	.L41
 626              	.L35:
1597:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1598:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Calculate the maximum acceptable priority group value for the number
1599:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * of bits read back. */
1600:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
1602:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1603:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulImplementedPrioBits++;
 627              		.loc 1 1603 13 view .LVU172
 628              		.loc 1 1603 34 is_stmt 0 view .LVU173
 629 005c 0133     		adds	r3, r3, #1
 630 005e 0393     		str	r3, [sp, #12]
1604:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ucMaxPriorityValue <<= ( uint8_t ) 0x01;
ARM GAS  /tmp/cczusFlJ.s 			page 41


 631              		.loc 1 1604 13 is_stmt 1 view .LVU174
 632              		.loc 1 1604 32 is_stmt 0 view .LVU175
 633 0060 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 634 0064 5B00     		lsls	r3, r3, #1
 635 0066 DBB2     		uxtb	r3, r3
 636 0068 8DF80730 		strb	r3, [sp, #7]
 637              	.L34:
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 638              		.loc 1 1601 61 is_stmt 1 view .LVU176
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 639              		.loc 1 1601 37 is_stmt 0 view .LVU177
 640 006c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 641              		.loc 1 1601 61 view .LVU178
 642 0070 13F0800F 		tst	r3, #128
1603:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 643              		.loc 1 1603 34 view .LVU179
 644 0074 039B     		ldr	r3, [sp, #12]
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 645              		.loc 1 1601 61 view .LVU180
 646 0076 F1D1     		bne	.L35
1605:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1606:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1607:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulImplementedPrioBits == 8 )
 647              		.loc 1 1607 9 is_stmt 1 view .LVU181
 648              		.loc 1 1607 11 is_stmt 0 view .LVU182
 649 0078 082B     		cmp	r3, #8
1608:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1609:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* When the hardware implements 8 priority bits, there is no way for
1610:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the software to configure PRIGROUP to not have sub-priorities. As
1611:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * a result, the least significant bit is always used for sub-priority
1612:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and there are 128 preemption priorities and 2 sub-priorities.
1613:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1614:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * This may cause some confusion in some cases - for example, if
1615:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY is set to 5, both 5 and 4
1616:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * priority interrupts will be masked in Critical Sections as those
1617:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * are at the same preemption priority. This may appear confusing as
1618:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * 4 is higher (numerically lower) priority than
1619:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY and therefore, should not
1620:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * have been masked. Instead, if we set configMAX_SYSCALL_INTERRUPT_PRIORITY
1621:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to 4, this confusion does not happen and the behaviour remains the same.
1622:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1623:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * The following assert ensures that the sub-priority bit in the
1624:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY is clear to avoid the above mentioned
1625:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * confusion. */
1626:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & 0x1U ) == 0U );
1627:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulMaxPRIGROUPValue = 0;
1628:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1629:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1630:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS - ulImplementedPrioBits;
 650              		.loc 1 1631 13 is_stmt 1 view .LVU183
1627:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 651              		.loc 1 1627 32 is_stmt 0 view .LVU184
 652 007a 0CBF     		ite	eq
 653 007c 0023     		moveq	r3, #0
1632:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
ARM GAS  /tmp/cczusFlJ.s 			page 42


1633:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1634:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Shift the priority group value back to its position within the AIRCR
1635:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * register. */
1636:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 654              		.loc 1 1636 9 is_stmt 1 view .LVU185
1637:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 655              		.loc 1 1637 9 view .LVU186
1631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 656              		.loc 1 1631 56 is_stmt 0 view .LVU187
 657 007e 039B     		ldrne	r3, [sp, #12]
 658              		.loc 1 1637 28 view .LVU188
 659 0080 174A     		ldr	r2, .L42+16
1631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 660              		.loc 1 1631 56 view .LVU189
 661 0082 18BF     		it	ne
 662 0084 C3F10703 		rsbne	r3, r3, #7
1636:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 663              		.loc 1 1636 28 view .LVU190
 664 0088 1B02     		lsls	r3, r3, #8
 665              		.loc 1 1637 28 view .LVU191
 666 008a 03F4E063 		and	r3, r3, #1792
 667 008e 1360     		str	r3, [r2]
1638:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1639:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Restore the clobbered interrupt priority register to its original
1640:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * value. */
1641:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portNVIC_SHPR2_REG = ulOriginalPriority;
 668              		.loc 1 1641 9 is_stmt 1 view .LVU192
 669              		.loc 1 1641 28 is_stmt 0 view .LVU193
 670 0090 4FF0E023 		mov	r3, #-536813568
 671              	.LBE11:
1642:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1643:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) ) */
1644:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1645:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
1646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
1647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
1648:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1649:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configENABLE_MPU == 1 )
1650:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1651:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Setup the Memory Protection Unit (MPU). */
1652:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         prvSetupMPU();
1653:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1654:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configENABLE_MPU */
1655:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1656:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Start the timer that generates the tick ISR. Interrupts are disabled
1657:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * here already. */
1658:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vPortSetupTimerInterrupt();
1659:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1660:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Initialize the critical nesting count ready for the first task. */
1661:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting = 0;
 672              		.loc 1 1661 23 view .LVU194
 673 0094 0024     		movs	r4, #0
 674              	.LBB12:
1641:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 675              		.loc 1 1641 28 view .LVU195
 676 0096 029A     		ldr	r2, [sp, #8]
 677 0098 C3F81C2D 		str	r2, [r3, #3356]
ARM GAS  /tmp/cczusFlJ.s 			page 43


 678              	.LBE12:
1646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 679              		.loc 1 1646 5 is_stmt 1 view .LVU196
 680 009c D3F8202D 		ldr	r2, [r3, #3360]
1646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 681              		.loc 1 1646 24 is_stmt 0 view .LVU197
 682 00a0 42F47F02 		orr	r2, r2, #16711680
 683 00a4 C3F8202D 		str	r2, [r3, #3360]
1647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 684              		.loc 1 1647 5 is_stmt 1 view .LVU198
 685 00a8 D3F8202D 		ldr	r2, [r3, #3360]
1647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 686              		.loc 1 1647 24 is_stmt 0 view .LVU199
 687 00ac 42F07F42 		orr	r2, r2, #-16777216
 688 00b0 C3F8202D 		str	r2, [r3, #3360]
1658:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 689              		.loc 1 1658 5 is_stmt 1 view .LVU200
 690 00b4 FFF7FEFF 		bl	vPortSetupTimerInterrupt
 691              	.LVL33:
 692              		.loc 1 1661 5 view .LVU201
 693              		.loc 1 1661 23 is_stmt 0 view .LVU202
 694 00b8 0A4B     		ldr	r3, .L42+20
 695 00ba 1C60     		str	r4, [r3]
1662:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1663:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_
1664:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1665:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xSchedulerRunning = pdTRUE;
1666:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1667:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif
1668:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1669:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Start the first task. */
1670:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vStartFirstTask();
 696              		.loc 1 1670 5 is_stmt 1 view .LVU203
 697 00bc FFF7FEFF 		bl	vStartFirstTask
 698              	.LVL34:
1671:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1672:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Should never get here as the tasks will now be executing. Call the task
1673:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * exit error function to prevent compiler warnings about a static function
1674:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * not being called in the case that the application writer overrides this
1675:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * functionality by defining configTASK_RETURN_ADDRESS. Call
1676:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * vTaskSwitchContext() so link time optimization does not remove the
1677:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * symbol. */
1678:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vTaskSwitchContext();
 699              		.loc 1 1678 5 view .LVU204
 700 00c0 FFF7FEFF 		bl	vTaskSwitchContext
 701              	.LVL35:
1679:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     prvTaskExitError();
 702              		.loc 1 1679 5 view .LVU205
 703 00c4 FFF7FEFF 		bl	prvTaskExitError
 704              	.LVL36:
1680:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1681:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Should not get here. */
1682:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     return 0;
 705              		.loc 1 1682 5 view .LVU206
1683:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 706              		.loc 1 1683 1 is_stmt 0 view .LVU207
 707 00c8 2046     		mov	r0, r4
ARM GAS  /tmp/cczusFlJ.s 			page 44


 708 00ca 04B0     		add	sp, sp, #16
 709              		.cfi_def_cfa_offset 8
 710              		@ sp needed
 711 00cc 10BD     		pop	{r4, pc}
 712              	.L43:
 713 00ce 00BF     		.align	2
 714              	.L42:
 715 00d0 00000000 		.word	ucMaxSysCallPriority
 716 00d4 00000000 		.word	.LC0
 717 00d8 00000000 		.word	__func__.2
 718 00dc 02000000 		.word	.LC1
 719 00e0 00000000 		.word	ulMaxPRIGROUPValue
 720 00e4 00000000 		.word	ulCriticalNesting
 721              		.cfi_endproc
 722              	.LFE9:
 724              		.section	.text.vPortEndScheduler,"ax",%progbits
 725              		.align	1
 726              		.global	vPortEndScheduler
 727              		.syntax unified
 728              		.thumb
 729              		.thumb_func
 731              	vPortEndScheduler:
 732              	.LFB10:
1684:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1685:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1686:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
1687:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 733              		.loc 1 1687 1 is_stmt 1 view -0
 734              		.cfi_startproc
 735              		@ args = 0, pretend = 0, frame = 0
 736              		@ frame_needed = 0, uses_anonymous_args = 0
1688:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Not implemented in ports where there is nothing to return to.
1689:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * Artificially force an assert. */
1690:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting == 1000UL );
 737              		.loc 1 1690 5 view .LVU209
1687:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Not implemented in ports where there is nothing to return to.
 738              		.loc 1 1687 1 is_stmt 0 view .LVU210
 739 0000 08B5     		push	{r3, lr}
 740              		.cfi_def_cfa_offset 8
 741              		.cfi_offset 3, -8
 742              		.cfi_offset 14, -4
 743              		.loc 1 1690 5 view .LVU211
 744 0002 074B     		ldr	r3, .L46
 745 0004 1B68     		ldr	r3, [r3]
 746 0006 B3F57A7F 		cmp	r3, #1000
 747 000a 08D0     		beq	.L44
 748              		.loc 1 1690 5 is_stmt 1 discriminator 1 view .LVU212
 749 000c FFF7FEFF 		bl	ulSetInterruptMask
 750              	.LVL37:
 751              		.loc 1 1690 5 discriminator 1 view .LVU213
 752 0010 40F29A61 		movw	r1, #1690
 753 0014 034B     		ldr	r3, .L46+4
 754 0016 044A     		ldr	r2, .L46+8
 755 0018 0448     		ldr	r0, .L46+12
 756 001a FFF7FEFF 		bl	__assert_func
 757              	.LVL38:
 758              	.L44:
ARM GAS  /tmp/cczusFlJ.s 			page 45


1691:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 759              		.loc 1 1691 1 is_stmt 0 view .LVU214
 760 001e 08BD     		pop	{r3, pc}
 761              	.L47:
 762              		.align	2
 763              	.L46:
 764 0020 00000000 		.word	ulCriticalNesting
 765 0024 00000000 		.word	.LC0
 766 0028 00000000 		.word	__func__.1
 767 002c 02000000 		.word	.LC1
 768              		.cfi_endproc
 769              	.LFE10:
 771              		.section	.text.xPortIsInsideInterrupt,"ax",%progbits
 772              		.align	1
 773              		.global	xPortIsInsideInterrupt
 774              		.syntax unified
 775              		.thumb
 776              		.thumb_func
 778              	xPortIsInsideInterrupt:
 779              	.LFB11:
1692:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1693:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1694:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1695:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vPortStoreTaskMPUSettings( xMPU_SETTINGS * xMPUSettings,
1696:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     const struct xMEMORY_REGION * const xRegions,
1697:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     StackType_t * pxBottomOfStack,
1698:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     uint32_t ulStackDepth )
1699:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1700:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
1701:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         int32_t lIndex = 0;
1702:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1703:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1704:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1705:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1706:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_start__;
1707:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_end__;
1708:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1709:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1710:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_start__[];
1711:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_end__[];
1712:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
1713:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1714:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Setup MAIR0. */
1715:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR
1716:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & port
1717:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1718:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* This function is called automatically when the task is created - in
1719:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * which case the stack region parameters will be valid.  At all other
1720:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * times the stack parameters will not be valid and it is assumed that
1721:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * the stack region has already been configured. */
1722:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulStackDepth > 0 )
1723:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1724:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulRegionStartAddress = ( uint32_t ) pxBottomOfStack;
1725:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeo
1726:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1727:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If the stack is within the privileged SRAM, do not protect it
1728:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * using a separate MPU region. This is needed because privileged
ARM GAS  /tmp/cczusFlJ.s 			page 46


1729:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SRAM is already protected using an MPU region and ARMv8-M does
1730:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * not allow overlapping MPU regions. */
1731:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( ulRegionStartAddress >= ( uint32_t ) __privileged_sram_start__ ) &&
1732:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ( ulRegionEndAddress <= ( uint32_t ) __privileged_sram_end__ ) )
1733:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1734:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = 0;
1735:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = 0;
1736:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1737:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1738:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1739:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Define the region that allows access to the stack. */
1740:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionStartAddress &= portMPU_RBAR_ADDRESS_MASK;
1741:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
1742:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1743:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = ( ulRegionStartAddress ) |
1744:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_NON_SHAREABLE ) |
1745:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_READ_WRITE ) |
1746:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_EXECUTE_NEVER );
1747:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1748:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = ( ulRegionEndAddress ) |
1749:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_RLAR_ATTR_INDEX0 ) |
1750:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_RLAR_REGION_ENABLE );
1751:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1752:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1753:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1754:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* User supplied configurable regions. */
1755:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
1756:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1757:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If xRegions is NULL i.e. the task has not specified any MPU
1758:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * region, the else part ensures that all the configurable MPU
1759:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * regions are invalidated. */
1760:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
1761:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1762:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Translate the generic region definition contained in xRegions
1763:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * into the ARMv8 specific MPU settings that are then stored in
1764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * xMPUSettings. */
1765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_
1766:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lInd
1767:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
1768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Start address. */
1770:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = ( ulRegionStartAddress ) 
1771:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                           ( portMPU_REGION_NON_SHAR
1772:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1773:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* RO/RW. */
1774:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
1775:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1776:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_REA
1777:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1778:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1779:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1780:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_REA
1781:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1782:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1783:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* XN. */
1784:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
1785:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
ARM GAS  /tmp/cczusFlJ.s 			page 47


1786:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXE
1787:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1788:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1789:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* End Address. */
1790:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = ( ulRegionEndAddress ) |
1791:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                           ( portMPU_RLAR_REGION_ENA
1792:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1793:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Normal memory/ Device memory. */
1794:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
1795:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1796:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Attr1 in MAIR0 is configured as device memory. */
1797:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_IN
1798:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1799:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1800:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1801:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Attr0 in MAIR0 is configured as normal memory. */
1802:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_IN
1803:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1804:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1805:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1806:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1807:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Invalidate the region. */
1808:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
1809:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
1810:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1811:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1812:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             lIndex++;
1813:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1814:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1815:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1816:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1817:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1818:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1819:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsAuthorizedToAccessBuffer( const void * pvBuffer,
1820:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                 uint32_t ulBufferLength,
1821:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                 uint32_t ulAccessRequested ) /* PRIVILEGED_FUNCTION
1822:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1823:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1824:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t i, ulBufferStartAddress, ulBufferEndAddress;
1825:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         BaseType_t xAccessGranted = pdFALSE;
1826:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU
1827:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1828:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEG
1829:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1830:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xAccessGranted = pdTRUE;
1831:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1832:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1833:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1834:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( portADD_UINT32_WILL_OVERFLOW( ( ( uint32_t ) pvBuffer ), ( ulBufferLength - 1UL ) )
1835:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1836:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulBufferStartAddress = ( uint32_t ) pvBuffer;
1837:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulBufferEndAddress = ( ( ( uint32_t ) pvBuffer ) + ulBufferLength - 1UL );
1838:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1839:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 for( i = 0; i < portTOTAL_NUM_REGIONS; i++ )
1840:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1841:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Is the MPU region enabled? */
1842:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     if( ( xTaskMpuSettings->xRegionsSettings[ i ].ulRLAR & portMPU_RLAR_REGION_ENAB
ARM GAS  /tmp/cczusFlJ.s 			page 48


1843:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     {
1844:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         if( portIS_ADDRESS_WITHIN_RANGE( ulBufferStartAddress,
1845:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_FIRST_ADDRESS_FROM_RBAR( xTask
1846:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskM
1847:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             portIS_ADDRESS_WITHIN_RANGE( ulBufferEndAddress,
1848:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_FIRST_ADDRESS_FROM_RBAR( xTask
1849:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskM
1850:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             portIS_AUTHORIZED( ulAccessRequested,
1851:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                prvGetRegionAccessPermissions( xTaskMpuSettings->xRe
1852:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         {
1853:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             xAccessGranted = pdTRUE;
1854:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             break;
1855:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         }
1856:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     }
1857:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1858:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1859:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1860:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1861:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return xAccessGranted;
1862:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1863:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1864:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1865:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1866:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortIsInsideInterrupt( void )
1867:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 780              		.loc 1 1867 1 is_stmt 1 view -0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 0
 783              		@ frame_needed = 0, uses_anonymous_args = 0
 784              		@ link register save eliminated.
1868:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulCurrentInterrupt;
 785              		.loc 1 1868 5 view .LVU216
1869:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xReturn;
 786              		.loc 1 1869 5 view .LVU217
1870:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1871:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Obtain the number of the currently executing interrupt. Interrupt Program
1872:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * Status Register (IPSR) holds the exception number of the currently-executing
1873:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * exception or zero for Thread mode.*/
1874:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 787              		.loc 1 1874 5 view .LVU218
 788              		.syntax unified
 789              	@ 1874 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 790 0000 EFF30580 		mrs r0, ipsr
 791              	@ 0 "" 2
 792              	.LVL39:
1875:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1876:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     if( ulCurrentInterrupt == 0 )
 793              		.loc 1 1876 5 view .LVU219
1877:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1878:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xReturn = pdFALSE;
1879:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1880:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     else
1881:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1882:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xReturn = pdTRUE;
1883:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1884:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1885:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     return xReturn;
ARM GAS  /tmp/cczusFlJ.s 			page 49


 794              		.loc 1 1885 5 view .LVU220
1886:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 795              		.loc 1 1886 1 is_stmt 0 view .LVU221
 796              		.thumb
 797              		.syntax unified
 798 0004 0038     		subs	r0, r0, #0
 799              		.loc 1 1886 1 view .LVU222
 800 0006 18BF     		it	ne
 801 0008 0120     		movne	r0, #1
 802              	.LVL40:
 803              		.loc 1 1886 1 view .LVU223
 804 000a 7047     		bx	lr
 805              		.cfi_endproc
 806              	.LFE11:
 808              		.section	.text.vPortValidateInterruptPriority,"ax",%progbits
 809              		.align	1
 810              		.global	vPortValidateInterruptPriority
 811              		.syntax unified
 812              		.thumb
 813              		.thumb_func
 815              	vPortValidateInterruptPriority:
 816              	.LFB12:
1887:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1888:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1889:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
1890:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1891:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vPortValidateInterruptPriority( void )
1892:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 817              		.loc 1 1892 5 is_stmt 1 view -0
 818              		.cfi_startproc
 819              		@ args = 0, pretend = 0, frame = 0
 820              		@ frame_needed = 0, uses_anonymous_args = 0
1893:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulCurrentInterrupt;
 821              		.loc 1 1893 9 view .LVU225
1894:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint8_t ucCurrentPriority;
 822              		.loc 1 1894 9 view .LVU226
1895:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1896:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Obtain the number of the currently executing interrupt. */
1897:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 823              		.loc 1 1897 9 view .LVU227
1892:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulCurrentInterrupt;
 824              		.loc 1 1892 5 is_stmt 0 view .LVU228
 825 0000 08B5     		push	{r3, lr}
 826              		.cfi_def_cfa_offset 8
 827              		.cfi_offset 3, -8
 828              		.cfi_offset 14, -4
 829              		.loc 1 1897 9 view .LVU229
 830              		.syntax unified
 831              	@ 1897 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 832 0002 EFF30583 		mrs r3, ipsr
 833              	@ 0 "" 2
 834              	.LVL41:
1898:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1899:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Is the interrupt number a user defined interrupt? */
1900:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 835              		.loc 1 1900 9 is_stmt 1 view .LVU230
 836              		.loc 1 1900 11 is_stmt 0 view .LVU231
ARM GAS  /tmp/cczusFlJ.s 			page 50


 837              		.thumb
 838              		.syntax unified
 839 0006 0F2B     		cmp	r3, #15
 840 0008 0ED9     		bls	.L50
1901:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1902:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Look up the interrupt's priority. */
1903:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 841              		.loc 1 1903 13 is_stmt 1 view .LVU232
 842              		.loc 1 1903 61 is_stmt 0 view .LVU233
 843 000a 104A     		ldr	r2, .L53
 844              		.loc 1 1903 31 view .LVU234
 845 000c 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 846              	.LVL42:
1904:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1905:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* The following assertion will fail if a service routine (ISR) for
1906:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * an interrupt that has been assigned a priority above
1907:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
1908:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * function.  ISR safe FreeRTOS API functions must *only* be called
1909:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * from interrupts that have been assigned a priority at or below
1910:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY.
1911:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1912:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Numerically low interrupt priority numbers represent logically high
1913:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * interrupt priorities, therefore the priority of the interrupt must
1914:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * be set to a value equal to or numerically *higher* than
1915:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY.
1916:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1917:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Interrupts that  use the FreeRTOS API must not be left at their
1918:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * default priority of  zero as that is the highest possible priority,
1919:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
1920:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and  therefore also guaranteed to be invalid.
1921:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * FreeRTOS maintains separate thread and ISR API functions to ensure
1923:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * interrupt entry is as fast and simple as possible.
1924:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1925:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * The following links provide detailed information:
1926:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
1927:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * https://www.FreeRTOS.org/FAQHelp.html */
1928:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 847              		.loc 1 1928 13 is_stmt 1 view .LVU235
 848 000e 104A     		ldr	r2, .L53+4
 849 0010 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 850 0012 9A42     		cmp	r2, r3
 851 0014 08D9     		bls	.L50
 852              		.loc 1 1928 13 discriminator 1 view .LVU236
 853 0016 FFF7FEFF 		bl	ulSetInterruptMask
 854              	.LVL43:
 855              		.loc 1 1928 13 discriminator 1 view .LVU237
 856 001a 4FF4F161 		mov	r1, #1928
 857 001e 0D4B     		ldr	r3, .L53+8
 858 0020 0D4A     		ldr	r2, .L53+12
 859              	.LVL44:
 860              	.L52:
1929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1930:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1931:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Priority grouping:  The interrupt controller (NVIC) allows the bits
1932:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * that define each interrupt's priority to be split between bits that
1933:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * define the interrupt's pre-emption priority bits and bits that define
ARM GAS  /tmp/cczusFlJ.s 			page 51


1934:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * the interrupt's sub-priority.  For simplicity all bits must be defined
1935:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * to be pre-emption priority bits.  The following assertion will fail if
1936:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * this is not the case (if some bits represent a sub-priority).
1937:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *
1938:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * If the application only uses CMSIS libraries for interrupt
1939:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * configuration then the correct setting can be achieved on all Cortex-M
1940:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
1941:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * scheduler.  Note however that some vendor specific peripheral libraries
1942:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * assume a non-zero priority group setting, in which cases using a value
1943:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * of zero will result in unpredictable behaviour. */
1944:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 861              		.loc 1 1944 9 is_stmt 0 discriminator 1 view .LVU238
 862 0022 0E48     		ldr	r0, .L53+16
 863 0024 FFF7FEFF 		bl	__assert_func
 864              	.LVL45:
 865              	.L50:
1928:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 866              		.loc 1 1928 70 is_stmt 1 discriminator 2 view .LVU239
 867              		.loc 1 1944 9 view .LVU240
 868 0028 4FF0E023 		mov	r3, #-536813568
 869 002c 0C4A     		ldr	r2, .L53+20
 870 002e D3F80C3D 		ldr	r3, [r3, #3340]
 871 0032 1268     		ldr	r2, [r2]
 872 0034 03F4E063 		and	r3, r3, #1792
 873 0038 9342     		cmp	r3, r2
 874 003a 06D9     		bls	.L49
 875              		.loc 1 1944 9 discriminator 1 view .LVU241
 876 003c FFF7FEFF 		bl	ulSetInterruptMask
 877              	.LVL46:
 878              		.loc 1 1944 9 discriminator 1 view .LVU242
 879 0040 4FF4F361 		mov	r1, #1944
 880 0044 034B     		ldr	r3, .L53+8
 881 0046 044A     		ldr	r2, .L53+12
 882 0048 EBE7     		b	.L52
 883              	.L49:
1945:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 884              		.loc 1 1945 5 is_stmt 0 view .LVU243
 885 004a 08BD     		pop	{r3, pc}
 886              	.L54:
 887              		.align	2
 888              	.L53:
 889 004c F0E300E0 		.word	-536812560
 890 0050 00000000 		.word	ucMaxSysCallPriority
 891 0054 00000000 		.word	.LC0
 892 0058 00000000 		.word	__func__.0
 893 005c 02000000 		.word	.LC1
 894 0060 00000000 		.word	ulMaxPRIGROUPValue
 895              		.cfi_endproc
 896              	.LFE12:
 898              		.section	.rodata.__func__.0,"a"
 901              	__func__.0:
 902 0000 76506F72 		.ascii	"vPortValidateInterruptPriority\000"
 902      7456616C 
 902      69646174 
 902      65496E74 
 902      65727275 
 903              		.section	.rodata.__func__.1,"a"
ARM GAS  /tmp/cczusFlJ.s 			page 52


 906              	__func__.1:
 907 0000 76506F72 		.ascii	"vPortEndScheduler\000"
 907      74456E64 
 907      53636865 
 907      64756C65 
 907      7200
 908              		.section	.rodata.__func__.2,"a"
 911              	__func__.2:
 912 0000 78506F72 		.ascii	"xPortStartScheduler\000"
 912      74537461 
 912      72745363 
 912      68656475 
 912      6C657200 
 913              		.section	.rodata.__func__.3,"a"
 916              	__func__.3:
 917 0000 70727654 		.ascii	"prvTaskExitError\000"
 917      61736B45 
 917      78697445 
 917      72726F72 
 917      00
 918              		.section	.rodata.__func__.4,"a"
 921              	__func__.4:
 922 0000 76506F72 		.ascii	"vPortSVCHandler_C\000"
 922      74535643 
 922      48616E64 
 922      6C65725F 
 922      4300
 923              		.section	.rodata.__func__.5,"a"
 926              	__func__.5:
 927 0000 76506F72 		.ascii	"vPortExitCritical\000"
 927      74457869 
 927      74437269 
 927      74696361 
 927      6C00
 928              		.section	.bss.ulMaxPRIGROUPValue,"aw",%nobits
 929              		.align	2
 932              	ulMaxPRIGROUPValue:
 933 0000 00000000 		.space	4
 934              		.section	.bss.ucMaxSysCallPriority,"aw",%nobits
 937              	ucMaxSysCallPriority:
 938 0000 00       		.space	1
 939              		.section	.data.ulCriticalNesting,"aw"
 940              		.align	2
 943              	ulCriticalNesting:
 944 0000 AAAAAAAA 		.word	-1431655766
 945              		.text
 946              	.Letext0:
 947              		.file 2 "/opt/st/stm32cubeide_1.18.1/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-
 948              		.file 3 "/opt/st/stm32cubeide_1.18.1/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-
 949              		.file 4 "Lib/FreeRTOS/Source/include/projdefs.h"
 950              		.file 5 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 951              		.file 6 "Lib/FreeRTOS/Source/include/task.h"
 952              		.file 7 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portasm.h"
 953              		.file 8 "Inc/FreeRTOSConfig.h"
 954              		.file 9 "/opt/st/stm32cubeide_1.18.1/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-
ARM GAS  /tmp/cczusFlJ.s 			page 53


DEFINED SYMBOLS
                            *ABS*:00000000 port.c
     /tmp/cczusFlJ.s:32     .text.prvTaskExitError:00000000 $t
     /tmp/cczusFlJ.s:37     .text.prvTaskExitError:00000000 prvTaskExitError
     /tmp/cczusFlJ.s:93     .text.prvTaskExitError:00000030 $d
     /tmp/cczusFlJ.s:943    .data.ulCriticalNesting:00000000 ulCriticalNesting
     /tmp/cczusFlJ.s:916    .rodata.__func__.3:00000000 __func__.3
     /tmp/cczusFlJ.s:101    .text.vPortSetupTimerInterrupt:00000000 $t
     /tmp/cczusFlJ.s:107    .text.vPortSetupTimerInterrupt:00000000 vPortSetupTimerInterrupt
     /tmp/cczusFlJ.s:143    .text.vPortSetupTimerInterrupt:00000020 $d
     /tmp/cczusFlJ.s:148    .text.vPortYield:00000000 $t
     /tmp/cczusFlJ.s:154    .text.vPortYield:00000000 vPortYield
     /tmp/cczusFlJ.s:183    .text.vPortEnterCritical:00000000 $t
     /tmp/cczusFlJ.s:189    .text.vPortEnterCritical:00000000 vPortEnterCritical
     /tmp/cczusFlJ.s:226    .text.vPortEnterCritical:00000018 $d
     /tmp/cczusFlJ.s:231    .text.vPortExitCritical:00000000 $t
     /tmp/cczusFlJ.s:237    .text.vPortExitCritical:00000000 vPortExitCritical
     /tmp/cczusFlJ.s:292    .text.vPortExitCritical:00000030 $d
     /tmp/cczusFlJ.s:926    .rodata.__func__.5:00000000 __func__.5
     /tmp/cczusFlJ.s:300    .text.SysTick_Handler:00000000 $t
     /tmp/cczusFlJ.s:306    .text.SysTick_Handler:00000000 SysTick_Handler
     /tmp/cczusFlJ.s:352    .text.vPortSVCHandler_C:00000000 $t
     /tmp/cczusFlJ.s:358    .text.vPortSVCHandler_C:00000000 vPortSVCHandler_C
     /tmp/cczusFlJ.s:426    .text.vPortSVCHandler_C:00000044 $d
     /tmp/cczusFlJ.s:921    .rodata.__func__.4:00000000 __func__.4
     /tmp/cczusFlJ.s:433    .text.pxPortInitialiseStack:00000000 $t
     /tmp/cczusFlJ.s:439    .text.pxPortInitialiseStack:00000000 pxPortInitialiseStack
     /tmp/cczusFlJ.s:541    .text.pxPortInitialiseStack:0000006c $d
     /tmp/cczusFlJ.s:546    .text.xPortStartScheduler:00000000 $t
     /tmp/cczusFlJ.s:552    .text.xPortStartScheduler:00000000 xPortStartScheduler
     /tmp/cczusFlJ.s:715    .text.xPortStartScheduler:000000d0 $d
     /tmp/cczusFlJ.s:937    .bss.ucMaxSysCallPriority:00000000 ucMaxSysCallPriority
     /tmp/cczusFlJ.s:911    .rodata.__func__.2:00000000 __func__.2
     /tmp/cczusFlJ.s:932    .bss.ulMaxPRIGROUPValue:00000000 ulMaxPRIGROUPValue
     /tmp/cczusFlJ.s:725    .text.vPortEndScheduler:00000000 $t
     /tmp/cczusFlJ.s:731    .text.vPortEndScheduler:00000000 vPortEndScheduler
     /tmp/cczusFlJ.s:764    .text.vPortEndScheduler:00000020 $d
     /tmp/cczusFlJ.s:906    .rodata.__func__.1:00000000 __func__.1
     /tmp/cczusFlJ.s:772    .text.xPortIsInsideInterrupt:00000000 $t
     /tmp/cczusFlJ.s:778    .text.xPortIsInsideInterrupt:00000000 xPortIsInsideInterrupt
     /tmp/cczusFlJ.s:809    .text.vPortValidateInterruptPriority:00000000 $t
     /tmp/cczusFlJ.s:815    .text.vPortValidateInterruptPriority:00000000 vPortValidateInterruptPriority
     /tmp/cczusFlJ.s:889    .text.vPortValidateInterruptPriority:0000004c $d
     /tmp/cczusFlJ.s:901    .rodata.__func__.0:00000000 __func__.0
     /tmp/cczusFlJ.s:929    .bss.ulMaxPRIGROUPValue:00000000 $d
     /tmp/cczusFlJ.s:938    .bss.ucMaxSysCallPriority:00000000 $d
     /tmp/cczusFlJ.s:940    .data.ulCriticalNesting:00000000 $d
                           .group:00000000 wm4.0.c552ae9005b0f2cca11872fae5d4b7f2
                           .group:00000000 wm4.stddef.h.39.0dc9006b34572d4d9cae4c8b422c4971
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.features.h.33.e0c9f337c65cb9f22ed5f23d082bc78b
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.newlib.h.7.a37ffbe9e5aff74303f4e60b1cc1c01b
ARM GAS  /tmp/cczusFlJ.s 			page 54


                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.FreeRTOSConfig.h.59.2629c72cff9e6dbe880a2dc225eae516
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.mpu_syscall_numbers.h.30.0a27a9934a6f5d596ea064151c3c3bfa

UNDEFINED SYMBOLS
ulSetInterruptMask
__assert_func
SystemCoreClock
vClearInterruptMask
xTaskIncrementTick
vRestoreContextOfFirstTask
vStartFirstTask
vTaskSwitchContext
