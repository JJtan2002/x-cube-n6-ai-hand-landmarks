ARM GAS  /tmp/ccTT1k9d.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 4
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"queue.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Lib/FreeRTOS/Source/queue.c"
  25              		.section	.text.prvIsQueueEmpty,"ax",%progbits
  26              		.align	1
  27              		.syntax unified
  28              		.thumb
  29              		.thumb_func
  31              	prvIsQueueEmpty:
  32              	.LVL0:
  33              	.LFB32:
   1:Lib/FreeRTOS/Source/queue.c **** /*
   2:Lib/FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.6.2
   3:Lib/FreeRTOS/Source/queue.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Lib/FreeRTOS/Source/queue.c ****  *
   5:Lib/FreeRTOS/Source/queue.c ****  * SPDX-License-Identifier: MIT
   6:Lib/FreeRTOS/Source/queue.c ****  *
   7:Lib/FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:Lib/FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:Lib/FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
  10:Lib/FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:Lib/FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:Lib/FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  13:Lib/FreeRTOS/Source/queue.c ****  *
  14:Lib/FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  15:Lib/FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  16:Lib/FreeRTOS/Source/queue.c ****  *
  17:Lib/FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:Lib/FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:Lib/FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:Lib/FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:Lib/FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:Lib/FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:Lib/FreeRTOS/Source/queue.c ****  *
  24:Lib/FreeRTOS/Source/queue.c ****  * https://www.FreeRTOS.org
  25:Lib/FreeRTOS/Source/queue.c ****  * https://github.com/FreeRTOS
ARM GAS  /tmp/ccTT1k9d.s 			page 2


  26:Lib/FreeRTOS/Source/queue.c ****  *
  27:Lib/FreeRTOS/Source/queue.c ****  */
  28:Lib/FreeRTOS/Source/queue.c **** 
  29:Lib/FreeRTOS/Source/queue.c **** #include <stdlib.h>
  30:Lib/FreeRTOS/Source/queue.c **** #include <string.h>
  31:Lib/FreeRTOS/Source/queue.c **** 
  32:Lib/FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:Lib/FreeRTOS/Source/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  34:Lib/FreeRTOS/Source/queue.c ****  * task.h is included from an application file. */
  35:Lib/FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:Lib/FreeRTOS/Source/queue.c **** 
  37:Lib/FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  38:Lib/FreeRTOS/Source/queue.c **** #include "task.h"
  39:Lib/FreeRTOS/Source/queue.c **** #include "queue.h"
  40:Lib/FreeRTOS/Source/queue.c **** 
  41:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  42:Lib/FreeRTOS/Source/queue.c ****     #include "croutine.h"
  43:Lib/FreeRTOS/Source/queue.c **** #endif
  44:Lib/FreeRTOS/Source/queue.c **** 
  45:Lib/FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  46:Lib/FreeRTOS/Source/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  47:Lib/FreeRTOS/Source/queue.c ****  * for the header files above, but not in this file, in order to generate the
  48:Lib/FreeRTOS/Source/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  49:Lib/FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  50:Lib/FreeRTOS/Source/queue.c **** 
  51:Lib/FreeRTOS/Source/queue.c **** 
  52:Lib/FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  53:Lib/FreeRTOS/Source/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  54:Lib/FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  55:Lib/FreeRTOS/Source/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  56:Lib/FreeRTOS/Source/queue.c **** 
  57:Lib/FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  58:Lib/FreeRTOS/Source/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  59:Lib/FreeRTOS/Source/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  60:Lib/FreeRTOS/Source/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  61:Lib/FreeRTOS/Source/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  62:Lib/FreeRTOS/Source/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
  63:Lib/FreeRTOS/Source/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  64:Lib/FreeRTOS/Source/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  65:Lib/FreeRTOS/Source/queue.c ****  * being used for. */
  66:Lib/FreeRTOS/Source/queue.c **** #define uxQueueType               pcHead
  67:Lib/FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  68:Lib/FreeRTOS/Source/queue.c **** 
  69:Lib/FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  70:Lib/FreeRTOS/Source/queue.c **** {
  71:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcTail;     /**< Points to the byte at the end of the queue storage area.  Once more b
  72:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcReadFrom; /**< Points to the last place that a queued item was read from when the st
  73:Lib/FreeRTOS/Source/queue.c **** } QueuePointers_t;
  74:Lib/FreeRTOS/Source/queue.c **** 
  75:Lib/FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  76:Lib/FreeRTOS/Source/queue.c **** {
  77:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xMutexHolder;        /**< The handle of the task that holds the mutex. */
  78:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxRecursiveCallCount; /**< Maintains a count of the number of times a recursive mut
  79:Lib/FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  80:Lib/FreeRTOS/Source/queue.c **** 
  81:Lib/FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  82:Lib/FreeRTOS/Source/queue.c ****  * zero. */
ARM GAS  /tmp/ccTT1k9d.s 			page 3


  83:Lib/FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  84:Lib/FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  85:Lib/FreeRTOS/Source/queue.c **** 
  86:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  87:Lib/FreeRTOS/Source/queue.c **** 
  88:Lib/FreeRTOS/Source/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  89:Lib/FreeRTOS/Source/queue.c ****  * performed just because a higher priority task has been woken. */
  90:Lib/FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  91:Lib/FreeRTOS/Source/queue.c **** #else
  92:Lib/FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  93:Lib/FreeRTOS/Source/queue.c **** #endif
  94:Lib/FreeRTOS/Source/queue.c **** 
  95:Lib/FreeRTOS/Source/queue.c **** /*
  96:Lib/FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  97:Lib/FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  98:Lib/FreeRTOS/Source/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  99:Lib/FreeRTOS/Source/queue.c ****  */
 100:Lib/FreeRTOS/Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
 101:Lib/FreeRTOS/Source/queue.c **** {
 102:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcHead;           /**< Points to the beginning of the queue storage area. */
 103:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcWriteTo;        /**< Points to the free next place in the storage area. */
 104:Lib/FreeRTOS/Source/queue.c **** 
 105:Lib/FreeRTOS/Source/queue.c ****     union
 106:Lib/FreeRTOS/Source/queue.c ****     {
 107:Lib/FreeRTOS/Source/queue.c ****         QueuePointers_t xQueue;     /**< Data required exclusively when this structure is used as a
 108:Lib/FreeRTOS/Source/queue.c ****         SemaphoreData_t xSemaphore; /**< Data required exclusively when this structure is used as a
 109:Lib/FreeRTOS/Source/queue.c ****     } u;
 110:Lib/FreeRTOS/Source/queue.c **** 
 111:Lib/FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToSend;             /**< List of tasks that are blocked waiting to post ont
 112:Lib/FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToReceive;          /**< List of tasks that are blocked waiting to read fro
 113:Lib/FreeRTOS/Source/queue.c **** 
 114:Lib/FreeRTOS/Source/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /**< The number of items currently in the queue. */
 115:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxLength;                   /**< The length of the queue defined as the number of i
 116:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxItemSize;                 /**< The size of each items that the queue will hold. *
 117:Lib/FreeRTOS/Source/queue.c **** 
 118:Lib/FreeRTOS/Source/queue.c ****     volatile int8_t cRxLock;                /**< Stores the number of items received from the queue
 119:Lib/FreeRTOS/Source/queue.c ****     volatile int8_t cTxLock;                /**< Stores the number of items transmitted to the queu
 120:Lib/FreeRTOS/Source/queue.c **** 
 121:Lib/FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 122:Lib/FreeRTOS/Source/queue.c ****         uint8_t ucStaticallyAllocated; /**< Set to pdTRUE if the memory used by the queue was stati
 123:Lib/FreeRTOS/Source/queue.c ****     #endif
 124:Lib/FreeRTOS/Source/queue.c **** 
 125:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 126:Lib/FreeRTOS/Source/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 127:Lib/FreeRTOS/Source/queue.c ****     #endif
 128:Lib/FreeRTOS/Source/queue.c **** 
 129:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 130:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t uxQueueNumber;
 131:Lib/FreeRTOS/Source/queue.c ****         uint8_t ucQueueType;
 132:Lib/FreeRTOS/Source/queue.c ****     #endif
 133:Lib/FreeRTOS/Source/queue.c **** } xQUEUE;
 134:Lib/FreeRTOS/Source/queue.c **** 
 135:Lib/FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 136:Lib/FreeRTOS/Source/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 137:Lib/FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 138:Lib/FreeRTOS/Source/queue.c **** 
 139:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccTT1k9d.s 			page 4


 140:Lib/FreeRTOS/Source/queue.c **** 
 141:Lib/FreeRTOS/Source/queue.c **** /*
 142:Lib/FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 143:Lib/FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 144:Lib/FreeRTOS/Source/queue.c ****  */
 145:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 146:Lib/FreeRTOS/Source/queue.c **** 
 147:Lib/FreeRTOS/Source/queue.c **** /* The type stored within the queue registry array.  This allows a name
 148:Lib/FreeRTOS/Source/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 149:Lib/FreeRTOS/Source/queue.c ****  * more user friendly. */
 150:Lib/FreeRTOS/Source/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 151:Lib/FreeRTOS/Source/queue.c ****     {
 152:Lib/FreeRTOS/Source/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 153:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 154:Lib/FreeRTOS/Source/queue.c ****     } xQueueRegistryItem;
 155:Lib/FreeRTOS/Source/queue.c **** 
 156:Lib/FreeRTOS/Source/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 157:Lib/FreeRTOS/Source/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 158:Lib/FreeRTOS/Source/queue.c ****  * debuggers. */
 159:Lib/FreeRTOS/Source/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 160:Lib/FreeRTOS/Source/queue.c **** 
 161:Lib/FreeRTOS/Source/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 162:Lib/FreeRTOS/Source/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 163:Lib/FreeRTOS/Source/queue.c ****  * array position being vacant. */
 164:Lib/FreeRTOS/Source/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 165:Lib/FreeRTOS/Source/queue.c **** 
 166:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 167:Lib/FreeRTOS/Source/queue.c **** 
 168:Lib/FreeRTOS/Source/queue.c **** /*
 169:Lib/FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 170:Lib/FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 171:Lib/FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 172:Lib/FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 173:Lib/FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 174:Lib/FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 175:Lib/FreeRTOS/Source/queue.c ****  */
 176:Lib/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 177:Lib/FreeRTOS/Source/queue.c **** 
 178:Lib/FreeRTOS/Source/queue.c **** /*
 179:Lib/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 180:Lib/FreeRTOS/Source/queue.c ****  *
 181:Lib/FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 182:Lib/FreeRTOS/Source/queue.c ****  */
 183:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 184:Lib/FreeRTOS/Source/queue.c **** 
 185:Lib/FreeRTOS/Source/queue.c **** /*
 186:Lib/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 187:Lib/FreeRTOS/Source/queue.c ****  *
 188:Lib/FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 189:Lib/FreeRTOS/Source/queue.c ****  */
 190:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 191:Lib/FreeRTOS/Source/queue.c **** 
 192:Lib/FreeRTOS/Source/queue.c **** /*
 193:Lib/FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 194:Lib/FreeRTOS/Source/queue.c ****  * back of the queue.
 195:Lib/FreeRTOS/Source/queue.c ****  */
 196:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
ARM GAS  /tmp/ccTT1k9d.s 			page 5


 197:Lib/FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
 198:Lib/FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 199:Lib/FreeRTOS/Source/queue.c **** 
 200:Lib/FreeRTOS/Source/queue.c **** /*
 201:Lib/FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 202:Lib/FreeRTOS/Source/queue.c ****  */
 203:Lib/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
 204:Lib/FreeRTOS/Source/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 205:Lib/FreeRTOS/Source/queue.c **** 
 206:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 207:Lib/FreeRTOS/Source/queue.c **** 
 208:Lib/FreeRTOS/Source/queue.c **** /*
 209:Lib/FreeRTOS/Source/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 210:Lib/FreeRTOS/Source/queue.c ****  * the queue set that the queue contains data.
 211:Lib/FreeRTOS/Source/queue.c ****  */
 212:Lib/FreeRTOS/Source/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 213:Lib/FreeRTOS/Source/queue.c **** #endif
 214:Lib/FreeRTOS/Source/queue.c **** 
 215:Lib/FreeRTOS/Source/queue.c **** /*
 216:Lib/FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 217:Lib/FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 218:Lib/FreeRTOS/Source/queue.c ****  */
 219:Lib/FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 220:Lib/FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 221:Lib/FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 222:Lib/FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 223:Lib/FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 224:Lib/FreeRTOS/Source/queue.c **** 
 225:Lib/FreeRTOS/Source/queue.c **** /*
 226:Lib/FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 227:Lib/FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 228:Lib/FreeRTOS/Source/queue.c ****  * as a mutex.
 229:Lib/FreeRTOS/Source/queue.c ****  */
 230:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 231:Lib/FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 232:Lib/FreeRTOS/Source/queue.c **** #endif
 233:Lib/FreeRTOS/Source/queue.c **** 
 234:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 235:Lib/FreeRTOS/Source/queue.c **** 
 236:Lib/FreeRTOS/Source/queue.c **** /*
 237:Lib/FreeRTOS/Source/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 238:Lib/FreeRTOS/Source/queue.c ****  * priority, but the waiting task times out, then the holder should
 239:Lib/FreeRTOS/Source/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 240:Lib/FreeRTOS/Source/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 241:Lib/FreeRTOS/Source/queue.c ****  * that priority.
 242:Lib/FreeRTOS/Source/queue.c ****  */
 243:Lib/FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 244:Lib/FreeRTOS/Source/queue.c **** #endif
 245:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 246:Lib/FreeRTOS/Source/queue.c **** 
 247:Lib/FreeRTOS/Source/queue.c **** /*
 248:Lib/FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 249:Lib/FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 250:Lib/FreeRTOS/Source/queue.c ****  */
 251:Lib/FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )                            \
 252:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();                                  \
 253:Lib/FreeRTOS/Source/queue.c ****     {                                                      \
ARM GAS  /tmp/ccTT1k9d.s 			page 6


 254:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 255:Lib/FreeRTOS/Source/queue.c ****         {                                                  \
 256:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 257:Lib/FreeRTOS/Source/queue.c ****         }                                                  \
 258:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
 259:Lib/FreeRTOS/Source/queue.c ****         {                                                  \
 260:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
 261:Lib/FreeRTOS/Source/queue.c ****         }                                                  \
 262:Lib/FreeRTOS/Source/queue.c ****     }                                                      \
 263:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL()
 264:Lib/FreeRTOS/Source/queue.c **** 
 265:Lib/FreeRTOS/Source/queue.c **** /*
 266:Lib/FreeRTOS/Source/queue.c ****  * Macro to increment cTxLock member of the queue data structure. It is
 267:Lib/FreeRTOS/Source/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 268:Lib/FreeRTOS/Source/queue.c ****  * tasks than the number of tasks in the system.
 269:Lib/FreeRTOS/Source/queue.c ****  */
 270:Lib/FreeRTOS/Source/queue.c **** #define prvIncrementQueueTxLock( pxQueue, cTxLock )                           \
 271:Lib/FreeRTOS/Source/queue.c ****     do {                                                                      \
 272:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 273:Lib/FreeRTOS/Source/queue.c ****         if( ( UBaseType_t ) ( cTxLock ) < uxNumberOfTasks )                   \
 274:Lib/FreeRTOS/Source/queue.c ****         {                                                                     \
 275:Lib/FreeRTOS/Source/queue.c ****             configASSERT( ( cTxLock ) != queueINT8_MAX );                     \
 276:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cTxLock = ( int8_t ) ( ( cTxLock ) + ( int8_t ) 1 ); \
 277:Lib/FreeRTOS/Source/queue.c ****         }                                                                     \
 278:Lib/FreeRTOS/Source/queue.c ****     } while( 0 )
 279:Lib/FreeRTOS/Source/queue.c **** 
 280:Lib/FreeRTOS/Source/queue.c **** /*
 281:Lib/FreeRTOS/Source/queue.c ****  * Macro to increment cRxLock member of the queue data structure. It is
 282:Lib/FreeRTOS/Source/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 283:Lib/FreeRTOS/Source/queue.c ****  * tasks than the number of tasks in the system.
 284:Lib/FreeRTOS/Source/queue.c ****  */
 285:Lib/FreeRTOS/Source/queue.c **** #define prvIncrementQueueRxLock( pxQueue, cRxLock )                           \
 286:Lib/FreeRTOS/Source/queue.c ****     do {                                                                      \
 287:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 288:Lib/FreeRTOS/Source/queue.c ****         if( ( UBaseType_t ) ( cRxLock ) < uxNumberOfTasks )                   \
 289:Lib/FreeRTOS/Source/queue.c ****         {                                                                     \
 290:Lib/FreeRTOS/Source/queue.c ****             configASSERT( ( cRxLock ) != queueINT8_MAX );                     \
 291:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cRxLock = ( int8_t ) ( ( cRxLock ) + ( int8_t ) 1 ); \
 292:Lib/FreeRTOS/Source/queue.c ****         }                                                                     \
 293:Lib/FreeRTOS/Source/queue.c ****     } while( 0 )
 294:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 295:Lib/FreeRTOS/Source/queue.c **** 
 296:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 297:Lib/FreeRTOS/Source/queue.c ****                                BaseType_t xNewQueue )
 298:Lib/FreeRTOS/Source/queue.c **** {
 299:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdPASS;
 300:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 301:Lib/FreeRTOS/Source/queue.c **** 
 302:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 303:Lib/FreeRTOS/Source/queue.c **** 
 304:Lib/FreeRTOS/Source/queue.c ****     if( ( pxQueue != NULL ) &&
 305:Lib/FreeRTOS/Source/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 306:Lib/FreeRTOS/Source/queue.c ****         /* Check for multiplication overflow. */
 307:Lib/FreeRTOS/Source/queue.c ****         ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 308:Lib/FreeRTOS/Source/queue.c ****     {
 309:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 310:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 7


 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize 
 312:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 313:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 315:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 316:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 317:Lib/FreeRTOS/Source/queue.c **** 
 318:Lib/FreeRTOS/Source/queue.c ****             if( xNewQueue == pdFALSE )
 319:Lib/FreeRTOS/Source/queue.c ****             {
 320:Lib/FreeRTOS/Source/queue.c ****                 /* If there are tasks blocked waiting to read from the queue, then
 321:Lib/FreeRTOS/Source/queue.c ****                  * the tasks will remain blocked as after this function exits the queue
 322:Lib/FreeRTOS/Source/queue.c ****                  * will still be empty.  If there are tasks blocked waiting to write to
 323:Lib/FreeRTOS/Source/queue.c ****                  * the queue, then one should be unblocked as after this function exits
 324:Lib/FreeRTOS/Source/queue.c ****                  * it will be possible to write to it. */
 325:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 326:Lib/FreeRTOS/Source/queue.c ****                 {
 327:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 328:Lib/FreeRTOS/Source/queue.c ****                     {
 329:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 330:Lib/FreeRTOS/Source/queue.c ****                     }
 331:Lib/FreeRTOS/Source/queue.c ****                     else
 332:Lib/FreeRTOS/Source/queue.c ****                     {
 333:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
 334:Lib/FreeRTOS/Source/queue.c ****                     }
 335:Lib/FreeRTOS/Source/queue.c ****                 }
 336:Lib/FreeRTOS/Source/queue.c ****                 else
 337:Lib/FreeRTOS/Source/queue.c ****                 {
 338:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 339:Lib/FreeRTOS/Source/queue.c ****                 }
 340:Lib/FreeRTOS/Source/queue.c ****             }
 341:Lib/FreeRTOS/Source/queue.c ****             else
 342:Lib/FreeRTOS/Source/queue.c ****             {
 343:Lib/FreeRTOS/Source/queue.c ****                 /* Ensure the event queues start in the correct state. */
 344:Lib/FreeRTOS/Source/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 345:Lib/FreeRTOS/Source/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 346:Lib/FreeRTOS/Source/queue.c ****             }
 347:Lib/FreeRTOS/Source/queue.c ****         }
 348:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 349:Lib/FreeRTOS/Source/queue.c ****     }
 350:Lib/FreeRTOS/Source/queue.c ****     else
 351:Lib/FreeRTOS/Source/queue.c ****     {
 352:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFAIL;
 353:Lib/FreeRTOS/Source/queue.c ****     }
 354:Lib/FreeRTOS/Source/queue.c **** 
 355:Lib/FreeRTOS/Source/queue.c ****     configASSERT( xReturn != pdFAIL );
 356:Lib/FreeRTOS/Source/queue.c **** 
 357:Lib/FreeRTOS/Source/queue.c ****     /* A value is returned for calling semantic consistency with previous
 358:Lib/FreeRTOS/Source/queue.c ****      * versions. */
 359:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 360:Lib/FreeRTOS/Source/queue.c **** }
 361:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 362:Lib/FreeRTOS/Source/queue.c **** 
 363:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 364:Lib/FreeRTOS/Source/queue.c **** 
 365:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 366:Lib/FreeRTOS/Source/queue.c ****                                              const UBaseType_t uxItemSize,
 367:Lib/FreeRTOS/Source/queue.c ****                                              uint8_t * pucQueueStorage,
ARM GAS  /tmp/ccTT1k9d.s 			page 8


 368:Lib/FreeRTOS/Source/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 369:Lib/FreeRTOS/Source/queue.c ****                                              const uint8_t ucQueueType )
 370:Lib/FreeRTOS/Source/queue.c ****     {
 371:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
 372:Lib/FreeRTOS/Source/queue.c **** 
 373:Lib/FreeRTOS/Source/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 374:Lib/FreeRTOS/Source/queue.c ****          * supplied. */
 375:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxStaticQueue );
 376:Lib/FreeRTOS/Source/queue.c **** 
 377:Lib/FreeRTOS/Source/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 378:Lib/FreeRTOS/Source/queue.c ****             ( pxStaticQueue != NULL ) &&
 379:Lib/FreeRTOS/Source/queue.c **** 
 380:Lib/FreeRTOS/Source/queue.c ****             /* A queue storage area should be provided if the item size is not 0, and
 381:Lib/FreeRTOS/Source/queue.c ****              * should not be provided if the item size is 0. */
 382:Lib/FreeRTOS/Source/queue.c ****             ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 383:Lib/FreeRTOS/Source/queue.c ****             ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
 384:Lib/FreeRTOS/Source/queue.c ****         {
 385:Lib/FreeRTOS/Source/queue.c ****             #if ( configASSERT_DEFINED == 1 )
 386:Lib/FreeRTOS/Source/queue.c ****             {
 387:Lib/FreeRTOS/Source/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 388:Lib/FreeRTOS/Source/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 389:Lib/FreeRTOS/Source/queue.c ****                  * the real queue and semaphore structures. */
 390:Lib/FreeRTOS/Source/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 391:Lib/FreeRTOS/Source/queue.c **** 
 392:Lib/FreeRTOS/Source/queue.c ****                 /* This assertion cannot be branch covered in unit tests */
 393:Lib/FreeRTOS/Source/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 394:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 395:Lib/FreeRTOS/Source/queue.c ****             }
 396:Lib/FreeRTOS/Source/queue.c ****             #endif /* configASSERT_DEFINED */
 397:Lib/FreeRTOS/Source/queue.c **** 
 398:Lib/FreeRTOS/Source/queue.c ****             /* The address of a statically allocated queue was passed in, use it.
 399:Lib/FreeRTOS/Source/queue.c ****              * The address of a statically allocated storage area was also passed in
 400:Lib/FreeRTOS/Source/queue.c ****              * but is already set. */
 401:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the
 402:Lib/FreeRTOS/Source/queue.c **** 
 403:Lib/FreeRTOS/Source/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 404:Lib/FreeRTOS/Source/queue.c ****             {
 405:Lib/FreeRTOS/Source/queue.c ****                 /* Queues can be allocated wither statically or dynamically, so
 406:Lib/FreeRTOS/Source/queue.c ****                  * note this queue was allocated statically in case the queue is
 407:Lib/FreeRTOS/Source/queue.c ****                  * later deleted. */
 408:Lib/FreeRTOS/Source/queue.c ****                 pxNewQueue->ucStaticallyAllocated = pdTRUE;
 409:Lib/FreeRTOS/Source/queue.c ****             }
 410:Lib/FreeRTOS/Source/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 411:Lib/FreeRTOS/Source/queue.c **** 
 412:Lib/FreeRTOS/Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 413:Lib/FreeRTOS/Source/queue.c ****         }
 414:Lib/FreeRTOS/Source/queue.c ****         else
 415:Lib/FreeRTOS/Source/queue.c ****         {
 416:Lib/FreeRTOS/Source/queue.c ****             configASSERT( pxNewQueue );
 417:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 418:Lib/FreeRTOS/Source/queue.c ****         }
 419:Lib/FreeRTOS/Source/queue.c **** 
 420:Lib/FreeRTOS/Source/queue.c ****         return pxNewQueue;
 421:Lib/FreeRTOS/Source/queue.c ****     }
 422:Lib/FreeRTOS/Source/queue.c **** 
 423:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 424:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccTT1k9d.s 			page 9


 425:Lib/FreeRTOS/Source/queue.c **** 
 426:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 427:Lib/FreeRTOS/Source/queue.c **** 
 428:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueGenericGetStaticBuffers( QueueHandle_t xQueue,
 429:Lib/FreeRTOS/Source/queue.c ****                                               uint8_t ** ppucQueueStorage,
 430:Lib/FreeRTOS/Source/queue.c ****                                               StaticQueue_t ** ppxStaticQueue )
 431:Lib/FreeRTOS/Source/queue.c ****     {
 432:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 433:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 434:Lib/FreeRTOS/Source/queue.c **** 
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxQueue );
 436:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 437:Lib/FreeRTOS/Source/queue.c **** 
 438:Lib/FreeRTOS/Source/queue.c ****         #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 439:Lib/FreeRTOS/Source/queue.c ****         {
 440:Lib/FreeRTOS/Source/queue.c ****             /* Check if the queue was statically allocated. */
 441:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdTRUE )
 442:Lib/FreeRTOS/Source/queue.c ****             {
 443:Lib/FreeRTOS/Source/queue.c ****                 if( ppucQueueStorage != NULL )
 444:Lib/FreeRTOS/Source/queue.c ****                 {
 445:Lib/FreeRTOS/Source/queue.c ****                     *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;
 446:Lib/FreeRTOS/Source/queue.c ****                 }
 447:Lib/FreeRTOS/Source/queue.c **** 
 448:Lib/FreeRTOS/Source/queue.c ****                 *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;
 449:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdTRUE;
 450:Lib/FreeRTOS/Source/queue.c ****             }
 451:Lib/FreeRTOS/Source/queue.c ****             else
 452:Lib/FreeRTOS/Source/queue.c ****             {
 453:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdFALSE;
 454:Lib/FreeRTOS/Source/queue.c ****             }
 455:Lib/FreeRTOS/Source/queue.c ****         }
 456:Lib/FreeRTOS/Source/queue.c ****         #else /* configSUPPORT_DYNAMIC_ALLOCATION */
 457:Lib/FreeRTOS/Source/queue.c ****         {
 458:Lib/FreeRTOS/Source/queue.c ****             /* Queue must have been statically allocated. */
 459:Lib/FreeRTOS/Source/queue.c ****             if( ppucQueueStorage != NULL )
 460:Lib/FreeRTOS/Source/queue.c ****             {
 461:Lib/FreeRTOS/Source/queue.c ****                 *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;
 462:Lib/FreeRTOS/Source/queue.c ****             }
 463:Lib/FreeRTOS/Source/queue.c **** 
 464:Lib/FreeRTOS/Source/queue.c ****             *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;
 465:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 466:Lib/FreeRTOS/Source/queue.c ****         }
 467:Lib/FreeRTOS/Source/queue.c ****         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 468:Lib/FreeRTOS/Source/queue.c **** 
 469:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 470:Lib/FreeRTOS/Source/queue.c ****     }
 471:Lib/FreeRTOS/Source/queue.c **** 
 472:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 473:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 474:Lib/FreeRTOS/Source/queue.c **** 
 475:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 476:Lib/FreeRTOS/Source/queue.c **** 
 477:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 478:Lib/FreeRTOS/Source/queue.c ****                                        const UBaseType_t uxItemSize,
 479:Lib/FreeRTOS/Source/queue.c ****                                        const uint8_t ucQueueType )
 480:Lib/FreeRTOS/Source/queue.c ****     {
 481:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
ARM GAS  /tmp/ccTT1k9d.s 			page 10


 482:Lib/FreeRTOS/Source/queue.c ****         size_t xQueueSizeInBytes;
 483:Lib/FreeRTOS/Source/queue.c ****         uint8_t * pucQueueStorage;
 484:Lib/FreeRTOS/Source/queue.c **** 
 485:Lib/FreeRTOS/Source/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 486:Lib/FreeRTOS/Source/queue.c ****             /* Check for multiplication overflow. */
 487:Lib/FreeRTOS/Source/queue.c ****             ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 488:Lib/FreeRTOS/Source/queue.c ****             /* Check for addition overflow. */
 489:Lib/FreeRTOS/Source/queue.c ****             ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 490:Lib/FreeRTOS/Source/queue.c ****         {
 491:Lib/FreeRTOS/Source/queue.c ****             /* Allocate enough space to hold the maximum number of items that
 492:Lib/FreeRTOS/Source/queue.c ****              * can be in the queue at any time.  It is valid for uxItemSize to be
 493:Lib/FreeRTOS/Source/queue.c ****              * zero in the case the queue is used as a semaphore. */
 494:Lib/FreeRTOS/Source/queue.c ****             xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA excep
 495:Lib/FreeRTOS/Source/queue.c **** 
 496:Lib/FreeRTOS/Source/queue.c ****             /* Allocate the queue and storage area.  Justification for MISRA
 497:Lib/FreeRTOS/Source/queue.c ****              * deviation as follows:  pvPortMalloc() always ensures returned memory
 498:Lib/FreeRTOS/Source/queue.c ****              * blocks are aligned per the requirements of the MCU stack.  In this case
 499:Lib/FreeRTOS/Source/queue.c ****              * pvPortMalloc() must return a pointer that is guaranteed to meet the
 500:Lib/FreeRTOS/Source/queue.c ****              * alignment requirements of the Queue_t structure - which in this case
 501:Lib/FreeRTOS/Source/queue.c ****              * is an int8_t *.  Therefore, whenever the stack alignment requirements
 502:Lib/FreeRTOS/Source/queue.c ****              * are greater than or equal to the pointer to char requirements the cast
 503:Lib/FreeRTOS/Source/queue.c ****              * is safe.  In other cases alignment requirements are not strict (one or
 504:Lib/FreeRTOS/Source/queue.c ****              * two bytes). */
 505:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lin
 506:Lib/FreeRTOS/Source/queue.c **** 
 507:Lib/FreeRTOS/Source/queue.c ****             if( pxNewQueue != NULL )
 508:Lib/FreeRTOS/Source/queue.c ****             {
 509:Lib/FreeRTOS/Source/queue.c ****                 /* Jump past the queue structure to find the location of the queue
 510:Lib/FreeRTOS/Source/queue.c ****                  * storage area. */
 511:Lib/FreeRTOS/Source/queue.c ****                 pucQueueStorage = ( uint8_t * ) pxNewQueue;
 512:Lib/FreeRTOS/Source/queue.c ****                 pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on c
 513:Lib/FreeRTOS/Source/queue.c **** 
 514:Lib/FreeRTOS/Source/queue.c ****                 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 515:Lib/FreeRTOS/Source/queue.c ****                 {
 516:Lib/FreeRTOS/Source/queue.c ****                     /* Queues can be created either statically or dynamically, so
 517:Lib/FreeRTOS/Source/queue.c ****                      * note this task was created dynamically in case it is later
 518:Lib/FreeRTOS/Source/queue.c ****                      * deleted. */
 519:Lib/FreeRTOS/Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 520:Lib/FreeRTOS/Source/queue.c ****                 }
 521:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configSUPPORT_STATIC_ALLOCATION */
 522:Lib/FreeRTOS/Source/queue.c **** 
 523:Lib/FreeRTOS/Source/queue.c ****                 prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxN
 524:Lib/FreeRTOS/Source/queue.c ****             }
 525:Lib/FreeRTOS/Source/queue.c ****             else
 526:Lib/FreeRTOS/Source/queue.c ****             {
 527:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_CREATE_FAILED( ucQueueType );
 528:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 529:Lib/FreeRTOS/Source/queue.c ****             }
 530:Lib/FreeRTOS/Source/queue.c ****         }
 531:Lib/FreeRTOS/Source/queue.c ****         else
 532:Lib/FreeRTOS/Source/queue.c ****         {
 533:Lib/FreeRTOS/Source/queue.c ****             configASSERT( pxNewQueue );
 534:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 535:Lib/FreeRTOS/Source/queue.c ****         }
 536:Lib/FreeRTOS/Source/queue.c **** 
 537:Lib/FreeRTOS/Source/queue.c ****         return pxNewQueue;
 538:Lib/FreeRTOS/Source/queue.c ****     }
ARM GAS  /tmp/ccTT1k9d.s 			page 11


 539:Lib/FreeRTOS/Source/queue.c **** 
 540:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 541:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 542:Lib/FreeRTOS/Source/queue.c **** 
 543:Lib/FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 544:Lib/FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 545:Lib/FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 546:Lib/FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 547:Lib/FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue )
 548:Lib/FreeRTOS/Source/queue.c **** {
 549:Lib/FreeRTOS/Source/queue.c ****     /* Remove compiler warnings about unused parameters should
 550:Lib/FreeRTOS/Source/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 551:Lib/FreeRTOS/Source/queue.c ****     ( void ) ucQueueType;
 552:Lib/FreeRTOS/Source/queue.c **** 
 553:Lib/FreeRTOS/Source/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 554:Lib/FreeRTOS/Source/queue.c ****     {
 555:Lib/FreeRTOS/Source/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 556:Lib/FreeRTOS/Source/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 557:Lib/FreeRTOS/Source/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 558:Lib/FreeRTOS/Source/queue.c ****          * value that is known to be within the memory map. */
 559:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 560:Lib/FreeRTOS/Source/queue.c ****     }
 561:Lib/FreeRTOS/Source/queue.c ****     else
 562:Lib/FreeRTOS/Source/queue.c ****     {
 563:Lib/FreeRTOS/Source/queue.c ****         /* Set the head to the start of the queue storage area. */
 564:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 565:Lib/FreeRTOS/Source/queue.c ****     }
 566:Lib/FreeRTOS/Source/queue.c **** 
 567:Lib/FreeRTOS/Source/queue.c ****     /* Initialise the queue members as described where the queue type is
 568:Lib/FreeRTOS/Source/queue.c ****      * defined. */
 569:Lib/FreeRTOS/Source/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 570:Lib/FreeRTOS/Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 571:Lib/FreeRTOS/Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 572:Lib/FreeRTOS/Source/queue.c **** 
 573:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 574:Lib/FreeRTOS/Source/queue.c ****     {
 575:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->ucQueueType = ucQueueType;
 576:Lib/FreeRTOS/Source/queue.c ****     }
 577:Lib/FreeRTOS/Source/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 578:Lib/FreeRTOS/Source/queue.c **** 
 579:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 580:Lib/FreeRTOS/Source/queue.c ****     {
 581:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pxQueueSetContainer = NULL;
 582:Lib/FreeRTOS/Source/queue.c ****     }
 583:Lib/FreeRTOS/Source/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 584:Lib/FreeRTOS/Source/queue.c **** 
 585:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 586:Lib/FreeRTOS/Source/queue.c **** }
 587:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 588:Lib/FreeRTOS/Source/queue.c **** 
 589:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 590:Lib/FreeRTOS/Source/queue.c **** 
 591:Lib/FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 592:Lib/FreeRTOS/Source/queue.c ****     {
 593:Lib/FreeRTOS/Source/queue.c ****         if( pxNewQueue != NULL )
 594:Lib/FreeRTOS/Source/queue.c ****         {
 595:Lib/FreeRTOS/Source/queue.c ****             /* The queue create function will set all the queue structure members
ARM GAS  /tmp/ccTT1k9d.s 			page 12


 596:Lib/FreeRTOS/Source/queue.c ****             * correctly for a generic queue, but this function is creating a
 597:Lib/FreeRTOS/Source/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
 598:Lib/FreeRTOS/Source/queue.c ****             * in particular the information required for priority inheritance. */
 599:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 600:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 601:Lib/FreeRTOS/Source/queue.c **** 
 602:Lib/FreeRTOS/Source/queue.c ****             /* In case this is a recursive mutex. */
 603:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 604:Lib/FreeRTOS/Source/queue.c **** 
 605:Lib/FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 606:Lib/FreeRTOS/Source/queue.c **** 
 607:Lib/FreeRTOS/Source/queue.c ****             /* Start with the semaphore in the expected state. */
 608:Lib/FreeRTOS/Source/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 609:Lib/FreeRTOS/Source/queue.c ****         }
 610:Lib/FreeRTOS/Source/queue.c ****         else
 611:Lib/FreeRTOS/Source/queue.c ****         {
 612:Lib/FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX_FAILED();
 613:Lib/FreeRTOS/Source/queue.c ****         }
 614:Lib/FreeRTOS/Source/queue.c ****     }
 615:Lib/FreeRTOS/Source/queue.c **** 
 616:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 617:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 618:Lib/FreeRTOS/Source/queue.c **** 
 619:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 620:Lib/FreeRTOS/Source/queue.c **** 
 621:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 622:Lib/FreeRTOS/Source/queue.c ****     {
 623:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 624:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 625:Lib/FreeRTOS/Source/queue.c **** 
 626:Lib/FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 627:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 628:Lib/FreeRTOS/Source/queue.c **** 
 629:Lib/FreeRTOS/Source/queue.c ****         return xNewQueue;
 630:Lib/FreeRTOS/Source/queue.c ****     }
 631:Lib/FreeRTOS/Source/queue.c **** 
 632:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 633:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 634:Lib/FreeRTOS/Source/queue.c **** 
 635:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 636:Lib/FreeRTOS/Source/queue.c **** 
 637:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 638:Lib/FreeRTOS/Source/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 639:Lib/FreeRTOS/Source/queue.c ****     {
 640:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 641:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 642:Lib/FreeRTOS/Source/queue.c **** 
 643:Lib/FreeRTOS/Source/queue.c ****         /* Prevent compiler warnings about unused parameters if
 644:Lib/FreeRTOS/Source/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 645:Lib/FreeRTOS/Source/queue.c ****         ( void ) ucQueueType;
 646:Lib/FreeRTOS/Source/queue.c **** 
 647:Lib/FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 648:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 649:Lib/FreeRTOS/Source/queue.c **** 
 650:Lib/FreeRTOS/Source/queue.c ****         return xNewQueue;
 651:Lib/FreeRTOS/Source/queue.c ****     }
 652:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 13


 653:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 654:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 655:Lib/FreeRTOS/Source/queue.c **** 
 656:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 657:Lib/FreeRTOS/Source/queue.c **** 
 658:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 659:Lib/FreeRTOS/Source/queue.c ****     {
 660:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 661:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 662:Lib/FreeRTOS/Source/queue.c **** 
 663:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xSemaphore );
 664:Lib/FreeRTOS/Source/queue.c **** 
 665:Lib/FreeRTOS/Source/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 666:Lib/FreeRTOS/Source/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 667:Lib/FreeRTOS/Source/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 668:Lib/FreeRTOS/Source/queue.c ****          * identity of the mutex holder, as the holder may change between the
 669:Lib/FreeRTOS/Source/queue.c ****          * following critical section exiting and the function returning. */
 670:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 671:Lib/FreeRTOS/Source/queue.c ****         {
 672:Lib/FreeRTOS/Source/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 673:Lib/FreeRTOS/Source/queue.c ****             {
 674:Lib/FreeRTOS/Source/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 675:Lib/FreeRTOS/Source/queue.c ****             }
 676:Lib/FreeRTOS/Source/queue.c ****             else
 677:Lib/FreeRTOS/Source/queue.c ****             {
 678:Lib/FreeRTOS/Source/queue.c ****                 pxReturn = NULL;
 679:Lib/FreeRTOS/Source/queue.c ****             }
 680:Lib/FreeRTOS/Source/queue.c ****         }
 681:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 682:Lib/FreeRTOS/Source/queue.c **** 
 683:Lib/FreeRTOS/Source/queue.c ****         return pxReturn;
 684:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 685:Lib/FreeRTOS/Source/queue.c **** 
 686:Lib/FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 687:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 688:Lib/FreeRTOS/Source/queue.c **** 
 689:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 690:Lib/FreeRTOS/Source/queue.c **** 
 691:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 692:Lib/FreeRTOS/Source/queue.c ****     {
 693:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 694:Lib/FreeRTOS/Source/queue.c **** 
 695:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xSemaphore );
 696:Lib/FreeRTOS/Source/queue.c **** 
 697:Lib/FreeRTOS/Source/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 698:Lib/FreeRTOS/Source/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 699:Lib/FreeRTOS/Source/queue.c ****          * not required here. */
 700:Lib/FreeRTOS/Source/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 701:Lib/FreeRTOS/Source/queue.c ****         {
 702:Lib/FreeRTOS/Source/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 703:Lib/FreeRTOS/Source/queue.c ****         }
 704:Lib/FreeRTOS/Source/queue.c ****         else
 705:Lib/FreeRTOS/Source/queue.c ****         {
 706:Lib/FreeRTOS/Source/queue.c ****             pxReturn = NULL;
 707:Lib/FreeRTOS/Source/queue.c ****         }
 708:Lib/FreeRTOS/Source/queue.c **** 
 709:Lib/FreeRTOS/Source/queue.c ****         return pxReturn;
ARM GAS  /tmp/ccTT1k9d.s 			page 14


 710:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 711:Lib/FreeRTOS/Source/queue.c **** 
 712:Lib/FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 713:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 714:Lib/FreeRTOS/Source/queue.c **** 
 715:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 716:Lib/FreeRTOS/Source/queue.c **** 
 717:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 718:Lib/FreeRTOS/Source/queue.c ****     {
 719:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 720:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 721:Lib/FreeRTOS/Source/queue.c **** 
 722:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 723:Lib/FreeRTOS/Source/queue.c **** 
 724:Lib/FreeRTOS/Source/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 725:Lib/FreeRTOS/Source/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 726:Lib/FreeRTOS/Source/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 727:Lib/FreeRTOS/Source/queue.c ****          * this is the only condition we are interested in it does not matter if
 728:Lib/FreeRTOS/Source/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 729:Lib/FreeRTOS/Source/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 730:Lib/FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 731:Lib/FreeRTOS/Source/queue.c ****         {
 732:Lib/FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 733:Lib/FreeRTOS/Source/queue.c **** 
 734:Lib/FreeRTOS/Source/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 735:Lib/FreeRTOS/Source/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 736:Lib/FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 737:Lib/FreeRTOS/Source/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 738:Lib/FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount member. */
 739:Lib/FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 740:Lib/FreeRTOS/Source/queue.c **** 
 741:Lib/FreeRTOS/Source/queue.c ****             /* Has the recursive call count unwound to 0? */
 742:Lib/FreeRTOS/Source/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 743:Lib/FreeRTOS/Source/queue.c ****             {
 744:Lib/FreeRTOS/Source/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 745:Lib/FreeRTOS/Source/queue.c ****                  * task that might be waiting to access the mutex. */
 746:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 747:Lib/FreeRTOS/Source/queue.c ****             }
 748:Lib/FreeRTOS/Source/queue.c ****             else
 749:Lib/FreeRTOS/Source/queue.c ****             {
 750:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 751:Lib/FreeRTOS/Source/queue.c ****             }
 752:Lib/FreeRTOS/Source/queue.c **** 
 753:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 754:Lib/FreeRTOS/Source/queue.c ****         }
 755:Lib/FreeRTOS/Source/queue.c ****         else
 756:Lib/FreeRTOS/Source/queue.c ****         {
 757:Lib/FreeRTOS/Source/queue.c ****             /* The mutex cannot be given because the calling task is not the
 758:Lib/FreeRTOS/Source/queue.c ****              * holder. */
 759:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
 760:Lib/FreeRTOS/Source/queue.c **** 
 761:Lib/FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 762:Lib/FreeRTOS/Source/queue.c ****         }
 763:Lib/FreeRTOS/Source/queue.c **** 
 764:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 765:Lib/FreeRTOS/Source/queue.c ****     }
 766:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 15


 767:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 768:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 769:Lib/FreeRTOS/Source/queue.c **** 
 770:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 771:Lib/FreeRTOS/Source/queue.c **** 
 772:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 773:Lib/FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait )
 774:Lib/FreeRTOS/Source/queue.c ****     {
 775:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 776:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 777:Lib/FreeRTOS/Source/queue.c **** 
 778:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 779:Lib/FreeRTOS/Source/queue.c **** 
 780:Lib/FreeRTOS/Source/queue.c ****         /* Comments regarding mutual exclusion as per those within
 781:Lib/FreeRTOS/Source/queue.c ****          * xQueueGiveMutexRecursive(). */
 782:Lib/FreeRTOS/Source/queue.c **** 
 783:Lib/FreeRTOS/Source/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 784:Lib/FreeRTOS/Source/queue.c **** 
 785:Lib/FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 786:Lib/FreeRTOS/Source/queue.c ****         {
 787:Lib/FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 788:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 789:Lib/FreeRTOS/Source/queue.c ****         }
 790:Lib/FreeRTOS/Source/queue.c ****         else
 791:Lib/FreeRTOS/Source/queue.c ****         {
 792:Lib/FreeRTOS/Source/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 793:Lib/FreeRTOS/Source/queue.c **** 
 794:Lib/FreeRTOS/Source/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 795:Lib/FreeRTOS/Source/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 796:Lib/FreeRTOS/Source/queue.c ****              * before reaching here. */
 797:Lib/FreeRTOS/Source/queue.c ****             if( xReturn != pdFAIL )
 798:Lib/FreeRTOS/Source/queue.c ****             {
 799:Lib/FreeRTOS/Source/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 800:Lib/FreeRTOS/Source/queue.c ****             }
 801:Lib/FreeRTOS/Source/queue.c ****             else
 802:Lib/FreeRTOS/Source/queue.c ****             {
 803:Lib/FreeRTOS/Source/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 804:Lib/FreeRTOS/Source/queue.c ****             }
 805:Lib/FreeRTOS/Source/queue.c ****         }
 806:Lib/FreeRTOS/Source/queue.c **** 
 807:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 808:Lib/FreeRTOS/Source/queue.c ****     }
 809:Lib/FreeRTOS/Source/queue.c **** 
 810:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 811:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 812:Lib/FreeRTOS/Source/queue.c **** 
 813:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 814:Lib/FreeRTOS/Source/queue.c **** 
 815:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 816:Lib/FreeRTOS/Source/queue.c ****                                                        const UBaseType_t uxInitialCount,
 817:Lib/FreeRTOS/Source/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 818:Lib/FreeRTOS/Source/queue.c ****     {
 819:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 820:Lib/FreeRTOS/Source/queue.c **** 
 821:Lib/FreeRTOS/Source/queue.c ****         if( ( uxMaxCount != 0 ) &&
 822:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 823:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 16


 824:Lib/FreeRTOS/Source/queue.c ****             xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL
 825:Lib/FreeRTOS/Source/queue.c **** 
 826:Lib/FreeRTOS/Source/queue.c ****             if( xHandle != NULL )
 827:Lib/FreeRTOS/Source/queue.c ****             {
 828:Lib/FreeRTOS/Source/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 829:Lib/FreeRTOS/Source/queue.c **** 
 830:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 831:Lib/FreeRTOS/Source/queue.c ****             }
 832:Lib/FreeRTOS/Source/queue.c ****             else
 833:Lib/FreeRTOS/Source/queue.c ****             {
 834:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 835:Lib/FreeRTOS/Source/queue.c ****             }
 836:Lib/FreeRTOS/Source/queue.c ****         }
 837:Lib/FreeRTOS/Source/queue.c ****         else
 838:Lib/FreeRTOS/Source/queue.c ****         {
 839:Lib/FreeRTOS/Source/queue.c ****             configASSERT( xHandle );
 840:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 841:Lib/FreeRTOS/Source/queue.c ****         }
 842:Lib/FreeRTOS/Source/queue.c **** 
 843:Lib/FreeRTOS/Source/queue.c ****         return xHandle;
 844:Lib/FreeRTOS/Source/queue.c ****     }
 845:Lib/FreeRTOS/Source/queue.c **** 
 846:Lib/FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 847:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 848:Lib/FreeRTOS/Source/queue.c **** 
 849:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 850:Lib/FreeRTOS/Source/queue.c **** 
 851:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 852:Lib/FreeRTOS/Source/queue.c ****                                                  const UBaseType_t uxInitialCount )
 853:Lib/FreeRTOS/Source/queue.c ****     {
 854:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 855:Lib/FreeRTOS/Source/queue.c **** 
 856:Lib/FreeRTOS/Source/queue.c ****         if( ( uxMaxCount != 0 ) &&
 857:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 858:Lib/FreeRTOS/Source/queue.c ****         {
 859:Lib/FreeRTOS/Source/queue.c ****             xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE
 860:Lib/FreeRTOS/Source/queue.c **** 
 861:Lib/FreeRTOS/Source/queue.c ****             if( xHandle != NULL )
 862:Lib/FreeRTOS/Source/queue.c ****             {
 863:Lib/FreeRTOS/Source/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 864:Lib/FreeRTOS/Source/queue.c **** 
 865:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 866:Lib/FreeRTOS/Source/queue.c ****             }
 867:Lib/FreeRTOS/Source/queue.c ****             else
 868:Lib/FreeRTOS/Source/queue.c ****             {
 869:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 870:Lib/FreeRTOS/Source/queue.c ****             }
 871:Lib/FreeRTOS/Source/queue.c ****         }
 872:Lib/FreeRTOS/Source/queue.c ****         else
 873:Lib/FreeRTOS/Source/queue.c ****         {
 874:Lib/FreeRTOS/Source/queue.c ****             configASSERT( xHandle );
 875:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 876:Lib/FreeRTOS/Source/queue.c ****         }
 877:Lib/FreeRTOS/Source/queue.c **** 
 878:Lib/FreeRTOS/Source/queue.c ****         return xHandle;
 879:Lib/FreeRTOS/Source/queue.c ****     }
 880:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 17


 881:Lib/FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 882:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 883:Lib/FreeRTOS/Source/queue.c **** 
 884:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 885:Lib/FreeRTOS/Source/queue.c ****                               const void * const pvItemToQueue,
 886:Lib/FreeRTOS/Source/queue.c ****                               TickType_t xTicksToWait,
 887:Lib/FreeRTOS/Source/queue.c ****                               const BaseType_t xCopyPosition )
 888:Lib/FreeRTOS/Source/queue.c **** {
 889:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 890:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 891:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 892:Lib/FreeRTOS/Source/queue.c **** 
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 895:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 896:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 897:Lib/FreeRTOS/Source/queue.c ****     {
 898:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 899:Lib/FreeRTOS/Source/queue.c ****     }
 900:Lib/FreeRTOS/Source/queue.c ****     #endif
 901:Lib/FreeRTOS/Source/queue.c **** 
 902:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 903:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
 904:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
 905:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
 906:Lib/FreeRTOS/Source/queue.c ****     {
 907:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 908:Lib/FreeRTOS/Source/queue.c ****         {
 909:Lib/FreeRTOS/Source/queue.c ****             /* Is there room on the queue now?  The running task must be the
 910:Lib/FreeRTOS/Source/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 911:Lib/FreeRTOS/Source/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 912:Lib/FreeRTOS/Source/queue.c ****              * queue is full. */
 913:Lib/FreeRTOS/Source/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 914:Lib/FreeRTOS/Source/queue.c ****             {
 915:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_SEND( pxQueue );
 916:Lib/FreeRTOS/Source/queue.c **** 
 917:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 918:Lib/FreeRTOS/Source/queue.c ****                 {
 919:Lib/FreeRTOS/Source/queue.c ****                     const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 920:Lib/FreeRTOS/Source/queue.c **** 
 921:Lib/FreeRTOS/Source/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 922:Lib/FreeRTOS/Source/queue.c **** 
 923:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
 924:Lib/FreeRTOS/Source/queue.c ****                     {
 925:Lib/FreeRTOS/Source/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
 926:Lib/FreeRTOS/Source/queue.c ****                         {
 927:Lib/FreeRTOS/Source/queue.c ****                             /* Do not notify the queue set as an existing item
 928:Lib/FreeRTOS/Source/queue.c ****                              * was overwritten in the queue so the number of items
 929:Lib/FreeRTOS/Source/queue.c ****                              * in the queue has not changed. */
 930:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 931:Lib/FreeRTOS/Source/queue.c ****                         }
 932:Lib/FreeRTOS/Source/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 933:Lib/FreeRTOS/Source/queue.c ****                         {
 934:Lib/FreeRTOS/Source/queue.c ****                             /* The queue is a member of a queue set, and posting
 935:Lib/FreeRTOS/Source/queue.c ****                              * to the queue set caused a higher priority task to
 936:Lib/FreeRTOS/Source/queue.c ****                              * unblock. A context switch is required. */
 937:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
ARM GAS  /tmp/ccTT1k9d.s 			page 18


 938:Lib/FreeRTOS/Source/queue.c ****                         }
 939:Lib/FreeRTOS/Source/queue.c ****                         else
 940:Lib/FreeRTOS/Source/queue.c ****                         {
 941:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 942:Lib/FreeRTOS/Source/queue.c ****                         }
 943:Lib/FreeRTOS/Source/queue.c ****                     }
 944:Lib/FreeRTOS/Source/queue.c ****                     else
 945:Lib/FreeRTOS/Source/queue.c ****                     {
 946:Lib/FreeRTOS/Source/queue.c ****                         /* If there was a task waiting for data to arrive on the
 947:Lib/FreeRTOS/Source/queue.c ****                          * queue then unblock it now. */
 948:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 949:Lib/FreeRTOS/Source/queue.c ****                         {
 950:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 951:Lib/FreeRTOS/Source/queue.c ****                             {
 952:Lib/FreeRTOS/Source/queue.c ****                                 /* The unblocked task has a priority higher than
 953:Lib/FreeRTOS/Source/queue.c ****                                  * our own so yield immediately.  Yes it is ok to
 954:Lib/FreeRTOS/Source/queue.c ****                                  * do this from within the critical section - the
 955:Lib/FreeRTOS/Source/queue.c ****                                  * kernel takes care of that. */
 956:Lib/FreeRTOS/Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 957:Lib/FreeRTOS/Source/queue.c ****                             }
 958:Lib/FreeRTOS/Source/queue.c ****                             else
 959:Lib/FreeRTOS/Source/queue.c ****                             {
 960:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 961:Lib/FreeRTOS/Source/queue.c ****                             }
 962:Lib/FreeRTOS/Source/queue.c ****                         }
 963:Lib/FreeRTOS/Source/queue.c ****                         else if( xYieldRequired != pdFALSE )
 964:Lib/FreeRTOS/Source/queue.c ****                         {
 965:Lib/FreeRTOS/Source/queue.c ****                             /* This path is a special case that will only get
 966:Lib/FreeRTOS/Source/queue.c ****                              * executed if the task was holding multiple mutexes
 967:Lib/FreeRTOS/Source/queue.c ****                              * and the mutexes were given back in an order that is
 968:Lib/FreeRTOS/Source/queue.c ****                              * different to that in which they were taken. */
 969:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 970:Lib/FreeRTOS/Source/queue.c ****                         }
 971:Lib/FreeRTOS/Source/queue.c ****                         else
 972:Lib/FreeRTOS/Source/queue.c ****                         {
 973:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 974:Lib/FreeRTOS/Source/queue.c ****                         }
 975:Lib/FreeRTOS/Source/queue.c ****                     }
 976:Lib/FreeRTOS/Source/queue.c ****                 }
 977:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 978:Lib/FreeRTOS/Source/queue.c ****                 {
 979:Lib/FreeRTOS/Source/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 980:Lib/FreeRTOS/Source/queue.c **** 
 981:Lib/FreeRTOS/Source/queue.c ****                     /* If there was a task waiting for data to arrive on the
 982:Lib/FreeRTOS/Source/queue.c ****                      * queue then unblock it now. */
 983:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 984:Lib/FreeRTOS/Source/queue.c ****                     {
 985:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 986:Lib/FreeRTOS/Source/queue.c ****                         {
 987:Lib/FreeRTOS/Source/queue.c ****                             /* The unblocked task has a priority higher than
 988:Lib/FreeRTOS/Source/queue.c ****                              * our own so yield immediately.  Yes it is ok to do
 989:Lib/FreeRTOS/Source/queue.c ****                              * this from within the critical section - the kernel
 990:Lib/FreeRTOS/Source/queue.c ****                              * takes care of that. */
 991:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 992:Lib/FreeRTOS/Source/queue.c ****                         }
 993:Lib/FreeRTOS/Source/queue.c ****                         else
 994:Lib/FreeRTOS/Source/queue.c ****                         {
ARM GAS  /tmp/ccTT1k9d.s 			page 19


 995:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 996:Lib/FreeRTOS/Source/queue.c ****                         }
 997:Lib/FreeRTOS/Source/queue.c ****                     }
 998:Lib/FreeRTOS/Source/queue.c ****                     else if( xYieldRequired != pdFALSE )
 999:Lib/FreeRTOS/Source/queue.c ****                     {
1000:Lib/FreeRTOS/Source/queue.c ****                         /* This path is a special case that will only get
1001:Lib/FreeRTOS/Source/queue.c ****                          * executed if the task was holding multiple mutexes and
1002:Lib/FreeRTOS/Source/queue.c ****                          * the mutexes were given back in an order that is
1003:Lib/FreeRTOS/Source/queue.c ****                          * different to that in which they were taken. */
1004:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1005:Lib/FreeRTOS/Source/queue.c ****                     }
1006:Lib/FreeRTOS/Source/queue.c ****                     else
1007:Lib/FreeRTOS/Source/queue.c ****                     {
1008:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1009:Lib/FreeRTOS/Source/queue.c ****                     }
1010:Lib/FreeRTOS/Source/queue.c ****                 }
1011:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1012:Lib/FreeRTOS/Source/queue.c **** 
1013:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1014:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
1015:Lib/FreeRTOS/Source/queue.c ****             }
1016:Lib/FreeRTOS/Source/queue.c ****             else
1017:Lib/FreeRTOS/Source/queue.c ****             {
1018:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1019:Lib/FreeRTOS/Source/queue.c ****                 {
1020:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was full and no block time is specified (or
1021:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1022:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1023:Lib/FreeRTOS/Source/queue.c **** 
1024:Lib/FreeRTOS/Source/queue.c ****                     /* Return to the original privilege level before exiting
1025:Lib/FreeRTOS/Source/queue.c ****                      * the function. */
1026:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
1027:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
1028:Lib/FreeRTOS/Source/queue.c ****                 }
1029:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1030:Lib/FreeRTOS/Source/queue.c ****                 {
1031:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was full and a block time was specified so
1032:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
1033:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1034:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1035:Lib/FreeRTOS/Source/queue.c ****                 }
1036:Lib/FreeRTOS/Source/queue.c ****                 else
1037:Lib/FreeRTOS/Source/queue.c ****                 {
1038:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1039:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1040:Lib/FreeRTOS/Source/queue.c ****                 }
1041:Lib/FreeRTOS/Source/queue.c ****             }
1042:Lib/FreeRTOS/Source/queue.c ****         }
1043:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1044:Lib/FreeRTOS/Source/queue.c **** 
1045:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1046:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1047:Lib/FreeRTOS/Source/queue.c **** 
1048:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1049:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1050:Lib/FreeRTOS/Source/queue.c **** 
1051:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
ARM GAS  /tmp/ccTT1k9d.s 			page 20


1052:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1053:Lib/FreeRTOS/Source/queue.c ****         {
1054:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
1055:Lib/FreeRTOS/Source/queue.c ****             {
1056:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
1057:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
1058:Lib/FreeRTOS/Source/queue.c **** 
1059:Lib/FreeRTOS/Source/queue.c ****                 /* Unlocking the queue means queue events can effect the
1060:Lib/FreeRTOS/Source/queue.c ****                  * event list. It is possible that interrupts occurring now
1061:Lib/FreeRTOS/Source/queue.c ****                  * remove this task from the event list again - but as the
1062:Lib/FreeRTOS/Source/queue.c ****                  * scheduler is suspended the task will go onto the pending
1063:Lib/FreeRTOS/Source/queue.c ****                  * ready list instead of the actual ready list. */
1064:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1065:Lib/FreeRTOS/Source/queue.c **** 
1066:Lib/FreeRTOS/Source/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
1067:Lib/FreeRTOS/Source/queue.c ****                  * ready list into the ready list - so it is feasible that this
1068:Lib/FreeRTOS/Source/queue.c ****                  * task is already in the ready list before it yields - in which
1069:Lib/FreeRTOS/Source/queue.c ****                  * case the yield will not cause a context switch unless there
1070:Lib/FreeRTOS/Source/queue.c ****                  * is also a higher priority task in the pending ready list. */
1071:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1072:Lib/FreeRTOS/Source/queue.c ****                 {
1073:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1074:Lib/FreeRTOS/Source/queue.c ****                 }
1075:Lib/FreeRTOS/Source/queue.c ****             }
1076:Lib/FreeRTOS/Source/queue.c ****             else
1077:Lib/FreeRTOS/Source/queue.c ****             {
1078:Lib/FreeRTOS/Source/queue.c ****                 /* Try again. */
1079:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1080:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1081:Lib/FreeRTOS/Source/queue.c ****             }
1082:Lib/FreeRTOS/Source/queue.c ****         }
1083:Lib/FreeRTOS/Source/queue.c ****         else
1084:Lib/FreeRTOS/Source/queue.c ****         {
1085:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has expired. */
1086:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1087:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1088:Lib/FreeRTOS/Source/queue.c **** 
1089:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
1090:Lib/FreeRTOS/Source/queue.c ****             return errQUEUE_FULL;
1091:Lib/FreeRTOS/Source/queue.c ****         }
1092:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1093:Lib/FreeRTOS/Source/queue.c **** }
1094:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1095:Lib/FreeRTOS/Source/queue.c **** 
1096:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
1097:Lib/FreeRTOS/Source/queue.c ****                                      const void * const pvItemToQueue,
1098:Lib/FreeRTOS/Source/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
1099:Lib/FreeRTOS/Source/queue.c ****                                      const BaseType_t xCopyPosition )
1100:Lib/FreeRTOS/Source/queue.c **** {
1101:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1102:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1103:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1104:Lib/FreeRTOS/Source/queue.c **** 
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
1107:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1108:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 21


1109:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1110:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1111:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1112:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1113:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1114:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1115:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1116:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1117:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1118:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1119:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1120:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1121:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1122:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1123:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1124:Lib/FreeRTOS/Source/queue.c **** 
1125:Lib/FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1126:Lib/FreeRTOS/Source/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1127:Lib/FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1128:Lib/FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1129:Lib/FreeRTOS/Source/queue.c ****      * post). */
1130:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1131:Lib/FreeRTOS/Source/queue.c ****     {
1132:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
1133:Lib/FreeRTOS/Source/queue.c ****         {
1134:Lib/FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1135:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
1136:Lib/FreeRTOS/Source/queue.c **** 
1137:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1138:Lib/FreeRTOS/Source/queue.c **** 
1139:Lib/FreeRTOS/Source/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1140:Lib/FreeRTOS/Source/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1141:Lib/FreeRTOS/Source/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1142:Lib/FreeRTOS/Source/queue.c ****              *  called here even though the disinherit function does not check if
1143:Lib/FreeRTOS/Source/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1144:Lib/FreeRTOS/Source/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
1145:Lib/FreeRTOS/Source/queue.c **** 
1146:Lib/FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1147:Lib/FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1148:Lib/FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
1149:Lib/FreeRTOS/Source/queue.c ****             {
1150:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1151:Lib/FreeRTOS/Source/queue.c ****                 {
1152:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1153:Lib/FreeRTOS/Source/queue.c ****                     {
1154:Lib/FreeRTOS/Source/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
1155:Lib/FreeRTOS/Source/queue.c ****                         {
1156:Lib/FreeRTOS/Source/queue.c ****                             /* Do not notify the queue set as an existing item
1157:Lib/FreeRTOS/Source/queue.c ****                              * was overwritten in the queue so the number of items
1158:Lib/FreeRTOS/Source/queue.c ****                              * in the queue has not changed. */
1159:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1160:Lib/FreeRTOS/Source/queue.c ****                         }
1161:Lib/FreeRTOS/Source/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1162:Lib/FreeRTOS/Source/queue.c ****                         {
1163:Lib/FreeRTOS/Source/queue.c ****                             /* The queue is a member of a queue set, and posting
1164:Lib/FreeRTOS/Source/queue.c ****                              * to the queue set caused a higher priority task to
1165:Lib/FreeRTOS/Source/queue.c ****                              * unblock.  A context switch is required. */
ARM GAS  /tmp/ccTT1k9d.s 			page 22


1166:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1167:Lib/FreeRTOS/Source/queue.c ****                             {
1168:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1169:Lib/FreeRTOS/Source/queue.c ****                             }
1170:Lib/FreeRTOS/Source/queue.c ****                             else
1171:Lib/FreeRTOS/Source/queue.c ****                             {
1172:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1173:Lib/FreeRTOS/Source/queue.c ****                             }
1174:Lib/FreeRTOS/Source/queue.c ****                         }
1175:Lib/FreeRTOS/Source/queue.c ****                         else
1176:Lib/FreeRTOS/Source/queue.c ****                         {
1177:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1178:Lib/FreeRTOS/Source/queue.c ****                         }
1179:Lib/FreeRTOS/Source/queue.c ****                     }
1180:Lib/FreeRTOS/Source/queue.c ****                     else
1181:Lib/FreeRTOS/Source/queue.c ****                     {
1182:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1183:Lib/FreeRTOS/Source/queue.c ****                         {
1184:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1185:Lib/FreeRTOS/Source/queue.c ****                             {
1186:Lib/FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so
1187:Lib/FreeRTOS/Source/queue.c ****                                  *  record that a context switch is required. */
1188:Lib/FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1189:Lib/FreeRTOS/Source/queue.c ****                                 {
1190:Lib/FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1191:Lib/FreeRTOS/Source/queue.c ****                                 }
1192:Lib/FreeRTOS/Source/queue.c ****                                 else
1193:Lib/FreeRTOS/Source/queue.c ****                                 {
1194:Lib/FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1195:Lib/FreeRTOS/Source/queue.c ****                                 }
1196:Lib/FreeRTOS/Source/queue.c ****                             }
1197:Lib/FreeRTOS/Source/queue.c ****                             else
1198:Lib/FreeRTOS/Source/queue.c ****                             {
1199:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1200:Lib/FreeRTOS/Source/queue.c ****                             }
1201:Lib/FreeRTOS/Source/queue.c ****                         }
1202:Lib/FreeRTOS/Source/queue.c ****                         else
1203:Lib/FreeRTOS/Source/queue.c ****                         {
1204:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1205:Lib/FreeRTOS/Source/queue.c ****                         }
1206:Lib/FreeRTOS/Source/queue.c ****                     }
1207:Lib/FreeRTOS/Source/queue.c ****                 }
1208:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1209:Lib/FreeRTOS/Source/queue.c ****                 {
1210:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1211:Lib/FreeRTOS/Source/queue.c ****                     {
1212:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
1213:Lib/FreeRTOS/Source/queue.c ****                         {
1214:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
1215:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
1216:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1217:Lib/FreeRTOS/Source/queue.c ****                             {
1218:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1219:Lib/FreeRTOS/Source/queue.c ****                             }
1220:Lib/FreeRTOS/Source/queue.c ****                             else
1221:Lib/FreeRTOS/Source/queue.c ****                             {
1222:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccTT1k9d.s 			page 23


1223:Lib/FreeRTOS/Source/queue.c ****                             }
1224:Lib/FreeRTOS/Source/queue.c ****                         }
1225:Lib/FreeRTOS/Source/queue.c ****                         else
1226:Lib/FreeRTOS/Source/queue.c ****                         {
1227:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1228:Lib/FreeRTOS/Source/queue.c ****                         }
1229:Lib/FreeRTOS/Source/queue.c ****                     }
1230:Lib/FreeRTOS/Source/queue.c ****                     else
1231:Lib/FreeRTOS/Source/queue.c ****                     {
1232:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1233:Lib/FreeRTOS/Source/queue.c ****                     }
1234:Lib/FreeRTOS/Source/queue.c **** 
1235:Lib/FreeRTOS/Source/queue.c ****                     /* Not used in this path. */
1236:Lib/FreeRTOS/Source/queue.c ****                     ( void ) uxPreviousMessagesWaiting;
1237:Lib/FreeRTOS/Source/queue.c ****                 }
1238:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1239:Lib/FreeRTOS/Source/queue.c ****             }
1240:Lib/FreeRTOS/Source/queue.c ****             else
1241:Lib/FreeRTOS/Source/queue.c ****             {
1242:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1243:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1244:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
1245:Lib/FreeRTOS/Source/queue.c ****             }
1246:Lib/FreeRTOS/Source/queue.c **** 
1247:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1248:Lib/FreeRTOS/Source/queue.c ****         }
1249:Lib/FreeRTOS/Source/queue.c ****         else
1250:Lib/FreeRTOS/Source/queue.c ****         {
1251:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1252:Lib/FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
1253:Lib/FreeRTOS/Source/queue.c ****         }
1254:Lib/FreeRTOS/Source/queue.c ****     }
1255:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1256:Lib/FreeRTOS/Source/queue.c **** 
1257:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
1258:Lib/FreeRTOS/Source/queue.c **** }
1259:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1260:Lib/FreeRTOS/Source/queue.c **** 
1261:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1262:Lib/FreeRTOS/Source/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1263:Lib/FreeRTOS/Source/queue.c **** {
1264:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1265:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1266:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1267:Lib/FreeRTOS/Source/queue.c **** 
1268:Lib/FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1269:Lib/FreeRTOS/Source/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1270:Lib/FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1271:Lib/FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1272:Lib/FreeRTOS/Source/queue.c ****      * post). */
1273:Lib/FreeRTOS/Source/queue.c **** 
1274:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1275:Lib/FreeRTOS/Source/queue.c **** 
1276:Lib/FreeRTOS/Source/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1277:Lib/FreeRTOS/Source/queue.c ****      * if the item size is not 0. */
1278:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1279:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 24


1280:Lib/FreeRTOS/Source/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1281:Lib/FreeRTOS/Source/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1282:Lib/FreeRTOS/Source/queue.c ****      * interrupts, only tasks. */
1283:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
1284:Lib/FreeRTOS/Source/queue.c **** 
1285:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1286:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1287:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1288:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1289:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1290:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1291:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1292:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1293:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1294:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1295:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1296:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1297:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1298:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1299:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1300:Lib/FreeRTOS/Source/queue.c **** 
1301:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1302:Lib/FreeRTOS/Source/queue.c ****     {
1303:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1304:Lib/FreeRTOS/Source/queue.c **** 
1305:Lib/FreeRTOS/Source/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1306:Lib/FreeRTOS/Source/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1307:Lib/FreeRTOS/Source/queue.c ****          * space'. */
1308:Lib/FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
1309:Lib/FreeRTOS/Source/queue.c ****         {
1310:Lib/FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
1311:Lib/FreeRTOS/Source/queue.c **** 
1312:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1313:Lib/FreeRTOS/Source/queue.c **** 
1314:Lib/FreeRTOS/Source/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1315:Lib/FreeRTOS/Source/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1316:Lib/FreeRTOS/Source/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1317:Lib/FreeRTOS/Source/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1318:Lib/FreeRTOS/Source/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1319:Lib/FreeRTOS/Source/queue.c ****              * messages (semaphores) available. */
1320:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
1321:Lib/FreeRTOS/Source/queue.c **** 
1322:Lib/FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1323:Lib/FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1324:Lib/FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
1325:Lib/FreeRTOS/Source/queue.c ****             {
1326:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1327:Lib/FreeRTOS/Source/queue.c ****                 {
1328:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1329:Lib/FreeRTOS/Source/queue.c ****                     {
1330:Lib/FreeRTOS/Source/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1331:Lib/FreeRTOS/Source/queue.c ****                         {
1332:Lib/FreeRTOS/Source/queue.c ****                             /* The semaphore is a member of a queue set, and
1333:Lib/FreeRTOS/Source/queue.c ****                              * posting to the queue set caused a higher priority
1334:Lib/FreeRTOS/Source/queue.c ****                              * task to unblock.  A context switch is required. */
1335:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1336:Lib/FreeRTOS/Source/queue.c ****                             {
ARM GAS  /tmp/ccTT1k9d.s 			page 25


1337:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1338:Lib/FreeRTOS/Source/queue.c ****                             }
1339:Lib/FreeRTOS/Source/queue.c ****                             else
1340:Lib/FreeRTOS/Source/queue.c ****                             {
1341:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1342:Lib/FreeRTOS/Source/queue.c ****                             }
1343:Lib/FreeRTOS/Source/queue.c ****                         }
1344:Lib/FreeRTOS/Source/queue.c ****                         else
1345:Lib/FreeRTOS/Source/queue.c ****                         {
1346:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1347:Lib/FreeRTOS/Source/queue.c ****                         }
1348:Lib/FreeRTOS/Source/queue.c ****                     }
1349:Lib/FreeRTOS/Source/queue.c ****                     else
1350:Lib/FreeRTOS/Source/queue.c ****                     {
1351:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1352:Lib/FreeRTOS/Source/queue.c ****                         {
1353:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1354:Lib/FreeRTOS/Source/queue.c ****                             {
1355:Lib/FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so
1356:Lib/FreeRTOS/Source/queue.c ****                                  *  record that a context switch is required. */
1357:Lib/FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1358:Lib/FreeRTOS/Source/queue.c ****                                 {
1359:Lib/FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1360:Lib/FreeRTOS/Source/queue.c ****                                 }
1361:Lib/FreeRTOS/Source/queue.c ****                                 else
1362:Lib/FreeRTOS/Source/queue.c ****                                 {
1363:Lib/FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1364:Lib/FreeRTOS/Source/queue.c ****                                 }
1365:Lib/FreeRTOS/Source/queue.c ****                             }
1366:Lib/FreeRTOS/Source/queue.c ****                             else
1367:Lib/FreeRTOS/Source/queue.c ****                             {
1368:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1369:Lib/FreeRTOS/Source/queue.c ****                             }
1370:Lib/FreeRTOS/Source/queue.c ****                         }
1371:Lib/FreeRTOS/Source/queue.c ****                         else
1372:Lib/FreeRTOS/Source/queue.c ****                         {
1373:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1374:Lib/FreeRTOS/Source/queue.c ****                         }
1375:Lib/FreeRTOS/Source/queue.c ****                     }
1376:Lib/FreeRTOS/Source/queue.c ****                 }
1377:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1378:Lib/FreeRTOS/Source/queue.c ****                 {
1379:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1380:Lib/FreeRTOS/Source/queue.c ****                     {
1381:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
1382:Lib/FreeRTOS/Source/queue.c ****                         {
1383:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
1384:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
1385:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1386:Lib/FreeRTOS/Source/queue.c ****                             {
1387:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1388:Lib/FreeRTOS/Source/queue.c ****                             }
1389:Lib/FreeRTOS/Source/queue.c ****                             else
1390:Lib/FreeRTOS/Source/queue.c ****                             {
1391:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1392:Lib/FreeRTOS/Source/queue.c ****                             }
1393:Lib/FreeRTOS/Source/queue.c ****                         }
ARM GAS  /tmp/ccTT1k9d.s 			page 26


1394:Lib/FreeRTOS/Source/queue.c ****                         else
1395:Lib/FreeRTOS/Source/queue.c ****                         {
1396:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1397:Lib/FreeRTOS/Source/queue.c ****                         }
1398:Lib/FreeRTOS/Source/queue.c ****                     }
1399:Lib/FreeRTOS/Source/queue.c ****                     else
1400:Lib/FreeRTOS/Source/queue.c ****                     {
1401:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1402:Lib/FreeRTOS/Source/queue.c ****                     }
1403:Lib/FreeRTOS/Source/queue.c ****                 }
1404:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1405:Lib/FreeRTOS/Source/queue.c ****             }
1406:Lib/FreeRTOS/Source/queue.c ****             else
1407:Lib/FreeRTOS/Source/queue.c ****             {
1408:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1409:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1410:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
1411:Lib/FreeRTOS/Source/queue.c ****             }
1412:Lib/FreeRTOS/Source/queue.c **** 
1413:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
1414:Lib/FreeRTOS/Source/queue.c ****         }
1415:Lib/FreeRTOS/Source/queue.c ****         else
1416:Lib/FreeRTOS/Source/queue.c ****         {
1417:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1418:Lib/FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
1419:Lib/FreeRTOS/Source/queue.c ****         }
1420:Lib/FreeRTOS/Source/queue.c ****     }
1421:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1422:Lib/FreeRTOS/Source/queue.c **** 
1423:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
1424:Lib/FreeRTOS/Source/queue.c **** }
1425:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1426:Lib/FreeRTOS/Source/queue.c **** 
1427:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1428:Lib/FreeRTOS/Source/queue.c ****                           void * const pvBuffer,
1429:Lib/FreeRTOS/Source/queue.c ****                           TickType_t xTicksToWait )
1430:Lib/FreeRTOS/Source/queue.c **** {
1431:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1432:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1433:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1434:Lib/FreeRTOS/Source/queue.c **** 
1435:Lib/FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1436:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1437:Lib/FreeRTOS/Source/queue.c **** 
1438:Lib/FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1439:Lib/FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer). */
1440:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1441:Lib/FreeRTOS/Source/queue.c **** 
1442:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1443:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1444:Lib/FreeRTOS/Source/queue.c ****     {
1445:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1446:Lib/FreeRTOS/Source/queue.c ****     }
1447:Lib/FreeRTOS/Source/queue.c ****     #endif
1448:Lib/FreeRTOS/Source/queue.c **** 
1449:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1450:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
ARM GAS  /tmp/ccTT1k9d.s 			page 27


1451:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1452:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1453:Lib/FreeRTOS/Source/queue.c ****     {
1454:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1455:Lib/FreeRTOS/Source/queue.c ****         {
1456:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1457:Lib/FreeRTOS/Source/queue.c **** 
1458:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1459:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1460:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1461:Lib/FreeRTOS/Source/queue.c ****             {
1462:Lib/FreeRTOS/Source/queue.c ****                 /* Data available, remove one item. */
1463:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1464:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1465:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1466:Lib/FreeRTOS/Source/queue.c **** 
1467:Lib/FreeRTOS/Source/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
1468:Lib/FreeRTOS/Source/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1469:Lib/FreeRTOS/Source/queue.c ****                  * task. */
1470:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1471:Lib/FreeRTOS/Source/queue.c ****                 {
1472:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1473:Lib/FreeRTOS/Source/queue.c ****                     {
1474:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1475:Lib/FreeRTOS/Source/queue.c ****                     }
1476:Lib/FreeRTOS/Source/queue.c ****                     else
1477:Lib/FreeRTOS/Source/queue.c ****                     {
1478:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1479:Lib/FreeRTOS/Source/queue.c ****                     }
1480:Lib/FreeRTOS/Source/queue.c ****                 }
1481:Lib/FreeRTOS/Source/queue.c ****                 else
1482:Lib/FreeRTOS/Source/queue.c ****                 {
1483:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1484:Lib/FreeRTOS/Source/queue.c ****                 }
1485:Lib/FreeRTOS/Source/queue.c **** 
1486:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1487:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
1488:Lib/FreeRTOS/Source/queue.c ****             }
1489:Lib/FreeRTOS/Source/queue.c ****             else
1490:Lib/FreeRTOS/Source/queue.c ****             {
1491:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1492:Lib/FreeRTOS/Source/queue.c ****                 {
1493:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1494:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1495:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1496:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1497:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1498:Lib/FreeRTOS/Source/queue.c ****                 }
1499:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1500:Lib/FreeRTOS/Source/queue.c ****                 {
1501:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1502:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
1503:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1504:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1505:Lib/FreeRTOS/Source/queue.c ****                 }
1506:Lib/FreeRTOS/Source/queue.c ****                 else
1507:Lib/FreeRTOS/Source/queue.c ****                 {
ARM GAS  /tmp/ccTT1k9d.s 			page 28


1508:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1509:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1510:Lib/FreeRTOS/Source/queue.c ****                 }
1511:Lib/FreeRTOS/Source/queue.c ****             }
1512:Lib/FreeRTOS/Source/queue.c ****         }
1513:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1514:Lib/FreeRTOS/Source/queue.c **** 
1515:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1516:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1517:Lib/FreeRTOS/Source/queue.c **** 
1518:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1519:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1520:Lib/FreeRTOS/Source/queue.c **** 
1521:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1522:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1523:Lib/FreeRTOS/Source/queue.c ****         {
1524:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1525:Lib/FreeRTOS/Source/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1526:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1527:Lib/FreeRTOS/Source/queue.c ****             {
1528:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1529:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1530:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1531:Lib/FreeRTOS/Source/queue.c **** 
1532:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1533:Lib/FreeRTOS/Source/queue.c ****                 {
1534:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1535:Lib/FreeRTOS/Source/queue.c ****                 }
1536:Lib/FreeRTOS/Source/queue.c ****                 else
1537:Lib/FreeRTOS/Source/queue.c ****                 {
1538:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1539:Lib/FreeRTOS/Source/queue.c ****                 }
1540:Lib/FreeRTOS/Source/queue.c ****             }
1541:Lib/FreeRTOS/Source/queue.c ****             else
1542:Lib/FreeRTOS/Source/queue.c ****             {
1543:Lib/FreeRTOS/Source/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1544:Lib/FreeRTOS/Source/queue.c ****                  * data. */
1545:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1546:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1547:Lib/FreeRTOS/Source/queue.c ****             }
1548:Lib/FreeRTOS/Source/queue.c ****         }
1549:Lib/FreeRTOS/Source/queue.c ****         else
1550:Lib/FreeRTOS/Source/queue.c ****         {
1551:Lib/FreeRTOS/Source/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1552:Lib/FreeRTOS/Source/queue.c ****              * back and attempt to read the data. */
1553:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1554:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1555:Lib/FreeRTOS/Source/queue.c **** 
1556:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1557:Lib/FreeRTOS/Source/queue.c ****             {
1558:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1559:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1560:Lib/FreeRTOS/Source/queue.c ****             }
1561:Lib/FreeRTOS/Source/queue.c ****             else
1562:Lib/FreeRTOS/Source/queue.c ****             {
1563:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1564:Lib/FreeRTOS/Source/queue.c ****             }
ARM GAS  /tmp/ccTT1k9d.s 			page 29


1565:Lib/FreeRTOS/Source/queue.c ****         }
1566:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1567:Lib/FreeRTOS/Source/queue.c **** }
1568:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1569:Lib/FreeRTOS/Source/queue.c **** 
1570:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1571:Lib/FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
1572:Lib/FreeRTOS/Source/queue.c **** {
1573:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1574:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1575:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1576:Lib/FreeRTOS/Source/queue.c **** 
1577:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1578:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
1579:Lib/FreeRTOS/Source/queue.c ****     #endif
1580:Lib/FreeRTOS/Source/queue.c **** 
1581:Lib/FreeRTOS/Source/queue.c ****     /* Check the queue pointer is not NULL. */
1582:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1583:Lib/FreeRTOS/Source/queue.c **** 
1584:Lib/FreeRTOS/Source/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1585:Lib/FreeRTOS/Source/queue.c ****      * 0. */
1586:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
1587:Lib/FreeRTOS/Source/queue.c **** 
1588:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1589:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1590:Lib/FreeRTOS/Source/queue.c ****     {
1591:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1592:Lib/FreeRTOS/Source/queue.c ****     }
1593:Lib/FreeRTOS/Source/queue.c ****     #endif
1594:Lib/FreeRTOS/Source/queue.c **** 
1595:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1596:Lib/FreeRTOS/Source/queue.c ****      * statements within the function itself.  This is done in the interest
1597:Lib/FreeRTOS/Source/queue.c ****      * of execution time efficiency. */
1598:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1599:Lib/FreeRTOS/Source/queue.c ****     {
1600:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1601:Lib/FreeRTOS/Source/queue.c ****         {
1602:Lib/FreeRTOS/Source/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1603:Lib/FreeRTOS/Source/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1604:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
1605:Lib/FreeRTOS/Source/queue.c **** 
1606:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1607:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1608:Lib/FreeRTOS/Source/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
1609:Lib/FreeRTOS/Source/queue.c ****             {
1610:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1611:Lib/FreeRTOS/Source/queue.c **** 
1612:Lib/FreeRTOS/Source/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1613:Lib/FreeRTOS/Source/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1614:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
1615:Lib/FreeRTOS/Source/queue.c **** 
1616:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1617:Lib/FreeRTOS/Source/queue.c ****                 {
1618:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1619:Lib/FreeRTOS/Source/queue.c ****                     {
1620:Lib/FreeRTOS/Source/queue.c ****                         /* Record the information required to implement
1621:Lib/FreeRTOS/Source/queue.c ****                          * priority inheritance should it become necessary. */
ARM GAS  /tmp/ccTT1k9d.s 			page 30


1622:Lib/FreeRTOS/Source/queue.c ****                         pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
1623:Lib/FreeRTOS/Source/queue.c ****                     }
1624:Lib/FreeRTOS/Source/queue.c ****                     else
1625:Lib/FreeRTOS/Source/queue.c ****                     {
1626:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1627:Lib/FreeRTOS/Source/queue.c ****                     }
1628:Lib/FreeRTOS/Source/queue.c ****                 }
1629:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1630:Lib/FreeRTOS/Source/queue.c **** 
1631:Lib/FreeRTOS/Source/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1632:Lib/FreeRTOS/Source/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1633:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1634:Lib/FreeRTOS/Source/queue.c ****                 {
1635:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1636:Lib/FreeRTOS/Source/queue.c ****                     {
1637:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1638:Lib/FreeRTOS/Source/queue.c ****                     }
1639:Lib/FreeRTOS/Source/queue.c ****                     else
1640:Lib/FreeRTOS/Source/queue.c ****                     {
1641:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1642:Lib/FreeRTOS/Source/queue.c ****                     }
1643:Lib/FreeRTOS/Source/queue.c ****                 }
1644:Lib/FreeRTOS/Source/queue.c ****                 else
1645:Lib/FreeRTOS/Source/queue.c ****                 {
1646:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1647:Lib/FreeRTOS/Source/queue.c ****                 }
1648:Lib/FreeRTOS/Source/queue.c **** 
1649:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1650:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
1651:Lib/FreeRTOS/Source/queue.c ****             }
1652:Lib/FreeRTOS/Source/queue.c ****             else
1653:Lib/FreeRTOS/Source/queue.c ****             {
1654:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1655:Lib/FreeRTOS/Source/queue.c ****                 {
1656:Lib/FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1657:Lib/FreeRTOS/Source/queue.c ****                      * (or the block time has expired) so exit now. */
1658:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1659:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1660:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1661:Lib/FreeRTOS/Source/queue.c ****                 }
1662:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1663:Lib/FreeRTOS/Source/queue.c ****                 {
1664:Lib/FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1665:Lib/FreeRTOS/Source/queue.c ****                      * so configure the timeout structure ready to block. */
1666:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1667:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1668:Lib/FreeRTOS/Source/queue.c ****                 }
1669:Lib/FreeRTOS/Source/queue.c ****                 else
1670:Lib/FreeRTOS/Source/queue.c ****                 {
1671:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1672:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1673:Lib/FreeRTOS/Source/queue.c ****                 }
1674:Lib/FreeRTOS/Source/queue.c ****             }
1675:Lib/FreeRTOS/Source/queue.c ****         }
1676:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1677:Lib/FreeRTOS/Source/queue.c **** 
1678:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
ARM GAS  /tmp/ccTT1k9d.s 			page 31


1679:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1680:Lib/FreeRTOS/Source/queue.c **** 
1681:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1682:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1683:Lib/FreeRTOS/Source/queue.c **** 
1684:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1685:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1686:Lib/FreeRTOS/Source/queue.c ****         {
1687:Lib/FreeRTOS/Source/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1688:Lib/FreeRTOS/Source/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1689:Lib/FreeRTOS/Source/queue.c ****              * become available.  As semaphores are implemented with queues the
1690:Lib/FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1691:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1692:Lib/FreeRTOS/Source/queue.c ****             {
1693:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1694:Lib/FreeRTOS/Source/queue.c **** 
1695:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1696:Lib/FreeRTOS/Source/queue.c ****                 {
1697:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
1698:Lib/FreeRTOS/Source/queue.c ****                     {
1699:Lib/FreeRTOS/Source/queue.c ****                         taskENTER_CRITICAL();
1700:Lib/FreeRTOS/Source/queue.c ****                         {
1701:Lib/FreeRTOS/Source/queue.c ****                             xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMut
1702:Lib/FreeRTOS/Source/queue.c ****                         }
1703:Lib/FreeRTOS/Source/queue.c ****                         taskEXIT_CRITICAL();
1704:Lib/FreeRTOS/Source/queue.c ****                     }
1705:Lib/FreeRTOS/Source/queue.c ****                     else
1706:Lib/FreeRTOS/Source/queue.c ****                     {
1707:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1708:Lib/FreeRTOS/Source/queue.c ****                     }
1709:Lib/FreeRTOS/Source/queue.c ****                 }
1710:Lib/FreeRTOS/Source/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1711:Lib/FreeRTOS/Source/queue.c **** 
1712:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1713:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1714:Lib/FreeRTOS/Source/queue.c **** 
1715:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1716:Lib/FreeRTOS/Source/queue.c ****                 {
1717:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1718:Lib/FreeRTOS/Source/queue.c ****                 }
1719:Lib/FreeRTOS/Source/queue.c ****                 else
1720:Lib/FreeRTOS/Source/queue.c ****                 {
1721:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1722:Lib/FreeRTOS/Source/queue.c ****                 }
1723:Lib/FreeRTOS/Source/queue.c ****             }
1724:Lib/FreeRTOS/Source/queue.c ****             else
1725:Lib/FreeRTOS/Source/queue.c ****             {
1726:Lib/FreeRTOS/Source/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1727:Lib/FreeRTOS/Source/queue.c ****                  * attempt to take the semaphore again. */
1728:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1729:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1730:Lib/FreeRTOS/Source/queue.c ****             }
1731:Lib/FreeRTOS/Source/queue.c ****         }
1732:Lib/FreeRTOS/Source/queue.c ****         else
1733:Lib/FreeRTOS/Source/queue.c ****         {
1734:Lib/FreeRTOS/Source/queue.c ****             /* Timed out. */
1735:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
ARM GAS  /tmp/ccTT1k9d.s 			page 32


1736:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1737:Lib/FreeRTOS/Source/queue.c **** 
1738:Lib/FreeRTOS/Source/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1739:Lib/FreeRTOS/Source/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1740:Lib/FreeRTOS/Source/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1741:Lib/FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1742:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1743:Lib/FreeRTOS/Source/queue.c ****             {
1744:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1745:Lib/FreeRTOS/Source/queue.c ****                 {
1746:Lib/FreeRTOS/Source/queue.c ****                     /* xInheritanceOccurred could only have be set if
1747:Lib/FreeRTOS/Source/queue.c ****                      * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1748:Lib/FreeRTOS/Source/queue.c ****                      * test the mutex type again to check it is actually a mutex. */
1749:Lib/FreeRTOS/Source/queue.c ****                     if( xInheritanceOccurred != pdFALSE )
1750:Lib/FreeRTOS/Source/queue.c ****                     {
1751:Lib/FreeRTOS/Source/queue.c ****                         taskENTER_CRITICAL();
1752:Lib/FreeRTOS/Source/queue.c ****                         {
1753:Lib/FreeRTOS/Source/queue.c ****                             UBaseType_t uxHighestWaitingPriority;
1754:Lib/FreeRTOS/Source/queue.c **** 
1755:Lib/FreeRTOS/Source/queue.c ****                             /* This task blocking on the mutex caused another
1756:Lib/FreeRTOS/Source/queue.c ****                              * task to inherit this task's priority.  Now this task
1757:Lib/FreeRTOS/Source/queue.c ****                              * has timed out the priority should be disinherited
1758:Lib/FreeRTOS/Source/queue.c ****                              * again, but only as low as the next highest priority
1759:Lib/FreeRTOS/Source/queue.c ****                              * task that is waiting for the same mutex. */
1760:Lib/FreeRTOS/Source/queue.c ****                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueu
1761:Lib/FreeRTOS/Source/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
1762:Lib/FreeRTOS/Source/queue.c ****                         }
1763:Lib/FreeRTOS/Source/queue.c ****                         taskEXIT_CRITICAL();
1764:Lib/FreeRTOS/Source/queue.c ****                     }
1765:Lib/FreeRTOS/Source/queue.c ****                 }
1766:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1767:Lib/FreeRTOS/Source/queue.c **** 
1768:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1769:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1770:Lib/FreeRTOS/Source/queue.c ****             }
1771:Lib/FreeRTOS/Source/queue.c ****             else
1772:Lib/FreeRTOS/Source/queue.c ****             {
1773:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1774:Lib/FreeRTOS/Source/queue.c ****             }
1775:Lib/FreeRTOS/Source/queue.c ****         }
1776:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1777:Lib/FreeRTOS/Source/queue.c **** }
1778:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1779:Lib/FreeRTOS/Source/queue.c **** 
1780:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1781:Lib/FreeRTOS/Source/queue.c ****                        void * const pvBuffer,
1782:Lib/FreeRTOS/Source/queue.c ****                        TickType_t xTicksToWait )
1783:Lib/FreeRTOS/Source/queue.c **** {
1784:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
1785:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1786:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
1787:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1788:Lib/FreeRTOS/Source/queue.c **** 
1789:Lib/FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1790:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
1791:Lib/FreeRTOS/Source/queue.c **** 
1792:Lib/FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
ARM GAS  /tmp/ccTT1k9d.s 			page 33


1793:Lib/FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer. */
1794:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
1795:Lib/FreeRTOS/Source/queue.c **** 
1796:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1797:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1798:Lib/FreeRTOS/Source/queue.c ****     {
1799:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
1800:Lib/FreeRTOS/Source/queue.c ****     }
1801:Lib/FreeRTOS/Source/queue.c ****     #endif
1802:Lib/FreeRTOS/Source/queue.c **** 
1803:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1804:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1805:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1806:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1807:Lib/FreeRTOS/Source/queue.c ****     {
1808:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
1809:Lib/FreeRTOS/Source/queue.c ****         {
1810:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1811:Lib/FreeRTOS/Source/queue.c **** 
1812:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1813:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1814:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
1815:Lib/FreeRTOS/Source/queue.c ****             {
1816:Lib/FreeRTOS/Source/queue.c ****                 /* Remember the read position so it can be reset after the data
1817:Lib/FreeRTOS/Source/queue.c ****                  * is read from the queue as this function is only peeking the
1818:Lib/FreeRTOS/Source/queue.c ****                  * data, not removing it. */
1819:Lib/FreeRTOS/Source/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
1820:Lib/FreeRTOS/Source/queue.c **** 
1821:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
1822:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1823:Lib/FreeRTOS/Source/queue.c **** 
1824:Lib/FreeRTOS/Source/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1825:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
1826:Lib/FreeRTOS/Source/queue.c **** 
1827:Lib/FreeRTOS/Source/queue.c ****                 /* The data is being left in the queue, so see if there are
1828:Lib/FreeRTOS/Source/queue.c ****                  * any other tasks waiting for the data. */
1829:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1830:Lib/FreeRTOS/Source/queue.c ****                 {
1831:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
1832:Lib/FreeRTOS/Source/queue.c ****                     {
1833:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than this task. */
1834:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
1835:Lib/FreeRTOS/Source/queue.c ****                     }
1836:Lib/FreeRTOS/Source/queue.c ****                     else
1837:Lib/FreeRTOS/Source/queue.c ****                     {
1838:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1839:Lib/FreeRTOS/Source/queue.c ****                     }
1840:Lib/FreeRTOS/Source/queue.c ****                 }
1841:Lib/FreeRTOS/Source/queue.c ****                 else
1842:Lib/FreeRTOS/Source/queue.c ****                 {
1843:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1844:Lib/FreeRTOS/Source/queue.c ****                 }
1845:Lib/FreeRTOS/Source/queue.c **** 
1846:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
1847:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
1848:Lib/FreeRTOS/Source/queue.c ****             }
1849:Lib/FreeRTOS/Source/queue.c ****             else
ARM GAS  /tmp/ccTT1k9d.s 			page 34


1850:Lib/FreeRTOS/Source/queue.c ****             {
1851:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
1852:Lib/FreeRTOS/Source/queue.c ****                 {
1853:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1854:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1855:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
1856:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1857:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
1858:Lib/FreeRTOS/Source/queue.c ****                 }
1859:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
1860:Lib/FreeRTOS/Source/queue.c ****                 {
1861:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1862:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure ready to enter the blocked
1863:Lib/FreeRTOS/Source/queue.c ****                      * state. */
1864:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
1865:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
1866:Lib/FreeRTOS/Source/queue.c ****                 }
1867:Lib/FreeRTOS/Source/queue.c ****                 else
1868:Lib/FreeRTOS/Source/queue.c ****                 {
1869:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1870:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1871:Lib/FreeRTOS/Source/queue.c ****                 }
1872:Lib/FreeRTOS/Source/queue.c ****             }
1873:Lib/FreeRTOS/Source/queue.c ****         }
1874:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
1875:Lib/FreeRTOS/Source/queue.c **** 
1876:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1877:Lib/FreeRTOS/Source/queue.c ****          * now that the critical section has been exited. */
1878:Lib/FreeRTOS/Source/queue.c **** 
1879:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
1880:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
1881:Lib/FreeRTOS/Source/queue.c **** 
1882:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1883:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
1884:Lib/FreeRTOS/Source/queue.c ****         {
1885:Lib/FreeRTOS/Source/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1886:Lib/FreeRTOS/Source/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1887:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1888:Lib/FreeRTOS/Source/queue.c ****             {
1889:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1890:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1891:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
1892:Lib/FreeRTOS/Source/queue.c **** 
1893:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
1894:Lib/FreeRTOS/Source/queue.c ****                 {
1895:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
1896:Lib/FreeRTOS/Source/queue.c ****                 }
1897:Lib/FreeRTOS/Source/queue.c ****                 else
1898:Lib/FreeRTOS/Source/queue.c ****                 {
1899:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1900:Lib/FreeRTOS/Source/queue.c ****                 }
1901:Lib/FreeRTOS/Source/queue.c ****             }
1902:Lib/FreeRTOS/Source/queue.c ****             else
1903:Lib/FreeRTOS/Source/queue.c ****             {
1904:Lib/FreeRTOS/Source/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1905:Lib/FreeRTOS/Source/queue.c ****                  * state, instead return to try and obtain the data. */
1906:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
ARM GAS  /tmp/ccTT1k9d.s 			page 35


1907:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
1908:Lib/FreeRTOS/Source/queue.c ****             }
1909:Lib/FreeRTOS/Source/queue.c ****         }
1910:Lib/FreeRTOS/Source/queue.c ****         else
1911:Lib/FreeRTOS/Source/queue.c ****         {
1912:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1913:Lib/FreeRTOS/Source/queue.c ****              * exit, otherwise go back and try to read the data again. */
1914:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
1915:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
1916:Lib/FreeRTOS/Source/queue.c **** 
1917:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
1918:Lib/FreeRTOS/Source/queue.c ****             {
1919:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1920:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
1921:Lib/FreeRTOS/Source/queue.c ****             }
1922:Lib/FreeRTOS/Source/queue.c ****             else
1923:Lib/FreeRTOS/Source/queue.c ****             {
1924:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1925:Lib/FreeRTOS/Source/queue.c ****             }
1926:Lib/FreeRTOS/Source/queue.c ****         }
1927:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1928:Lib/FreeRTOS/Source/queue.c **** }
1929:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1930:Lib/FreeRTOS/Source/queue.c **** 
1931:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1932:Lib/FreeRTOS/Source/queue.c ****                                  void * const pvBuffer,
1933:Lib/FreeRTOS/Source/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1934:Lib/FreeRTOS/Source/queue.c **** {
1935:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1936:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1937:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
1938:Lib/FreeRTOS/Source/queue.c **** 
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
1940:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1941:Lib/FreeRTOS/Source/queue.c **** 
1942:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1943:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1944:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1945:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1946:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1947:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1948:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1949:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1950:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1951:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1952:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1953:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1954:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1955:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1956:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1957:Lib/FreeRTOS/Source/queue.c **** 
1958:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1959:Lib/FreeRTOS/Source/queue.c ****     {
1960:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
1961:Lib/FreeRTOS/Source/queue.c **** 
1962:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1963:Lib/FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
ARM GAS  /tmp/ccTT1k9d.s 			page 36


1964:Lib/FreeRTOS/Source/queue.c ****         {
1965:Lib/FreeRTOS/Source/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
1966:Lib/FreeRTOS/Source/queue.c **** 
1967:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1968:Lib/FreeRTOS/Source/queue.c **** 
1969:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
1970:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
1971:Lib/FreeRTOS/Source/queue.c **** 
1972:Lib/FreeRTOS/Source/queue.c ****             /* If the queue is locked the event list will not be modified.
1973:Lib/FreeRTOS/Source/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1974:Lib/FreeRTOS/Source/queue.c ****              * will know that an ISR has removed data while the queue was
1975:Lib/FreeRTOS/Source/queue.c ****              * locked. */
1976:Lib/FreeRTOS/Source/queue.c ****             if( cRxLock == queueUNLOCKED )
1977:Lib/FreeRTOS/Source/queue.c ****             {
1978:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1979:Lib/FreeRTOS/Source/queue.c ****                 {
1980:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1981:Lib/FreeRTOS/Source/queue.c ****                     {
1982:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than us so
1983:Lib/FreeRTOS/Source/queue.c ****                          * force a context switch. */
1984:Lib/FreeRTOS/Source/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
1985:Lib/FreeRTOS/Source/queue.c ****                         {
1986:Lib/FreeRTOS/Source/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
1987:Lib/FreeRTOS/Source/queue.c ****                         }
1988:Lib/FreeRTOS/Source/queue.c ****                         else
1989:Lib/FreeRTOS/Source/queue.c ****                         {
1990:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1991:Lib/FreeRTOS/Source/queue.c ****                         }
1992:Lib/FreeRTOS/Source/queue.c ****                     }
1993:Lib/FreeRTOS/Source/queue.c ****                     else
1994:Lib/FreeRTOS/Source/queue.c ****                     {
1995:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1996:Lib/FreeRTOS/Source/queue.c ****                     }
1997:Lib/FreeRTOS/Source/queue.c ****                 }
1998:Lib/FreeRTOS/Source/queue.c ****                 else
1999:Lib/FreeRTOS/Source/queue.c ****                 {
2000:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2001:Lib/FreeRTOS/Source/queue.c ****                 }
2002:Lib/FreeRTOS/Source/queue.c ****             }
2003:Lib/FreeRTOS/Source/queue.c ****             else
2004:Lib/FreeRTOS/Source/queue.c ****             {
2005:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
2006:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was removed while it was locked. */
2007:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueRxLock( pxQueue, cRxLock );
2008:Lib/FreeRTOS/Source/queue.c ****             }
2009:Lib/FreeRTOS/Source/queue.c **** 
2010:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
2011:Lib/FreeRTOS/Source/queue.c ****         }
2012:Lib/FreeRTOS/Source/queue.c ****         else
2013:Lib/FreeRTOS/Source/queue.c ****         {
2014:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
2015:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
2016:Lib/FreeRTOS/Source/queue.c ****         }
2017:Lib/FreeRTOS/Source/queue.c ****     }
2018:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2019:Lib/FreeRTOS/Source/queue.c **** 
2020:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
ARM GAS  /tmp/ccTT1k9d.s 			page 37


2021:Lib/FreeRTOS/Source/queue.c **** }
2022:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2023:Lib/FreeRTOS/Source/queue.c **** 
2024:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
2025:Lib/FreeRTOS/Source/queue.c ****                               void * const pvBuffer )
2026:Lib/FreeRTOS/Source/queue.c **** {
2027:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2028:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
2029:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
2030:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2031:Lib/FreeRTOS/Source/queue.c **** 
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
2034:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
2035:Lib/FreeRTOS/Source/queue.c **** 
2036:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
2037:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
2038:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
2039:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
2040:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2041:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2042:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
2043:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
2044:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
2045:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
2046:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
2047:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
2048:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
2049:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2050:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2051:Lib/FreeRTOS/Source/queue.c **** 
2052:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
2053:Lib/FreeRTOS/Source/queue.c ****     {
2054:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
2055:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2056:Lib/FreeRTOS/Source/queue.c ****         {
2057:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
2058:Lib/FreeRTOS/Source/queue.c **** 
2059:Lib/FreeRTOS/Source/queue.c ****             /* Remember the read position so it can be reset as nothing is
2060:Lib/FreeRTOS/Source/queue.c ****              * actually being removed from the queue. */
2061:Lib/FreeRTOS/Source/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
2062:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
2063:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
2064:Lib/FreeRTOS/Source/queue.c **** 
2065:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
2066:Lib/FreeRTOS/Source/queue.c ****         }
2067:Lib/FreeRTOS/Source/queue.c ****         else
2068:Lib/FreeRTOS/Source/queue.c ****         {
2069:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
2070:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
2071:Lib/FreeRTOS/Source/queue.c ****         }
2072:Lib/FreeRTOS/Source/queue.c ****     }
2073:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2074:Lib/FreeRTOS/Source/queue.c **** 
2075:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
2076:Lib/FreeRTOS/Source/queue.c **** }
2077:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccTT1k9d.s 			page 38


2078:Lib/FreeRTOS/Source/queue.c **** 
2079:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
2080:Lib/FreeRTOS/Source/queue.c **** {
2081:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2082:Lib/FreeRTOS/Source/queue.c **** 
2083:Lib/FreeRTOS/Source/queue.c ****     configASSERT( xQueue );
2084:Lib/FreeRTOS/Source/queue.c **** 
2085:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2086:Lib/FreeRTOS/Source/queue.c ****     {
2087:Lib/FreeRTOS/Source/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
2088:Lib/FreeRTOS/Source/queue.c ****     }
2089:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2090:Lib/FreeRTOS/Source/queue.c **** 
2091:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
2092:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2093:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2094:Lib/FreeRTOS/Source/queue.c **** 
2095:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
2096:Lib/FreeRTOS/Source/queue.c **** {
2097:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2098:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2099:Lib/FreeRTOS/Source/queue.c **** 
2100:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2101:Lib/FreeRTOS/Source/queue.c **** 
2102:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2103:Lib/FreeRTOS/Source/queue.c ****     {
2104:Lib/FreeRTOS/Source/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
2105:Lib/FreeRTOS/Source/queue.c ****     }
2106:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2107:Lib/FreeRTOS/Source/queue.c **** 
2108:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
2109:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2110:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2111:Lib/FreeRTOS/Source/queue.c **** 
2112:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2113:Lib/FreeRTOS/Source/queue.c **** {
2114:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2115:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2116:Lib/FreeRTOS/Source/queue.c **** 
2117:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2118:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
2119:Lib/FreeRTOS/Source/queue.c **** 
2120:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
2121:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
2122:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2123:Lib/FreeRTOS/Source/queue.c **** 
2124:Lib/FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2125:Lib/FreeRTOS/Source/queue.c **** {
2126:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2127:Lib/FreeRTOS/Source/queue.c **** 
2128:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2129:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
2130:Lib/FreeRTOS/Source/queue.c **** 
2131:Lib/FreeRTOS/Source/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2132:Lib/FreeRTOS/Source/queue.c ****     {
2133:Lib/FreeRTOS/Source/queue.c ****         vQueueUnregisterQueue( pxQueue );
2134:Lib/FreeRTOS/Source/queue.c ****     }
ARM GAS  /tmp/ccTT1k9d.s 			page 39


2135:Lib/FreeRTOS/Source/queue.c ****     #endif
2136:Lib/FreeRTOS/Source/queue.c **** 
2137:Lib/FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
2138:Lib/FreeRTOS/Source/queue.c ****     {
2139:Lib/FreeRTOS/Source/queue.c ****         /* The queue can only have been allocated dynamically - free it
2140:Lib/FreeRTOS/Source/queue.c ****          * again. */
2141:Lib/FreeRTOS/Source/queue.c ****         vPortFree( pxQueue );
2142:Lib/FreeRTOS/Source/queue.c ****     }
2143:Lib/FreeRTOS/Source/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2144:Lib/FreeRTOS/Source/queue.c ****     {
2145:Lib/FreeRTOS/Source/queue.c ****         /* The queue could have been allocated statically or dynamically, so
2146:Lib/FreeRTOS/Source/queue.c ****          * check before attempting to free the memory. */
2147:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
2148:Lib/FreeRTOS/Source/queue.c ****         {
2149:Lib/FreeRTOS/Source/queue.c ****             vPortFree( pxQueue );
2150:Lib/FreeRTOS/Source/queue.c ****         }
2151:Lib/FreeRTOS/Source/queue.c ****         else
2152:Lib/FreeRTOS/Source/queue.c ****         {
2153:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2154:Lib/FreeRTOS/Source/queue.c ****         }
2155:Lib/FreeRTOS/Source/queue.c ****     }
2156:Lib/FreeRTOS/Source/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2157:Lib/FreeRTOS/Source/queue.c ****     {
2158:Lib/FreeRTOS/Source/queue.c ****         /* The queue must have been statically allocated, so is not going to be
2159:Lib/FreeRTOS/Source/queue.c ****          * deleted.  Avoid compiler warnings about the unused parameter. */
2160:Lib/FreeRTOS/Source/queue.c ****         ( void ) pxQueue;
2161:Lib/FreeRTOS/Source/queue.c ****     }
2162:Lib/FreeRTOS/Source/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2163:Lib/FreeRTOS/Source/queue.c **** }
2164:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2165:Lib/FreeRTOS/Source/queue.c **** 
2166:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2167:Lib/FreeRTOS/Source/queue.c **** 
2168:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2169:Lib/FreeRTOS/Source/queue.c ****     {
2170:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
2171:Lib/FreeRTOS/Source/queue.c ****     }
2172:Lib/FreeRTOS/Source/queue.c **** 
2173:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2174:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2175:Lib/FreeRTOS/Source/queue.c **** 
2176:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2177:Lib/FreeRTOS/Source/queue.c **** 
2178:Lib/FreeRTOS/Source/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2179:Lib/FreeRTOS/Source/queue.c ****                                UBaseType_t uxQueueNumber )
2180:Lib/FreeRTOS/Source/queue.c ****     {
2181:Lib/FreeRTOS/Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
2182:Lib/FreeRTOS/Source/queue.c ****     }
2183:Lib/FreeRTOS/Source/queue.c **** 
2184:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2185:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2186:Lib/FreeRTOS/Source/queue.c **** 
2187:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2188:Lib/FreeRTOS/Source/queue.c **** 
2189:Lib/FreeRTOS/Source/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2190:Lib/FreeRTOS/Source/queue.c ****     {
2191:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
ARM GAS  /tmp/ccTT1k9d.s 			page 40


2192:Lib/FreeRTOS/Source/queue.c ****     }
2193:Lib/FreeRTOS/Source/queue.c **** 
2194:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2195:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2196:Lib/FreeRTOS/Source/queue.c **** 
2197:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueGetQueueItemSize( QueueHandle_t xQueue ) /* PRIVILEGED_FUNCTION */
2198:Lib/FreeRTOS/Source/queue.c **** {
2199:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxItemSize;
2200:Lib/FreeRTOS/Source/queue.c **** }
2201:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2202:Lib/FreeRTOS/Source/queue.c **** 
2203:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueGetQueueLength( QueueHandle_t xQueue ) /* PRIVILEGED_FUNCTION */
2204:Lib/FreeRTOS/Source/queue.c **** {
2205:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxLength;
2206:Lib/FreeRTOS/Source/queue.c **** }
2207:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2208:Lib/FreeRTOS/Source/queue.c **** 
2209:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
2210:Lib/FreeRTOS/Source/queue.c **** 
2211:Lib/FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2212:Lib/FreeRTOS/Source/queue.c ****     {
2213:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
2214:Lib/FreeRTOS/Source/queue.c **** 
2215:Lib/FreeRTOS/Source/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2216:Lib/FreeRTOS/Source/queue.c ****          * priority, but the waiting task times out, then the holder should
2217:Lib/FreeRTOS/Source/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2218:Lib/FreeRTOS/Source/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2219:Lib/FreeRTOS/Source/queue.c ****          * return the priority of the highest priority task that is waiting for the
2220:Lib/FreeRTOS/Source/queue.c ****          * mutex. */
2221:Lib/FreeRTOS/Source/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
2222:Lib/FreeRTOS/Source/queue.c ****         {
2223:Lib/FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
2224:Lib/FreeRTOS/Source/queue.c ****         }
2225:Lib/FreeRTOS/Source/queue.c ****         else
2226:Lib/FreeRTOS/Source/queue.c ****         {
2227:Lib/FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
2228:Lib/FreeRTOS/Source/queue.c ****         }
2229:Lib/FreeRTOS/Source/queue.c **** 
2230:Lib/FreeRTOS/Source/queue.c ****         return uxHighestPriorityOfWaitingTasks;
2231:Lib/FreeRTOS/Source/queue.c ****     }
2232:Lib/FreeRTOS/Source/queue.c **** 
2233:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2234:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2235:Lib/FreeRTOS/Source/queue.c **** 
2236:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2237:Lib/FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
2238:Lib/FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition )
2239:Lib/FreeRTOS/Source/queue.c **** {
2240:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
2241:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
2242:Lib/FreeRTOS/Source/queue.c **** 
2243:Lib/FreeRTOS/Source/queue.c ****     /* This function is called from a critical section. */
2244:Lib/FreeRTOS/Source/queue.c **** 
2245:Lib/FreeRTOS/Source/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
2246:Lib/FreeRTOS/Source/queue.c **** 
2247:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
2248:Lib/FreeRTOS/Source/queue.c ****     {
ARM GAS  /tmp/ccTT1k9d.s 			page 41


2249:Lib/FreeRTOS/Source/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2250:Lib/FreeRTOS/Source/queue.c ****         {
2251:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
2252:Lib/FreeRTOS/Source/queue.c ****             {
2253:Lib/FreeRTOS/Source/queue.c ****                 /* The mutex is no longer being held. */
2254:Lib/FreeRTOS/Source/queue.c ****                 xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
2255:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
2256:Lib/FreeRTOS/Source/queue.c ****             }
2257:Lib/FreeRTOS/Source/queue.c ****             else
2258:Lib/FreeRTOS/Source/queue.c ****             {
2259:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2260:Lib/FreeRTOS/Source/queue.c ****             }
2261:Lib/FreeRTOS/Source/queue.c ****         }
2262:Lib/FreeRTOS/Source/queue.c ****         #endif /* configUSE_MUTEXES */
2263:Lib/FreeRTOS/Source/queue.c ****     }
2264:Lib/FreeRTOS/Source/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
2265:Lib/FreeRTOS/Source/queue.c ****     {
2266:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
2267:Lib/FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
2268:Lib/FreeRTOS/Source/queue.c **** 
2269:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
2270:Lib/FreeRTOS/Source/queue.c ****         {
2271:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
2272:Lib/FreeRTOS/Source/queue.c ****         }
2273:Lib/FreeRTOS/Source/queue.c ****         else
2274:Lib/FreeRTOS/Source/queue.c ****         {
2275:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2276:Lib/FreeRTOS/Source/queue.c ****         }
2277:Lib/FreeRTOS/Source/queue.c ****     }
2278:Lib/FreeRTOS/Source/queue.c ****     else
2279:Lib/FreeRTOS/Source/queue.c ****     {
2280:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
2281:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
2282:Lib/FreeRTOS/Source/queue.c **** 
2283:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
2284:Lib/FreeRTOS/Source/queue.c ****         {
2285:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
2286:Lib/FreeRTOS/Source/queue.c ****         }
2287:Lib/FreeRTOS/Source/queue.c ****         else
2288:Lib/FreeRTOS/Source/queue.c ****         {
2289:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2290:Lib/FreeRTOS/Source/queue.c ****         }
2291:Lib/FreeRTOS/Source/queue.c **** 
2292:Lib/FreeRTOS/Source/queue.c ****         if( xPosition == queueOVERWRITE )
2293:Lib/FreeRTOS/Source/queue.c ****         {
2294:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
2295:Lib/FreeRTOS/Source/queue.c ****             {
2296:Lib/FreeRTOS/Source/queue.c ****                 /* An item is not being added but overwritten, so subtract
2297:Lib/FreeRTOS/Source/queue.c ****                  * one from the recorded number of items in the queue so when
2298:Lib/FreeRTOS/Source/queue.c ****                  * one is added again below the number of recorded items remains
2299:Lib/FreeRTOS/Source/queue.c ****                  * correct. */
2300:Lib/FreeRTOS/Source/queue.c ****                 --uxMessagesWaiting;
2301:Lib/FreeRTOS/Source/queue.c ****             }
2302:Lib/FreeRTOS/Source/queue.c ****             else
2303:Lib/FreeRTOS/Source/queue.c ****             {
2304:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2305:Lib/FreeRTOS/Source/queue.c ****             }
ARM GAS  /tmp/ccTT1k9d.s 			page 42


2306:Lib/FreeRTOS/Source/queue.c ****         }
2307:Lib/FreeRTOS/Source/queue.c ****         else
2308:Lib/FreeRTOS/Source/queue.c ****         {
2309:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2310:Lib/FreeRTOS/Source/queue.c ****         }
2311:Lib/FreeRTOS/Source/queue.c ****     }
2312:Lib/FreeRTOS/Source/queue.c **** 
2313:Lib/FreeRTOS/Source/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
2314:Lib/FreeRTOS/Source/queue.c **** 
2315:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
2316:Lib/FreeRTOS/Source/queue.c **** }
2317:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2318:Lib/FreeRTOS/Source/queue.c **** 
2319:Lib/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2320:Lib/FreeRTOS/Source/queue.c ****                                   void * const pvBuffer )
2321:Lib/FreeRTOS/Source/queue.c **** {
2322:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
2323:Lib/FreeRTOS/Source/queue.c ****     {
2324:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
2325:Lib/FreeRTOS/Source/queue.c **** 
2326:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
2327:Lib/FreeRTOS/Source/queue.c ****         {
2328:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2329:Lib/FreeRTOS/Source/queue.c ****         }
2330:Lib/FreeRTOS/Source/queue.c ****         else
2331:Lib/FreeRTOS/Source/queue.c ****         {
2332:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2333:Lib/FreeRTOS/Source/queue.c ****         }
2334:Lib/FreeRTOS/Source/queue.c **** 
2335:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
2336:Lib/FreeRTOS/Source/queue.c ****     }
2337:Lib/FreeRTOS/Source/queue.c **** }
2338:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2339:Lib/FreeRTOS/Source/queue.c **** 
2340:Lib/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2341:Lib/FreeRTOS/Source/queue.c **** {
2342:Lib/FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2343:Lib/FreeRTOS/Source/queue.c **** 
2344:Lib/FreeRTOS/Source/queue.c ****     /* The lock counts contains the number of extra data items placed or
2345:Lib/FreeRTOS/Source/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2346:Lib/FreeRTOS/Source/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2347:Lib/FreeRTOS/Source/queue.c ****      * updated. */
2348:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2349:Lib/FreeRTOS/Source/queue.c ****     {
2350:Lib/FreeRTOS/Source/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
2351:Lib/FreeRTOS/Source/queue.c **** 
2352:Lib/FreeRTOS/Source/queue.c ****         /* See if data was added to the queue while it was locked. */
2353:Lib/FreeRTOS/Source/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
2354:Lib/FreeRTOS/Source/queue.c ****         {
2355:Lib/FreeRTOS/Source/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2356:Lib/FreeRTOS/Source/queue.c ****              * blocked waiting for data to become available? */
2357:Lib/FreeRTOS/Source/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2358:Lib/FreeRTOS/Source/queue.c ****             {
2359:Lib/FreeRTOS/Source/queue.c ****                 if( pxQueue->pxQueueSetContainer != NULL )
2360:Lib/FreeRTOS/Source/queue.c ****                 {
2361:Lib/FreeRTOS/Source/queue.c ****                     if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2362:Lib/FreeRTOS/Source/queue.c ****                     {
ARM GAS  /tmp/ccTT1k9d.s 			page 43


2363:Lib/FreeRTOS/Source/queue.c ****                         /* The queue is a member of a queue set, and posting to
2364:Lib/FreeRTOS/Source/queue.c ****                          * the queue set caused a higher priority task to unblock.
2365:Lib/FreeRTOS/Source/queue.c ****                          * A context switch is required. */
2366:Lib/FreeRTOS/Source/queue.c ****                         vTaskMissedYield();
2367:Lib/FreeRTOS/Source/queue.c ****                     }
2368:Lib/FreeRTOS/Source/queue.c ****                     else
2369:Lib/FreeRTOS/Source/queue.c ****                     {
2370:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2371:Lib/FreeRTOS/Source/queue.c ****                     }
2372:Lib/FreeRTOS/Source/queue.c ****                 }
2373:Lib/FreeRTOS/Source/queue.c ****                 else
2374:Lib/FreeRTOS/Source/queue.c ****                 {
2375:Lib/FreeRTOS/Source/queue.c ****                     /* Tasks that are removed from the event list will get
2376:Lib/FreeRTOS/Source/queue.c ****                      * added to the pending ready list as the scheduler is still
2377:Lib/FreeRTOS/Source/queue.c ****                      * suspended. */
2378:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2379:Lib/FreeRTOS/Source/queue.c ****                     {
2380:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
2381:Lib/FreeRTOS/Source/queue.c ****                         {
2382:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
2383:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
2384:Lib/FreeRTOS/Source/queue.c ****                             vTaskMissedYield();
2385:Lib/FreeRTOS/Source/queue.c ****                         }
2386:Lib/FreeRTOS/Source/queue.c ****                         else
2387:Lib/FreeRTOS/Source/queue.c ****                         {
2388:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2389:Lib/FreeRTOS/Source/queue.c ****                         }
2390:Lib/FreeRTOS/Source/queue.c ****                     }
2391:Lib/FreeRTOS/Source/queue.c ****                     else
2392:Lib/FreeRTOS/Source/queue.c ****                     {
2393:Lib/FreeRTOS/Source/queue.c ****                         break;
2394:Lib/FreeRTOS/Source/queue.c ****                     }
2395:Lib/FreeRTOS/Source/queue.c ****                 }
2396:Lib/FreeRTOS/Source/queue.c ****             }
2397:Lib/FreeRTOS/Source/queue.c ****             #else /* configUSE_QUEUE_SETS */
2398:Lib/FreeRTOS/Source/queue.c ****             {
2399:Lib/FreeRTOS/Source/queue.c ****                 /* Tasks that are removed from the event list will get added to
2400:Lib/FreeRTOS/Source/queue.c ****                  * the pending ready list as the scheduler is still suspended. */
2401:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2402:Lib/FreeRTOS/Source/queue.c ****                 {
2403:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
2404:Lib/FreeRTOS/Source/queue.c ****                     {
2405:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority so record that
2406:Lib/FreeRTOS/Source/queue.c ****                          * a context switch is required. */
2407:Lib/FreeRTOS/Source/queue.c ****                         vTaskMissedYield();
2408:Lib/FreeRTOS/Source/queue.c ****                     }
2409:Lib/FreeRTOS/Source/queue.c ****                     else
2410:Lib/FreeRTOS/Source/queue.c ****                     {
2411:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2412:Lib/FreeRTOS/Source/queue.c ****                     }
2413:Lib/FreeRTOS/Source/queue.c ****                 }
2414:Lib/FreeRTOS/Source/queue.c ****                 else
2415:Lib/FreeRTOS/Source/queue.c ****                 {
2416:Lib/FreeRTOS/Source/queue.c ****                     break;
2417:Lib/FreeRTOS/Source/queue.c ****                 }
2418:Lib/FreeRTOS/Source/queue.c ****             }
2419:Lib/FreeRTOS/Source/queue.c ****             #endif /* configUSE_QUEUE_SETS */
ARM GAS  /tmp/ccTT1k9d.s 			page 44


2420:Lib/FreeRTOS/Source/queue.c **** 
2421:Lib/FreeRTOS/Source/queue.c ****             --cTxLock;
2422:Lib/FreeRTOS/Source/queue.c ****         }
2423:Lib/FreeRTOS/Source/queue.c **** 
2424:Lib/FreeRTOS/Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
2425:Lib/FreeRTOS/Source/queue.c ****     }
2426:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2427:Lib/FreeRTOS/Source/queue.c **** 
2428:Lib/FreeRTOS/Source/queue.c ****     /* Do the same for the Rx lock. */
2429:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
2430:Lib/FreeRTOS/Source/queue.c ****     {
2431:Lib/FreeRTOS/Source/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
2432:Lib/FreeRTOS/Source/queue.c **** 
2433:Lib/FreeRTOS/Source/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
2434:Lib/FreeRTOS/Source/queue.c ****         {
2435:Lib/FreeRTOS/Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2436:Lib/FreeRTOS/Source/queue.c ****             {
2437:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2438:Lib/FreeRTOS/Source/queue.c ****                 {
2439:Lib/FreeRTOS/Source/queue.c ****                     vTaskMissedYield();
2440:Lib/FreeRTOS/Source/queue.c ****                 }
2441:Lib/FreeRTOS/Source/queue.c ****                 else
2442:Lib/FreeRTOS/Source/queue.c ****                 {
2443:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2444:Lib/FreeRTOS/Source/queue.c ****                 }
2445:Lib/FreeRTOS/Source/queue.c **** 
2446:Lib/FreeRTOS/Source/queue.c ****                 --cRxLock;
2447:Lib/FreeRTOS/Source/queue.c ****             }
2448:Lib/FreeRTOS/Source/queue.c ****             else
2449:Lib/FreeRTOS/Source/queue.c ****             {
2450:Lib/FreeRTOS/Source/queue.c ****                 break;
2451:Lib/FreeRTOS/Source/queue.c ****             }
2452:Lib/FreeRTOS/Source/queue.c ****         }
2453:Lib/FreeRTOS/Source/queue.c **** 
2454:Lib/FreeRTOS/Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
2455:Lib/FreeRTOS/Source/queue.c ****     }
2456:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
2457:Lib/FreeRTOS/Source/queue.c **** }
2458:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2459:Lib/FreeRTOS/Source/queue.c **** 
2460:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2461:Lib/FreeRTOS/Source/queue.c **** {
  34              		.loc 1 2461 1 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 0, uses_anonymous_args = 0
2462:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
  38              		.loc 1 2462 5 view .LVU1
2463:Lib/FreeRTOS/Source/queue.c **** 
2464:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
  39              		.loc 1 2464 5 view .LVU2
2461:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
  40              		.loc 1 2461 1 is_stmt 0 view .LVU3
  41 0000 10B5     		push	{r4, lr}
  42              		.cfi_def_cfa_offset 8
  43              		.cfi_offset 4, -8
  44              		.cfi_offset 14, -4
ARM GAS  /tmp/ccTT1k9d.s 			page 45


2461:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
  45              		.loc 1 2461 1 view .LVU4
  46 0002 0446     		mov	r4, r0
  47              		.loc 1 2464 5 view .LVU5
  48 0004 FFF7FEFF 		bl	vPortEnterCritical
  49              	.LVL1:
2465:Lib/FreeRTOS/Source/queue.c ****     {
2466:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
  50              		.loc 1 2466 9 is_stmt 1 view .LVU6
  51              		.loc 1 2466 20 is_stmt 0 view .LVU7
  52 0008 A46B     		ldr	r4, [r4, #56]
  53              	.LVL2:
2467:Lib/FreeRTOS/Source/queue.c ****         {
2468:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
2469:Lib/FreeRTOS/Source/queue.c ****         }
2470:Lib/FreeRTOS/Source/queue.c ****         else
2471:Lib/FreeRTOS/Source/queue.c ****         {
2472:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
2473:Lib/FreeRTOS/Source/queue.c ****         }
2474:Lib/FreeRTOS/Source/queue.c ****     }
2475:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
  54              		.loc 1 2475 5 is_stmt 1 view .LVU8
  55 000a FFF7FEFF 		bl	vPortExitCritical
  56              	.LVL3:
2476:Lib/FreeRTOS/Source/queue.c **** 
2477:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
  57              		.loc 1 2477 5 view .LVU9
2478:Lib/FreeRTOS/Source/queue.c **** }
  58              		.loc 1 2478 1 is_stmt 0 view .LVU10
  59 000e B4FA84F0 		clz	r0, r4
  60 0012 4009     		lsrs	r0, r0, #5
  61 0014 10BD     		pop	{r4, pc}
  62              		.loc 1 2478 1 view .LVU11
  63              		.cfi_endproc
  64              	.LFE32:
  66              		.section	.text.prvCopyDataToQueue,"ax",%progbits
  67              		.align	1
  68              		.syntax unified
  69              		.thumb
  70              		.thumb_func
  72              	prvCopyDataToQueue:
  73              	.LVL4:
  74              	.LFB29:
2239:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
  75              		.loc 1 2239 1 is_stmt 1 view -0
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
2240:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
  79              		.loc 1 2240 5 view .LVU13
2241:Lib/FreeRTOS/Source/queue.c **** 
  80              		.loc 1 2241 5 view .LVU14
2245:Lib/FreeRTOS/Source/queue.c **** 
  81              		.loc 1 2245 5 view .LVU15
2239:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
  82              		.loc 1 2239 1 is_stmt 0 view .LVU16
  83 0000 70B5     		push	{r4, r5, r6, lr}
ARM GAS  /tmp/ccTT1k9d.s 			page 46


  84              		.cfi_def_cfa_offset 16
  85              		.cfi_offset 4, -16
  86              		.cfi_offset 5, -12
  87              		.cfi_offset 6, -8
  88              		.cfi_offset 14, -4
2239:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
  89              		.loc 1 2239 1 view .LVU17
  90 0002 1646     		mov	r6, r2
2247:Lib/FreeRTOS/Source/queue.c ****     {
  91              		.loc 1 2247 16 view .LVU18
  92 0004 026C     		ldr	r2, [r0, #64]
  93              	.LVL5:
2239:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
  94              		.loc 1 2239 1 view .LVU19
  95 0006 0446     		mov	r4, r0
2245:Lib/FreeRTOS/Source/queue.c **** 
  96              		.loc 1 2245 23 view .LVU20
  97 0008 856B     		ldr	r5, [r0, #56]
  98              	.LVL6:
2247:Lib/FreeRTOS/Source/queue.c ****     {
  99              		.loc 1 2247 5 is_stmt 1 view .LVU21
2247:Lib/FreeRTOS/Source/queue.c ****     {
 100              		.loc 1 2247 7 is_stmt 0 view .LVU22
 101 000a 42B9     		cbnz	r2, .L3
2251:Lib/FreeRTOS/Source/queue.c ****             {
 102              		.loc 1 2251 13 is_stmt 1 view .LVU23
2251:Lib/FreeRTOS/Source/queue.c ****             {
 103              		.loc 1 2251 15 is_stmt 0 view .LVU24
 104 000c 0668     		ldr	r6, [r0]
 105              	.LVL7:
2251:Lib/FreeRTOS/Source/queue.c ****             {
 106              		.loc 1 2251 15 view .LVU25
 107 000e 9EB9     		cbnz	r6, .L9
2254:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 108              		.loc 1 2254 17 is_stmt 1 view .LVU26
2254:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 109              		.loc 1 2254 27 is_stmt 0 view .LVU27
 110 0010 8068     		ldr	r0, [r0, #8]
 111              	.LVL8:
2254:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 112              		.loc 1 2254 27 view .LVU28
 113 0012 FFF7FEFF 		bl	xTaskPriorityDisinherit
 114              	.LVL9:
2255:Lib/FreeRTOS/Source/queue.c ****             }
 115              		.loc 1 2255 17 is_stmt 1 view .LVU29
2255:Lib/FreeRTOS/Source/queue.c ****             }
 116              		.loc 1 2255 52 is_stmt 0 view .LVU30
 117 0016 A660     		str	r6, [r4, #8]
 118              	.LVL10:
 119              	.L5:
2309:Lib/FreeRTOS/Source/queue.c ****         }
 120              		.loc 1 2309 37 is_stmt 1 view .LVU31
2313:Lib/FreeRTOS/Source/queue.c **** 
 121              		.loc 1 2313 5 view .LVU32
2313:Lib/FreeRTOS/Source/queue.c **** 
 122              		.loc 1 2313 52 is_stmt 0 view .LVU33
 123 0018 0135     		adds	r5, r5, #1
ARM GAS  /tmp/ccTT1k9d.s 			page 47


 124              	.LVL11:
2313:Lib/FreeRTOS/Source/queue.c **** 
 125              		.loc 1 2313 32 view .LVU34
 126 001a A563     		str	r5, [r4, #56]
2315:Lib/FreeRTOS/Source/queue.c **** }
 127              		.loc 1 2315 5 is_stmt 1 view .LVU35
2316:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 128              		.loc 1 2316 1 is_stmt 0 view .LVU36
 129 001c 70BD     		pop	{r4, r5, r6, pc}
 130              	.LVL12:
 131              	.L3:
2264:Lib/FreeRTOS/Source/queue.c ****     {
 132              		.loc 1 2264 10 is_stmt 1 view .LVU37
2264:Lib/FreeRTOS/Source/queue.c ****     {
 133              		.loc 1 2264 12 is_stmt 0 view .LVU38
 134 001e 6EB9     		cbnz	r6, .L6
2266:Lib/FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 135              		.loc 1 2266 9 is_stmt 1 view .LVU39
2266:Lib/FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 136              		.loc 1 2266 18 is_stmt 0 view .LVU40
 137 0020 4068     		ldr	r0, [r0, #4]
 138              	.LVL13:
2266:Lib/FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 139              		.loc 1 2266 18 view .LVU41
 140 0022 FFF7FEFF 		bl	memcpy
 141              	.LVL14:
2267:Lib/FreeRTOS/Source/queue.c **** 
 142              		.loc 1 2267 9 is_stmt 1 view .LVU42
2267:Lib/FreeRTOS/Source/queue.c **** 
 143              		.loc 1 2267 28 is_stmt 0 view .LVU43
 144 0026 6368     		ldr	r3, [r4, #4]
 145 0028 226C     		ldr	r2, [r4, #64]
 146 002a 1344     		add	r3, r3, r2
2269:Lib/FreeRTOS/Source/queue.c ****         {
 147              		.loc 1 2269 11 view .LVU44
 148 002c A268     		ldr	r2, [r4, #8]
2267:Lib/FreeRTOS/Source/queue.c **** 
 149              		.loc 1 2267 28 view .LVU45
 150 002e 6360     		str	r3, [r4, #4]
2269:Lib/FreeRTOS/Source/queue.c ****         {
 151              		.loc 1 2269 9 is_stmt 1 view .LVU46
2269:Lib/FreeRTOS/Source/queue.c ****         {
 152              		.loc 1 2269 11 is_stmt 0 view .LVU47
 153 0030 9342     		cmp	r3, r2
2271:Lib/FreeRTOS/Source/queue.c ****         }
 154              		.loc 1 2271 13 is_stmt 1 view .LVU48
2271:Lib/FreeRTOS/Source/queue.c ****         }
 155              		.loc 1 2271 32 is_stmt 0 view .LVU49
 156 0032 24BF     		itt	cs
 157 0034 2368     		ldrcs	r3, [r4]
 158 0036 6360     		strcs	r3, [r4, #4]
 159              	.LVL15:
 160              	.L9:
2240:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
 161              		.loc 1 2240 16 view .LVU50
 162 0038 0020     		movs	r0, #0
 163 003a EDE7     		b	.L5
ARM GAS  /tmp/ccTT1k9d.s 			page 48


 164              	.LVL16:
 165              	.L6:
2280:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 166              		.loc 1 2280 9 is_stmt 1 view .LVU51
2280:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 167              		.loc 1 2280 18 is_stmt 0 view .LVU52
 168 003c C068     		ldr	r0, [r0, #12]
 169              	.LVL17:
2280:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 170              		.loc 1 2280 18 view .LVU53
 171 003e FFF7FEFF 		bl	memcpy
 172              	.LVL18:
2281:Lib/FreeRTOS/Source/queue.c **** 
 173              		.loc 1 2281 9 is_stmt 1 view .LVU54
2281:Lib/FreeRTOS/Source/queue.c **** 
 174              		.loc 1 2281 38 is_stmt 0 view .LVU55
 175 0042 226C     		ldr	r2, [r4, #64]
 176 0044 E368     		ldr	r3, [r4, #12]
 177 0046 5142     		rsbs	r1, r2, #0
 178 0048 9B1A     		subs	r3, r3, r2
2283:Lib/FreeRTOS/Source/queue.c ****         {
 179              		.loc 1 2283 11 view .LVU56
 180 004a 2268     		ldr	r2, [r4]
2281:Lib/FreeRTOS/Source/queue.c **** 
 181              		.loc 1 2281 38 view .LVU57
 182 004c E360     		str	r3, [r4, #12]
2283:Lib/FreeRTOS/Source/queue.c ****         {
 183              		.loc 1 2283 9 is_stmt 1 view .LVU58
2283:Lib/FreeRTOS/Source/queue.c ****         {
 184              		.loc 1 2283 11 is_stmt 0 view .LVU59
 185 004e 9342     		cmp	r3, r2
2285:Lib/FreeRTOS/Source/queue.c ****         }
 186              		.loc 1 2285 13 is_stmt 1 view .LVU60
2285:Lib/FreeRTOS/Source/queue.c ****         }
 187              		.loc 1 2285 71 is_stmt 0 view .LVU61
 188 0050 3EBF     		ittt	cc
 189 0052 A368     		ldrcc	r3, [r4, #8]
 190 0054 5B18     		addcc	r3, r3, r1
2285:Lib/FreeRTOS/Source/queue.c ****         }
 191              		.loc 1 2285 42 view .LVU62
 192 0056 E360     		strcc	r3, [r4, #12]
2289:Lib/FreeRTOS/Source/queue.c ****         }
 193              		.loc 1 2289 37 is_stmt 1 view .LVU63
2292:Lib/FreeRTOS/Source/queue.c ****         {
 194              		.loc 1 2292 9 view .LVU64
2292:Lib/FreeRTOS/Source/queue.c ****         {
 195              		.loc 1 2292 11 is_stmt 0 view .LVU65
 196 0058 022E     		cmp	r6, #2
 197 005a EDD1     		bne	.L9
2294:Lib/FreeRTOS/Source/queue.c ****             {
 198              		.loc 1 2294 13 is_stmt 1 view .LVU66
2240:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
 199              		.loc 1 2240 16 is_stmt 0 view .LVU67
 200 005c 2846     		mov	r0, r5
2294:Lib/FreeRTOS/Source/queue.c ****             {
 201              		.loc 1 2294 15 view .LVU68
 202 005e 002D     		cmp	r5, #0
ARM GAS  /tmp/ccTT1k9d.s 			page 49


 203 0060 DAD0     		beq	.L5
 204              	.LVL19:
2300:Lib/FreeRTOS/Source/queue.c ****             }
 205              		.loc 1 2300 17 is_stmt 1 view .LVU69
 206 0062 013D     		subs	r5, r5, #1
 207              	.LVL20:
2300:Lib/FreeRTOS/Source/queue.c ****             }
 208              		.loc 1 2300 17 is_stmt 0 view .LVU70
 209 0064 E8E7     		b	.L9
 210              		.cfi_endproc
 211              	.LFE29:
 213              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 214              		.align	1
 215              		.syntax unified
 216              		.thumb
 217              		.thumb_func
 219              	prvCopyDataFromQueue:
 220              	.LVL21:
 221              	.LFB30:
2321:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 222              		.loc 1 2321 1 is_stmt 1 view -0
 223              		.cfi_startproc
 224              		@ args = 0, pretend = 0, frame = 0
 225              		@ frame_needed = 0, uses_anonymous_args = 0
 226              		@ link register save eliminated.
2322:Lib/FreeRTOS/Source/queue.c ****     {
 227              		.loc 1 2322 5 view .LVU72
2321:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 228              		.loc 1 2321 1 is_stmt 0 view .LVU73
 229 0000 0346     		mov	r3, r0
2322:Lib/FreeRTOS/Source/queue.c ****     {
 230              		.loc 1 2322 16 view .LVU74
 231 0002 1A6C     		ldr	r2, [r3, #64]
2321:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 232              		.loc 1 2321 1 view .LVU75
 233 0004 0846     		mov	r0, r1
 234              	.LVL22:
2321:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 235              		.loc 1 2321 1 view .LVU76
 236 0006 10B4     		push	{r4}
 237              		.cfi_def_cfa_offset 4
 238              		.cfi_offset 4, -4
2322:Lib/FreeRTOS/Source/queue.c ****     {
 239              		.loc 1 2322 7 view .LVU77
 240 0008 6AB1     		cbz	r2, .L11
2324:Lib/FreeRTOS/Source/queue.c **** 
 241              		.loc 1 2324 9 is_stmt 1 view .LVU78
2324:Lib/FreeRTOS/Source/queue.c **** 
 242              		.loc 1 2324 38 is_stmt 0 view .LVU79
 243 000a DC68     		ldr	r4, [r3, #12]
2326:Lib/FreeRTOS/Source/queue.c ****         {
 244              		.loc 1 2326 11 view .LVU80
 245 000c 9968     		ldr	r1, [r3, #8]
 246              	.LVL23:
2324:Lib/FreeRTOS/Source/queue.c **** 
 247              		.loc 1 2324 38 view .LVU81
 248 000e 1444     		add	r4, r4, r2
ARM GAS  /tmp/ccTT1k9d.s 			page 50


2326:Lib/FreeRTOS/Source/queue.c ****         {
 249              		.loc 1 2326 11 view .LVU82
 250 0010 8C42     		cmp	r4, r1
2328:Lib/FreeRTOS/Source/queue.c ****         }
 251              		.loc 1 2328 42 view .LVU83
 252 0012 28BF     		it	cs
 253 0014 1968     		ldrcs	r1, [r3]
2324:Lib/FreeRTOS/Source/queue.c **** 
 254              		.loc 1 2324 38 view .LVU84
 255 0016 DC60     		str	r4, [r3, #12]
2326:Lib/FreeRTOS/Source/queue.c ****         {
 256              		.loc 1 2326 9 is_stmt 1 view .LVU85
2328:Lib/FreeRTOS/Source/queue.c ****         }
 257              		.loc 1 2328 13 view .LVU86
2328:Lib/FreeRTOS/Source/queue.c ****         }
 258              		.loc 1 2328 42 is_stmt 0 view .LVU87
 259 0018 28BF     		it	cs
 260 001a D960     		strcs	r1, [r3, #12]
2332:Lib/FreeRTOS/Source/queue.c ****         }
 261              		.loc 1 2332 37 is_stmt 1 view .LVU88
2335:Lib/FreeRTOS/Source/queue.c ****     }
 262              		.loc 1 2335 9 view .LVU89
2335:Lib/FreeRTOS/Source/queue.c ****     }
 263              		.loc 1 2335 18 is_stmt 0 view .LVU90
 264 001c D968     		ldr	r1, [r3, #12]
2337:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 265              		.loc 1 2337 1 view .LVU91
 266 001e 5DF8044B 		ldr	r4, [sp], #4
 267              		.cfi_remember_state
 268              		.cfi_restore 4
 269              		.cfi_def_cfa_offset 0
2335:Lib/FreeRTOS/Source/queue.c ****     }
 270              		.loc 1 2335 18 view .LVU92
 271 0022 FFF7FEBF 		b	memcpy
 272              	.LVL24:
 273              	.L11:
 274              		.cfi_restore_state
2337:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 275              		.loc 1 2337 1 view .LVU93
 276 0026 5DF8044B 		ldr	r4, [sp], #4
 277              		.cfi_restore 4
 278              		.cfi_def_cfa_offset 0
 279 002a 7047     		bx	lr
 280              		.cfi_endproc
 281              	.LFE30:
 283              		.section	.text.prvUnlockQueue,"ax",%progbits
 284              		.align	1
 285              		.syntax unified
 286              		.thumb
 287              		.thumb_func
 289              	prvUnlockQueue:
 290              	.LVL25:
 291              	.LFB31:
2341:Lib/FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 292              		.loc 1 2341 1 is_stmt 1 view -0
 293              		.cfi_startproc
 294              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccTT1k9d.s 			page 51


 295              		@ frame_needed = 0, uses_anonymous_args = 0
2348:Lib/FreeRTOS/Source/queue.c ****     {
 296              		.loc 1 2348 5 view .LVU95
2341:Lib/FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 297              		.loc 1 2341 1 is_stmt 0 view .LVU96
 298 0000 70B5     		push	{r4, r5, r6, lr}
 299              		.cfi_def_cfa_offset 16
 300              		.cfi_offset 4, -16
 301              		.cfi_offset 5, -12
 302              		.cfi_offset 6, -8
 303              		.cfi_offset 14, -4
2341:Lib/FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
 304              		.loc 1 2341 1 view .LVU97
 305 0002 0446     		mov	r4, r0
2348:Lib/FreeRTOS/Source/queue.c ****     {
 306              		.loc 1 2348 5 view .LVU98
 307 0004 FFF7FEFF 		bl	vPortEnterCritical
 308              	.LVL26:
 309              	.LBB2:
2350:Lib/FreeRTOS/Source/queue.c **** 
 310              		.loc 1 2350 9 is_stmt 1 view .LVU99
2350:Lib/FreeRTOS/Source/queue.c **** 
 311              		.loc 1 2350 16 is_stmt 0 view .LVU100
 312 0008 94F84550 		ldrb	r5, [r4, #69]	@ zero_extendqisi2
2403:Lib/FreeRTOS/Source/queue.c ****                     {
 313              		.loc 1 2403 51 view .LVU101
 314 000c 04F12406 		add	r6, r4, #36
2350:Lib/FreeRTOS/Source/queue.c **** 
 315              		.loc 1 2350 16 view .LVU102
 316 0010 6DB2     		sxtb	r5, r5
 317              	.LVL27:
2353:Lib/FreeRTOS/Source/queue.c ****         {
 318              		.loc 1 2353 9 is_stmt 1 view .LVU103
 319              	.L15:
2353:Lib/FreeRTOS/Source/queue.c ****         {
 320              		.loc 1 2353 24 view .LVU104
 321 0012 002D     		cmp	r5, #0
 322 0014 01DD     		ble	.L20
2401:Lib/FreeRTOS/Source/queue.c ****                 {
 323              		.loc 1 2401 17 view .LVU105
2401:Lib/FreeRTOS/Source/queue.c ****                 {
 324              		.loc 1 2401 21 is_stmt 0 view .LVU106
 325 0016 636A     		ldr	r3, [r4, #36]
2401:Lib/FreeRTOS/Source/queue.c ****                 {
 326              		.loc 1 2401 19 view .LVU107
 327 0018 B3B9     		cbnz	r3, .L16
 328              	.L20:
2424:Lib/FreeRTOS/Source/queue.c ****     }
 329              		.loc 1 2424 9 is_stmt 1 view .LVU108
2424:Lib/FreeRTOS/Source/queue.c ****     }
 330              		.loc 1 2424 26 is_stmt 0 view .LVU109
 331 001a FF23     		movs	r3, #255
 332 001c 84F84530 		strb	r3, [r4, #69]
 333              	.LBE2:
2426:Lib/FreeRTOS/Source/queue.c **** 
 334              		.loc 1 2426 5 is_stmt 1 view .LVU110
 335 0020 FFF7FEFF 		bl	vPortExitCritical
ARM GAS  /tmp/ccTT1k9d.s 			page 52


 336              	.LVL28:
2429:Lib/FreeRTOS/Source/queue.c ****     {
 337              		.loc 1 2429 5 view .LVU111
 338 0024 FFF7FEFF 		bl	vPortEnterCritical
 339              	.LVL29:
 340              	.LBB3:
2431:Lib/FreeRTOS/Source/queue.c **** 
 341              		.loc 1 2431 9 view .LVU112
2431:Lib/FreeRTOS/Source/queue.c **** 
 342              		.loc 1 2431 16 is_stmt 0 view .LVU113
 343 0028 94F84450 		ldrb	r5, [r4, #68]	@ zero_extendqisi2
 344              	.LVL30:
2437:Lib/FreeRTOS/Source/queue.c ****                 {
 345              		.loc 1 2437 47 view .LVU114
 346 002c 04F11006 		add	r6, r4, #16
2431:Lib/FreeRTOS/Source/queue.c **** 
 347              		.loc 1 2431 16 view .LVU115
 348 0030 6DB2     		sxtb	r5, r5
 349              	.LVL31:
2433:Lib/FreeRTOS/Source/queue.c ****         {
 350              		.loc 1 2433 9 is_stmt 1 view .LVU116
 351              	.L17:
2433:Lib/FreeRTOS/Source/queue.c ****         {
 352              		.loc 1 2433 24 view .LVU117
 353 0032 002D     		cmp	r5, #0
 354 0034 01DD     		ble	.L24
2435:Lib/FreeRTOS/Source/queue.c ****             {
 355              		.loc 1 2435 13 view .LVU118
2435:Lib/FreeRTOS/Source/queue.c ****             {
 356              		.loc 1 2435 17 is_stmt 0 view .LVU119
 357 0036 2369     		ldr	r3, [r4, #16]
2435:Lib/FreeRTOS/Source/queue.c ****             {
 358              		.loc 1 2435 15 view .LVU120
 359 0038 7BB9     		cbnz	r3, .L21
 360              	.L24:
2454:Lib/FreeRTOS/Source/queue.c ****     }
 361              		.loc 1 2454 9 is_stmt 1 view .LVU121
2454:Lib/FreeRTOS/Source/queue.c ****     }
 362              		.loc 1 2454 26 is_stmt 0 view .LVU122
 363 003a FF23     		movs	r3, #255
 364 003c 84F84430 		strb	r3, [r4, #68]
 365              	.LBE3:
2456:Lib/FreeRTOS/Source/queue.c **** }
 366              		.loc 1 2456 5 is_stmt 1 view .LVU123
2457:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 367              		.loc 1 2457 1 is_stmt 0 view .LVU124
 368 0040 BDE87040 		pop	{r4, r5, r6, lr}
 369              		.cfi_remember_state
 370              		.cfi_restore 14
 371              		.cfi_restore 6
 372              		.cfi_restore 5
 373              		.cfi_restore 4
 374              		.cfi_def_cfa_offset 0
 375              	.LVL32:
2456:Lib/FreeRTOS/Source/queue.c **** }
 376              		.loc 1 2456 5 view .LVU125
 377 0044 FFF7FEBF 		b	vPortExitCritical
ARM GAS  /tmp/ccTT1k9d.s 			page 53


 378              	.LVL33:
 379              	.L16:
 380              		.cfi_restore_state
 381              	.LBB4:
2403:Lib/FreeRTOS/Source/queue.c ****                     {
 382              		.loc 1 2403 21 is_stmt 1 view .LVU126
2403:Lib/FreeRTOS/Source/queue.c ****                     {
 383              		.loc 1 2403 25 is_stmt 0 view .LVU127
 384 0048 3046     		mov	r0, r6
 385 004a FFF7FEFF 		bl	xTaskRemoveFromEventList
 386              	.LVL34:
2403:Lib/FreeRTOS/Source/queue.c ****                     {
 387              		.loc 1 2403 23 discriminator 1 view .LVU128
 388 004e 08B1     		cbz	r0, .L18
2407:Lib/FreeRTOS/Source/queue.c ****                     }
 389              		.loc 1 2407 25 is_stmt 1 view .LVU129
 390 0050 FFF7FEFF 		bl	vTaskMissedYield
 391              	.LVL35:
 392              	.L18:
2411:Lib/FreeRTOS/Source/queue.c ****                     }
 393              		.loc 1 2411 49 view .LVU130
2421:Lib/FreeRTOS/Source/queue.c ****         }
 394              		.loc 1 2421 13 view .LVU131
 395 0054 013D     		subs	r5, r5, #1
 396              	.LVL36:
2421:Lib/FreeRTOS/Source/queue.c ****         }
 397              		.loc 1 2421 13 is_stmt 0 view .LVU132
 398 0056 6DB2     		sxtb	r5, r5
 399              	.LVL37:
2421:Lib/FreeRTOS/Source/queue.c ****         }
 400              		.loc 1 2421 13 view .LVU133
 401 0058 DBE7     		b	.L15
 402              	.LVL38:
 403              	.L21:
2421:Lib/FreeRTOS/Source/queue.c ****         }
 404              		.loc 1 2421 13 view .LVU134
 405              	.LBE4:
 406              	.LBB5:
2437:Lib/FreeRTOS/Source/queue.c ****                 {
 407              		.loc 1 2437 17 is_stmt 1 view .LVU135
2437:Lib/FreeRTOS/Source/queue.c ****                 {
 408              		.loc 1 2437 21 is_stmt 0 view .LVU136
 409 005a 3046     		mov	r0, r6
 410 005c FFF7FEFF 		bl	xTaskRemoveFromEventList
 411              	.LVL39:
2437:Lib/FreeRTOS/Source/queue.c ****                 {
 412              		.loc 1 2437 19 discriminator 1 view .LVU137
 413 0060 08B1     		cbz	r0, .L22
2439:Lib/FreeRTOS/Source/queue.c ****                 }
 414              		.loc 1 2439 21 is_stmt 1 view .LVU138
 415 0062 FFF7FEFF 		bl	vTaskMissedYield
 416              	.LVL40:
 417              	.L22:
2443:Lib/FreeRTOS/Source/queue.c ****                 }
 418              		.loc 1 2443 45 view .LVU139
2446:Lib/FreeRTOS/Source/queue.c ****             }
 419              		.loc 1 2446 17 view .LVU140
ARM GAS  /tmp/ccTT1k9d.s 			page 54


 420 0066 013D     		subs	r5, r5, #1
 421              	.LVL41:
2446:Lib/FreeRTOS/Source/queue.c ****             }
 422              		.loc 1 2446 17 is_stmt 0 view .LVU141
 423 0068 6DB2     		sxtb	r5, r5
 424              	.LVL42:
2446:Lib/FreeRTOS/Source/queue.c ****             }
 425              		.loc 1 2446 17 view .LVU142
 426 006a E2E7     		b	.L17
 427              	.LBE5:
 428              		.cfi_endproc
 429              	.LFE31:
 431              		.section	.rodata.xQueueGenericReset.str1.1,"aMS",%progbits,1
 432              	.LC0:
 433 0000 3000     		.ascii	"0\000"
 434              	.LC1:
 435 0002 4C69622F 		.ascii	"Lib/FreeRTOS/Source/queue.c\000"
 435      46726565 
 435      52544F53 
 435      2F536F75 
 435      7263652F 
 436              		.section	.text.xQueueGenericReset,"ax",%progbits
 437              		.align	1
 438              		.global	xQueueGenericReset
 439              		.syntax unified
 440              		.thumb
 441              		.thumb_func
 443              	xQueueGenericReset:
 444              	.LVL43:
 445              	.LFB0:
 298:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdPASS;
 446              		.loc 1 298 1 is_stmt 1 view -0
 447              		.cfi_startproc
 448              		@ args = 0, pretend = 0, frame = 0
 449              		@ frame_needed = 0, uses_anonymous_args = 0
 299:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 450              		.loc 1 299 5 view .LVU144
 300:Lib/FreeRTOS/Source/queue.c **** 
 451              		.loc 1 300 5 view .LVU145
 302:Lib/FreeRTOS/Source/queue.c **** 
 452              		.loc 1 302 5 view .LVU146
 298:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdPASS;
 453              		.loc 1 298 1 is_stmt 0 view .LVU147
 454 0000 70B5     		push	{r4, r5, r6, lr}
 455              		.cfi_def_cfa_offset 16
 456              		.cfi_offset 4, -16
 457              		.cfi_offset 5, -12
 458              		.cfi_offset 6, -8
 459              		.cfi_offset 14, -4
 298:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdPASS;
 460              		.loc 1 298 1 view .LVU148
 461 0002 0E46     		mov	r6, r1
 302:Lib/FreeRTOS/Source/queue.c **** 
 462              		.loc 1 302 5 view .LVU149
 463 0004 0446     		mov	r4, r0
 464 0006 40B9     		cbnz	r0, .L32
 302:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 55


 465              		.loc 1 302 5 is_stmt 1 discriminator 1 view .LVU150
 466 0008 FFF7FEFF 		bl	ulSetInterruptMask
 467              	.LVL44:
 302:Lib/FreeRTOS/Source/queue.c **** 
 468              		.loc 1 302 5 discriminator 1 view .LVU151
 469 000c 4FF49771 		mov	r1, #302
 470 0010 1D4B     		ldr	r3, .L49
 471 0012 1E4A     		ldr	r2, .L49+4
 472              	.LVL45:
 473              	.L48:
 355:Lib/FreeRTOS/Source/queue.c **** 
 474              		.loc 1 355 5 is_stmt 0 discriminator 1 view .LVU152
 475 0014 1E48     		ldr	r0, .L49+8
 476 0016 FFF7FEFF 		bl	__assert_func
 477              	.LVL46:
 478              	.L32:
 302:Lib/FreeRTOS/Source/queue.c **** 
 479              		.loc 1 302 28 is_stmt 1 discriminator 2 view .LVU153
 304:Lib/FreeRTOS/Source/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 480              		.loc 1 304 5 view .LVU154
 305:Lib/FreeRTOS/Source/queue.c ****         /* Check for multiplication overflow. */
 481              		.loc 1 305 18 is_stmt 0 view .LVU155
 482 001a C56B     		ldr	r5, [r0, #60]
 304:Lib/FreeRTOS/Source/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
 483              		.loc 1 304 29 discriminator 1 view .LVU156
 484 001c 65B3     		cbz	r5, .L33
 307:Lib/FreeRTOS/Source/queue.c ****     {
 485              		.loc 1 307 44 view .LVU157
 486 001e 036C     		ldr	r3, [r0, #64]
 487 0020 A3FB0535 		umull	r3, r5, r3, r5
 488 0024 45BB     		cbnz	r5, .L33
 309:Lib/FreeRTOS/Source/queue.c ****         {
 489              		.loc 1 309 9 is_stmt 1 view .LVU158
 490 0026 FFF7FEFF 		bl	vPortEnterCritical
 491              	.LVL47:
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 492              		.loc 1 311 13 view .LVU159
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 493              		.loc 1 311 78 is_stmt 0 view .LVU160
 494 002a D4E90F31 		ldrd	r3, r1, [r4, #60]
 495 002e 4B43     		muls	r3, r1, r3
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 496              		.loc 1 311 47 view .LVU161
 497 0030 2268     		ldr	r2, [r4]
 312:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 498              		.loc 1 312 40 view .LVU162
 499 0032 A563     		str	r5, [r4, #56]
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 500              		.loc 1 311 56 view .LVU163
 501 0034 D018     		adds	r0, r2, r3
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 502              		.loc 1 314 60 view .LVU164
 503 0036 5B1A     		subs	r3, r3, r1
 313:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 504              		.loc 1 313 32 view .LVU165
 505 0038 6260     		str	r2, [r4, #4]
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
ARM GAS  /tmp/ccTT1k9d.s 			page 56


 506              		.loc 1 314 60 view .LVU166
 507 003a 1A44     		add	r2, r2, r3
 315:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 508              		.loc 1 315 30 view .LVU167
 509 003c FF23     		movs	r3, #255
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 510              		.loc 1 311 38 view .LVU168
 511 003e A060     		str	r0, [r4, #8]
 312:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 512              		.loc 1 312 13 is_stmt 1 view .LVU169
 313:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
 513              		.loc 1 313 13 view .LVU170
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 514              		.loc 1 314 13 view .LVU171
 315:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 515              		.loc 1 315 30 is_stmt 0 view .LVU172
 516 0040 84F84430 		strb	r3, [r4, #68]
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 517              		.loc 1 314 42 view .LVU173
 518 0044 E260     		str	r2, [r4, #12]
 315:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 519              		.loc 1 315 13 is_stmt 1 view .LVU174
 316:Lib/FreeRTOS/Source/queue.c **** 
 520              		.loc 1 316 13 view .LVU175
 316:Lib/FreeRTOS/Source/queue.c **** 
 521              		.loc 1 316 30 is_stmt 0 view .LVU176
 522 0046 84F84530 		strb	r3, [r4, #69]
 318:Lib/FreeRTOS/Source/queue.c ****             {
 523              		.loc 1 318 13 is_stmt 1 view .LVU177
 318:Lib/FreeRTOS/Source/queue.c ****             {
 524              		.loc 1 318 15 is_stmt 0 view .LVU178
 525 004a 66B9     		cbnz	r6, .L36
 325:Lib/FreeRTOS/Source/queue.c ****                 {
 526              		.loc 1 325 17 is_stmt 1 view .LVU179
 325:Lib/FreeRTOS/Source/queue.c ****                 {
 527              		.loc 1 325 21 is_stmt 0 view .LVU180
 528 004c 2369     		ldr	r3, [r4, #16]
 325:Lib/FreeRTOS/Source/queue.c ****                 {
 529              		.loc 1 325 19 view .LVU181
 530 004e 33B1     		cbz	r3, .L38
 327:Lib/FreeRTOS/Source/queue.c ****                     {
 531              		.loc 1 327 21 is_stmt 1 view .LVU182
 327:Lib/FreeRTOS/Source/queue.c ****                     {
 532              		.loc 1 327 25 is_stmt 0 view .LVU183
 533 0050 04F11000 		add	r0, r4, #16
 534 0054 FFF7FEFF 		bl	xTaskRemoveFromEventList
 535              	.LVL48:
 327:Lib/FreeRTOS/Source/queue.c ****                     {
 536              		.loc 1 327 23 discriminator 1 view .LVU184
 537 0058 08B1     		cbz	r0, .L38
 329:Lib/FreeRTOS/Source/queue.c ****                     }
 538              		.loc 1 329 25 is_stmt 1 view .LVU185
 539 005a FFF7FEFF 		bl	vPortYield
 540              	.LVL49:
 541              	.L38:
 348:Lib/FreeRTOS/Source/queue.c ****     }
 542              		.loc 1 348 9 view .LVU186
ARM GAS  /tmp/ccTT1k9d.s 			page 57


 543 005e FFF7FEFF 		bl	vPortExitCritical
 544              	.LVL50:
 355:Lib/FreeRTOS/Source/queue.c **** 
 545              		.loc 1 355 5 view .LVU187
 355:Lib/FreeRTOS/Source/queue.c **** 
 546              		.loc 1 355 38 discriminator 2 view .LVU188
 359:Lib/FreeRTOS/Source/queue.c **** }
 547              		.loc 1 359 5 view .LVU189
 360:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 548              		.loc 1 360 1 is_stmt 0 view .LVU190
 549 0062 0120     		movs	r0, #1
 550 0064 70BD     		pop	{r4, r5, r6, pc}
 551              	.LVL51:
 552              	.L36:
 344:Lib/FreeRTOS/Source/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 553              		.loc 1 344 17 is_stmt 1 view .LVU191
 554 0066 04F11000 		add	r0, r4, #16
 555 006a FFF7FEFF 		bl	vListInitialise
 556              	.LVL52:
 345:Lib/FreeRTOS/Source/queue.c ****             }
 557              		.loc 1 345 17 view .LVU192
 558 006e 04F12400 		add	r0, r4, #36
 559 0072 FFF7FEFF 		bl	vListInitialise
 560              	.LVL53:
 561 0076 F2E7     		b	.L38
 562              	.LVL54:
 563              	.L33:
 355:Lib/FreeRTOS/Source/queue.c **** 
 564              		.loc 1 355 5 discriminator 1 view .LVU193
 565 0078 FFF7FEFF 		bl	ulSetInterruptMask
 566              	.LVL55:
 355:Lib/FreeRTOS/Source/queue.c **** 
 567              		.loc 1 355 5 discriminator 1 view .LVU194
 568 007c 40F26311 		movw	r1, #355
 569 0080 014B     		ldr	r3, .L49
 570 0082 024A     		ldr	r2, .L49+4
 571 0084 C6E7     		b	.L48
 572              	.L50:
 573 0086 00BF     		.align	2
 574              	.L49:
 575 0088 00000000 		.word	.LC0
 576 008c 00000000 		.word	__func__.24
 577 0090 02000000 		.word	.LC1
 578              		.cfi_endproc
 579              	.LFE0:
 581              		.section	.text.xQueueGenericCreateStatic,"ax",%progbits
 582              		.align	1
 583              		.global	xQueueGenericCreateStatic
 584              		.syntax unified
 585              		.thumb
 586              		.thumb_func
 588              	xQueueGenericCreateStatic:
 589              	.LVL56:
 590              	.LFB1:
 370:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
 591              		.loc 1 370 5 view -0
 592              		.cfi_startproc
ARM GAS  /tmp/ccTT1k9d.s 			page 58


 593              		@ args = 4, pretend = 0, frame = 8
 594              		@ frame_needed = 0, uses_anonymous_args = 0
 371:Lib/FreeRTOS/Source/queue.c **** 
 595              		.loc 1 371 9 view .LVU196
 375:Lib/FreeRTOS/Source/queue.c **** 
 596              		.loc 1 375 9 view .LVU197
 370:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
 597              		.loc 1 370 5 is_stmt 0 view .LVU198
 598 0000 13B5     		push	{r0, r1, r4, lr}
 599              		.cfi_def_cfa_offset 16
 600              		.cfi_offset 4, -8
 601              		.cfi_offset 14, -4
 375:Lib/FreeRTOS/Source/queue.c **** 
 602              		.loc 1 375 9 view .LVU199
 603 0002 1C46     		mov	r4, r3
 604 0004 43B9     		cbnz	r3, .L52
 375:Lib/FreeRTOS/Source/queue.c **** 
 605              		.loc 1 375 9 is_stmt 1 discriminator 1 view .LVU200
 606 0006 FFF7FEFF 		bl	ulSetInterruptMask
 607              	.LVL57:
 375:Lib/FreeRTOS/Source/queue.c **** 
 608              		.loc 1 375 9 discriminator 1 view .LVU201
 609 000a 40F27711 		movw	r1, #375
 610 000e 174B     		ldr	r3, .L63
 611 0010 174A     		ldr	r2, .L63+4
 612              	.L62:
 613              	.LBB9:
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 614              		.loc 1 393 17 is_stmt 0 discriminator 1 view .LVU202
 615 0012 1848     		ldr	r0, .L63+8
 616 0014 FFF7FEFF 		bl	__assert_func
 617              	.LVL58:
 618              	.L52:
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 619              		.loc 1 393 17 discriminator 1 view .LVU203
 620              	.LBE9:
 375:Lib/FreeRTOS/Source/queue.c **** 
 621              		.loc 1 375 38 is_stmt 1 discriminator 2 view .LVU204
 377:Lib/FreeRTOS/Source/queue.c ****             ( pxStaticQueue != NULL ) &&
 622              		.loc 1 377 9 view .LVU205
 377:Lib/FreeRTOS/Source/queue.c ****             ( pxStaticQueue != NULL ) &&
 623              		.loc 1 377 11 is_stmt 0 view .LVU206
 624 0018 08B1     		cbz	r0, .L53
 378:Lib/FreeRTOS/Source/queue.c **** 
 625              		.loc 1 378 39 view .LVU207
 626 001a 3AB1     		cbz	r2, .L54
 382:Lib/FreeRTOS/Source/queue.c ****             ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
 627              		.loc 1 382 15 view .LVU208
 628 001c 41B9     		cbnz	r1, .L55
 629              	.L53:
 416:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 630              		.loc 1 416 13 is_stmt 1 view .LVU209
 416:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 631              		.loc 1 416 13 discriminator 1 view .LVU210
 632 001e FFF7FEFF 		bl	ulSetInterruptMask
 633              	.LVL59:
 416:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccTT1k9d.s 			page 59


 634              		.loc 1 416 13 discriminator 1 view .LVU211
 635 0022 4FF4D071 		mov	r1, #416
 636 0026 114B     		ldr	r3, .L63
 637 0028 114A     		ldr	r2, .L63+4
 638 002a F2E7     		b	.L62
 639              	.LVL60:
 640              	.L54:
 383:Lib/FreeRTOS/Source/queue.c ****         {
 641              		.loc 1 383 15 is_stmt 0 view .LVU212
 642 002c 0029     		cmp	r1, #0
 643 002e F6D1     		bne	.L53
 644              	.L55:
 645              	.LBB10:
 390:Lib/FreeRTOS/Source/queue.c **** 
 646              		.loc 1 390 17 is_stmt 1 view .LVU213
 390:Lib/FreeRTOS/Source/queue.c **** 
 647              		.loc 1 390 33 is_stmt 0 view .LVU214
 648 0030 5023     		movs	r3, #80
 649              	.LVL61:
 390:Lib/FreeRTOS/Source/queue.c **** 
 650              		.loc 1 390 33 view .LVU215
 651 0032 0193     		str	r3, [sp, #4]
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 652              		.loc 1 393 17 is_stmt 1 view .LVU216
 653 0034 019B     		ldr	r3, [sp, #4]
 654 0036 502B     		cmp	r3, #80
 655 0038 06D0     		beq	.L56
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 656              		.loc 1 393 17 discriminator 1 view .LVU217
 657 003a FFF7FEFF 		bl	ulSetInterruptMask
 658              	.LVL62:
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 659              		.loc 1 393 17 discriminator 1 view .LVU218
 660 003e 40F28911 		movw	r1, #393
 661 0042 0A4B     		ldr	r3, .L63
 662 0044 0A4A     		ldr	r2, .L63+4
 663 0046 E4E7     		b	.L62
 664              	.LVL63:
 665              	.L56:
 393:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 666              		.loc 1 393 59 discriminator 2 view .LVU219
 394:Lib/FreeRTOS/Source/queue.c ****             }
 667              		.loc 1 394 17 view .LVU220
 668              	.LBE10:
 669              	.LBB11:
 670              	.LBB12:
 559:Lib/FreeRTOS/Source/queue.c ****     }
 671              		.loc 1 559 28 is_stmt 0 view .LVU221
 672 0048 0029     		cmp	r1, #0
 673 004a 08BF     		it	eq
 674 004c 2246     		moveq	r2, r4
 675              	.LVL64:
 570:Lib/FreeRTOS/Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 676              		.loc 1 570 28 view .LVU222
 677 004e C4E90F01 		strd	r0, r1, [r4, #60]
 678 0052 2260     		str	r2, [r4]
 571:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 60


 679              		.loc 1 571 14 view .LVU223
 680 0054 0121     		movs	r1, #1
 681              	.LVL65:
 571:Lib/FreeRTOS/Source/queue.c **** 
 682              		.loc 1 571 14 view .LVU224
 683 0056 2046     		mov	r0, r4
 684              	.LVL66:
 571:Lib/FreeRTOS/Source/queue.c **** 
 685              		.loc 1 571 14 view .LVU225
 686              	.LBE12:
 687              	.LBE11:
 688              	.LBB15:
 394:Lib/FreeRTOS/Source/queue.c ****             }
 689              		.loc 1 394 17 view .LVU226
 690 0058 019B     		ldr	r3, [sp, #4]
 691              	.LBE15:
 401:Lib/FreeRTOS/Source/queue.c **** 
 692              		.loc 1 401 13 is_stmt 1 view .LVU227
 693              	.LVL67:
 412:Lib/FreeRTOS/Source/queue.c ****         }
 694              		.loc 1 412 13 view .LVU228
 695              	.LBB16:
 696              	.LBI11:
 543:Lib/FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 697              		.loc 1 543 13 view .LVU229
 698              	.LBB13:
 551:Lib/FreeRTOS/Source/queue.c **** 
 699              		.loc 1 551 5 view .LVU230
 553:Lib/FreeRTOS/Source/queue.c ****     {
 700              		.loc 1 553 5 view .LVU231
 569:Lib/FreeRTOS/Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 701              		.loc 1 569 5 view .LVU232
 571:Lib/FreeRTOS/Source/queue.c **** 
 702              		.loc 1 571 5 view .LVU233
 571:Lib/FreeRTOS/Source/queue.c **** 
 703              		.loc 1 571 14 is_stmt 0 view .LVU234
 704 005a FFF7FEFF 		bl	xQueueGenericReset
 705              	.LVL68:
 575:Lib/FreeRTOS/Source/queue.c ****     }
 706              		.loc 1 575 9 is_stmt 1 view .LVU235
 707              	.LBE13:
 708              	.LBE16:
 421:Lib/FreeRTOS/Source/queue.c **** 
 709              		.loc 1 421 5 is_stmt 0 view .LVU236
 710 005e 2046     		mov	r0, r4
 711              	.LBB17:
 712              	.LBB14:
 575:Lib/FreeRTOS/Source/queue.c ****     }
 713              		.loc 1 575 33 view .LVU237
 714 0060 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 715 0064 84F84C30 		strb	r3, [r4, #76]
 585:Lib/FreeRTOS/Source/queue.c **** }
 716              		.loc 1 585 36 is_stmt 1 view .LVU238
 717              	.LVL69:
 585:Lib/FreeRTOS/Source/queue.c **** }
 718              		.loc 1 585 36 is_stmt 0 view .LVU239
 719              	.LBE14:
ARM GAS  /tmp/ccTT1k9d.s 			page 61


 720              	.LBE17:
 416:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 721              		.loc 1 416 39 is_stmt 1 discriminator 2 view .LVU240
 417:Lib/FreeRTOS/Source/queue.c ****         }
 722              		.loc 1 417 37 view .LVU241
 420:Lib/FreeRTOS/Source/queue.c ****     }
 723              		.loc 1 420 9 view .LVU242
 421:Lib/FreeRTOS/Source/queue.c **** 
 724              		.loc 1 421 5 is_stmt 0 view .LVU243
 725 0068 02B0     		add	sp, sp, #8
 726              		.cfi_def_cfa_offset 8
 727              		@ sp needed
 728 006a 10BD     		pop	{r4, pc}
 729              	.LVL70:
 730              	.L64:
 421:Lib/FreeRTOS/Source/queue.c **** 
 731              		.loc 1 421 5 view .LVU244
 732              		.align	2
 733              	.L63:
 734 006c 00000000 		.word	.LC0
 735 0070 00000000 		.word	__func__.23
 736 0074 02000000 		.word	.LC1
 737              		.cfi_endproc
 738              	.LFE1:
 740              		.section	.text.xQueueGenericGetStaticBuffers,"ax",%progbits
 741              		.align	1
 742              		.global	xQueueGenericGetStaticBuffers
 743              		.syntax unified
 744              		.thumb
 745              		.thumb_func
 747              	xQueueGenericGetStaticBuffers:
 748              	.LVL71:
 749              	.LFB2:
 431:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 750              		.loc 1 431 5 is_stmt 1 view -0
 751              		.cfi_startproc
 752              		@ args = 0, pretend = 0, frame = 0
 753              		@ frame_needed = 0, uses_anonymous_args = 0
 432:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 754              		.loc 1 432 9 view .LVU246
 433:Lib/FreeRTOS/Source/queue.c **** 
 755              		.loc 1 433 9 view .LVU247
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 756              		.loc 1 435 9 view .LVU248
 431:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 757              		.loc 1 431 5 is_stmt 0 view .LVU249
 758 0000 08B5     		push	{r3, lr}
 759              		.cfi_def_cfa_offset 8
 760              		.cfi_offset 3, -8
 761              		.cfi_offset 14, -4
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 762              		.loc 1 435 9 view .LVU250
 763 0002 40B9     		cbnz	r0, .L66
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 764              		.loc 1 435 9 is_stmt 1 discriminator 1 view .LVU251
 765 0004 FFF7FEFF 		bl	ulSetInterruptMask
 766              	.LVL72:
ARM GAS  /tmp/ccTT1k9d.s 			page 62


 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 767              		.loc 1 435 9 discriminator 1 view .LVU252
 768 0008 40F2B311 		movw	r1, #435
 769 000c 094B     		ldr	r3, .L73
 770 000e 0A4A     		ldr	r2, .L73+4
 771              	.L72:
 436:Lib/FreeRTOS/Source/queue.c **** 
 772              		.loc 1 436 9 is_stmt 0 discriminator 1 view .LVU253
 773 0010 0A48     		ldr	r0, .L73+8
 774 0012 FFF7FEFF 		bl	__assert_func
 775              	.LVL73:
 776              	.L66:
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 777              		.loc 1 435 32 is_stmt 1 discriminator 2 view .LVU254
 436:Lib/FreeRTOS/Source/queue.c **** 
 778              		.loc 1 436 9 view .LVU255
 779 0016 32B9     		cbnz	r2, .L67
 436:Lib/FreeRTOS/Source/queue.c **** 
 780              		.loc 1 436 9 discriminator 1 view .LVU256
 781 0018 FFF7FEFF 		bl	ulSetInterruptMask
 782              	.LVL74:
 436:Lib/FreeRTOS/Source/queue.c **** 
 783              		.loc 1 436 9 discriminator 1 view .LVU257
 784 001c 4FF4DA71 		mov	r1, #436
 785 0020 044B     		ldr	r3, .L73
 786 0022 054A     		ldr	r2, .L73+4
 787 0024 F4E7     		b	.L72
 788              	.LVL75:
 789              	.L67:
 436:Lib/FreeRTOS/Source/queue.c **** 
 790              		.loc 1 436 39 discriminator 2 view .LVU258
 459:Lib/FreeRTOS/Source/queue.c ****             {
 791              		.loc 1 459 13 view .LVU259
 459:Lib/FreeRTOS/Source/queue.c ****             {
 792              		.loc 1 459 15 is_stmt 0 view .LVU260
 793 0026 09B1     		cbz	r1, .L68
 461:Lib/FreeRTOS/Source/queue.c ****             }
 794              		.loc 1 461 17 is_stmt 1 view .LVU261
 461:Lib/FreeRTOS/Source/queue.c ****             }
 795              		.loc 1 461 35 is_stmt 0 view .LVU262
 796 0028 0368     		ldr	r3, [r0]
 797 002a 0B60     		str	r3, [r1]
 798              	.L68:
 464:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 799              		.loc 1 464 13 is_stmt 1 view .LVU263
 464:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 800              		.loc 1 464 29 is_stmt 0 view .LVU264
 801 002c 1060     		str	r0, [r2]
 465:Lib/FreeRTOS/Source/queue.c ****         }
 802              		.loc 1 465 13 is_stmt 1 view .LVU265
 803              	.LVL76:
 469:Lib/FreeRTOS/Source/queue.c ****     }
 804              		.loc 1 469 9 view .LVU266
 470:Lib/FreeRTOS/Source/queue.c **** 
 805              		.loc 1 470 5 is_stmt 0 view .LVU267
 806 002e 0120     		movs	r0, #1
 807              	.LVL77:
ARM GAS  /tmp/ccTT1k9d.s 			page 63


 470:Lib/FreeRTOS/Source/queue.c **** 
 808              		.loc 1 470 5 view .LVU268
 809 0030 08BD     		pop	{r3, pc}
 810              	.L74:
 811 0032 00BF     		.align	2
 812              	.L73:
 813 0034 00000000 		.word	.LC0
 814 0038 00000000 		.word	__func__.22
 815 003c 02000000 		.word	.LC1
 816              		.cfi_endproc
 817              	.LFE2:
 819              		.section	.text.xQueueGetMutexHolder,"ax",%progbits
 820              		.align	1
 821              		.global	xQueueGetMutexHolder
 822              		.syntax unified
 823              		.thumb
 824              		.thumb_func
 826              	xQueueGetMutexHolder:
 827              	.LVL78:
 828              	.LFB6:
 659:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 829              		.loc 1 659 5 is_stmt 1 view -0
 830              		.cfi_startproc
 831              		@ args = 0, pretend = 0, frame = 0
 832              		@ frame_needed = 0, uses_anonymous_args = 0
 660:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 833              		.loc 1 660 9 view .LVU270
 661:Lib/FreeRTOS/Source/queue.c **** 
 834              		.loc 1 661 9 view .LVU271
 663:Lib/FreeRTOS/Source/queue.c **** 
 835              		.loc 1 663 9 view .LVU272
 659:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 836              		.loc 1 659 5 is_stmt 0 view .LVU273
 837 0000 10B5     		push	{r4, lr}
 838              		.cfi_def_cfa_offset 8
 839              		.cfi_offset 4, -8
 840              		.cfi_offset 14, -4
 663:Lib/FreeRTOS/Source/queue.c **** 
 841              		.loc 1 663 9 view .LVU274
 842 0002 0446     		mov	r4, r0
 843 0004 40B9     		cbnz	r0, .L76
 663:Lib/FreeRTOS/Source/queue.c **** 
 844              		.loc 1 663 9 is_stmt 1 discriminator 1 view .LVU275
 845 0006 FFF7FEFF 		bl	ulSetInterruptMask
 846              	.LVL79:
 663:Lib/FreeRTOS/Source/queue.c **** 
 847              		.loc 1 663 9 discriminator 1 view .LVU276
 848 000a 40F29721 		movw	r1, #663
 849 000e 084B     		ldr	r3, .L79
 850 0010 084A     		ldr	r2, .L79+4
 851 0012 0948     		ldr	r0, .L79+8
 852 0014 FFF7FEFF 		bl	__assert_func
 853              	.LVL80:
 854              	.L76:
 663:Lib/FreeRTOS/Source/queue.c **** 
 855              		.loc 1 663 35 discriminator 2 view .LVU277
 670:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 64


 856              		.loc 1 670 9 view .LVU278
 857 0018 FFF7FEFF 		bl	vPortEnterCritical
 858              	.LVL81:
 672:Lib/FreeRTOS/Source/queue.c ****             {
 859              		.loc 1 672 13 view .LVU279
 672:Lib/FreeRTOS/Source/queue.c ****             {
 860              		.loc 1 672 15 is_stmt 0 view .LVU280
 861 001c 2368     		ldr	r3, [r4]
 862 001e 23B9     		cbnz	r3, .L78
 674:Lib/FreeRTOS/Source/queue.c ****             }
 863              		.loc 1 674 17 is_stmt 1 view .LVU281
 674:Lib/FreeRTOS/Source/queue.c ****             }
 864              		.loc 1 674 26 is_stmt 0 view .LVU282
 865 0020 A468     		ldr	r4, [r4, #8]
 866              	.LVL82:
 867              	.L77:
 681:Lib/FreeRTOS/Source/queue.c **** 
 868              		.loc 1 681 9 is_stmt 1 view .LVU283
 869 0022 FFF7FEFF 		bl	vPortExitCritical
 870              	.LVL83:
 683:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 871              		.loc 1 683 9 view .LVU284
 684:Lib/FreeRTOS/Source/queue.c **** 
 872              		.loc 1 684 5 is_stmt 0 view .LVU285
 873 0026 2046     		mov	r0, r4
 874 0028 10BD     		pop	{r4, pc}
 875              	.LVL84:
 876              	.L78:
 678:Lib/FreeRTOS/Source/queue.c ****             }
 877              		.loc 1 678 26 view .LVU286
 878 002a 0024     		movs	r4, #0
 879              	.LVL85:
 678:Lib/FreeRTOS/Source/queue.c ****             }
 880              		.loc 1 678 26 view .LVU287
 881 002c F9E7     		b	.L77
 882              	.L80:
 883 002e 00BF     		.align	2
 884              	.L79:
 885 0030 00000000 		.word	.LC0
 886 0034 00000000 		.word	__func__.21
 887 0038 02000000 		.word	.LC1
 888              		.cfi_endproc
 889              	.LFE6:
 891              		.section	.text.xQueueGetMutexHolderFromISR,"ax",%progbits
 892              		.align	1
 893              		.global	xQueueGetMutexHolderFromISR
 894              		.syntax unified
 895              		.thumb
 896              		.thumb_func
 898              	xQueueGetMutexHolderFromISR:
 899              	.LVL86:
 900              	.LFB7:
 692:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 901              		.loc 1 692 5 is_stmt 1 view -0
 902              		.cfi_startproc
 903              		@ args = 0, pretend = 0, frame = 0
 904              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccTT1k9d.s 			page 65


 693:Lib/FreeRTOS/Source/queue.c **** 
 905              		.loc 1 693 9 view .LVU289
 695:Lib/FreeRTOS/Source/queue.c **** 
 906              		.loc 1 695 9 view .LVU290
 692:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 907              		.loc 1 692 5 is_stmt 0 view .LVU291
 908 0000 08B5     		push	{r3, lr}
 909              		.cfi_def_cfa_offset 8
 910              		.cfi_offset 3, -8
 911              		.cfi_offset 14, -4
 695:Lib/FreeRTOS/Source/queue.c **** 
 912              		.loc 1 695 9 view .LVU292
 913 0002 40B9     		cbnz	r0, .L82
 695:Lib/FreeRTOS/Source/queue.c **** 
 914              		.loc 1 695 9 is_stmt 1 discriminator 1 view .LVU293
 915 0004 FFF7FEFF 		bl	ulSetInterruptMask
 916              	.LVL87:
 695:Lib/FreeRTOS/Source/queue.c **** 
 917              		.loc 1 695 9 discriminator 1 view .LVU294
 918 0008 40F2B721 		movw	r1, #695
 919 000c 054B     		ldr	r3, .L85
 920 000e 064A     		ldr	r2, .L85+4
 921 0010 0648     		ldr	r0, .L85+8
 922 0012 FFF7FEFF 		bl	__assert_func
 923              	.LVL88:
 924              	.L82:
 695:Lib/FreeRTOS/Source/queue.c **** 
 925              		.loc 1 695 35 discriminator 2 view .LVU295
 700:Lib/FreeRTOS/Source/queue.c ****         {
 926              		.loc 1 700 9 view .LVU296
 700:Lib/FreeRTOS/Source/queue.c ****         {
 927              		.loc 1 700 11 is_stmt 0 view .LVU297
 928 0016 0368     		ldr	r3, [r0]
 929 0018 0BB9     		cbnz	r3, .L84
 702:Lib/FreeRTOS/Source/queue.c ****         }
 930              		.loc 1 702 13 is_stmt 1 view .LVU298
 702:Lib/FreeRTOS/Source/queue.c ****         }
 931              		.loc 1 702 22 is_stmt 0 view .LVU299
 932 001a 8068     		ldr	r0, [r0, #8]
 933              	.LVL89:
 934              	.L81:
 710:Lib/FreeRTOS/Source/queue.c **** 
 935              		.loc 1 710 5 view .LVU300
 936 001c 08BD     		pop	{r3, pc}
 937              	.LVL90:
 938              	.L84:
 706:Lib/FreeRTOS/Source/queue.c ****         }
 939              		.loc 1 706 22 view .LVU301
 940 001e 0020     		movs	r0, #0
 941              	.LVL91:
 709:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 942              		.loc 1 709 9 is_stmt 1 view .LVU302
 709:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 943              		.loc 1 709 16 is_stmt 0 view .LVU303
 944 0020 FCE7     		b	.L81
 945              	.L86:
 946 0022 00BF     		.align	2
ARM GAS  /tmp/ccTT1k9d.s 			page 66


 947              	.L85:
 948 0024 00000000 		.word	.LC0
 949 0028 00000000 		.word	__func__.20
 950 002c 02000000 		.word	.LC1
 951              		.cfi_endproc
 952              	.LFE7:
 954              		.section	.text.xQueueCreateCountingSemaphoreStatic,"ax",%progbits
 955              		.align	1
 956              		.global	xQueueCreateCountingSemaphoreStatic
 957              		.syntax unified
 958              		.thumb
 959              		.thumb_func
 961              	xQueueCreateCountingSemaphoreStatic:
 962              	.LVL92:
 963              	.LFB10:
 818:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 964              		.loc 1 818 5 is_stmt 1 view -0
 965              		.cfi_startproc
 966              		@ args = 0, pretend = 0, frame = 0
 967              		@ frame_needed = 0, uses_anonymous_args = 0
 819:Lib/FreeRTOS/Source/queue.c **** 
 968              		.loc 1 819 9 view .LVU305
 821:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 969              		.loc 1 821 9 view .LVU306
 818:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 970              		.loc 1 818 5 is_stmt 0 view .LVU307
 971 0000 13B5     		push	{r0, r1, r4, lr}
 972              		.cfi_def_cfa_offset 16
 973              		.cfi_offset 4, -8
 974              		.cfi_offset 14, -4
 818:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 975              		.loc 1 818 5 view .LVU308
 976 0002 1346     		mov	r3, r2
 977 0004 0C46     		mov	r4, r1
 821:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 978              		.loc 1 821 11 view .LVU309
 979 0006 58B1     		cbz	r0, .L88
 821:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 980              		.loc 1 821 33 discriminator 1 view .LVU310
 981 0008 8842     		cmp	r0, r1
 982 000a 09D3     		bcc	.L88
 824:Lib/FreeRTOS/Source/queue.c **** 
 983              		.loc 1 824 13 is_stmt 1 view .LVU311
 824:Lib/FreeRTOS/Source/queue.c **** 
 984              		.loc 1 824 23 is_stmt 0 view .LVU312
 985 000c 0222     		movs	r2, #2
 986              	.LVL93:
 824:Lib/FreeRTOS/Source/queue.c **** 
 987              		.loc 1 824 23 view .LVU313
 988 000e 0092     		str	r2, [sp]
 989 0010 0022     		movs	r2, #0
 990 0012 1146     		mov	r1, r2
 991              	.LVL94:
 824:Lib/FreeRTOS/Source/queue.c **** 
 992              		.loc 1 824 23 view .LVU314
 993 0014 FFF7FEFF 		bl	xQueueGenericCreateStatic
 994              	.LVL95:
ARM GAS  /tmp/ccTT1k9d.s 			page 67


 826:Lib/FreeRTOS/Source/queue.c ****             {
 995              		.loc 1 826 13 is_stmt 1 view .LVU315
 826:Lib/FreeRTOS/Source/queue.c ****             {
 996              		.loc 1 826 15 is_stmt 0 view .LVU316
 997 0018 00B1     		cbz	r0, .L87
 828:Lib/FreeRTOS/Source/queue.c **** 
 998              		.loc 1 828 17 is_stmt 1 view .LVU317
 828:Lib/FreeRTOS/Source/queue.c **** 
 999              		.loc 1 828 62 is_stmt 0 view .LVU318
 1000 001a 8463     		str	r4, [r0, #56]
 830:Lib/FreeRTOS/Source/queue.c ****             }
 1001              		.loc 1 830 49 is_stmt 1 view .LVU319
 1002              	.L87:
 844:Lib/FreeRTOS/Source/queue.c **** 
 1003              		.loc 1 844 5 is_stmt 0 view .LVU320
 1004 001c 02B0     		add	sp, sp, #8
 1005              		.cfi_remember_state
 1006              		.cfi_def_cfa_offset 8
 1007              		@ sp needed
 1008 001e 10BD     		pop	{r4, pc}
 1009              	.LVL96:
 1010              	.L88:
 1011              		.cfi_restore_state
 839:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 1012              		.loc 1 839 13 is_stmt 1 view .LVU321
 839:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 1013              		.loc 1 839 13 discriminator 1 view .LVU322
 1014 0020 FFF7FEFF 		bl	ulSetInterruptMask
 1015              	.LVL97:
 839:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 1016              		.loc 1 839 13 discriminator 1 view .LVU323
 1017 0024 40F24731 		movw	r1, #839
 1018 0028 024B     		ldr	r3, .L96
 1019 002a 034A     		ldr	r2, .L96+4
 1020 002c 0348     		ldr	r0, .L96+8
 1021 002e FFF7FEFF 		bl	__assert_func
 1022              	.LVL98:
 1023              	.L97:
 1024 0032 00BF     		.align	2
 1025              	.L96:
 1026 0034 00000000 		.word	.LC0
 1027 0038 00000000 		.word	__func__.17
 1028 003c 02000000 		.word	.LC1
 1029              		.cfi_endproc
 1030              	.LFE10:
 1032              		.section	.text.xQueueGenericSend,"ax",%progbits
 1033              		.align	1
 1034              		.global	xQueueGenericSend
 1035              		.syntax unified
 1036              		.thumb
 1037              		.thumb_func
 1039              	xQueueGenericSend:
 1040              	.LVL99:
 1041              	.LFB11:
 888:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1042              		.loc 1 888 1 view -0
 1043              		.cfi_startproc
ARM GAS  /tmp/ccTT1k9d.s 			page 68


 1044              		@ args = 0, pretend = 0, frame = 16
 1045              		@ frame_needed = 0, uses_anonymous_args = 0
 889:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 1046              		.loc 1 889 5 view .LVU325
 890:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1047              		.loc 1 890 5 view .LVU326
 891:Lib/FreeRTOS/Source/queue.c **** 
 1048              		.loc 1 891 5 view .LVU327
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1049              		.loc 1 893 5 view .LVU328
 888:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1050              		.loc 1 888 1 is_stmt 0 view .LVU329
 1051 0000 2DE9FF41 		push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 1052              		.cfi_def_cfa_offset 40
 1053              		.cfi_offset 4, -24
 1054              		.cfi_offset 5, -20
 1055              		.cfi_offset 6, -16
 1056              		.cfi_offset 7, -12
 1057              		.cfi_offset 8, -8
 1058              		.cfi_offset 14, -4
 888:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1059              		.loc 1 888 1 view .LVU330
 1060 0004 0F46     		mov	r7, r1
 1061 0006 1E46     		mov	r6, r3
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1062              		.loc 1 893 5 view .LVU331
 1063 0008 0446     		mov	r4, r0
 888:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1064              		.loc 1 888 1 view .LVU332
 1065 000a 0192     		str	r2, [sp, #4]
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1066              		.loc 1 893 5 view .LVU333
 1067 000c 40B9     		cbnz	r0, .L99
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1068              		.loc 1 893 5 is_stmt 1 discriminator 1 view .LVU334
 1069 000e FFF7FEFF 		bl	ulSetInterruptMask
 1070              	.LVL100:
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1071              		.loc 1 893 5 discriminator 1 view .LVU335
 1072 0012 40F27D31 		movw	r1, #893
 1073 0016 484B     		ldr	r3, .L139
 1074 0018 484A     		ldr	r2, .L139+4
 1075              	.L138:
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1076              		.loc 1 894 5 is_stmt 0 discriminator 1 view .LVU336
 1077 001a 4948     		ldr	r0, .L139+8
 1078 001c FFF7FEFF 		bl	__assert_func
 1079              	.LVL101:
 1080              	.L99:
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1081              		.loc 1 893 28 is_stmt 1 discriminator 2 view .LVU337
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1082              		.loc 1 894 5 view .LVU338
 1083 0020 41B9     		cbnz	r1, .L100
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1084              		.loc 1 894 5 is_stmt 0 discriminator 2 view .LVU339
 1085 0022 036C     		ldr	r3, [r0, #64]
ARM GAS  /tmp/ccTT1k9d.s 			page 69


 1086              	.LVL102:
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1087              		.loc 1 894 5 discriminator 2 view .LVU340
 1088 0024 33B1     		cbz	r3, .L100
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1089              		.loc 1 894 5 is_stmt 1 discriminator 7 view .LVU341
 1090 0026 FFF7FEFF 		bl	ulSetInterruptMask
 1091              	.LVL103:
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1092              		.loc 1 894 5 discriminator 1 view .LVU342
 1093 002a 40F27E31 		movw	r1, #894
 1094 002e 424B     		ldr	r3, .L139
 1095 0030 424A     		ldr	r2, .L139+4
 1096 0032 F2E7     		b	.L138
 1097              	.LVL104:
 1098              	.L100:
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1099              		.loc 1 894 100 discriminator 8 view .LVU343
 895:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1100              		.loc 1 895 5 view .LVU344
 1101 0034 022E     		cmp	r6, #2
 1102 0036 09D1     		bne	.L101
 895:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1103              		.loc 1 895 5 is_stmt 0 discriminator 2 view .LVU345
 1104 0038 E36B     		ldr	r3, [r4, #60]
 1105 003a 012B     		cmp	r3, #1
 1106 003c 06D0     		beq	.L101
 895:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1107              		.loc 1 895 5 is_stmt 1 discriminator 7 view .LVU346
 1108 003e FFF7FEFF 		bl	ulSetInterruptMask
 1109              	.LVL105:
 895:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1110              		.loc 1 895 5 discriminator 1 view .LVU347
 1111 0042 40F27F31 		movw	r1, #895
 1112 0046 3C4B     		ldr	r3, .L139
 1113 0048 3C4A     		ldr	r2, .L139+4
 1114 004a E6E7     		b	.L138
 1115              	.LVL106:
 1116              	.L101:
 895:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 1117              		.loc 1 895 91 discriminator 8 view .LVU348
 898:Lib/FreeRTOS/Source/queue.c ****     }
 1118              		.loc 1 898 9 view .LVU349
 1119 004c FFF7FEFF 		bl	xTaskGetSchedulerState
 1120              	.LVL107:
 898:Lib/FreeRTOS/Source/queue.c ****     }
 1121              		.loc 1 898 9 is_stmt 0 discriminator 1 view .LVU350
 1122 0050 0546     		mov	r5, r0
 1123 0052 E0B1     		cbz	r0, .L102
 1124 0054 0025     		movs	r5, #0
 1125              	.L104:
1049:Lib/FreeRTOS/Source/queue.c **** 
 1126              		.loc 1 1049 9 discriminator 1 view .LVU351
 1127 0056 4FF00008 		mov	r8, #0
 1128              	.LVL108:
 1129              	.L103:
 898:Lib/FreeRTOS/Source/queue.c ****     }
ARM GAS  /tmp/ccTT1k9d.s 			page 70


 1130              		.loc 1 898 110 is_stmt 1 discriminator 8 view .LVU352
 905:Lib/FreeRTOS/Source/queue.c ****     {
 1131              		.loc 1 905 5 view .LVU353
 907:Lib/FreeRTOS/Source/queue.c ****         {
 1132              		.loc 1 907 9 view .LVU354
 1133 005a FFF7FEFF 		bl	vPortEnterCritical
 1134              	.LVL109:
 913:Lib/FreeRTOS/Source/queue.c ****             {
 1135              		.loc 1 913 13 view .LVU355
 913:Lib/FreeRTOS/Source/queue.c ****             {
 1136              		.loc 1 913 26 is_stmt 0 view .LVU356
 1137 005e A26B     		ldr	r2, [r4, #56]
 913:Lib/FreeRTOS/Source/queue.c ****             {
 1138              		.loc 1 913 15 view .LVU357
 1139 0060 E36B     		ldr	r3, [r4, #60]
 1140 0062 9A42     		cmp	r2, r3
 1141 0064 1DD2     		bcs	.L105
 1142              	.L108:
 915:Lib/FreeRTOS/Source/queue.c **** 
 1143              		.loc 1 915 43 is_stmt 1 view .LVU358
 979:Lib/FreeRTOS/Source/queue.c **** 
 1144              		.loc 1 979 21 view .LVU359
 979:Lib/FreeRTOS/Source/queue.c **** 
 1145              		.loc 1 979 38 is_stmt 0 view .LVU360
 1146 0066 3246     		mov	r2, r6
 1147 0068 3946     		mov	r1, r7
 1148 006a 2046     		mov	r0, r4
 1149 006c FFF7FEFF 		bl	prvCopyDataToQueue
 1150              	.LVL110:
 983:Lib/FreeRTOS/Source/queue.c ****                     {
 1151              		.loc 1 983 21 is_stmt 1 view .LVU361
 983:Lib/FreeRTOS/Source/queue.c ****                     {
 1152              		.loc 1 983 25 is_stmt 0 view .LVU362
 1153 0070 636A     		ldr	r3, [r4, #36]
 983:Lib/FreeRTOS/Source/queue.c ****                     {
 1154              		.loc 1 983 23 view .LVU363
 1155 0072 1BB1     		cbz	r3, .L137
 985:Lib/FreeRTOS/Source/queue.c ****                         {
 1156              		.loc 1 985 25 is_stmt 1 view .LVU364
 985:Lib/FreeRTOS/Source/queue.c ****                         {
 1157              		.loc 1 985 29 is_stmt 0 view .LVU365
 1158 0074 04F12400 		add	r0, r4, #36
 1159              	.LVL111:
 985:Lib/FreeRTOS/Source/queue.c ****                         {
 1160              		.loc 1 985 29 view .LVU366
 1161 0078 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1162              	.LVL112:
 1163              	.L137:
 985:Lib/FreeRTOS/Source/queue.c ****                         {
 1164              		.loc 1 985 27 discriminator 1 view .LVU367
 1165 007c 08B1     		cbz	r0, .L111
 991:Lib/FreeRTOS/Source/queue.c ****                         }
 1166              		.loc 1 991 29 is_stmt 1 view .LVU368
 1167 007e FFF7FEFF 		bl	vPortYield
 1168              	.LVL113:
 1169              	.L111:
1008:Lib/FreeRTOS/Source/queue.c ****                     }
ARM GAS  /tmp/ccTT1k9d.s 			page 71


 1170              		.loc 1 1008 49 view .LVU369
1013:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 1171              		.loc 1 1013 17 view .LVU370
 1172 0082 FFF7FEFF 		bl	vPortExitCritical
 1173              	.LVL114:
1014:Lib/FreeRTOS/Source/queue.c ****             }
 1174              		.loc 1 1014 17 view .LVU371
1014:Lib/FreeRTOS/Source/queue.c ****             }
 1175              		.loc 1 1014 24 is_stmt 0 view .LVU372
 1176 0086 0120     		movs	r0, #1
 1177              	.LVL115:
 1178              	.L98:
1093:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1179              		.loc 1 1093 1 view .LVU373
 1180 0088 04B0     		add	sp, sp, #16
 1181              		.cfi_remember_state
 1182              		.cfi_def_cfa_offset 24
 1183              		@ sp needed
 1184 008a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1185              	.LVL116:
 1186              	.L102:
 1187              		.cfi_restore_state
 898:Lib/FreeRTOS/Source/queue.c ****     }
 1188              		.loc 1 898 9 discriminator 2 view .LVU374
 1189 008e 019B     		ldr	r3, [sp, #4]
 1190 0090 002B     		cmp	r3, #0
 1191 0092 E0D0     		beq	.L104
 898:Lib/FreeRTOS/Source/queue.c ****     }
 1192              		.loc 1 898 9 is_stmt 1 discriminator 7 view .LVU375
 1193 0094 FFF7FEFF 		bl	ulSetInterruptMask
 1194              	.LVL117:
 898:Lib/FreeRTOS/Source/queue.c ****     }
 1195              		.loc 1 898 9 discriminator 1 view .LVU376
 1196 0098 40F28231 		movw	r1, #898
 1197 009c 264B     		ldr	r3, .L139
 1198 009e 274A     		ldr	r2, .L139+4
 1199 00a0 BBE7     		b	.L138
 1200              	.LVL118:
 1201              	.L105:
 913:Lib/FreeRTOS/Source/queue.c ****             {
 1202              		.loc 1 913 68 is_stmt 0 discriminator 1 view .LVU377
 1203 00a2 022E     		cmp	r6, #2
 1204 00a4 DFD0     		beq	.L108
1018:Lib/FreeRTOS/Source/queue.c ****                 {
 1205              		.loc 1 1018 17 is_stmt 1 view .LVU378
1018:Lib/FreeRTOS/Source/queue.c ****                 {
 1206              		.loc 1 1018 19 is_stmt 0 view .LVU379
 1207 00a6 019B     		ldr	r3, [sp, #4]
 1208 00a8 1BB9     		cbnz	r3, .L114
1022:Lib/FreeRTOS/Source/queue.c **** 
 1209              		.loc 1 1022 21 is_stmt 1 view .LVU380
 1210 00aa FFF7FEFF 		bl	vPortExitCritical
 1211              	.LVL119:
1026:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
 1212              		.loc 1 1026 54 view .LVU381
1027:Lib/FreeRTOS/Source/queue.c ****                 }
 1213              		.loc 1 1027 21 view .LVU382
ARM GAS  /tmp/ccTT1k9d.s 			page 72


 1214              	.L115:
1027:Lib/FreeRTOS/Source/queue.c ****                 }
 1215              		.loc 1 1027 28 is_stmt 0 view .LVU383
 1216 00ae 0020     		movs	r0, #0
 1217 00b0 EAE7     		b	.L98
 1218              	.LVL120:
 1219              	.L114:
1029:Lib/FreeRTOS/Source/queue.c ****                 {
 1220              		.loc 1 1029 22 is_stmt 1 view .LVU384
1029:Lib/FreeRTOS/Source/queue.c ****                 {
 1221              		.loc 1 1029 24 is_stmt 0 view .LVU385
 1222 00b2 15B9     		cbnz	r5, .L116
1033:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1223              		.loc 1 1033 21 is_stmt 1 view .LVU386
 1224 00b4 02A8     		add	r0, sp, #8
 1225 00b6 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 1226              	.LVL121:
1034:Lib/FreeRTOS/Source/queue.c ****                 }
 1227              		.loc 1 1034 21 view .LVU387
 1228              	.L116:
1039:Lib/FreeRTOS/Source/queue.c ****                 }
 1229              		.loc 1 1039 45 view .LVU388
1043:Lib/FreeRTOS/Source/queue.c **** 
 1230              		.loc 1 1043 9 view .LVU389
 1231 00ba FFF7FEFF 		bl	vPortExitCritical
 1232              	.LVL122:
1048:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 1233              		.loc 1 1048 9 view .LVU390
 1234 00be FFF7FEFF 		bl	vTaskSuspendAll
 1235              	.LVL123:
1049:Lib/FreeRTOS/Source/queue.c **** 
 1236              		.loc 1 1049 9 view .LVU391
 1237 00c2 FFF7FEFF 		bl	vPortEnterCritical
 1238              	.LVL124:
1049:Lib/FreeRTOS/Source/queue.c **** 
 1239              		.loc 1 1049 9 discriminator 1 view .LVU392
 1240 00c6 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 1241 00ca FF2B     		cmp	r3, #255
1049:Lib/FreeRTOS/Source/queue.c **** 
 1242              		.loc 1 1049 9 discriminator 1 view .LVU393
 1243 00cc 08BF     		it	eq
 1244 00ce 84F84480 		strbeq	r8, [r4, #68]
1049:Lib/FreeRTOS/Source/queue.c **** 
 1245              		.loc 1 1049 9 discriminator 3 view .LVU394
 1246 00d2 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 1247 00d6 FF2B     		cmp	r3, #255
1049:Lib/FreeRTOS/Source/queue.c **** 
 1248              		.loc 1 1049 9 discriminator 4 view .LVU395
 1249 00d8 08BF     		it	eq
 1250 00da 84F84580 		strbeq	r8, [r4, #69]
1049:Lib/FreeRTOS/Source/queue.c **** 
 1251              		.loc 1 1049 9 discriminator 6 view .LVU396
 1252 00de FFF7FEFF 		bl	vPortExitCritical
 1253              	.LVL125:
1052:Lib/FreeRTOS/Source/queue.c ****         {
 1254              		.loc 1 1052 9 view .LVU397
1052:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 73


 1255              		.loc 1 1052 13 is_stmt 0 view .LVU398
 1256 00e2 01A9     		add	r1, sp, #4
 1257 00e4 02A8     		add	r0, sp, #8
 1258 00e6 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1259              	.LVL126:
1052:Lib/FreeRTOS/Source/queue.c ****         {
 1260              		.loc 1 1052 11 discriminator 1 view .LVU399
 1261 00ea F0B9     		cbnz	r0, .L119
1054:Lib/FreeRTOS/Source/queue.c ****             {
 1262              		.loc 1 1054 13 is_stmt 1 view .LVU400
 1263              	.LVL127:
 1264              	.LBB20:
 1265              	.LBI20:
2479:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2480:Lib/FreeRTOS/Source/queue.c **** 
2481:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2482:Lib/FreeRTOS/Source/queue.c **** {
2483:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2484:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
2485:Lib/FreeRTOS/Source/queue.c **** 
2486:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
2487:Lib/FreeRTOS/Source/queue.c **** 
2488:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2489:Lib/FreeRTOS/Source/queue.c ****     {
2490:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
2491:Lib/FreeRTOS/Source/queue.c ****     }
2492:Lib/FreeRTOS/Source/queue.c ****     else
2493:Lib/FreeRTOS/Source/queue.c ****     {
2494:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
2495:Lib/FreeRTOS/Source/queue.c ****     }
2496:Lib/FreeRTOS/Source/queue.c **** 
2497:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
2498:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2499:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2500:Lib/FreeRTOS/Source/queue.c **** 
2501:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
 1266              		.loc 1 2501 19 view .LVU401
 1267              	.LBB21:
2502:Lib/FreeRTOS/Source/queue.c **** {
2503:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1268              		.loc 1 2503 5 view .LVU402
2504:Lib/FreeRTOS/Source/queue.c **** 
2505:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 1269              		.loc 1 2505 5 view .LVU403
 1270 00ec FFF7FEFF 		bl	vPortEnterCritical
 1271              	.LVL128:
2506:Lib/FreeRTOS/Source/queue.c ****     {
2507:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 1272              		.loc 1 2507 9 view .LVU404
 1273              		.loc 1 2507 20 is_stmt 0 view .LVU405
 1274 00f0 A26B     		ldr	r2, [r4, #56]
 1275              		.loc 1 2507 11 view .LVU406
 1276 00f2 E36B     		ldr	r3, [r4, #60]
 1277 00f4 9A42     		cmp	r2, r3
 1278 00f6 0FD1     		bne	.L120
 1279              	.LVL129:
2508:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 74


2509:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
2510:Lib/FreeRTOS/Source/queue.c ****         }
2511:Lib/FreeRTOS/Source/queue.c ****         else
2512:Lib/FreeRTOS/Source/queue.c ****         {
2513:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
2514:Lib/FreeRTOS/Source/queue.c ****         }
2515:Lib/FreeRTOS/Source/queue.c ****     }
2516:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 1280              		.loc 1 2516 5 is_stmt 1 view .LVU407
 1281 00f8 FFF7FEFF 		bl	vPortExitCritical
 1282              	.LVL130:
2517:Lib/FreeRTOS/Source/queue.c **** 
2518:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 1283              		.loc 1 2518 5 view .LVU408
 1284              		.loc 1 2518 5 is_stmt 0 view .LVU409
 1285              	.LBE21:
 1286              	.LBE20:
1056:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1287              		.loc 1 1056 55 is_stmt 1 view .LVU410
1057:Lib/FreeRTOS/Source/queue.c **** 
 1288              		.loc 1 1057 17 view .LVU411
 1289 00fc 0199     		ldr	r1, [sp, #4]
 1290 00fe 04F11000 		add	r0, r4, #16
 1291 0102 FFF7FEFF 		bl	vTaskPlaceOnEventList
 1292              	.LVL131:
1064:Lib/FreeRTOS/Source/queue.c **** 
 1293              		.loc 1 1064 17 view .LVU412
 1294 0106 2046     		mov	r0, r4
 1295 0108 FFF7FEFF 		bl	prvUnlockQueue
 1296              	.LVL132:
1071:Lib/FreeRTOS/Source/queue.c ****                 {
 1297              		.loc 1 1071 17 view .LVU413
1071:Lib/FreeRTOS/Source/queue.c ****                 {
 1298              		.loc 1 1071 21 is_stmt 0 view .LVU414
 1299 010c FFF7FEFF 		bl	xTaskResumeAll
 1300              	.LVL133:
1071:Lib/FreeRTOS/Source/queue.c ****                 {
 1301              		.loc 1 1071 19 discriminator 1 view .LVU415
 1302 0110 48B9     		cbnz	r0, .L122
1073:Lib/FreeRTOS/Source/queue.c ****                 }
 1303              		.loc 1 1073 21 is_stmt 1 view .LVU416
 1304 0112 FFF7FEFF 		bl	vPortYield
 1305              	.LVL134:
 1306 0116 06E0     		b	.L122
 1307              	.LVL135:
 1308              	.L120:
 1309              	.LBB23:
 1310              	.LBB22:
2513:Lib/FreeRTOS/Source/queue.c ****         }
 1311              		.loc 1 2513 13 view .LVU417
2516:Lib/FreeRTOS/Source/queue.c **** 
 1312              		.loc 1 2516 5 view .LVU418
 1313 0118 FFF7FEFF 		bl	vPortExitCritical
 1314              	.LVL136:
 1315              		.loc 1 2518 5 view .LVU419
 1316              		.loc 1 2518 5 is_stmt 0 view .LVU420
 1317              	.LBE22:
ARM GAS  /tmp/ccTT1k9d.s 			page 75


 1318              	.LBE23:
1079:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 1319              		.loc 1 1079 17 is_stmt 1 view .LVU421
 1320 011c 2046     		mov	r0, r4
 1321 011e FFF7FEFF 		bl	prvUnlockQueue
 1322              	.LVL137:
1080:Lib/FreeRTOS/Source/queue.c ****             }
 1323              		.loc 1 1080 17 view .LVU422
1080:Lib/FreeRTOS/Source/queue.c ****             }
 1324              		.loc 1 1080 26 is_stmt 0 view .LVU423
 1325 0122 FFF7FEFF 		bl	xTaskResumeAll
 1326              	.LVL138:
 1327              	.L122:
1080:Lib/FreeRTOS/Source/queue.c ****             }
 1328              		.loc 1 1080 26 view .LVU424
 1329 0126 0125     		movs	r5, #1
 1330 0128 97E7     		b	.L103
 1331              	.L119:
1086:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 1332              		.loc 1 1086 13 is_stmt 1 view .LVU425
 1333 012a 2046     		mov	r0, r4
 1334 012c FFF7FEFF 		bl	prvUnlockQueue
 1335              	.LVL139:
1087:Lib/FreeRTOS/Source/queue.c **** 
 1336              		.loc 1 1087 13 view .LVU426
1087:Lib/FreeRTOS/Source/queue.c **** 
 1337              		.loc 1 1087 22 is_stmt 0 view .LVU427
 1338 0130 FFF7FEFF 		bl	xTaskResumeAll
 1339              	.LVL140:
1089:Lib/FreeRTOS/Source/queue.c ****             return errQUEUE_FULL;
 1340              		.loc 1 1089 46 is_stmt 1 view .LVU428
1090:Lib/FreeRTOS/Source/queue.c ****         }
 1341              		.loc 1 1090 13 view .LVU429
1090:Lib/FreeRTOS/Source/queue.c ****         }
 1342              		.loc 1 1090 20 is_stmt 0 view .LVU430
 1343 0134 BBE7     		b	.L115
 1344              	.L140:
 1345 0136 00BF     		.align	2
 1346              	.L139:
 1347 0138 00000000 		.word	.LC0
 1348 013c 00000000 		.word	__func__.16
 1349 0140 02000000 		.word	.LC1
 1350              		.cfi_endproc
 1351              	.LFE11:
 1353              		.section	.text.xQueueCreateMutexStatic,"ax",%progbits
 1354              		.align	1
 1355              		.global	xQueueCreateMutexStatic
 1356              		.syntax unified
 1357              		.thumb
 1358              		.thumb_func
 1360              	xQueueCreateMutexStatic:
 1361              	.LVL141:
 1362              	.LFB5:
 639:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 1363              		.loc 1 639 5 is_stmt 1 view -0
 1364              		.cfi_startproc
 1365              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccTT1k9d.s 			page 76


 1366              		@ frame_needed = 0, uses_anonymous_args = 0
 640:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 1367              		.loc 1 640 9 view .LVU432
 641:Lib/FreeRTOS/Source/queue.c **** 
 1368              		.loc 1 641 9 view .LVU433
 645:Lib/FreeRTOS/Source/queue.c **** 
 1369              		.loc 1 645 9 view .LVU434
 647:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1370              		.loc 1 647 9 view .LVU435
 647:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1371              		.loc 1 647 21 is_stmt 0 view .LVU436
 1372 0000 0022     		movs	r2, #0
 639:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 1373              		.loc 1 639 5 view .LVU437
 1374 0002 13B5     		push	{r0, r1, r4, lr}
 1375              		.cfi_def_cfa_offset 16
 1376              		.cfi_offset 4, -8
 1377              		.cfi_offset 14, -4
 639:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 1378              		.loc 1 639 5 view .LVU438
 1379 0004 0B46     		mov	r3, r1
 647:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1380              		.loc 1 647 21 view .LVU439
 1381 0006 0090     		str	r0, [sp]
 1382 0008 1146     		mov	r1, r2
 1383              	.LVL142:
 647:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1384              		.loc 1 647 21 view .LVU440
 1385 000a 0120     		movs	r0, #1
 1386              	.LVL143:
 647:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 1387              		.loc 1 647 21 view .LVU441
 1388 000c FFF7FEFF 		bl	xQueueGenericCreateStatic
 1389              	.LVL144:
 648:Lib/FreeRTOS/Source/queue.c **** 
 1390              		.loc 1 648 9 is_stmt 1 view .LVU442
 1391              	.LBB26:
 1392              	.LBI26:
 591:Lib/FreeRTOS/Source/queue.c ****     {
 1393              		.loc 1 591 17 view .LVU443
 1394              	.LBB27:
 593:Lib/FreeRTOS/Source/queue.c ****         {
 1395              		.loc 1 593 9 view .LVU444
 593:Lib/FreeRTOS/Source/queue.c ****         {
 1396              		.loc 1 593 11 is_stmt 0 view .LVU445
 1397 0010 0446     		mov	r4, r0
 1398 0012 38B1     		cbz	r0, .L141
 599:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1399              		.loc 1 599 13 is_stmt 1 view .LVU446
 599:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 1400              		.loc 1 599 51 is_stmt 0 view .LVU447
 1401 0014 0023     		movs	r3, #0
 608:Lib/FreeRTOS/Source/queue.c ****         }
 1402              		.loc 1 608 22 view .LVU448
 1403 0016 1A46     		mov	r2, r3
 1404 0018 1946     		mov	r1, r3
 599:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
ARM GAS  /tmp/ccTT1k9d.s 			page 77


 1405              		.loc 1 599 51 view .LVU449
 1406 001a 8360     		str	r3, [r0, #8]
 600:Lib/FreeRTOS/Source/queue.c **** 
 1407              		.loc 1 600 13 is_stmt 1 view .LVU450
 600:Lib/FreeRTOS/Source/queue.c **** 
 1408              		.loc 1 600 37 is_stmt 0 view .LVU451
 1409 001c 0360     		str	r3, [r0]
 603:Lib/FreeRTOS/Source/queue.c **** 
 1410              		.loc 1 603 13 is_stmt 1 view .LVU452
 603:Lib/FreeRTOS/Source/queue.c **** 
 1411              		.loc 1 603 59 is_stmt 0 view .LVU453
 1412 001e C360     		str	r3, [r0, #12]
 605:Lib/FreeRTOS/Source/queue.c **** 
 1413              		.loc 1 605 44 is_stmt 1 view .LVU454
 608:Lib/FreeRTOS/Source/queue.c ****         }
 1414              		.loc 1 608 13 view .LVU455
 608:Lib/FreeRTOS/Source/queue.c ****         }
 1415              		.loc 1 608 22 is_stmt 0 view .LVU456
 1416 0020 FFF7FEFF 		bl	xQueueGenericSend
 1417              	.LVL145:
 612:Lib/FreeRTOS/Source/queue.c ****         }
 1418              		.loc 1 612 39 is_stmt 1 view .LVU457
 612:Lib/FreeRTOS/Source/queue.c ****         }
 1419              		.loc 1 612 39 is_stmt 0 view .LVU458
 1420              	.LBE27:
 1421              	.LBE26:
 650:Lib/FreeRTOS/Source/queue.c ****     }
 1422              		.loc 1 650 9 is_stmt 1 view .LVU459
 1423              	.L141:
 651:Lib/FreeRTOS/Source/queue.c **** 
 1424              		.loc 1 651 5 is_stmt 0 view .LVU460
 1425 0024 2046     		mov	r0, r4
 1426 0026 02B0     		add	sp, sp, #8
 1427              		.cfi_def_cfa_offset 8
 1428              		@ sp needed
 1429 0028 10BD     		pop	{r4, pc}
 651:Lib/FreeRTOS/Source/queue.c **** 
 1430              		.loc 1 651 5 view .LVU461
 1431              		.cfi_endproc
 1432              	.LFE5:
 1434              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 1435              		.align	1
 1436              		.global	xQueueGiveMutexRecursive
 1437              		.syntax unified
 1438              		.thumb
 1439              		.thumb_func
 1441              	xQueueGiveMutexRecursive:
 1442              	.LVL146:
 1443              	.LFB8:
 718:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 1444              		.loc 1 718 5 is_stmt 1 view -0
 1445              		.cfi_startproc
 1446              		@ args = 0, pretend = 0, frame = 0
 1447              		@ frame_needed = 0, uses_anonymous_args = 0
 719:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1448              		.loc 1 719 9 view .LVU463
 720:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 78


 1449              		.loc 1 720 9 view .LVU464
 722:Lib/FreeRTOS/Source/queue.c **** 
 1450              		.loc 1 722 9 view .LVU465
 718:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 1451              		.loc 1 718 5 is_stmt 0 view .LVU466
 1452 0000 38B5     		push	{r3, r4, r5, lr}
 1453              		.cfi_def_cfa_offset 16
 1454              		.cfi_offset 3, -16
 1455              		.cfi_offset 4, -12
 1456              		.cfi_offset 5, -8
 1457              		.cfi_offset 14, -4
 722:Lib/FreeRTOS/Source/queue.c **** 
 1458              		.loc 1 722 9 view .LVU467
 1459 0002 0446     		mov	r4, r0
 1460 0004 40B9     		cbnz	r0, .L147
 722:Lib/FreeRTOS/Source/queue.c **** 
 1461              		.loc 1 722 9 is_stmt 1 discriminator 1 view .LVU468
 1462 0006 FFF7FEFF 		bl	ulSetInterruptMask
 1463              	.LVL147:
 722:Lib/FreeRTOS/Source/queue.c **** 
 1464              		.loc 1 722 9 discriminator 1 view .LVU469
 1465 000a 40F2D221 		movw	r1, #722
 1466 000e 0C4B     		ldr	r3, .L152
 1467 0010 0C4A     		ldr	r2, .L152+4
 1468 0012 0D48     		ldr	r0, .L152+8
 1469 0014 FFF7FEFF 		bl	__assert_func
 1470              	.LVL148:
 1471              	.L147:
 722:Lib/FreeRTOS/Source/queue.c **** 
 1472              		.loc 1 722 32 discriminator 2 view .LVU470
 730:Lib/FreeRTOS/Source/queue.c ****         {
 1473              		.loc 1 730 9 view .LVU471
 730:Lib/FreeRTOS/Source/queue.c ****         {
 1474              		.loc 1 730 34 is_stmt 0 view .LVU472
 1475 0018 8568     		ldr	r5, [r0, #8]
 730:Lib/FreeRTOS/Source/queue.c ****         {
 1476              		.loc 1 730 51 view .LVU473
 1477 001a FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 1478              	.LVL149:
 730:Lib/FreeRTOS/Source/queue.c ****         {
 1479              		.loc 1 730 11 discriminator 1 view .LVU474
 1480 001e 8542     		cmp	r5, r0
 1481 0020 0BD1     		bne	.L151
 732:Lib/FreeRTOS/Source/queue.c **** 
 1482              		.loc 1 732 49 is_stmt 1 view .LVU475
 739:Lib/FreeRTOS/Source/queue.c **** 
 1483              		.loc 1 739 13 view .LVU476
 739:Lib/FreeRTOS/Source/queue.c **** 
 1484              		.loc 1 739 59 is_stmt 0 view .LVU477
 1485 0022 E368     		ldr	r3, [r4, #12]
 1486 0024 013B     		subs	r3, r3, #1
 1487 0026 E360     		str	r3, [r4, #12]
 742:Lib/FreeRTOS/Source/queue.c ****             {
 1488              		.loc 1 742 13 is_stmt 1 view .LVU478
 742:Lib/FreeRTOS/Source/queue.c ****             {
 1489              		.loc 1 742 15 is_stmt 0 view .LVU479
 1490 0028 0BB1     		cbz	r3, .L149
ARM GAS  /tmp/ccTT1k9d.s 			page 79


 1491              	.L150:
 753:Lib/FreeRTOS/Source/queue.c ****         }
 1492              		.loc 1 753 21 view .LVU480
 1493 002a 0120     		movs	r0, #1
 1494              	.L146:
 765:Lib/FreeRTOS/Source/queue.c **** 
 1495              		.loc 1 765 5 view .LVU481
 1496 002c 38BD     		pop	{r3, r4, r5, pc}
 1497              	.LVL150:
 1498              	.L149:
 746:Lib/FreeRTOS/Source/queue.c ****             }
 1499              		.loc 1 746 17 is_stmt 1 view .LVU482
 746:Lib/FreeRTOS/Source/queue.c ****             }
 1500              		.loc 1 746 26 is_stmt 0 view .LVU483
 1501 002e 1A46     		mov	r2, r3
 1502 0030 1946     		mov	r1, r3
 1503 0032 2046     		mov	r0, r4
 1504 0034 FFF7FEFF 		bl	xQueueGenericSend
 1505              	.LVL151:
 1506 0038 F7E7     		b	.L150
 1507              	.L151:
 759:Lib/FreeRTOS/Source/queue.c **** 
 1508              		.loc 1 759 21 view .LVU484
 1509 003a 0020     		movs	r0, #0
 1510              	.LVL152:
 761:Lib/FreeRTOS/Source/queue.c ****         }
 1511              		.loc 1 761 56 is_stmt 1 view .LVU485
 764:Lib/FreeRTOS/Source/queue.c ****     }
 1512              		.loc 1 764 9 view .LVU486
 764:Lib/FreeRTOS/Source/queue.c ****     }
 1513              		.loc 1 764 16 is_stmt 0 view .LVU487
 1514 003c F6E7     		b	.L146
 1515              	.L153:
 1516 003e 00BF     		.align	2
 1517              	.L152:
 1518 0040 00000000 		.word	.LC0
 1519 0044 00000000 		.word	__func__.19
 1520 0048 02000000 		.word	.LC1
 1521              		.cfi_endproc
 1522              	.LFE8:
 1524              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1525              		.align	1
 1526              		.global	xQueueGenericSendFromISR
 1527              		.syntax unified
 1528              		.thumb
 1529              		.thumb_func
 1531              	xQueueGenericSendFromISR:
 1532              	.LVL153:
 1533              	.LFB12:
1100:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1534              		.loc 1 1100 1 is_stmt 1 view -0
 1535              		.cfi_startproc
 1536              		@ args = 0, pretend = 0, frame = 0
 1537              		@ frame_needed = 0, uses_anonymous_args = 0
1101:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1538              		.loc 1 1101 5 view .LVU489
1102:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
ARM GAS  /tmp/ccTT1k9d.s 			page 80


 1539              		.loc 1 1102 5 view .LVU490
1103:Lib/FreeRTOS/Source/queue.c **** 
 1540              		.loc 1 1103 5 view .LVU491
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1541              		.loc 1 1105 5 view .LVU492
1100:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1542              		.loc 1 1100 1 is_stmt 0 view .LVU493
 1543 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1544              		.cfi_def_cfa_offset 32
 1545              		.cfi_offset 3, -32
 1546              		.cfi_offset 4, -28
 1547              		.cfi_offset 5, -24
 1548              		.cfi_offset 6, -20
 1549              		.cfi_offset 7, -16
 1550              		.cfi_offset 8, -12
 1551              		.cfi_offset 9, -8
 1552              		.cfi_offset 14, -4
1100:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1553              		.loc 1 1100 1 view .LVU494
 1554 0004 8946     		mov	r9, r1
 1555 0006 1746     		mov	r7, r2
 1556 0008 1E46     		mov	r6, r3
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1557              		.loc 1 1105 5 view .LVU495
 1558 000a 0446     		mov	r4, r0
 1559 000c 40B9     		cbnz	r0, .L155
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1560              		.loc 1 1105 5 is_stmt 1 discriminator 1 view .LVU496
 1561 000e FFF7FEFF 		bl	ulSetInterruptMask
 1562              	.LVL154:
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1563              		.loc 1 1105 5 discriminator 1 view .LVU497
 1564 0012 40F25141 		movw	r1, #1105
 1565 0016 2B4B     		ldr	r3, .L179
 1566 0018 2B4A     		ldr	r2, .L179+4
 1567              	.L178:
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1568              		.loc 1 1106 5 is_stmt 0 discriminator 1 view .LVU498
 1569 001a 2C48     		ldr	r0, .L179+8
 1570 001c FFF7FEFF 		bl	__assert_func
 1571              	.LVL155:
 1572              	.L155:
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1573              		.loc 1 1105 28 is_stmt 1 discriminator 2 view .LVU499
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1574              		.loc 1 1106 5 view .LVU500
 1575 0020 41B9     		cbnz	r1, .L156
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1576              		.loc 1 1106 5 is_stmt 0 discriminator 2 view .LVU501
 1577 0022 036C     		ldr	r3, [r0, #64]
 1578              	.LVL156:
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1579              		.loc 1 1106 5 discriminator 2 view .LVU502
 1580 0024 33B1     		cbz	r3, .L156
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1581              		.loc 1 1106 5 is_stmt 1 discriminator 7 view .LVU503
 1582 0026 FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/ccTT1k9d.s 			page 81


 1583              	.LVL157:
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1584              		.loc 1 1106 5 discriminator 1 view .LVU504
 1585 002a 40F25241 		movw	r1, #1106
 1586 002e 254B     		ldr	r3, .L179
 1587 0030 254A     		ldr	r2, .L179+4
 1588 0032 F2E7     		b	.L178
 1589              	.LVL158:
 1590              	.L156:
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1591              		.loc 1 1106 100 discriminator 8 view .LVU505
1107:Lib/FreeRTOS/Source/queue.c **** 
 1592              		.loc 1 1107 5 view .LVU506
 1593 0034 022E     		cmp	r6, #2
 1594 0036 09D1     		bne	.L157
1107:Lib/FreeRTOS/Source/queue.c **** 
 1595              		.loc 1 1107 5 is_stmt 0 discriminator 2 view .LVU507
 1596 0038 E36B     		ldr	r3, [r4, #60]
 1597 003a 012B     		cmp	r3, #1
 1598 003c 06D0     		beq	.L157
1107:Lib/FreeRTOS/Source/queue.c **** 
 1599              		.loc 1 1107 5 is_stmt 1 discriminator 7 view .LVU508
 1600 003e FFF7FEFF 		bl	ulSetInterruptMask
 1601              	.LVL159:
1107:Lib/FreeRTOS/Source/queue.c **** 
 1602              		.loc 1 1107 5 discriminator 1 view .LVU509
 1603 0042 40F25341 		movw	r1, #1107
 1604 0046 1F4B     		ldr	r3, .L179
 1605 0048 1F4A     		ldr	r2, .L179+4
 1606 004a E6E7     		b	.L178
 1607              	.LVL160:
 1608              	.L157:
1107:Lib/FreeRTOS/Source/queue.c **** 
 1609              		.loc 1 1107 91 discriminator 8 view .LVU510
1123:Lib/FreeRTOS/Source/queue.c **** 
 1610              		.loc 1 1123 5 view .LVU511
 1611 004c FFF7FEFF 		bl	vPortValidateInterruptPriority
 1612              	.LVL161:
1130:Lib/FreeRTOS/Source/queue.c ****     {
 1613              		.loc 1 1130 5 view .LVU512
1130:Lib/FreeRTOS/Source/queue.c ****     {
 1614              		.loc 1 1130 30 is_stmt 0 view .LVU513
 1615 0050 FFF7FEFF 		bl	ulSetInterruptMask
 1616              	.LVL162:
1132:Lib/FreeRTOS/Source/queue.c ****         {
 1617              		.loc 1 1132 22 view .LVU514
 1618 0054 A26B     		ldr	r2, [r4, #56]
1132:Lib/FreeRTOS/Source/queue.c ****         {
 1619              		.loc 1 1132 11 view .LVU515
 1620 0056 E36B     		ldr	r3, [r4, #60]
1130:Lib/FreeRTOS/Source/queue.c ****     {
 1621              		.loc 1 1130 30 view .LVU516
 1622 0058 8046     		mov	r8, r0
 1623              	.LVL163:
1132:Lib/FreeRTOS/Source/queue.c ****         {
 1624              		.loc 1 1132 9 is_stmt 1 view .LVU517
1132:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 82


 1625              		.loc 1 1132 11 is_stmt 0 view .LVU518
 1626 005a 9A42     		cmp	r2, r3
 1627 005c 01D3     		bcc	.L158
1132:Lib/FreeRTOS/Source/queue.c ****         {
 1628              		.loc 1 1132 64 discriminator 1 view .LVU519
 1629 005e 022E     		cmp	r6, #2
 1630 0060 2DD1     		bne	.L165
 1631              	.L158:
 1632              	.LBB28:
1134:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1633              		.loc 1 1134 13 is_stmt 1 view .LVU520
1134:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1634              		.loc 1 1134 26 is_stmt 0 view .LVU521
 1635 0062 94F84550 		ldrb	r5, [r4, #69]	@ zero_extendqisi2
1144:Lib/FreeRTOS/Source/queue.c **** 
 1636              		.loc 1 1144 22 view .LVU522
 1637 0066 3246     		mov	r2, r6
 1638 0068 4946     		mov	r1, r9
 1639 006a 2046     		mov	r0, r4
 1640              	.LVL164:
1134:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1641              		.loc 1 1134 26 view .LVU523
 1642 006c 6DB2     		sxtb	r5, r5
 1643              	.LVL165:
1135:Lib/FreeRTOS/Source/queue.c **** 
 1644              		.loc 1 1135 13 is_stmt 1 view .LVU524
1135:Lib/FreeRTOS/Source/queue.c **** 
 1645              		.loc 1 1135 31 is_stmt 0 view .LVU525
 1646 006e A36B     		ldr	r3, [r4, #56]
1137:Lib/FreeRTOS/Source/queue.c **** 
 1647              		.loc 1 1137 48 is_stmt 1 view .LVU526
1144:Lib/FreeRTOS/Source/queue.c **** 
 1648              		.loc 1 1144 13 view .LVU527
1144:Lib/FreeRTOS/Source/queue.c **** 
 1649              		.loc 1 1144 22 is_stmt 0 view .LVU528
 1650 0070 FFF7FEFF 		bl	prvCopyDataToQueue
 1651              	.LVL166:
1148:Lib/FreeRTOS/Source/queue.c ****             {
 1652              		.loc 1 1148 13 is_stmt 1 view .LVU529
1148:Lib/FreeRTOS/Source/queue.c ****             {
 1653              		.loc 1 1148 15 is_stmt 0 view .LVU530
 1654 0074 6B1C     		adds	r3, r5, #1
 1655 0076 10D1     		bne	.L160
1210:Lib/FreeRTOS/Source/queue.c ****                     {
 1656              		.loc 1 1210 21 is_stmt 1 view .LVU531
1210:Lib/FreeRTOS/Source/queue.c ****                     {
 1657              		.loc 1 1210 25 is_stmt 0 view .LVU532
 1658 0078 636A     		ldr	r3, [r4, #36]
1210:Lib/FreeRTOS/Source/queue.c ****                     {
 1659              		.loc 1 1210 23 view .LVU533
 1660 007a 3BB1     		cbz	r3, .L162
1212:Lib/FreeRTOS/Source/queue.c ****                         {
 1661              		.loc 1 1212 25 is_stmt 1 view .LVU534
1212:Lib/FreeRTOS/Source/queue.c ****                         {
 1662              		.loc 1 1212 29 is_stmt 0 view .LVU535
 1663 007c 04F12400 		add	r0, r4, #36
 1664 0080 FFF7FEFF 		bl	xTaskRemoveFromEventList
ARM GAS  /tmp/ccTT1k9d.s 			page 83


 1665              	.LVL167:
1212:Lib/FreeRTOS/Source/queue.c ****                         {
 1666              		.loc 1 1212 27 discriminator 1 view .LVU536
 1667 0084 10B1     		cbz	r0, .L162
1216:Lib/FreeRTOS/Source/queue.c ****                             {
 1668              		.loc 1 1216 29 is_stmt 1 view .LVU537
1216:Lib/FreeRTOS/Source/queue.c ****                             {
 1669              		.loc 1 1216 31 is_stmt 0 view .LVU538
 1670 0086 0FB1     		cbz	r7, .L162
1218:Lib/FreeRTOS/Source/queue.c ****                             }
 1671              		.loc 1 1218 33 is_stmt 1 view .LVU539
1218:Lib/FreeRTOS/Source/queue.c ****                             }
 1672              		.loc 1 1218 60 is_stmt 0 view .LVU540
 1673 0088 0123     		movs	r3, #1
 1674 008a 3B60     		str	r3, [r7]
 1675              	.LVL168:
 1676              	.L162:
1247:Lib/FreeRTOS/Source/queue.c ****         }
 1677              		.loc 1 1247 21 view .LVU541
 1678 008c 0124     		movs	r4, #1
 1679              	.LVL169:
 1680              	.L159:
1247:Lib/FreeRTOS/Source/queue.c ****         }
 1681              		.loc 1 1247 21 view .LVU542
 1682              	.LBE28:
1255:Lib/FreeRTOS/Source/queue.c **** 
 1683              		.loc 1 1255 5 is_stmt 1 view .LVU543
 1684 008e 4046     		mov	r0, r8
 1685 0090 FFF7FEFF 		bl	vClearInterruptMask
 1686              	.LVL170:
1257:Lib/FreeRTOS/Source/queue.c **** }
 1687              		.loc 1 1257 5 view .LVU544
1258:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1688              		.loc 1 1258 1 is_stmt 0 view .LVU545
 1689 0094 2046     		mov	r0, r4
 1690 0096 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1691              	.LVL171:
 1692              	.L160:
 1693              	.LBB30:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1694              		.loc 1 1244 17 is_stmt 1 view .LVU546
 1695              	.LBB29:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1696              		.loc 1 1244 17 view .LVU547
 1697 009a FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1698              	.LVL172:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1699              		.loc 1 1244 17 discriminator 1 view .LVU548
 1700 009e 8542     		cmp	r5, r0
 1701 00a0 F4D2     		bcs	.L162
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1702              		.loc 1 1244 17 discriminator 1 view .LVU549
 1703 00a2 7F2D     		cmp	r5, #127
 1704 00a4 06D1     		bne	.L164
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1705              		.loc 1 1244 17 discriminator 3 view .LVU550
 1706 00a6 FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/ccTT1k9d.s 			page 84


 1707              	.LVL173:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1708              		.loc 1 1244 17 discriminator 1 view .LVU551
 1709 00aa 40F2DC41 		movw	r1, #1244
 1710 00ae 054B     		ldr	r3, .L179
 1711 00b0 054A     		ldr	r2, .L179+4
 1712 00b2 B2E7     		b	.L178
 1713              	.LVL174:
 1714              	.L164:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1715              		.loc 1 1244 17 discriminator 4 view .LVU552
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1716              		.loc 1 1244 17 discriminator 4 view .LVU553
 1717 00b4 0135     		adds	r5, r5, #1
 1718              	.LVL175:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1719              		.loc 1 1244 17 is_stmt 0 discriminator 4 view .LVU554
 1720 00b6 6DB2     		sxtb	r5, r5
 1721              	.LVL176:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1722              		.loc 1 1244 17 discriminator 4 view .LVU555
 1723 00b8 84F84550 		strb	r5, [r4, #69]
 1724 00bc E6E7     		b	.L162
 1725              	.LVL177:
 1726              	.L165:
1244:Lib/FreeRTOS/Source/queue.c ****             }
 1727              		.loc 1 1244 17 discriminator 4 view .LVU556
 1728              	.LBE29:
 1729              	.LBE30:
1252:Lib/FreeRTOS/Source/queue.c ****         }
 1730              		.loc 1 1252 21 view .LVU557
 1731 00be 0024     		movs	r4, #0
 1732              	.LVL178:
1252:Lib/FreeRTOS/Source/queue.c ****         }
 1733              		.loc 1 1252 21 view .LVU558
 1734 00c0 E5E7     		b	.L159
 1735              	.L180:
 1736 00c2 00BF     		.align	2
 1737              	.L179:
 1738 00c4 00000000 		.word	.LC0
 1739 00c8 00000000 		.word	__func__.15
 1740 00cc 02000000 		.word	.LC1
 1741              		.cfi_endproc
 1742              	.LFE12:
 1744              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1745              		.align	1
 1746              		.global	xQueueGiveFromISR
 1747              		.syntax unified
 1748              		.thumb
 1749              		.thumb_func
 1751              	xQueueGiveFromISR:
 1752              	.LVL179:
 1753              	.LFB13:
1263:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1754              		.loc 1 1263 1 is_stmt 1 view -0
 1755              		.cfi_startproc
 1756              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccTT1k9d.s 			page 85


 1757              		@ frame_needed = 0, uses_anonymous_args = 0
1264:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 1758              		.loc 1 1264 5 view .LVU560
1265:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1759              		.loc 1 1265 5 view .LVU561
1266:Lib/FreeRTOS/Source/queue.c **** 
 1760              		.loc 1 1266 5 view .LVU562
1274:Lib/FreeRTOS/Source/queue.c **** 
 1761              		.loc 1 1274 5 view .LVU563
1263:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1762              		.loc 1 1263 1 is_stmt 0 view .LVU564
 1763 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1764              		.cfi_def_cfa_offset 24
 1765              		.cfi_offset 3, -24
 1766              		.cfi_offset 4, -20
 1767              		.cfi_offset 5, -16
 1768              		.cfi_offset 6, -12
 1769              		.cfi_offset 7, -8
 1770              		.cfi_offset 14, -4
1263:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 1771              		.loc 1 1263 1 view .LVU565
 1772 0002 0E46     		mov	r6, r1
1274:Lib/FreeRTOS/Source/queue.c **** 
 1773              		.loc 1 1274 5 view .LVU566
 1774 0004 0446     		mov	r4, r0
 1775 0006 40B9     		cbnz	r0, .L182
1274:Lib/FreeRTOS/Source/queue.c **** 
 1776              		.loc 1 1274 5 is_stmt 1 discriminator 1 view .LVU567
 1777 0008 FFF7FEFF 		bl	ulSetInterruptMask
 1778              	.LVL180:
1274:Lib/FreeRTOS/Source/queue.c **** 
 1779              		.loc 1 1274 5 discriminator 1 view .LVU568
 1780 000c 40F2FA41 		movw	r1, #1274
 1781 0010 264B     		ldr	r3, .L202
 1782 0012 274A     		ldr	r2, .L202+4
 1783              	.L201:
1278:Lib/FreeRTOS/Source/queue.c **** 
 1784              		.loc 1 1278 5 is_stmt 0 discriminator 1 view .LVU569
 1785 0014 2748     		ldr	r0, .L202+8
 1786 0016 FFF7FEFF 		bl	__assert_func
 1787              	.LVL181:
 1788              	.L182:
1274:Lib/FreeRTOS/Source/queue.c **** 
 1789              		.loc 1 1274 28 is_stmt 1 discriminator 2 view .LVU570
1278:Lib/FreeRTOS/Source/queue.c **** 
 1790              		.loc 1 1278 5 view .LVU571
 1791 001a 036C     		ldr	r3, [r0, #64]
 1792 001c 33B1     		cbz	r3, .L183
1278:Lib/FreeRTOS/Source/queue.c **** 
 1793              		.loc 1 1278 5 discriminator 1 view .LVU572
 1794 001e FFF7FEFF 		bl	ulSetInterruptMask
 1795              	.LVL182:
1278:Lib/FreeRTOS/Source/queue.c **** 
 1796              		.loc 1 1278 5 discriminator 1 view .LVU573
 1797 0022 40F2FE41 		movw	r1, #1278
 1798 0026 214B     		ldr	r3, .L202
 1799 0028 214A     		ldr	r2, .L202+4
ARM GAS  /tmp/ccTT1k9d.s 			page 86


 1800 002a F3E7     		b	.L201
 1801              	.LVL183:
 1802              	.L183:
1278:Lib/FreeRTOS/Source/queue.c **** 
 1803              		.loc 1 1278 45 discriminator 2 view .LVU574
1283:Lib/FreeRTOS/Source/queue.c **** 
 1804              		.loc 1 1283 5 view .LVU575
 1805 002c 0368     		ldr	r3, [r0]
 1806 002e 43B9     		cbnz	r3, .L184
1283:Lib/FreeRTOS/Source/queue.c **** 
 1807              		.loc 1 1283 5 is_stmt 0 discriminator 2 view .LVU576
 1808 0030 8368     		ldr	r3, [r0, #8]
 1809 0032 33B1     		cbz	r3, .L184
1283:Lib/FreeRTOS/Source/queue.c **** 
 1810              		.loc 1 1283 5 is_stmt 1 discriminator 7 view .LVU577
 1811 0034 FFF7FEFF 		bl	ulSetInterruptMask
 1812              	.LVL184:
1283:Lib/FreeRTOS/Source/queue.c **** 
 1813              		.loc 1 1283 5 discriminator 1 view .LVU578
 1814 0038 40F20351 		movw	r1, #1283
 1815 003c 1B4B     		ldr	r3, .L202
 1816 003e 1C4A     		ldr	r2, .L202+4
 1817 0040 E8E7     		b	.L201
 1818              	.LVL185:
 1819              	.L184:
1283:Lib/FreeRTOS/Source/queue.c **** 
 1820              		.loc 1 1283 123 discriminator 8 view .LVU579
1299:Lib/FreeRTOS/Source/queue.c **** 
 1821              		.loc 1 1299 5 view .LVU580
 1822 0042 FFF7FEFF 		bl	vPortValidateInterruptPriority
 1823              	.LVL186:
1301:Lib/FreeRTOS/Source/queue.c ****     {
 1824              		.loc 1 1301 5 view .LVU581
1301:Lib/FreeRTOS/Source/queue.c ****     {
 1825              		.loc 1 1301 30 is_stmt 0 view .LVU582
 1826 0046 FFF7FEFF 		bl	ulSetInterruptMask
 1827              	.LVL187:
 1828              	.LBB31:
1303:Lib/FreeRTOS/Source/queue.c **** 
 1829              		.loc 1 1303 27 view .LVU583
 1830 004a A36B     		ldr	r3, [r4, #56]
1308:Lib/FreeRTOS/Source/queue.c ****         {
 1831              		.loc 1 1308 11 view .LVU584
 1832 004c E26B     		ldr	r2, [r4, #60]
 1833              	.LBE31:
1301:Lib/FreeRTOS/Source/queue.c ****     {
 1834              		.loc 1 1301 30 view .LVU585
 1835 004e 0746     		mov	r7, r0
 1836              	.LVL188:
 1837              	.LBB35:
1303:Lib/FreeRTOS/Source/queue.c **** 
 1838              		.loc 1 1303 9 is_stmt 1 view .LVU586
1308:Lib/FreeRTOS/Source/queue.c ****         {
 1839              		.loc 1 1308 9 view .LVU587
1308:Lib/FreeRTOS/Source/queue.c ****         {
 1840              		.loc 1 1308 11 is_stmt 0 view .LVU588
 1841 0050 9A42     		cmp	r2, r3
ARM GAS  /tmp/ccTT1k9d.s 			page 87


 1842 0052 28D9     		bls	.L191
 1843              	.LBB32:
1310:Lib/FreeRTOS/Source/queue.c **** 
 1844              		.loc 1 1310 13 is_stmt 1 view .LVU589
1310:Lib/FreeRTOS/Source/queue.c **** 
 1845              		.loc 1 1310 26 is_stmt 0 view .LVU590
 1846 0054 94F84520 		ldrb	r2, [r4, #69]	@ zero_extendqisi2
1320:Lib/FreeRTOS/Source/queue.c **** 
 1847              		.loc 1 1320 60 view .LVU591
 1848 0058 0133     		adds	r3, r3, #1
 1849              	.LVL189:
1324:Lib/FreeRTOS/Source/queue.c ****             {
 1850              		.loc 1 1324 15 view .LVU592
 1851 005a FF2A     		cmp	r2, #255
1310:Lib/FreeRTOS/Source/queue.c **** 
 1852              		.loc 1 1310 26 view .LVU593
 1853 005c 55B2     		sxtb	r5, r2
 1854              	.LVL190:
1312:Lib/FreeRTOS/Source/queue.c **** 
 1855              		.loc 1 1312 48 is_stmt 1 view .LVU594
1320:Lib/FreeRTOS/Source/queue.c **** 
 1856              		.loc 1 1320 13 view .LVU595
1320:Lib/FreeRTOS/Source/queue.c **** 
 1857              		.loc 1 1320 40 is_stmt 0 view .LVU596
 1858 005e A363     		str	r3, [r4, #56]
1324:Lib/FreeRTOS/Source/queue.c ****             {
 1859              		.loc 1 1324 13 is_stmt 1 view .LVU597
1324:Lib/FreeRTOS/Source/queue.c ****             {
 1860              		.loc 1 1324 15 is_stmt 0 view .LVU598
 1861 0060 0FD1     		bne	.L186
1379:Lib/FreeRTOS/Source/queue.c ****                     {
 1862              		.loc 1 1379 21 is_stmt 1 view .LVU599
1379:Lib/FreeRTOS/Source/queue.c ****                     {
 1863              		.loc 1 1379 25 is_stmt 0 view .LVU600
 1864 0062 636A     		ldr	r3, [r4, #36]
 1865              	.LVL191:
1379:Lib/FreeRTOS/Source/queue.c ****                     {
 1866              		.loc 1 1379 23 view .LVU601
 1867 0064 3BB1     		cbz	r3, .L188
1381:Lib/FreeRTOS/Source/queue.c ****                         {
 1868              		.loc 1 1381 25 is_stmt 1 view .LVU602
1381:Lib/FreeRTOS/Source/queue.c ****                         {
 1869              		.loc 1 1381 29 is_stmt 0 view .LVU603
 1870 0066 04F12400 		add	r0, r4, #36
 1871              	.LVL192:
1381:Lib/FreeRTOS/Source/queue.c ****                         {
 1872              		.loc 1 1381 29 view .LVU604
 1873 006a FFF7FEFF 		bl	xTaskRemoveFromEventList
 1874              	.LVL193:
1381:Lib/FreeRTOS/Source/queue.c ****                         {
 1875              		.loc 1 1381 27 discriminator 1 view .LVU605
 1876 006e 10B1     		cbz	r0, .L188
1385:Lib/FreeRTOS/Source/queue.c ****                             {
 1877              		.loc 1 1385 29 is_stmt 1 view .LVU606
1385:Lib/FreeRTOS/Source/queue.c ****                             {
 1878              		.loc 1 1385 31 is_stmt 0 view .LVU607
 1879 0070 0EB1     		cbz	r6, .L188
ARM GAS  /tmp/ccTT1k9d.s 			page 88


1387:Lib/FreeRTOS/Source/queue.c ****                             }
 1880              		.loc 1 1387 33 is_stmt 1 view .LVU608
1387:Lib/FreeRTOS/Source/queue.c ****                             }
 1881              		.loc 1 1387 60 is_stmt 0 view .LVU609
 1882 0072 0123     		movs	r3, #1
 1883 0074 3360     		str	r3, [r6]
 1884              	.LVL194:
 1885              	.L188:
1413:Lib/FreeRTOS/Source/queue.c ****         }
 1886              		.loc 1 1413 21 view .LVU610
 1887 0076 0124     		movs	r4, #1
 1888              	.LVL195:
 1889              	.L185:
1413:Lib/FreeRTOS/Source/queue.c ****         }
 1890              		.loc 1 1413 21 view .LVU611
 1891              	.LBE32:
 1892              	.LBE35:
1421:Lib/FreeRTOS/Source/queue.c **** 
 1893              		.loc 1 1421 5 is_stmt 1 view .LVU612
 1894 0078 3846     		mov	r0, r7
 1895 007a FFF7FEFF 		bl	vClearInterruptMask
 1896              	.LVL196:
1423:Lib/FreeRTOS/Source/queue.c **** }
 1897              		.loc 1 1423 5 view .LVU613
1424:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 1898              		.loc 1 1424 1 is_stmt 0 view .LVU614
 1899 007e 2046     		mov	r0, r4
 1900 0080 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1901              	.LVL197:
 1902              	.L186:
 1903              	.LBB36:
 1904              	.LBB34:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1905              		.loc 1 1410 17 is_stmt 1 view .LVU615
 1906              	.LBB33:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1907              		.loc 1 1410 17 view .LVU616
 1908 0082 FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1909              	.LVL198:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1910              		.loc 1 1410 17 discriminator 1 view .LVU617
 1911 0086 8542     		cmp	r5, r0
 1912 0088 F5D2     		bcs	.L188
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1913              		.loc 1 1410 17 discriminator 1 view .LVU618
 1914 008a 7F2D     		cmp	r5, #127
 1915 008c 06D1     		bne	.L190
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1916              		.loc 1 1410 17 discriminator 3 view .LVU619
 1917 008e FFF7FEFF 		bl	ulSetInterruptMask
 1918              	.LVL199:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1919              		.loc 1 1410 17 discriminator 1 view .LVU620
 1920 0092 40F28251 		movw	r1, #1410
 1921 0096 054B     		ldr	r3, .L202
 1922 0098 054A     		ldr	r2, .L202+4
 1923 009a BBE7     		b	.L201
ARM GAS  /tmp/ccTT1k9d.s 			page 89


 1924              	.LVL200:
 1925              	.L190:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1926              		.loc 1 1410 17 discriminator 4 view .LVU621
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1927              		.loc 1 1410 17 discriminator 4 view .LVU622
 1928 009c 0135     		adds	r5, r5, #1
 1929              	.LVL201:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1930              		.loc 1 1410 17 is_stmt 0 discriminator 4 view .LVU623
 1931 009e 6DB2     		sxtb	r5, r5
 1932              	.LVL202:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1933              		.loc 1 1410 17 discriminator 4 view .LVU624
 1934 00a0 84F84550 		strb	r5, [r4, #69]
 1935 00a4 E7E7     		b	.L188
 1936              	.LVL203:
 1937              	.L191:
1410:Lib/FreeRTOS/Source/queue.c ****             }
 1938              		.loc 1 1410 17 discriminator 4 view .LVU625
 1939              	.LBE33:
 1940              	.LBE34:
1418:Lib/FreeRTOS/Source/queue.c ****         }
 1941              		.loc 1 1418 21 view .LVU626
 1942 00a6 0024     		movs	r4, #0
 1943              	.LVL204:
1418:Lib/FreeRTOS/Source/queue.c ****         }
 1944              		.loc 1 1418 21 view .LVU627
 1945 00a8 E6E7     		b	.L185
 1946              	.L203:
 1947 00aa 00BF     		.align	2
 1948              	.L202:
 1949 00ac 00000000 		.word	.LC0
 1950 00b0 00000000 		.word	__func__.14
 1951 00b4 02000000 		.word	.LC1
 1952              	.LBE36:
 1953              		.cfi_endproc
 1954              	.LFE13:
 1956              		.section	.text.xQueueReceive,"ax",%progbits
 1957              		.align	1
 1958              		.global	xQueueReceive
 1959              		.syntax unified
 1960              		.thumb
 1961              		.thumb_func
 1963              	xQueueReceive:
 1964              	.LVL205:
 1965              	.LFB14:
1430:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1966              		.loc 1 1430 1 is_stmt 1 view -0
 1967              		.cfi_startproc
 1968              		@ args = 0, pretend = 0, frame = 16
 1969              		@ frame_needed = 0, uses_anonymous_args = 0
1431:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 1970              		.loc 1 1431 5 view .LVU629
1432:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1971              		.loc 1 1432 5 view .LVU630
1433:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 90


 1972              		.loc 1 1433 5 view .LVU631
1436:Lib/FreeRTOS/Source/queue.c **** 
 1973              		.loc 1 1436 5 view .LVU632
1430:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1974              		.loc 1 1430 1 is_stmt 0 view .LVU633
 1975 0000 2DE9FF41 		push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 1976              		.cfi_def_cfa_offset 40
 1977              		.cfi_offset 4, -24
 1978              		.cfi_offset 5, -20
 1979              		.cfi_offset 6, -16
 1980              		.cfi_offset 7, -12
 1981              		.cfi_offset 8, -8
 1982              		.cfi_offset 14, -4
1430:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1983              		.loc 1 1430 1 view .LVU634
 1984 0004 0E46     		mov	r6, r1
1436:Lib/FreeRTOS/Source/queue.c **** 
 1985              		.loc 1 1436 5 view .LVU635
 1986 0006 0446     		mov	r4, r0
1430:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1987              		.loc 1 1430 1 view .LVU636
 1988 0008 0192     		str	r2, [sp, #4]
1436:Lib/FreeRTOS/Source/queue.c **** 
 1989              		.loc 1 1436 5 view .LVU637
 1990 000a 40B9     		cbnz	r0, .L205
1436:Lib/FreeRTOS/Source/queue.c **** 
 1991              		.loc 1 1436 5 is_stmt 1 discriminator 1 view .LVU638
 1992 000c FFF7FEFF 		bl	ulSetInterruptMask
 1993              	.LVL206:
1436:Lib/FreeRTOS/Source/queue.c **** 
 1994              		.loc 1 1436 5 discriminator 1 view .LVU639
 1995 0010 40F29C51 		movw	r1, #1436
 1996 0014 3F4B     		ldr	r3, .L237
 1997 0016 404A     		ldr	r2, .L237+4
 1998              	.L236:
1440:Lib/FreeRTOS/Source/queue.c **** 
 1999              		.loc 1 1440 5 is_stmt 0 discriminator 1 view .LVU640
 2000 0018 4048     		ldr	r0, .L237+8
 2001 001a FFF7FEFF 		bl	__assert_func
 2002              	.LVL207:
 2003              	.L205:
1436:Lib/FreeRTOS/Source/queue.c **** 
 2004              		.loc 1 1436 32 is_stmt 1 discriminator 2 view .LVU641
1440:Lib/FreeRTOS/Source/queue.c **** 
 2005              		.loc 1 1440 5 view .LVU642
 2006 001e 41B9     		cbnz	r1, .L206
1440:Lib/FreeRTOS/Source/queue.c **** 
 2007              		.loc 1 1440 5 is_stmt 0 discriminator 2 view .LVU643
 2008 0020 036C     		ldr	r3, [r0, #64]
 2009 0022 33B1     		cbz	r3, .L206
1440:Lib/FreeRTOS/Source/queue.c **** 
 2010              		.loc 1 1440 5 is_stmt 1 discriminator 7 view .LVU644
 2011 0024 FFF7FEFF 		bl	ulSetInterruptMask
 2012              	.LVL208:
1440:Lib/FreeRTOS/Source/queue.c **** 
 2013              		.loc 1 1440 5 discriminator 1 view .LVU645
 2014 0028 4FF4B461 		mov	r1, #1440
ARM GAS  /tmp/ccTT1k9d.s 			page 91


 2015 002c 394B     		ldr	r3, .L237
 2016 002e 3A4A     		ldr	r2, .L237+4
 2017 0030 F2E7     		b	.L236
 2018              	.LVL209:
 2019              	.L206:
1440:Lib/FreeRTOS/Source/queue.c **** 
 2020              		.loc 1 1440 103 discriminator 8 view .LVU646
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2021              		.loc 1 1445 9 view .LVU647
 2022 0032 FFF7FEFF 		bl	xTaskGetSchedulerState
 2023              	.LVL210:
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2024              		.loc 1 1445 9 is_stmt 0 discriminator 1 view .LVU648
 2025 0036 0546     		mov	r5, r0
 2026 0038 D8B1     		cbz	r0, .L207
 2027 003a 0025     		movs	r5, #0
 2028              	.L209:
1519:Lib/FreeRTOS/Source/queue.c **** 
 2029              		.loc 1 1519 9 discriminator 1 view .LVU649
 2030 003c 4FF00008 		mov	r8, #0
 2031              	.LVL211:
 2032              	.L208:
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2033              		.loc 1 1445 110 is_stmt 1 discriminator 8 view .LVU650
1452:Lib/FreeRTOS/Source/queue.c ****     {
 2034              		.loc 1 1452 5 view .LVU651
1454:Lib/FreeRTOS/Source/queue.c ****         {
 2035              		.loc 1 1454 9 view .LVU652
 2036 0040 FFF7FEFF 		bl	vPortEnterCritical
 2037              	.LVL212:
 2038              	.LBB37:
1456:Lib/FreeRTOS/Source/queue.c **** 
 2039              		.loc 1 1456 13 view .LVU653
1456:Lib/FreeRTOS/Source/queue.c **** 
 2040              		.loc 1 1456 31 is_stmt 0 view .LVU654
 2041 0044 A76B     		ldr	r7, [r4, #56]
 2042              	.LVL213:
1460:Lib/FreeRTOS/Source/queue.c ****             {
 2043              		.loc 1 1460 13 is_stmt 1 view .LVU655
1460:Lib/FreeRTOS/Source/queue.c ****             {
 2044              		.loc 1 1460 15 is_stmt 0 view .LVU656
 2045 0046 F7B1     		cbz	r7, .L210
1463:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
 2046              		.loc 1 1463 17 is_stmt 1 view .LVU657
 2047 0048 3146     		mov	r1, r6
 2048 004a 2046     		mov	r0, r4
1465:Lib/FreeRTOS/Source/queue.c **** 
 2049              		.loc 1 1465 64 is_stmt 0 view .LVU658
 2050 004c 013F     		subs	r7, r7, #1
 2051              	.LVL214:
1463:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
 2052              		.loc 1 1463 17 view .LVU659
 2053 004e FFF7FEFF 		bl	prvCopyDataFromQueue
 2054              	.LVL215:
1464:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2055              		.loc 1 1464 46 is_stmt 1 view .LVU660
1465:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 92


 2056              		.loc 1 1465 17 view .LVU661
1465:Lib/FreeRTOS/Source/queue.c **** 
 2057              		.loc 1 1465 44 is_stmt 0 view .LVU662
 2058 0052 A763     		str	r7, [r4, #56]
1470:Lib/FreeRTOS/Source/queue.c ****                 {
 2059              		.loc 1 1470 17 is_stmt 1 view .LVU663
1470:Lib/FreeRTOS/Source/queue.c ****                 {
 2060              		.loc 1 1470 21 is_stmt 0 view .LVU664
 2061 0054 2369     		ldr	r3, [r4, #16]
1470:Lib/FreeRTOS/Source/queue.c ****                 {
 2062              		.loc 1 1470 19 view .LVU665
 2063 0056 33B1     		cbz	r3, .L212
1472:Lib/FreeRTOS/Source/queue.c ****                     {
 2064              		.loc 1 1472 21 is_stmt 1 view .LVU666
1472:Lib/FreeRTOS/Source/queue.c ****                     {
 2065              		.loc 1 1472 25 is_stmt 0 view .LVU667
 2066 0058 04F11000 		add	r0, r4, #16
 2067 005c FFF7FEFF 		bl	xTaskRemoveFromEventList
 2068              	.LVL216:
1472:Lib/FreeRTOS/Source/queue.c ****                     {
 2069              		.loc 1 1472 23 discriminator 1 view .LVU668
 2070 0060 08B1     		cbz	r0, .L212
1474:Lib/FreeRTOS/Source/queue.c ****                     }
 2071              		.loc 1 1474 25 is_stmt 1 view .LVU669
 2072 0062 FFF7FEFF 		bl	vPortYield
 2073              	.LVL217:
 2074              	.L212:
1483:Lib/FreeRTOS/Source/queue.c ****                 }
 2075              		.loc 1 1483 45 view .LVU670
1486:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 2076              		.loc 1 1486 17 view .LVU671
 2077 0066 FFF7FEFF 		bl	vPortExitCritical
 2078              	.LVL218:
1487:Lib/FreeRTOS/Source/queue.c ****             }
 2079              		.loc 1 1487 17 view .LVU672
1487:Lib/FreeRTOS/Source/queue.c ****             }
 2080              		.loc 1 1487 24 is_stmt 0 view .LVU673
 2081 006a 0120     		movs	r0, #1
 2082              	.LVL219:
 2083              	.L204:
1487:Lib/FreeRTOS/Source/queue.c ****             }
 2084              		.loc 1 1487 24 view .LVU674
 2085              	.LBE37:
1567:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2086              		.loc 1 1567 1 view .LVU675
 2087 006c 04B0     		add	sp, sp, #16
 2088              		.cfi_remember_state
 2089              		.cfi_def_cfa_offset 24
 2090              		@ sp needed
 2091 006e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2092              	.LVL220:
 2093              	.L207:
 2094              		.cfi_restore_state
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2095              		.loc 1 1445 9 discriminator 2 view .LVU676
 2096 0072 019B     		ldr	r3, [sp, #4]
 2097 0074 002B     		cmp	r3, #0
ARM GAS  /tmp/ccTT1k9d.s 			page 93


 2098 0076 E1D0     		beq	.L209
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2099              		.loc 1 1445 9 is_stmt 1 discriminator 7 view .LVU677
 2100 0078 FFF7FEFF 		bl	ulSetInterruptMask
 2101              	.LVL221:
1445:Lib/FreeRTOS/Source/queue.c ****     }
 2102              		.loc 1 1445 9 discriminator 1 view .LVU678
 2103 007c 40F2A551 		movw	r1, #1445
 2104 0080 244B     		ldr	r3, .L237
 2105 0082 254A     		ldr	r2, .L237+4
 2106 0084 C8E7     		b	.L236
 2107              	.LVL222:
 2108              	.L210:
 2109              	.LBB38:
1491:Lib/FreeRTOS/Source/queue.c ****                 {
 2110              		.loc 1 1491 17 view .LVU679
1491:Lib/FreeRTOS/Source/queue.c ****                 {
 2111              		.loc 1 1491 19 is_stmt 0 view .LVU680
 2112 0086 019B     		ldr	r3, [sp, #4]
 2113 0088 1BB9     		cbnz	r3, .L215
1495:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
 2114              		.loc 1 1495 21 is_stmt 1 view .LVU681
 2115 008a FFF7FEFF 		bl	vPortExitCritical
 2116              	.LVL223:
1496:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
 2117              		.loc 1 1496 57 view .LVU682
1497:Lib/FreeRTOS/Source/queue.c ****                 }
 2118              		.loc 1 1497 21 view .LVU683
 2119              	.L216:
1497:Lib/FreeRTOS/Source/queue.c ****                 }
 2120              		.loc 1 1497 28 is_stmt 0 view .LVU684
 2121 008e 0020     		movs	r0, #0
 2122 0090 ECE7     		b	.L204
 2123              	.LVL224:
 2124              	.L215:
1499:Lib/FreeRTOS/Source/queue.c ****                 {
 2125              		.loc 1 1499 22 is_stmt 1 view .LVU685
1499:Lib/FreeRTOS/Source/queue.c ****                 {
 2126              		.loc 1 1499 24 is_stmt 0 view .LVU686
 2127 0092 15B9     		cbnz	r5, .L217
1503:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2128              		.loc 1 1503 21 is_stmt 1 view .LVU687
 2129 0094 02A8     		add	r0, sp, #8
 2130 0096 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2131              	.LVL225:
1504:Lib/FreeRTOS/Source/queue.c ****                 }
 2132              		.loc 1 1504 21 view .LVU688
 2133              	.L217:
1509:Lib/FreeRTOS/Source/queue.c ****                 }
 2134              		.loc 1 1509 45 view .LVU689
 2135              	.LBE38:
1513:Lib/FreeRTOS/Source/queue.c **** 
 2136              		.loc 1 1513 9 view .LVU690
 2137 009a FFF7FEFF 		bl	vPortExitCritical
 2138              	.LVL226:
1518:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2139              		.loc 1 1518 9 view .LVU691
ARM GAS  /tmp/ccTT1k9d.s 			page 94


 2140 009e FFF7FEFF 		bl	vTaskSuspendAll
 2141              	.LVL227:
1519:Lib/FreeRTOS/Source/queue.c **** 
 2142              		.loc 1 1519 9 view .LVU692
 2143 00a2 FFF7FEFF 		bl	vPortEnterCritical
 2144              	.LVL228:
1519:Lib/FreeRTOS/Source/queue.c **** 
 2145              		.loc 1 1519 9 discriminator 1 view .LVU693
 2146 00a6 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2147 00aa FF2B     		cmp	r3, #255
1519:Lib/FreeRTOS/Source/queue.c **** 
 2148              		.loc 1 1519 9 discriminator 1 view .LVU694
 2149 00ac 08BF     		it	eq
 2150 00ae 84F84480 		strbeq	r8, [r4, #68]
1519:Lib/FreeRTOS/Source/queue.c **** 
 2151              		.loc 1 1519 9 discriminator 3 view .LVU695
 2152 00b2 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2153 00b6 FF2B     		cmp	r3, #255
1519:Lib/FreeRTOS/Source/queue.c **** 
 2154              		.loc 1 1519 9 discriminator 4 view .LVU696
 2155 00b8 08BF     		it	eq
 2156 00ba 84F84580 		strbeq	r8, [r4, #69]
1519:Lib/FreeRTOS/Source/queue.c **** 
 2157              		.loc 1 1519 9 discriminator 6 view .LVU697
 2158 00be FFF7FEFF 		bl	vPortExitCritical
 2159              	.LVL229:
1522:Lib/FreeRTOS/Source/queue.c ****         {
 2160              		.loc 1 1522 9 view .LVU698
1522:Lib/FreeRTOS/Source/queue.c ****         {
 2161              		.loc 1 1522 13 is_stmt 0 view .LVU699
 2162 00c2 01A9     		add	r1, sp, #4
 2163 00c4 02A8     		add	r0, sp, #8
 2164 00c6 FFF7FEFF 		bl	xTaskCheckForTimeOut
 2165              	.LVL230:
1522:Lib/FreeRTOS/Source/queue.c ****         {
 2166              		.loc 1 1522 11 discriminator 1 view .LVU700
 2167 00ca C0B9     		cbnz	r0, .L220
1526:Lib/FreeRTOS/Source/queue.c ****             {
 2168              		.loc 1 1526 13 is_stmt 1 view .LVU701
1526:Lib/FreeRTOS/Source/queue.c ****             {
 2169              		.loc 1 1526 17 is_stmt 0 view .LVU702
 2170 00cc 2046     		mov	r0, r4
 2171 00ce FFF7FEFF 		bl	prvIsQueueEmpty
 2172              	.LVL231:
1526:Lib/FreeRTOS/Source/queue.c ****             {
 2173              		.loc 1 1526 15 discriminator 1 view .LVU703
 2174 00d2 70B1     		cbz	r0, .L221
1528:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2175              		.loc 1 1528 58 is_stmt 1 view .LVU704
1529:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2176              		.loc 1 1529 17 view .LVU705
 2177 00d4 0199     		ldr	r1, [sp, #4]
 2178 00d6 04F12400 		add	r0, r4, #36
 2179 00da FFF7FEFF 		bl	vTaskPlaceOnEventList
 2180              	.LVL232:
1530:Lib/FreeRTOS/Source/queue.c **** 
 2181              		.loc 1 1530 17 view .LVU706
ARM GAS  /tmp/ccTT1k9d.s 			page 95


 2182 00de 2046     		mov	r0, r4
 2183 00e0 FFF7FEFF 		bl	prvUnlockQueue
 2184              	.LVL233:
1532:Lib/FreeRTOS/Source/queue.c ****                 {
 2185              		.loc 1 1532 17 view .LVU707
1532:Lib/FreeRTOS/Source/queue.c ****                 {
 2186              		.loc 1 1532 21 is_stmt 0 view .LVU708
 2187 00e4 FFF7FEFF 		bl	xTaskResumeAll
 2188              	.LVL234:
1532:Lib/FreeRTOS/Source/queue.c ****                 {
 2189              		.loc 1 1532 19 discriminator 1 view .LVU709
 2190 00e8 08B9     		cbnz	r0, .L223
1534:Lib/FreeRTOS/Source/queue.c ****                 }
 2191              		.loc 1 1534 21 is_stmt 1 view .LVU710
 2192 00ea FFF7FEFF 		bl	vPortYield
 2193              	.LVL235:
 2194              	.L223:
 2195 00ee 0125     		movs	r5, #1
 2196 00f0 A6E7     		b	.L208
 2197              	.L221:
1545:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2198              		.loc 1 1545 17 view .LVU711
 2199 00f2 2046     		mov	r0, r4
 2200 00f4 FFF7FEFF 		bl	prvUnlockQueue
 2201              	.LVL236:
1546:Lib/FreeRTOS/Source/queue.c ****             }
 2202              		.loc 1 1546 17 view .LVU712
1546:Lib/FreeRTOS/Source/queue.c ****             }
 2203              		.loc 1 1546 26 is_stmt 0 view .LVU713
 2204 00f8 FFF7FEFF 		bl	xTaskResumeAll
 2205              	.LVL237:
 2206 00fc F7E7     		b	.L223
 2207              	.L220:
1553:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2208              		.loc 1 1553 13 is_stmt 1 view .LVU714
 2209 00fe 2046     		mov	r0, r4
 2210 0100 FFF7FEFF 		bl	prvUnlockQueue
 2211              	.LVL238:
1554:Lib/FreeRTOS/Source/queue.c **** 
 2212              		.loc 1 1554 13 view .LVU715
1554:Lib/FreeRTOS/Source/queue.c **** 
 2213              		.loc 1 1554 22 is_stmt 0 view .LVU716
 2214 0104 FFF7FEFF 		bl	xTaskResumeAll
 2215              	.LVL239:
1556:Lib/FreeRTOS/Source/queue.c ****             {
 2216              		.loc 1 1556 13 is_stmt 1 view .LVU717
1556:Lib/FreeRTOS/Source/queue.c ****             {
 2217              		.loc 1 1556 17 is_stmt 0 view .LVU718
 2218 0108 2046     		mov	r0, r4
 2219 010a FFF7FEFF 		bl	prvIsQueueEmpty
 2220              	.LVL240:
1556:Lib/FreeRTOS/Source/queue.c ****             {
 2221              		.loc 1 1556 15 discriminator 1 view .LVU719
 2222 010e 0028     		cmp	r0, #0
 2223 0110 EDD0     		beq	.L223
 2224 0112 BCE7     		b	.L216
 2225              	.L238:
ARM GAS  /tmp/ccTT1k9d.s 			page 96


 2226              		.align	2
 2227              	.L237:
 2228 0114 00000000 		.word	.LC0
 2229 0118 00000000 		.word	__func__.13
 2230 011c 02000000 		.word	.LC1
 2231              		.cfi_endproc
 2232              	.LFE14:
 2234              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 2235              		.align	1
 2236              		.global	xQueueSemaphoreTake
 2237              		.syntax unified
 2238              		.thumb
 2239              		.thumb_func
 2241              	xQueueSemaphoreTake:
 2242              	.LVL241:
 2243              	.LFB15:
1572:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2244              		.loc 1 1572 1 is_stmt 1 view -0
 2245              		.cfi_startproc
 2246              		@ args = 0, pretend = 0, frame = 16
 2247              		@ frame_needed = 0, uses_anonymous_args = 0
1573:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 2248              		.loc 1 1573 5 view .LVU721
1574:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2249              		.loc 1 1574 5 view .LVU722
1575:Lib/FreeRTOS/Source/queue.c **** 
 2250              		.loc 1 1575 5 view .LVU723
1578:Lib/FreeRTOS/Source/queue.c ****     #endif
 2251              		.loc 1 1578 9 view .LVU724
1582:Lib/FreeRTOS/Source/queue.c **** 
 2252              		.loc 1 1582 5 view .LVU725
1572:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2253              		.loc 1 1572 1 is_stmt 0 view .LVU726
 2254 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2255              		.cfi_def_cfa_offset 20
 2256              		.cfi_offset 4, -20
 2257              		.cfi_offset 5, -16
 2258              		.cfi_offset 6, -12
 2259              		.cfi_offset 7, -8
 2260              		.cfi_offset 14, -4
 2261 0002 85B0     		sub	sp, sp, #20
 2262              		.cfi_def_cfa_offset 40
1582:Lib/FreeRTOS/Source/queue.c **** 
 2263              		.loc 1 1582 5 view .LVU727
 2264 0004 0446     		mov	r4, r0
1572:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2265              		.loc 1 1572 1 view .LVU728
 2266 0006 0191     		str	r1, [sp, #4]
1582:Lib/FreeRTOS/Source/queue.c **** 
 2267              		.loc 1 1582 5 view .LVU729
 2268 0008 40B9     		cbnz	r0, .L240
1582:Lib/FreeRTOS/Source/queue.c **** 
 2269              		.loc 1 1582 5 is_stmt 1 discriminator 1 view .LVU730
 2270 000a FFF7FEFF 		bl	ulSetInterruptMask
 2271              	.LVL242:
1582:Lib/FreeRTOS/Source/queue.c **** 
 2272              		.loc 1 1582 5 discriminator 1 view .LVU731
ARM GAS  /tmp/ccTT1k9d.s 			page 97


 2273 000e 40F22E61 		movw	r1, #1582
 2274 0012 4B4B     		ldr	r3, .L277
 2275 0014 4B4A     		ldr	r2, .L277+4
 2276              	.L276:
1586:Lib/FreeRTOS/Source/queue.c **** 
 2277              		.loc 1 1586 5 is_stmt 0 discriminator 1 view .LVU732
 2278 0016 4C48     		ldr	r0, .L277+8
 2279 0018 FFF7FEFF 		bl	__assert_func
 2280              	.LVL243:
 2281              	.L240:
1582:Lib/FreeRTOS/Source/queue.c **** 
 2282              		.loc 1 1582 32 is_stmt 1 discriminator 2 view .LVU733
1586:Lib/FreeRTOS/Source/queue.c **** 
 2283              		.loc 1 1586 5 view .LVU734
 2284 001c 056C     		ldr	r5, [r0, #64]
 2285 001e 35B1     		cbz	r5, .L241
1586:Lib/FreeRTOS/Source/queue.c **** 
 2286              		.loc 1 1586 5 discriminator 1 view .LVU735
 2287 0020 FFF7FEFF 		bl	ulSetInterruptMask
 2288              	.LVL244:
1586:Lib/FreeRTOS/Source/queue.c **** 
 2289              		.loc 1 1586 5 discriminator 1 view .LVU736
 2290 0024 40F23261 		movw	r1, #1586
 2291 0028 454B     		ldr	r3, .L277
 2292 002a 464A     		ldr	r2, .L277+4
 2293 002c F3E7     		b	.L276
 2294              	.LVL245:
 2295              	.L241:
1586:Lib/FreeRTOS/Source/queue.c **** 
 2296              		.loc 1 1586 45 discriminator 2 view .LVU737
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2297              		.loc 1 1591 9 view .LVU738
 2298 002e FFF7FEFF 		bl	xTaskGetSchedulerState
 2299              	.LVL246:
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2300              		.loc 1 1591 9 is_stmt 0 discriminator 1 view .LVU739
 2301 0032 0646     		mov	r6, r0
 2302 0034 D0B1     		cbz	r0, .L242
 2303 0036 2E46     		mov	r6, r5
 2304              	.L244:
1682:Lib/FreeRTOS/Source/queue.c **** 
 2305              		.loc 1 1682 9 discriminator 1 view .LVU740
 2306 0038 0027     		movs	r7, #0
 2307              	.LVL247:
 2308              	.L243:
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2309              		.loc 1 1591 110 is_stmt 1 discriminator 8 view .LVU741
1598:Lib/FreeRTOS/Source/queue.c ****     {
 2310              		.loc 1 1598 5 view .LVU742
1600:Lib/FreeRTOS/Source/queue.c ****         {
 2311              		.loc 1 1600 9 view .LVU743
 2312 003a FFF7FEFF 		bl	vPortEnterCritical
 2313              	.LVL248:
 2314              	.LBB43:
1604:Lib/FreeRTOS/Source/queue.c **** 
 2315              		.loc 1 1604 13 view .LVU744
1604:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 98


 2316              		.loc 1 1604 31 is_stmt 0 view .LVU745
 2317 003e A36B     		ldr	r3, [r4, #56]
 2318              	.LVL249:
1608:Lib/FreeRTOS/Source/queue.c ****             {
 2319              		.loc 1 1608 13 is_stmt 1 view .LVU746
1608:Lib/FreeRTOS/Source/queue.c ****             {
 2320              		.loc 1 1608 15 is_stmt 0 view .LVU747
 2321 0040 FBB1     		cbz	r3, .L245
1610:Lib/FreeRTOS/Source/queue.c **** 
 2322              		.loc 1 1610 46 is_stmt 1 view .LVU748
1614:Lib/FreeRTOS/Source/queue.c **** 
 2323              		.loc 1 1614 17 view .LVU749
1614:Lib/FreeRTOS/Source/queue.c **** 
 2324              		.loc 1 1614 63 is_stmt 0 view .LVU750
 2325 0042 013B     		subs	r3, r3, #1
 2326              	.LVL250:
1614:Lib/FreeRTOS/Source/queue.c **** 
 2327              		.loc 1 1614 44 view .LVU751
 2328 0044 A363     		str	r3, [r4, #56]
1618:Lib/FreeRTOS/Source/queue.c ****                     {
 2329              		.loc 1 1618 21 is_stmt 1 view .LVU752
1618:Lib/FreeRTOS/Source/queue.c ****                     {
 2330              		.loc 1 1618 23 is_stmt 0 view .LVU753
 2331 0046 2368     		ldr	r3, [r4]
 2332              	.LVL251:
1618:Lib/FreeRTOS/Source/queue.c ****                     {
 2333              		.loc 1 1618 23 view .LVU754
 2334 0048 13B9     		cbnz	r3, .L246
1622:Lib/FreeRTOS/Source/queue.c ****                     }
 2335              		.loc 1 1622 25 is_stmt 1 view .LVU755
1622:Lib/FreeRTOS/Source/queue.c ****                     }
 2336              		.loc 1 1622 62 is_stmt 0 view .LVU756
 2337 004a FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 2338              	.LVL252:
1622:Lib/FreeRTOS/Source/queue.c ****                     }
 2339              		.loc 1 1622 60 discriminator 1 view .LVU757
 2340 004e A060     		str	r0, [r4, #8]
 2341              	.L246:
1626:Lib/FreeRTOS/Source/queue.c ****                     }
 2342              		.loc 1 1626 49 is_stmt 1 view .LVU758
1633:Lib/FreeRTOS/Source/queue.c ****                 {
 2343              		.loc 1 1633 17 view .LVU759
1633:Lib/FreeRTOS/Source/queue.c ****                 {
 2344              		.loc 1 1633 21 is_stmt 0 view .LVU760
 2345 0050 2369     		ldr	r3, [r4, #16]
1633:Lib/FreeRTOS/Source/queue.c ****                 {
 2346              		.loc 1 1633 19 view .LVU761
 2347 0052 33B1     		cbz	r3, .L248
1635:Lib/FreeRTOS/Source/queue.c ****                     {
 2348              		.loc 1 1635 21 is_stmt 1 view .LVU762
1635:Lib/FreeRTOS/Source/queue.c ****                     {
 2349              		.loc 1 1635 25 is_stmt 0 view .LVU763
 2350 0054 04F11000 		add	r0, r4, #16
 2351 0058 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2352              	.LVL253:
1635:Lib/FreeRTOS/Source/queue.c ****                     {
 2353              		.loc 1 1635 23 discriminator 1 view .LVU764
ARM GAS  /tmp/ccTT1k9d.s 			page 99


 2354 005c 08B1     		cbz	r0, .L248
1637:Lib/FreeRTOS/Source/queue.c ****                     }
 2355              		.loc 1 1637 25 is_stmt 1 view .LVU765
 2356 005e FFF7FEFF 		bl	vPortYield
 2357              	.LVL254:
 2358              	.L248:
1646:Lib/FreeRTOS/Source/queue.c ****                 }
 2359              		.loc 1 1646 45 view .LVU766
1649:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 2360              		.loc 1 1649 17 view .LVU767
 2361 0062 FFF7FEFF 		bl	vPortExitCritical
 2362              	.LVL255:
1650:Lib/FreeRTOS/Source/queue.c ****             }
 2363              		.loc 1 1650 17 view .LVU768
1650:Lib/FreeRTOS/Source/queue.c ****             }
 2364              		.loc 1 1650 24 is_stmt 0 view .LVU769
 2365 0066 0120     		movs	r0, #1
 2366              	.LVL256:
 2367              	.L239:
1650:Lib/FreeRTOS/Source/queue.c ****             }
 2368              		.loc 1 1650 24 view .LVU770
 2369              	.LBE43:
1777:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2370              		.loc 1 1777 1 view .LVU771
 2371 0068 05B0     		add	sp, sp, #20
 2372              		.cfi_remember_state
 2373              		.cfi_def_cfa_offset 20
 2374              		@ sp needed
 2375 006a F0BD     		pop	{r4, r5, r6, r7, pc}
 2376              	.LVL257:
 2377              	.L242:
 2378              		.cfi_restore_state
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2379              		.loc 1 1591 9 discriminator 2 view .LVU772
 2380 006c 019B     		ldr	r3, [sp, #4]
 2381 006e 0546     		mov	r5, r0
 2382 0070 002B     		cmp	r3, #0
 2383 0072 E1D0     		beq	.L244
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2384              		.loc 1 1591 9 is_stmt 1 discriminator 7 view .LVU773
 2385 0074 FFF7FEFF 		bl	ulSetInterruptMask
 2386              	.LVL258:
1591:Lib/FreeRTOS/Source/queue.c ****     }
 2387              		.loc 1 1591 9 discriminator 1 view .LVU774
 2388 0078 40F23761 		movw	r1, #1591
 2389 007c 304B     		ldr	r3, .L277
 2390 007e 314A     		ldr	r2, .L277+4
 2391 0080 C9E7     		b	.L276
 2392              	.LVL259:
 2393              	.L245:
 2394              	.LBB44:
1654:Lib/FreeRTOS/Source/queue.c ****                 {
 2395              		.loc 1 1654 17 view .LVU775
1654:Lib/FreeRTOS/Source/queue.c ****                 {
 2396              		.loc 1 1654 19 is_stmt 0 view .LVU776
 2397 0082 019B     		ldr	r3, [sp, #4]
 2398              	.LVL260:
ARM GAS  /tmp/ccTT1k9d.s 			page 100


1654:Lib/FreeRTOS/Source/queue.c ****                 {
 2399              		.loc 1 1654 19 view .LVU777
 2400 0084 1BB9     		cbnz	r3, .L251
 2401              	.LVL261:
 2402              	.L275:
1654:Lib/FreeRTOS/Source/queue.c ****                 {
 2403              		.loc 1 1654 19 view .LVU778
 2404              	.LBE44:
1763:Lib/FreeRTOS/Source/queue.c ****                     }
 2405              		.loc 1 1763 25 is_stmt 1 view .LVU779
 2406 0086 FFF7FEFF 		bl	vPortExitCritical
 2407              	.LVL262:
 2408              	.L252:
 2409              	.LBB45:
1660:Lib/FreeRTOS/Source/queue.c ****                 }
 2410              		.loc 1 1660 28 is_stmt 0 view .LVU780
 2411 008a 0020     		movs	r0, #0
 2412 008c ECE7     		b	.L239
 2413              	.LVL263:
 2414              	.L251:
1662:Lib/FreeRTOS/Source/queue.c ****                 {
 2415              		.loc 1 1662 22 is_stmt 1 view .LVU781
1662:Lib/FreeRTOS/Source/queue.c ****                 {
 2416              		.loc 1 1662 24 is_stmt 0 view .LVU782
 2417 008e 16B9     		cbnz	r6, .L253
1666:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2418              		.loc 1 1666 21 is_stmt 1 view .LVU783
 2419 0090 02A8     		add	r0, sp, #8
 2420 0092 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2421              	.LVL264:
1667:Lib/FreeRTOS/Source/queue.c ****                 }
 2422              		.loc 1 1667 21 view .LVU784
 2423              	.L253:
1672:Lib/FreeRTOS/Source/queue.c ****                 }
 2424              		.loc 1 1672 45 view .LVU785
 2425              	.LBE45:
1676:Lib/FreeRTOS/Source/queue.c **** 
 2426              		.loc 1 1676 9 view .LVU786
 2427 0096 FFF7FEFF 		bl	vPortExitCritical
 2428              	.LVL265:
1681:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2429              		.loc 1 1681 9 view .LVU787
 2430 009a FFF7FEFF 		bl	vTaskSuspendAll
 2431              	.LVL266:
1682:Lib/FreeRTOS/Source/queue.c **** 
 2432              		.loc 1 1682 9 view .LVU788
 2433 009e FFF7FEFF 		bl	vPortEnterCritical
 2434              	.LVL267:
1682:Lib/FreeRTOS/Source/queue.c **** 
 2435              		.loc 1 1682 9 discriminator 1 view .LVU789
 2436 00a2 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2437 00a6 FF2B     		cmp	r3, #255
1682:Lib/FreeRTOS/Source/queue.c **** 
 2438              		.loc 1 1682 9 discriminator 1 view .LVU790
 2439 00a8 08BF     		it	eq
 2440 00aa 84F84470 		strbeq	r7, [r4, #68]
1682:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 101


 2441              		.loc 1 1682 9 discriminator 3 view .LVU791
 2442 00ae 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2443 00b2 FF2B     		cmp	r3, #255
1682:Lib/FreeRTOS/Source/queue.c **** 
 2444              		.loc 1 1682 9 discriminator 4 view .LVU792
 2445 00b4 08BF     		it	eq
 2446 00b6 84F84570 		strbeq	r7, [r4, #69]
1682:Lib/FreeRTOS/Source/queue.c **** 
 2447              		.loc 1 1682 9 discriminator 6 view .LVU793
 2448 00ba FFF7FEFF 		bl	vPortExitCritical
 2449              	.LVL268:
1685:Lib/FreeRTOS/Source/queue.c ****         {
 2450              		.loc 1 1685 9 view .LVU794
1685:Lib/FreeRTOS/Source/queue.c ****         {
 2451              		.loc 1 1685 13 is_stmt 0 view .LVU795
 2452 00be 01A9     		add	r1, sp, #4
 2453 00c0 02A8     		add	r0, sp, #8
 2454 00c2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 2455              	.LVL269:
1685:Lib/FreeRTOS/Source/queue.c ****         {
 2456              		.loc 1 1685 11 discriminator 1 view .LVU796
 2457 00c6 10BB     		cbnz	r0, .L256
1691:Lib/FreeRTOS/Source/queue.c ****             {
 2458              		.loc 1 1691 13 is_stmt 1 view .LVU797
1691:Lib/FreeRTOS/Source/queue.c ****             {
 2459              		.loc 1 1691 17 is_stmt 0 view .LVU798
 2460 00c8 2046     		mov	r0, r4
 2461 00ca FFF7FEFF 		bl	prvIsQueueEmpty
 2462              	.LVL270:
1691:Lib/FreeRTOS/Source/queue.c ****             {
 2463              		.loc 1 1691 15 discriminator 1 view .LVU799
 2464 00ce C0B1     		cbz	r0, .L257
1693:Lib/FreeRTOS/Source/queue.c **** 
 2465              		.loc 1 1693 58 is_stmt 1 view .LVU800
1697:Lib/FreeRTOS/Source/queue.c ****                     {
 2466              		.loc 1 1697 21 view .LVU801
1697:Lib/FreeRTOS/Source/queue.c ****                     {
 2467              		.loc 1 1697 23 is_stmt 0 view .LVU802
 2468 00d0 2368     		ldr	r3, [r4]
 2469 00d2 3BB9     		cbnz	r3, .L258
1699:Lib/FreeRTOS/Source/queue.c ****                         {
 2470              		.loc 1 1699 25 is_stmt 1 view .LVU803
 2471 00d4 FFF7FEFF 		bl	vPortEnterCritical
 2472              	.LVL271:
1701:Lib/FreeRTOS/Source/queue.c ****                         }
 2473              		.loc 1 1701 29 view .LVU804
1701:Lib/FreeRTOS/Source/queue.c ****                         }
 2474              		.loc 1 1701 52 is_stmt 0 view .LVU805
 2475 00d8 A068     		ldr	r0, [r4, #8]
 2476 00da FFF7FEFF 		bl	xTaskPriorityInherit
 2477              	.LVL272:
 2478 00de 0546     		mov	r5, r0
 2479              	.LVL273:
1703:Lib/FreeRTOS/Source/queue.c ****                     }
 2480              		.loc 1 1703 25 is_stmt 1 view .LVU806
 2481 00e0 FFF7FEFF 		bl	vPortExitCritical
 2482              	.LVL274:
ARM GAS  /tmp/ccTT1k9d.s 			page 102


 2483              	.L258:
1707:Lib/FreeRTOS/Source/queue.c ****                     }
 2484              		.loc 1 1707 49 view .LVU807
1712:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2485              		.loc 1 1712 17 view .LVU808
 2486 00e4 0199     		ldr	r1, [sp, #4]
 2487 00e6 04F12400 		add	r0, r4, #36
 2488 00ea FFF7FEFF 		bl	vTaskPlaceOnEventList
 2489              	.LVL275:
1713:Lib/FreeRTOS/Source/queue.c **** 
 2490              		.loc 1 1713 17 view .LVU809
 2491 00ee 2046     		mov	r0, r4
 2492 00f0 FFF7FEFF 		bl	prvUnlockQueue
 2493              	.LVL276:
1715:Lib/FreeRTOS/Source/queue.c ****                 {
 2494              		.loc 1 1715 17 view .LVU810
1715:Lib/FreeRTOS/Source/queue.c ****                 {
 2495              		.loc 1 1715 21 is_stmt 0 view .LVU811
 2496 00f4 FFF7FEFF 		bl	xTaskResumeAll
 2497              	.LVL277:
1715:Lib/FreeRTOS/Source/queue.c ****                 {
 2498              		.loc 1 1715 19 discriminator 1 view .LVU812
 2499 00f8 08B9     		cbnz	r0, .L262
1717:Lib/FreeRTOS/Source/queue.c ****                 }
 2500              		.loc 1 1717 21 is_stmt 1 view .LVU813
 2501 00fa FFF7FEFF 		bl	vPortYield
 2502              	.LVL278:
 2503              	.L262:
1717:Lib/FreeRTOS/Source/queue.c ****                 }
 2504              		.loc 1 1717 21 is_stmt 0 view .LVU814
 2505 00fe 0126     		movs	r6, #1
 2506 0100 9BE7     		b	.L243
 2507              	.L257:
1728:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2508              		.loc 1 1728 17 is_stmt 1 view .LVU815
 2509 0102 2046     		mov	r0, r4
 2510 0104 FFF7FEFF 		bl	prvUnlockQueue
 2511              	.LVL279:
1729:Lib/FreeRTOS/Source/queue.c ****             }
 2512              		.loc 1 1729 17 view .LVU816
1729:Lib/FreeRTOS/Source/queue.c ****             }
 2513              		.loc 1 1729 26 is_stmt 0 view .LVU817
 2514 0108 FFF7FEFF 		bl	xTaskResumeAll
 2515              	.LVL280:
 2516 010c F7E7     		b	.L262
 2517              	.L256:
1735:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2518              		.loc 1 1735 13 is_stmt 1 view .LVU818
 2519 010e 2046     		mov	r0, r4
 2520 0110 FFF7FEFF 		bl	prvUnlockQueue
 2521              	.LVL281:
1736:Lib/FreeRTOS/Source/queue.c **** 
 2522              		.loc 1 1736 13 view .LVU819
1736:Lib/FreeRTOS/Source/queue.c **** 
 2523              		.loc 1 1736 22 is_stmt 0 view .LVU820
 2524 0114 FFF7FEFF 		bl	xTaskResumeAll
 2525              	.LVL282:
ARM GAS  /tmp/ccTT1k9d.s 			page 103


1742:Lib/FreeRTOS/Source/queue.c ****             {
 2526              		.loc 1 1742 13 is_stmt 1 view .LVU821
1742:Lib/FreeRTOS/Source/queue.c ****             {
 2527              		.loc 1 1742 17 is_stmt 0 view .LVU822
 2528 0118 2046     		mov	r0, r4
 2529 011a FFF7FEFF 		bl	prvIsQueueEmpty
 2530              	.LVL283:
1742:Lib/FreeRTOS/Source/queue.c ****             {
 2531              		.loc 1 1742 15 discriminator 1 view .LVU823
 2532 011e 0028     		cmp	r0, #0
 2533 0120 EDD0     		beq	.L262
1749:Lib/FreeRTOS/Source/queue.c ****                     {
 2534              		.loc 1 1749 21 is_stmt 1 view .LVU824
1749:Lib/FreeRTOS/Source/queue.c ****                     {
 2535              		.loc 1 1749 23 is_stmt 0 view .LVU825
 2536 0122 002D     		cmp	r5, #0
 2537 0124 B1D0     		beq	.L252
1751:Lib/FreeRTOS/Source/queue.c ****                         {
 2538              		.loc 1 1751 25 is_stmt 1 view .LVU826
 2539 0126 FFF7FEFF 		bl	vPortEnterCritical
 2540              	.LVL284:
 2541              	.LBB46:
1753:Lib/FreeRTOS/Source/queue.c **** 
 2542              		.loc 1 1753 29 view .LVU827
1760:Lib/FreeRTOS/Source/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
 2543              		.loc 1 1760 29 view .LVU828
 2544              	.LBB47:
 2545              	.LBI47:
2211:Lib/FreeRTOS/Source/queue.c ****     {
 2546              		.loc 1 2211 24 view .LVU829
 2547              	.LBB48:
2213:Lib/FreeRTOS/Source/queue.c **** 
 2548              		.loc 1 2213 9 view .LVU830
2221:Lib/FreeRTOS/Source/queue.c ****         {
 2549              		.loc 1 2221 9 view .LVU831
2221:Lib/FreeRTOS/Source/queue.c ****         {
 2550              		.loc 1 2221 13 is_stmt 0 view .LVU832
 2551 012a 616A     		ldr	r1, [r4, #36]
2221:Lib/FreeRTOS/Source/queue.c ****         {
 2552              		.loc 1 2221 11 view .LVU833
 2553 012c 19B1     		cbz	r1, .L263
2223:Lib/FreeRTOS/Source/queue.c ****         }
 2554              		.loc 1 2223 13 is_stmt 1 view .LVU834
2223:Lib/FreeRTOS/Source/queue.c ****         }
 2555              		.loc 1 2223 102 is_stmt 0 view .LVU835
 2556 012e 236B     		ldr	r3, [r4, #48]
2223:Lib/FreeRTOS/Source/queue.c ****         }
 2557              		.loc 1 2223 45 view .LVU836
 2558 0130 1968     		ldr	r1, [r3]
 2559 0132 C1F13801 		rsb	r1, r1, #56
 2560              	.LVL285:
 2561              	.L263:
2230:Lib/FreeRTOS/Source/queue.c ****     }
 2562              		.loc 1 2230 9 is_stmt 1 view .LVU837
2230:Lib/FreeRTOS/Source/queue.c ****     }
 2563              		.loc 1 2230 9 is_stmt 0 view .LVU838
 2564              	.LBE48:
ARM GAS  /tmp/ccTT1k9d.s 			page 104


 2565              	.LBE47:
1761:Lib/FreeRTOS/Source/queue.c ****                         }
 2566              		.loc 1 1761 29 is_stmt 1 view .LVU839
 2567 0136 A068     		ldr	r0, [r4, #8]
 2568 0138 FFF7FEFF 		bl	vTaskPriorityDisinheritAfterTimeout
 2569              	.LVL286:
1761:Lib/FreeRTOS/Source/queue.c ****                         }
 2570              		.loc 1 1761 29 is_stmt 0 view .LVU840
 2571 013c A3E7     		b	.L275
 2572              	.L278:
 2573 013e 00BF     		.align	2
 2574              	.L277:
 2575 0140 00000000 		.word	.LC0
 2576 0144 00000000 		.word	__func__.12
 2577 0148 02000000 		.word	.LC1
 2578              	.LBE46:
 2579              		.cfi_endproc
 2580              	.LFE15:
 2582              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 2583              		.align	1
 2584              		.global	xQueueTakeMutexRecursive
 2585              		.syntax unified
 2586              		.thumb
 2587              		.thumb_func
 2589              	xQueueTakeMutexRecursive:
 2590              	.LVL287:
 2591              	.LFB9:
 774:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 2592              		.loc 1 774 5 is_stmt 1 view -0
 2593              		.cfi_startproc
 2594              		@ args = 0, pretend = 0, frame = 0
 2595              		@ frame_needed = 0, uses_anonymous_args = 0
 775:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 2596              		.loc 1 775 9 view .LVU842
 776:Lib/FreeRTOS/Source/queue.c **** 
 2597              		.loc 1 776 9 view .LVU843
 778:Lib/FreeRTOS/Source/queue.c **** 
 2598              		.loc 1 778 9 view .LVU844
 774:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 2599              		.loc 1 774 5 is_stmt 0 view .LVU845
 2600 0000 70B5     		push	{r4, r5, r6, lr}
 2601              		.cfi_def_cfa_offset 16
 2602              		.cfi_offset 4, -16
 2603              		.cfi_offset 5, -12
 2604              		.cfi_offset 6, -8
 2605              		.cfi_offset 14, -4
 774:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 2606              		.loc 1 774 5 view .LVU846
 2607 0002 0D46     		mov	r5, r1
 778:Lib/FreeRTOS/Source/queue.c **** 
 2608              		.loc 1 778 9 view .LVU847
 2609 0004 0446     		mov	r4, r0
 2610 0006 40B9     		cbnz	r0, .L280
 778:Lib/FreeRTOS/Source/queue.c **** 
 2611              		.loc 1 778 9 is_stmt 1 discriminator 1 view .LVU848
 2612 0008 FFF7FEFF 		bl	ulSetInterruptMask
 2613              	.LVL288:
ARM GAS  /tmp/ccTT1k9d.s 			page 105


 778:Lib/FreeRTOS/Source/queue.c **** 
 2614              		.loc 1 778 9 discriminator 1 view .LVU849
 2615 000c 40F20A31 		movw	r1, #778
 2616 0010 0C4B     		ldr	r3, .L285
 2617 0012 0D4A     		ldr	r2, .L285+4
 2618 0014 0D48     		ldr	r0, .L285+8
 2619 0016 FFF7FEFF 		bl	__assert_func
 2620              	.LVL289:
 2621              	.L280:
 778:Lib/FreeRTOS/Source/queue.c **** 
 2622              		.loc 1 778 32 discriminator 2 view .LVU850
 783:Lib/FreeRTOS/Source/queue.c **** 
 2623              		.loc 1 783 45 view .LVU851
 785:Lib/FreeRTOS/Source/queue.c ****         {
 2624              		.loc 1 785 9 view .LVU852
 785:Lib/FreeRTOS/Source/queue.c ****         {
 2625              		.loc 1 785 34 is_stmt 0 view .LVU853
 2626 001a 8668     		ldr	r6, [r0, #8]
 785:Lib/FreeRTOS/Source/queue.c ****         {
 2627              		.loc 1 785 51 view .LVU854
 2628 001c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 2629              	.LVL290:
 785:Lib/FreeRTOS/Source/queue.c ****         {
 2630              		.loc 1 785 11 discriminator 1 view .LVU855
 2631 0020 8642     		cmp	r6, r0
 2632 0022 04D1     		bne	.L281
 787:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 2633              		.loc 1 787 13 is_stmt 1 view .LVU856
 788:Lib/FreeRTOS/Source/queue.c ****         }
 2634              		.loc 1 788 21 is_stmt 0 view .LVU857
 2635 0024 0120     		movs	r0, #1
 787:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 2636              		.loc 1 787 59 view .LVU858
 2637 0026 E368     		ldr	r3, [r4, #12]
 2638 0028 0133     		adds	r3, r3, #1
 2639 002a E360     		str	r3, [r4, #12]
 788:Lib/FreeRTOS/Source/queue.c ****         }
 2640              		.loc 1 788 13 is_stmt 1 view .LVU859
 2641              	.LVL291:
 2642              	.L279:
 808:Lib/FreeRTOS/Source/queue.c **** 
 2643              		.loc 1 808 5 is_stmt 0 view .LVU860
 2644 002c 70BD     		pop	{r4, r5, r6, pc}
 2645              	.LVL292:
 2646              	.L281:
 792:Lib/FreeRTOS/Source/queue.c **** 
 2647              		.loc 1 792 13 is_stmt 1 view .LVU861
 792:Lib/FreeRTOS/Source/queue.c **** 
 2648              		.loc 1 792 23 is_stmt 0 view .LVU862
 2649 002e 2946     		mov	r1, r5
 2650 0030 2046     		mov	r0, r4
 2651 0032 FFF7FEFF 		bl	xQueueSemaphoreTake
 2652              	.LVL293:
 797:Lib/FreeRTOS/Source/queue.c ****             {
 2653              		.loc 1 797 13 is_stmt 1 view .LVU863
 797:Lib/FreeRTOS/Source/queue.c ****             {
 2654              		.loc 1 797 15 is_stmt 0 view .LVU864
ARM GAS  /tmp/ccTT1k9d.s 			page 106


 2655 0036 0028     		cmp	r0, #0
 2656 0038 F8D0     		beq	.L279
 799:Lib/FreeRTOS/Source/queue.c ****             }
 2657              		.loc 1 799 17 is_stmt 1 view .LVU865
 799:Lib/FreeRTOS/Source/queue.c ****             }
 2658              		.loc 1 799 63 is_stmt 0 view .LVU866
 2659 003a E368     		ldr	r3, [r4, #12]
 2660 003c 0133     		adds	r3, r3, #1
 2661 003e E360     		str	r3, [r4, #12]
 2662 0040 F4E7     		b	.L279
 2663              	.L286:
 2664 0042 00BF     		.align	2
 2665              	.L285:
 2666 0044 00000000 		.word	.LC0
 2667 0048 00000000 		.word	__func__.18
 2668 004c 02000000 		.word	.LC1
 2669              		.cfi_endproc
 2670              	.LFE9:
 2672              		.section	.text.xQueuePeek,"ax",%progbits
 2673              		.align	1
 2674              		.global	xQueuePeek
 2675              		.syntax unified
 2676              		.thumb
 2677              		.thumb_func
 2679              	xQueuePeek:
 2680              	.LVL294:
 2681              	.LFB16:
1783:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2682              		.loc 1 1783 1 is_stmt 1 view -0
 2683              		.cfi_startproc
 2684              		@ args = 0, pretend = 0, frame = 16
 2685              		@ frame_needed = 0, uses_anonymous_args = 0
1784:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 2686              		.loc 1 1784 5 view .LVU868
1785:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
 2687              		.loc 1 1785 5 view .LVU869
1786:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2688              		.loc 1 1786 5 view .LVU870
1787:Lib/FreeRTOS/Source/queue.c **** 
 2689              		.loc 1 1787 5 view .LVU871
1790:Lib/FreeRTOS/Source/queue.c **** 
 2690              		.loc 1 1790 5 view .LVU872
1783:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2691              		.loc 1 1783 1 is_stmt 0 view .LVU873
 2692 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2693              		.cfi_def_cfa_offset 20
 2694              		.cfi_offset 4, -20
 2695              		.cfi_offset 5, -16
 2696              		.cfi_offset 6, -12
 2697              		.cfi_offset 7, -8
 2698              		.cfi_offset 14, -4
 2699 0002 85B0     		sub	sp, sp, #20
 2700              		.cfi_def_cfa_offset 40
1783:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2701              		.loc 1 1783 1 view .LVU874
 2702 0004 0E46     		mov	r6, r1
1790:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 107


 2703              		.loc 1 1790 5 view .LVU875
 2704 0006 0446     		mov	r4, r0
1783:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2705              		.loc 1 1783 1 view .LVU876
 2706 0008 0192     		str	r2, [sp, #4]
1790:Lib/FreeRTOS/Source/queue.c **** 
 2707              		.loc 1 1790 5 view .LVU877
 2708 000a 40B9     		cbnz	r0, .L288
1790:Lib/FreeRTOS/Source/queue.c **** 
 2709              		.loc 1 1790 5 is_stmt 1 discriminator 1 view .LVU878
 2710 000c FFF7FEFF 		bl	ulSetInterruptMask
 2711              	.LVL295:
1790:Lib/FreeRTOS/Source/queue.c **** 
 2712              		.loc 1 1790 5 discriminator 1 view .LVU879
 2713 0010 40F2FE61 		movw	r1, #1790
 2714 0014 3E4B     		ldr	r3, .L320
 2715 0016 3F4A     		ldr	r2, .L320+4
 2716              	.L319:
1794:Lib/FreeRTOS/Source/queue.c **** 
 2717              		.loc 1 1794 5 is_stmt 0 discriminator 1 view .LVU880
 2718 0018 3F48     		ldr	r0, .L320+8
 2719 001a FFF7FEFF 		bl	__assert_func
 2720              	.LVL296:
 2721              	.L288:
1790:Lib/FreeRTOS/Source/queue.c **** 
 2722              		.loc 1 1790 32 is_stmt 1 discriminator 2 view .LVU881
1794:Lib/FreeRTOS/Source/queue.c **** 
 2723              		.loc 1 1794 5 view .LVU882
 2724 001e 41B9     		cbnz	r1, .L289
1794:Lib/FreeRTOS/Source/queue.c **** 
 2725              		.loc 1 1794 5 is_stmt 0 discriminator 2 view .LVU883
 2726 0020 036C     		ldr	r3, [r0, #64]
 2727 0022 33B1     		cbz	r3, .L289
1794:Lib/FreeRTOS/Source/queue.c **** 
 2728              		.loc 1 1794 5 is_stmt 1 discriminator 7 view .LVU884
 2729 0024 FFF7FEFF 		bl	ulSetInterruptMask
 2730              	.LVL297:
1794:Lib/FreeRTOS/Source/queue.c **** 
 2731              		.loc 1 1794 5 discriminator 1 view .LVU885
 2732 0028 40F20271 		movw	r1, #1794
 2733 002c 384B     		ldr	r3, .L320
 2734 002e 394A     		ldr	r2, .L320+4
 2735 0030 F2E7     		b	.L319
 2736              	.LVL298:
 2737              	.L289:
1794:Lib/FreeRTOS/Source/queue.c **** 
 2738              		.loc 1 1794 103 discriminator 8 view .LVU886
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2739              		.loc 1 1799 9 view .LVU887
 2740 0032 FFF7FEFF 		bl	xTaskGetSchedulerState
 2741              	.LVL299:
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2742              		.loc 1 1799 9 is_stmt 0 discriminator 1 view .LVU888
 2743 0036 0546     		mov	r5, r0
 2744 0038 C8B1     		cbz	r0, .L290
 2745 003a 0025     		movs	r5, #0
 2746              	.L292:
ARM GAS  /tmp/ccTT1k9d.s 			page 108


1880:Lib/FreeRTOS/Source/queue.c **** 
 2747              		.loc 1 1880 9 discriminator 1 view .LVU889
 2748 003c 0027     		movs	r7, #0
 2749              	.LVL300:
 2750              	.L291:
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2751              		.loc 1 1799 110 is_stmt 1 discriminator 8 view .LVU890
1806:Lib/FreeRTOS/Source/queue.c ****     {
 2752              		.loc 1 1806 5 view .LVU891
1808:Lib/FreeRTOS/Source/queue.c ****         {
 2753              		.loc 1 1808 9 view .LVU892
 2754 003e FFF7FEFF 		bl	vPortEnterCritical
 2755              	.LVL301:
 2756              	.LBB49:
1810:Lib/FreeRTOS/Source/queue.c **** 
 2757              		.loc 1 1810 13 view .LVU893
1810:Lib/FreeRTOS/Source/queue.c **** 
 2758              		.loc 1 1810 31 is_stmt 0 view .LVU894
 2759 0042 A36B     		ldr	r3, [r4, #56]
 2760              	.LVL302:
1814:Lib/FreeRTOS/Source/queue.c ****             {
 2761              		.loc 1 1814 13 is_stmt 1 view .LVU895
1814:Lib/FreeRTOS/Source/queue.c ****             {
 2762              		.loc 1 1814 15 is_stmt 0 view .LVU896
 2763 0044 EBB1     		cbz	r3, .L293
1819:Lib/FreeRTOS/Source/queue.c **** 
 2764              		.loc 1 1819 17 is_stmt 1 view .LVU897
1821:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
 2765              		.loc 1 1821 17 is_stmt 0 view .LVU898
 2766 0046 3146     		mov	r1, r6
 2767 0048 2046     		mov	r0, r4
1819:Lib/FreeRTOS/Source/queue.c **** 
 2768              		.loc 1 1819 40 view .LVU899
 2769 004a E568     		ldr	r5, [r4, #12]
 2770              	.LVL303:
1821:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
 2771              		.loc 1 1821 17 is_stmt 1 view .LVU900
 2772 004c FFF7FEFF 		bl	prvCopyDataFromQueue
 2773              	.LVL304:
1822:Lib/FreeRTOS/Source/queue.c **** 
 2774              		.loc 1 1822 43 view .LVU901
1825:Lib/FreeRTOS/Source/queue.c **** 
 2775              		.loc 1 1825 17 view .LVU902
1829:Lib/FreeRTOS/Source/queue.c ****                 {
 2776              		.loc 1 1829 21 is_stmt 0 view .LVU903
 2777 0050 636A     		ldr	r3, [r4, #36]
1825:Lib/FreeRTOS/Source/queue.c **** 
 2778              		.loc 1 1825 46 view .LVU904
 2779 0052 E560     		str	r5, [r4, #12]
1829:Lib/FreeRTOS/Source/queue.c ****                 {
 2780              		.loc 1 1829 17 is_stmt 1 view .LVU905
1829:Lib/FreeRTOS/Source/queue.c ****                 {
 2781              		.loc 1 1829 19 is_stmt 0 view .LVU906
 2782 0054 33B1     		cbz	r3, .L295
1831:Lib/FreeRTOS/Source/queue.c ****                     {
 2783              		.loc 1 1831 21 is_stmt 1 view .LVU907
1831:Lib/FreeRTOS/Source/queue.c ****                     {
ARM GAS  /tmp/ccTT1k9d.s 			page 109


 2784              		.loc 1 1831 25 is_stmt 0 view .LVU908
 2785 0056 04F12400 		add	r0, r4, #36
 2786 005a FFF7FEFF 		bl	xTaskRemoveFromEventList
 2787              	.LVL305:
1831:Lib/FreeRTOS/Source/queue.c ****                     {
 2788              		.loc 1 1831 23 discriminator 1 view .LVU909
 2789 005e 08B1     		cbz	r0, .L295
1834:Lib/FreeRTOS/Source/queue.c ****                     }
 2790              		.loc 1 1834 25 is_stmt 1 view .LVU910
 2791 0060 FFF7FEFF 		bl	vPortYield
 2792              	.LVL306:
 2793              	.L295:
1843:Lib/FreeRTOS/Source/queue.c ****                 }
 2794              		.loc 1 1843 45 view .LVU911
1846:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 2795              		.loc 1 1846 17 view .LVU912
 2796 0064 FFF7FEFF 		bl	vPortExitCritical
 2797              	.LVL307:
1847:Lib/FreeRTOS/Source/queue.c ****             }
 2798              		.loc 1 1847 17 view .LVU913
1847:Lib/FreeRTOS/Source/queue.c ****             }
 2799              		.loc 1 1847 24 is_stmt 0 view .LVU914
 2800 0068 0120     		movs	r0, #1
 2801              	.LVL308:
 2802              	.L287:
1847:Lib/FreeRTOS/Source/queue.c ****             }
 2803              		.loc 1 1847 24 view .LVU915
 2804              	.LBE49:
1928:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 2805              		.loc 1 1928 1 view .LVU916
 2806 006a 05B0     		add	sp, sp, #20
 2807              		.cfi_remember_state
 2808              		.cfi_def_cfa_offset 20
 2809              		@ sp needed
 2810 006c F0BD     		pop	{r4, r5, r6, r7, pc}
 2811              	.LVL309:
 2812              	.L290:
 2813              		.cfi_restore_state
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2814              		.loc 1 1799 9 discriminator 2 view .LVU917
 2815 006e 019B     		ldr	r3, [sp, #4]
 2816 0070 002B     		cmp	r3, #0
 2817 0072 E3D0     		beq	.L292
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2818              		.loc 1 1799 9 is_stmt 1 discriminator 7 view .LVU918
 2819 0074 FFF7FEFF 		bl	ulSetInterruptMask
 2820              	.LVL310:
1799:Lib/FreeRTOS/Source/queue.c ****     }
 2821              		.loc 1 1799 9 discriminator 1 view .LVU919
 2822 0078 40F20771 		movw	r1, #1799
 2823 007c 244B     		ldr	r3, .L320
 2824 007e 254A     		ldr	r2, .L320+4
 2825 0080 CAE7     		b	.L319
 2826              	.LVL311:
 2827              	.L293:
 2828              	.LBB50:
1851:Lib/FreeRTOS/Source/queue.c ****                 {
ARM GAS  /tmp/ccTT1k9d.s 			page 110


 2829              		.loc 1 1851 17 view .LVU920
1851:Lib/FreeRTOS/Source/queue.c ****                 {
 2830              		.loc 1 1851 19 is_stmt 0 view .LVU921
 2831 0082 019B     		ldr	r3, [sp, #4]
 2832              	.LVL312:
1851:Lib/FreeRTOS/Source/queue.c ****                 {
 2833              		.loc 1 1851 19 view .LVU922
 2834 0084 1BB9     		cbnz	r3, .L298
1855:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
 2835              		.loc 1 1855 21 is_stmt 1 view .LVU923
 2836 0086 FFF7FEFF 		bl	vPortExitCritical
 2837              	.LVL313:
1856:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
 2838              		.loc 1 1856 54 view .LVU924
1857:Lib/FreeRTOS/Source/queue.c ****                 }
 2839              		.loc 1 1857 21 view .LVU925
 2840              	.L299:
1857:Lib/FreeRTOS/Source/queue.c ****                 }
 2841              		.loc 1 1857 28 is_stmt 0 view .LVU926
 2842 008a 0020     		movs	r0, #0
 2843 008c EDE7     		b	.L287
 2844              	.LVL314:
 2845              	.L298:
1859:Lib/FreeRTOS/Source/queue.c ****                 {
 2846              		.loc 1 1859 22 is_stmt 1 view .LVU927
1859:Lib/FreeRTOS/Source/queue.c ****                 {
 2847              		.loc 1 1859 24 is_stmt 0 view .LVU928
 2848 008e 15B9     		cbnz	r5, .L300
1864:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2849              		.loc 1 1864 21 is_stmt 1 view .LVU929
 2850 0090 02A8     		add	r0, sp, #8
 2851 0092 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
 2852              	.LVL315:
1865:Lib/FreeRTOS/Source/queue.c ****                 }
 2853              		.loc 1 1865 21 view .LVU930
 2854              	.L300:
1870:Lib/FreeRTOS/Source/queue.c ****                 }
 2855              		.loc 1 1870 45 view .LVU931
 2856              	.LBE50:
1874:Lib/FreeRTOS/Source/queue.c **** 
 2857              		.loc 1 1874 9 view .LVU932
 2858 0096 FFF7FEFF 		bl	vPortExitCritical
 2859              	.LVL316:
1879:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2860              		.loc 1 1879 9 view .LVU933
 2861 009a FFF7FEFF 		bl	vTaskSuspendAll
 2862              	.LVL317:
1880:Lib/FreeRTOS/Source/queue.c **** 
 2863              		.loc 1 1880 9 view .LVU934
 2864 009e FFF7FEFF 		bl	vPortEnterCritical
 2865              	.LVL318:
1880:Lib/FreeRTOS/Source/queue.c **** 
 2866              		.loc 1 1880 9 discriminator 1 view .LVU935
 2867 00a2 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 2868 00a6 FF2B     		cmp	r3, #255
1880:Lib/FreeRTOS/Source/queue.c **** 
 2869              		.loc 1 1880 9 discriminator 1 view .LVU936
ARM GAS  /tmp/ccTT1k9d.s 			page 111


 2870 00a8 08BF     		it	eq
 2871 00aa 84F84470 		strbeq	r7, [r4, #68]
1880:Lib/FreeRTOS/Source/queue.c **** 
 2872              		.loc 1 1880 9 discriminator 3 view .LVU937
 2873 00ae 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 2874 00b2 FF2B     		cmp	r3, #255
1880:Lib/FreeRTOS/Source/queue.c **** 
 2875              		.loc 1 1880 9 discriminator 4 view .LVU938
 2876 00b4 08BF     		it	eq
 2877 00b6 84F84570 		strbeq	r7, [r4, #69]
1880:Lib/FreeRTOS/Source/queue.c **** 
 2878              		.loc 1 1880 9 discriminator 6 view .LVU939
 2879 00ba FFF7FEFF 		bl	vPortExitCritical
 2880              	.LVL319:
1883:Lib/FreeRTOS/Source/queue.c ****         {
 2881              		.loc 1 1883 9 view .LVU940
1883:Lib/FreeRTOS/Source/queue.c ****         {
 2882              		.loc 1 1883 13 is_stmt 0 view .LVU941
 2883 00be 01A9     		add	r1, sp, #4
 2884 00c0 02A8     		add	r0, sp, #8
 2885 00c2 FFF7FEFF 		bl	xTaskCheckForTimeOut
 2886              	.LVL320:
1883:Lib/FreeRTOS/Source/queue.c ****         {
 2887              		.loc 1 1883 11 discriminator 1 view .LVU942
 2888 00c6 C0B9     		cbnz	r0, .L303
1887:Lib/FreeRTOS/Source/queue.c ****             {
 2889              		.loc 1 1887 13 is_stmt 1 view .LVU943
1887:Lib/FreeRTOS/Source/queue.c ****             {
 2890              		.loc 1 1887 17 is_stmt 0 view .LVU944
 2891 00c8 2046     		mov	r0, r4
 2892 00ca FFF7FEFF 		bl	prvIsQueueEmpty
 2893              	.LVL321:
1887:Lib/FreeRTOS/Source/queue.c ****             {
 2894              		.loc 1 1887 15 discriminator 1 view .LVU945
 2895 00ce 70B1     		cbz	r0, .L304
1889:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2896              		.loc 1 1889 55 is_stmt 1 view .LVU946
1890:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2897              		.loc 1 1890 17 view .LVU947
 2898 00d0 0199     		ldr	r1, [sp, #4]
 2899 00d2 04F12400 		add	r0, r4, #36
 2900 00d6 FFF7FEFF 		bl	vTaskPlaceOnEventList
 2901              	.LVL322:
1891:Lib/FreeRTOS/Source/queue.c **** 
 2902              		.loc 1 1891 17 view .LVU948
 2903 00da 2046     		mov	r0, r4
 2904 00dc FFF7FEFF 		bl	prvUnlockQueue
 2905              	.LVL323:
1893:Lib/FreeRTOS/Source/queue.c ****                 {
 2906              		.loc 1 1893 17 view .LVU949
1893:Lib/FreeRTOS/Source/queue.c ****                 {
 2907              		.loc 1 1893 21 is_stmt 0 view .LVU950
 2908 00e0 FFF7FEFF 		bl	xTaskResumeAll
 2909              	.LVL324:
1893:Lib/FreeRTOS/Source/queue.c ****                 {
 2910              		.loc 1 1893 19 discriminator 1 view .LVU951
 2911 00e4 08B9     		cbnz	r0, .L306
ARM GAS  /tmp/ccTT1k9d.s 			page 112


1895:Lib/FreeRTOS/Source/queue.c ****                 }
 2912              		.loc 1 1895 21 is_stmt 1 view .LVU952
 2913 00e6 FFF7FEFF 		bl	vPortYield
 2914              	.LVL325:
 2915              	.L306:
 2916 00ea 0125     		movs	r5, #1
 2917 00ec A7E7     		b	.L291
 2918              	.L304:
1906:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2919              		.loc 1 1906 17 view .LVU953
 2920 00ee 2046     		mov	r0, r4
 2921 00f0 FFF7FEFF 		bl	prvUnlockQueue
 2922              	.LVL326:
1907:Lib/FreeRTOS/Source/queue.c ****             }
 2923              		.loc 1 1907 17 view .LVU954
1907:Lib/FreeRTOS/Source/queue.c ****             }
 2924              		.loc 1 1907 26 is_stmt 0 view .LVU955
 2925 00f4 FFF7FEFF 		bl	xTaskResumeAll
 2926              	.LVL327:
 2927 00f8 F7E7     		b	.L306
 2928              	.L303:
1914:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2929              		.loc 1 1914 13 is_stmt 1 view .LVU956
 2930 00fa 2046     		mov	r0, r4
 2931 00fc FFF7FEFF 		bl	prvUnlockQueue
 2932              	.LVL328:
1915:Lib/FreeRTOS/Source/queue.c **** 
 2933              		.loc 1 1915 13 view .LVU957
1915:Lib/FreeRTOS/Source/queue.c **** 
 2934              		.loc 1 1915 22 is_stmt 0 view .LVU958
 2935 0100 FFF7FEFF 		bl	xTaskResumeAll
 2936              	.LVL329:
1917:Lib/FreeRTOS/Source/queue.c ****             {
 2937              		.loc 1 1917 13 is_stmt 1 view .LVU959
1917:Lib/FreeRTOS/Source/queue.c ****             {
 2938              		.loc 1 1917 17 is_stmt 0 view .LVU960
 2939 0104 2046     		mov	r0, r4
 2940 0106 FFF7FEFF 		bl	prvIsQueueEmpty
 2941              	.LVL330:
1917:Lib/FreeRTOS/Source/queue.c ****             {
 2942              		.loc 1 1917 15 discriminator 1 view .LVU961
 2943 010a 0028     		cmp	r0, #0
 2944 010c EDD0     		beq	.L306
 2945 010e BCE7     		b	.L299
 2946              	.L321:
 2947              		.align	2
 2948              	.L320:
 2949 0110 00000000 		.word	.LC0
 2950 0114 00000000 		.word	__func__.11
 2951 0118 02000000 		.word	.LC1
 2952              		.cfi_endproc
 2953              	.LFE16:
 2955              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 2956              		.align	1
 2957              		.global	xQueueReceiveFromISR
 2958              		.syntax unified
 2959              		.thumb
ARM GAS  /tmp/ccTT1k9d.s 			page 113


 2960              		.thumb_func
 2962              	xQueueReceiveFromISR:
 2963              	.LVL331:
 2964              	.LFB17:
1934:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 2965              		.loc 1 1934 1 is_stmt 1 view -0
 2966              		.cfi_startproc
 2967              		@ args = 0, pretend = 0, frame = 0
 2968              		@ frame_needed = 0, uses_anonymous_args = 0
1935:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 2969              		.loc 1 1935 5 view .LVU963
1936:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2970              		.loc 1 1936 5 view .LVU964
1937:Lib/FreeRTOS/Source/queue.c **** 
 2971              		.loc 1 1937 5 view .LVU965
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2972              		.loc 1 1939 5 view .LVU966
1934:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 2973              		.loc 1 1934 1 is_stmt 0 view .LVU967
 2974 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 2975              		.cfi_def_cfa_offset 32
 2976              		.cfi_offset 3, -32
 2977              		.cfi_offset 4, -28
 2978              		.cfi_offset 5, -24
 2979              		.cfi_offset 6, -20
 2980              		.cfi_offset 7, -16
 2981              		.cfi_offset 8, -12
 2982              		.cfi_offset 9, -8
 2983              		.cfi_offset 14, -4
1934:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 2984              		.loc 1 1934 1 view .LVU968
 2985 0004 8946     		mov	r9, r1
 2986 0006 9046     		mov	r8, r2
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2987              		.loc 1 1939 5 view .LVU969
 2988 0008 0446     		mov	r4, r0
 2989 000a 40B9     		cbnz	r0, .L323
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2990              		.loc 1 1939 5 is_stmt 1 discriminator 1 view .LVU970
 2991 000c FFF7FEFF 		bl	ulSetInterruptMask
 2992              	.LVL332:
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2993              		.loc 1 1939 5 discriminator 1 view .LVU971
 2994 0010 40F29371 		movw	r1, #1939
 2995 0014 234B     		ldr	r3, .L342
 2996 0016 244A     		ldr	r2, .L342+4
 2997              	.L341:
1940:Lib/FreeRTOS/Source/queue.c **** 
 2998              		.loc 1 1940 5 is_stmt 0 discriminator 1 view .LVU972
 2999 0018 2448     		ldr	r0, .L342+8
 3000 001a FFF7FEFF 		bl	__assert_func
 3001              	.LVL333:
 3002              	.L323:
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3003              		.loc 1 1939 28 is_stmt 1 discriminator 2 view .LVU973
1940:Lib/FreeRTOS/Source/queue.c **** 
 3004              		.loc 1 1940 5 view .LVU974
ARM GAS  /tmp/ccTT1k9d.s 			page 114


 3005 001e 41B9     		cbnz	r1, .L324
1940:Lib/FreeRTOS/Source/queue.c **** 
 3006              		.loc 1 1940 5 is_stmt 0 discriminator 2 view .LVU975
 3007 0020 036C     		ldr	r3, [r0, #64]
 3008 0022 33B1     		cbz	r3, .L324
1940:Lib/FreeRTOS/Source/queue.c **** 
 3009              		.loc 1 1940 5 is_stmt 1 discriminator 7 view .LVU976
 3010 0024 FFF7FEFF 		bl	ulSetInterruptMask
 3011              	.LVL334:
1940:Lib/FreeRTOS/Source/queue.c **** 
 3012              		.loc 1 1940 5 discriminator 1 view .LVU977
 3013 0028 40F29471 		movw	r1, #1940
 3014 002c 1D4B     		ldr	r3, .L342
 3015 002e 1E4A     		ldr	r2, .L342+4
 3016 0030 F2E7     		b	.L341
 3017              	.LVL335:
 3018              	.L324:
1940:Lib/FreeRTOS/Source/queue.c **** 
 3019              		.loc 1 1940 95 discriminator 8 view .LVU978
1956:Lib/FreeRTOS/Source/queue.c **** 
 3020              		.loc 1 1956 5 view .LVU979
 3021 0032 FFF7FEFF 		bl	vPortValidateInterruptPriority
 3022              	.LVL336:
1958:Lib/FreeRTOS/Source/queue.c ****     {
 3023              		.loc 1 1958 5 view .LVU980
1958:Lib/FreeRTOS/Source/queue.c ****     {
 3024              		.loc 1 1958 30 is_stmt 0 view .LVU981
 3025 0036 FFF7FEFF 		bl	ulSetInterruptMask
 3026              	.LVL337:
 3027              	.LBB51:
1960:Lib/FreeRTOS/Source/queue.c **** 
 3028              		.loc 1 1960 27 view .LVU982
 3029 003a A66B     		ldr	r6, [r4, #56]
 3030              	.LBE51:
1958:Lib/FreeRTOS/Source/queue.c ****     {
 3031              		.loc 1 1958 30 view .LVU983
 3032 003c 0746     		mov	r7, r0
 3033              	.LVL338:
 3034              	.LBB55:
1960:Lib/FreeRTOS/Source/queue.c **** 
 3035              		.loc 1 1960 9 is_stmt 1 view .LVU984
1963:Lib/FreeRTOS/Source/queue.c ****         {
 3036              		.loc 1 1963 9 view .LVU985
1963:Lib/FreeRTOS/Source/queue.c ****         {
 3037              		.loc 1 1963 11 is_stmt 0 view .LVU986
 3038 003e C6B1     		cbz	r6, .L325
 3039              	.LBB52:
1965:Lib/FreeRTOS/Source/queue.c **** 
 3040              		.loc 1 1965 13 is_stmt 1 view .LVU987
1965:Lib/FreeRTOS/Source/queue.c **** 
 3041              		.loc 1 1965 26 is_stmt 0 view .LVU988
 3042 0040 94F84450 		ldrb	r5, [r4, #68]	@ zero_extendqisi2
1969:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 3043              		.loc 1 1969 13 view .LVU989
 3044 0044 4946     		mov	r1, r9
 3045 0046 2046     		mov	r0, r4
 3046              	.LVL339:
ARM GAS  /tmp/ccTT1k9d.s 			page 115


1965:Lib/FreeRTOS/Source/queue.c **** 
 3047              		.loc 1 1965 26 view .LVU990
 3048 0048 6DB2     		sxtb	r5, r5
 3049              	.LVL340:
1967:Lib/FreeRTOS/Source/queue.c **** 
 3050              		.loc 1 1967 51 is_stmt 1 view .LVU991
1969:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 3051              		.loc 1 1969 13 view .LVU992
 3052 004a FFF7FEFF 		bl	prvCopyDataFromQueue
 3053              	.LVL341:
1970:Lib/FreeRTOS/Source/queue.c **** 
 3054              		.loc 1 1970 13 view .LVU993
1970:Lib/FreeRTOS/Source/queue.c **** 
 3055              		.loc 1 1970 60 is_stmt 0 view .LVU994
 3056 004e 013E     		subs	r6, r6, #1
 3057              	.LVL342:
1976:Lib/FreeRTOS/Source/queue.c ****             {
 3058              		.loc 1 1976 15 view .LVU995
 3059 0050 6B1C     		adds	r3, r5, #1
1970:Lib/FreeRTOS/Source/queue.c **** 
 3060              		.loc 1 1970 40 view .LVU996
 3061 0052 A663     		str	r6, [r4, #56]
1976:Lib/FreeRTOS/Source/queue.c ****             {
 3062              		.loc 1 1976 13 is_stmt 1 view .LVU997
1976:Lib/FreeRTOS/Source/queue.c ****             {
 3063              		.loc 1 1976 15 is_stmt 0 view .LVU998
 3064 0054 13D1     		bne	.L326
1978:Lib/FreeRTOS/Source/queue.c ****                 {
 3065              		.loc 1 1978 17 is_stmt 1 view .LVU999
1978:Lib/FreeRTOS/Source/queue.c ****                 {
 3066              		.loc 1 1978 21 is_stmt 0 view .LVU1000
 3067 0056 2369     		ldr	r3, [r4, #16]
1978:Lib/FreeRTOS/Source/queue.c ****                 {
 3068              		.loc 1 1978 19 view .LVU1001
 3069 0058 53B1     		cbz	r3, .L328
1980:Lib/FreeRTOS/Source/queue.c ****                     {
 3070              		.loc 1 1980 21 is_stmt 1 view .LVU1002
1980:Lib/FreeRTOS/Source/queue.c ****                     {
 3071              		.loc 1 1980 25 is_stmt 0 view .LVU1003
 3072 005a 04F11000 		add	r0, r4, #16
 3073 005e FFF7FEFF 		bl	xTaskRemoveFromEventList
 3074              	.LVL343:
1980:Lib/FreeRTOS/Source/queue.c ****                     {
 3075              		.loc 1 1980 23 discriminator 1 view .LVU1004
 3076 0062 28B1     		cbz	r0, .L328
1984:Lib/FreeRTOS/Source/queue.c ****                         {
 3077              		.loc 1 1984 25 is_stmt 1 view .LVU1005
1984:Lib/FreeRTOS/Source/queue.c ****                         {
 3078              		.loc 1 1984 27 is_stmt 0 view .LVU1006
 3079 0064 B8F1000F 		cmp	r8, #0
 3080 0068 02D0     		beq	.L328
1986:Lib/FreeRTOS/Source/queue.c ****                         }
 3081              		.loc 1 1986 29 is_stmt 1 view .LVU1007
1986:Lib/FreeRTOS/Source/queue.c ****                         }
 3082              		.loc 1 1986 56 is_stmt 0 view .LVU1008
 3083 006a 0123     		movs	r3, #1
 3084 006c C8F80030 		str	r3, [r8]
ARM GAS  /tmp/ccTT1k9d.s 			page 116


 3085              	.LVL344:
 3086              	.L328:
2010:Lib/FreeRTOS/Source/queue.c ****         }
 3087              		.loc 1 2010 21 view .LVU1009
 3088 0070 0126     		movs	r6, #1
 3089              	.LVL345:
 3090              	.L325:
2010:Lib/FreeRTOS/Source/queue.c ****         }
 3091              		.loc 1 2010 21 view .LVU1010
 3092              	.LBE52:
2015:Lib/FreeRTOS/Source/queue.c ****         }
 3093              		.loc 1 2015 58 is_stmt 1 view .LVU1011
 3094              	.LBE55:
2018:Lib/FreeRTOS/Source/queue.c **** 
 3095              		.loc 1 2018 5 view .LVU1012
 3096 0072 3846     		mov	r0, r7
 3097 0074 FFF7FEFF 		bl	vClearInterruptMask
 3098              	.LVL346:
2020:Lib/FreeRTOS/Source/queue.c **** }
 3099              		.loc 1 2020 5 view .LVU1013
2021:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3100              		.loc 1 2021 1 is_stmt 0 view .LVU1014
 3101 0078 3046     		mov	r0, r6
 3102 007a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 3103              	.LVL347:
 3104              	.L326:
 3105              	.LBB56:
 3106              	.LBB54:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3107              		.loc 1 2007 17 is_stmt 1 view .LVU1015
 3108              	.LBB53:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3109              		.loc 1 2007 17 view .LVU1016
 3110 007e FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 3111              	.LVL348:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3112              		.loc 1 2007 17 discriminator 1 view .LVU1017
 3113 0082 8542     		cmp	r5, r0
 3114 0084 F4D2     		bcs	.L328
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3115              		.loc 1 2007 17 discriminator 1 view .LVU1018
 3116 0086 7F2D     		cmp	r5, #127
 3117 0088 06D1     		bne	.L330
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3118              		.loc 1 2007 17 discriminator 3 view .LVU1019
 3119 008a FFF7FEFF 		bl	ulSetInterruptMask
 3120              	.LVL349:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3121              		.loc 1 2007 17 discriminator 1 view .LVU1020
 3122 008e 40F2D771 		movw	r1, #2007
 3123 0092 044B     		ldr	r3, .L342
 3124 0094 044A     		ldr	r2, .L342+4
 3125 0096 BFE7     		b	.L341
 3126              	.LVL350:
 3127              	.L330:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3128              		.loc 1 2007 17 discriminator 4 view .LVU1021
ARM GAS  /tmp/ccTT1k9d.s 			page 117


2007:Lib/FreeRTOS/Source/queue.c ****             }
 3129              		.loc 1 2007 17 discriminator 4 view .LVU1022
 3130 0098 0135     		adds	r5, r5, #1
 3131              	.LVL351:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3132              		.loc 1 2007 17 is_stmt 0 discriminator 4 view .LVU1023
 3133 009a 6DB2     		sxtb	r5, r5
 3134              	.LVL352:
2007:Lib/FreeRTOS/Source/queue.c ****             }
 3135              		.loc 1 2007 17 discriminator 4 view .LVU1024
 3136 009c 84F84450 		strb	r5, [r4, #68]
 3137 00a0 E6E7     		b	.L328
 3138              	.L343:
 3139 00a2 00BF     		.align	2
 3140              	.L342:
 3141 00a4 00000000 		.word	.LC0
 3142 00a8 00000000 		.word	__func__.10
 3143 00ac 02000000 		.word	.LC1
 3144              	.LBE53:
 3145              	.LBE54:
 3146              	.LBE56:
 3147              		.cfi_endproc
 3148              	.LFE17:
 3150              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 3151              		.align	1
 3152              		.global	xQueuePeekFromISR
 3153              		.syntax unified
 3154              		.thumb
 3155              		.thumb_func
 3157              	xQueuePeekFromISR:
 3158              	.LVL353:
 3159              	.LFB18:
2026:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3160              		.loc 1 2026 1 is_stmt 1 view -0
 3161              		.cfi_startproc
 3162              		@ args = 0, pretend = 0, frame = 0
 3163              		@ frame_needed = 0, uses_anonymous_args = 0
2027:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
 3164              		.loc 1 2027 5 view .LVU1026
2028:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
 3165              		.loc 1 2028 5 view .LVU1027
2029:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3166              		.loc 1 2029 5 view .LVU1028
2030:Lib/FreeRTOS/Source/queue.c **** 
 3167              		.loc 1 2030 5 view .LVU1029
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3168              		.loc 1 2032 5 view .LVU1030
2026:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3169              		.loc 1 2026 1 is_stmt 0 view .LVU1031
 3170 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3171              		.cfi_def_cfa_offset 24
 3172              		.cfi_offset 3, -24
 3173              		.cfi_offset 4, -20
 3174              		.cfi_offset 5, -16
 3175              		.cfi_offset 6, -12
 3176              		.cfi_offset 7, -8
 3177              		.cfi_offset 14, -4
ARM GAS  /tmp/ccTT1k9d.s 			page 118


2026:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3178              		.loc 1 2026 1 view .LVU1032
 3179 0002 0D46     		mov	r5, r1
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3180              		.loc 1 2032 5 view .LVU1033
 3181 0004 0446     		mov	r4, r0
 3182 0006 40B9     		cbnz	r0, .L345
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3183              		.loc 1 2032 5 is_stmt 1 discriminator 1 view .LVU1034
 3184 0008 FFF7FEFF 		bl	ulSetInterruptMask
 3185              	.LVL354:
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3186              		.loc 1 2032 5 discriminator 1 view .LVU1035
 3187 000c 4FF4FE61 		mov	r1, #2032
 3188 0010 154B     		ldr	r3, .L355
 3189 0012 164A     		ldr	r2, .L355+4
 3190              	.L354:
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3191              		.loc 1 2033 5 is_stmt 0 discriminator 1 view .LVU1036
 3192 0014 1648     		ldr	r0, .L355+8
 3193 0016 FFF7FEFF 		bl	__assert_func
 3194              	.LVL355:
 3195              	.L345:
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 3196              		.loc 1 2032 28 is_stmt 1 discriminator 2 view .LVU1037
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3197              		.loc 1 2033 5 view .LVU1038
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3198              		.loc 1 2033 5 is_stmt 0 discriminator 2 view .LVU1039
 3199 001a 036C     		ldr	r3, [r0, #64]
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3200              		.loc 1 2033 5 view .LVU1040
 3201 001c 39B9     		cbnz	r1, .L346
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3202              		.loc 1 2033 5 discriminator 2 view .LVU1041
 3203 001e 3BB1     		cbz	r3, .L347
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3204              		.loc 1 2033 5 is_stmt 1 discriminator 7 view .LVU1042
 3205 0020 FFF7FEFF 		bl	ulSetInterruptMask
 3206              	.LVL356:
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3207              		.loc 1 2033 5 discriminator 1 view .LVU1043
 3208 0024 40F2F171 		movw	r1, #2033
 3209 0028 0F4B     		ldr	r3, .L355
 3210 002a 104A     		ldr	r2, .L355+4
 3211 002c F2E7     		b	.L354
 3212              	.LVL357:
 3213              	.L346:
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 3214              		.loc 1 2033 95 discriminator 8 view .LVU1044
2034:Lib/FreeRTOS/Source/queue.c **** 
 3215              		.loc 1 2034 5 view .LVU1045
 3216 002e 33B9     		cbnz	r3, .L348
 3217              	.L347:
2034:Lib/FreeRTOS/Source/queue.c **** 
 3218              		.loc 1 2034 5 discriminator 1 view .LVU1046
 3219 0030 FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/ccTT1k9d.s 			page 119


 3220              	.LVL358:
2034:Lib/FreeRTOS/Source/queue.c **** 
 3221              		.loc 1 2034 5 discriminator 1 view .LVU1047
 3222 0034 40F2F271 		movw	r1, #2034
 3223 0038 0B4B     		ldr	r3, .L355
 3224 003a 0C4A     		ldr	r2, .L355+4
 3225 003c EAE7     		b	.L354
 3226              	.LVL359:
 3227              	.L348:
2034:Lib/FreeRTOS/Source/queue.c **** 
 3228              		.loc 1 2034 45 discriminator 2 view .LVU1048
2050:Lib/FreeRTOS/Source/queue.c **** 
 3229              		.loc 1 2050 5 view .LVU1049
 3230 003e FFF7FEFF 		bl	vPortValidateInterruptPriority
 3231              	.LVL360:
2052:Lib/FreeRTOS/Source/queue.c ****     {
 3232              		.loc 1 2052 5 view .LVU1050
2052:Lib/FreeRTOS/Source/queue.c ****     {
 3233              		.loc 1 2052 30 is_stmt 0 view .LVU1051
 3234 0042 FFF7FEFF 		bl	ulSetInterruptMask
 3235              	.LVL361:
2055:Lib/FreeRTOS/Source/queue.c ****         {
 3236              		.loc 1 2055 20 view .LVU1052
 3237 0046 A36B     		ldr	r3, [r4, #56]
2052:Lib/FreeRTOS/Source/queue.c ****     {
 3238              		.loc 1 2052 30 view .LVU1053
 3239 0048 0646     		mov	r6, r0
 3240              	.LVL362:
2055:Lib/FreeRTOS/Source/queue.c ****         {
 3241              		.loc 1 2055 9 is_stmt 1 view .LVU1054
2069:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 3242              		.loc 1 2069 21 is_stmt 0 view .LVU1055
 3243 004a 1F46     		mov	r7, r3
2055:Lib/FreeRTOS/Source/queue.c ****         {
 3244              		.loc 1 2055 11 view .LVU1056
 3245 004c 33B1     		cbz	r3, .L349
2057:Lib/FreeRTOS/Source/queue.c **** 
 3246              		.loc 1 2057 48 is_stmt 1 view .LVU1057
2061:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 3247              		.loc 1 2061 13 view .LVU1058
2061:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 3248              		.loc 1 2061 36 is_stmt 0 view .LVU1059
 3249 004e E768     		ldr	r7, [r4, #12]
 3250              	.LVL363:
2062:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 3251              		.loc 1 2062 13 is_stmt 1 view .LVU1060
 3252 0050 2946     		mov	r1, r5
 3253 0052 2046     		mov	r0, r4
 3254              	.LVL364:
2062:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 3255              		.loc 1 2062 13 is_stmt 0 view .LVU1061
 3256 0054 FFF7FEFF 		bl	prvCopyDataFromQueue
 3257              	.LVL365:
2063:Lib/FreeRTOS/Source/queue.c **** 
 3258              		.loc 1 2063 13 is_stmt 1 view .LVU1062
2063:Lib/FreeRTOS/Source/queue.c **** 
 3259              		.loc 1 2063 42 is_stmt 0 view .LVU1063
ARM GAS  /tmp/ccTT1k9d.s 			page 120


 3260 0058 E760     		str	r7, [r4, #12]
2065:Lib/FreeRTOS/Source/queue.c ****         }
 3261              		.loc 1 2065 13 is_stmt 1 view .LVU1064
 3262              	.LVL366:
2065:Lib/FreeRTOS/Source/queue.c ****         }
 3263              		.loc 1 2065 21 is_stmt 0 view .LVU1065
 3264 005a 0127     		movs	r7, #1
 3265              	.LVL367:
 3266              	.L349:
2070:Lib/FreeRTOS/Source/queue.c ****         }
 3267              		.loc 1 2070 55 is_stmt 1 view .LVU1066
2073:Lib/FreeRTOS/Source/queue.c **** 
 3268              		.loc 1 2073 5 view .LVU1067
 3269 005c 3046     		mov	r0, r6
 3270 005e FFF7FEFF 		bl	vClearInterruptMask
 3271              	.LVL368:
2075:Lib/FreeRTOS/Source/queue.c **** }
 3272              		.loc 1 2075 5 view .LVU1068
2076:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3273              		.loc 1 2076 1 is_stmt 0 view .LVU1069
 3274 0062 3846     		mov	r0, r7
 3275 0064 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3276              	.LVL369:
 3277              	.L356:
2076:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3278              		.loc 1 2076 1 view .LVU1070
 3279 0066 00BF     		.align	2
 3280              	.L355:
 3281 0068 00000000 		.word	.LC0
 3282 006c 00000000 		.word	__func__.9
 3283 0070 02000000 		.word	.LC1
 3284              		.cfi_endproc
 3285              	.LFE18:
 3287              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 3288              		.align	1
 3289              		.global	uxQueueMessagesWaiting
 3290              		.syntax unified
 3291              		.thumb
 3292              		.thumb_func
 3294              	uxQueueMessagesWaiting:
 3295              	.LVL370:
 3296              	.LFB19:
2080:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3297              		.loc 1 2080 1 is_stmt 1 view -0
 3298              		.cfi_startproc
 3299              		@ args = 0, pretend = 0, frame = 0
 3300              		@ frame_needed = 0, uses_anonymous_args = 0
2081:Lib/FreeRTOS/Source/queue.c **** 
 3301              		.loc 1 2081 5 view .LVU1072
2083:Lib/FreeRTOS/Source/queue.c **** 
 3302              		.loc 1 2083 5 view .LVU1073
2080:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3303              		.loc 1 2080 1 is_stmt 0 view .LVU1074
 3304 0000 10B5     		push	{r4, lr}
 3305              		.cfi_def_cfa_offset 8
 3306              		.cfi_offset 4, -8
 3307              		.cfi_offset 14, -4
ARM GAS  /tmp/ccTT1k9d.s 			page 121


2083:Lib/FreeRTOS/Source/queue.c **** 
 3308              		.loc 1 2083 5 view .LVU1075
 3309 0002 0446     		mov	r4, r0
 3310 0004 40B9     		cbnz	r0, .L358
2083:Lib/FreeRTOS/Source/queue.c **** 
 3311              		.loc 1 2083 5 is_stmt 1 discriminator 1 view .LVU1076
 3312 0006 FFF7FEFF 		bl	ulSetInterruptMask
 3313              	.LVL371:
2083:Lib/FreeRTOS/Source/queue.c **** 
 3314              		.loc 1 2083 5 discriminator 1 view .LVU1077
 3315 000a 40F62301 		movw	r1, #2083
 3316 000e 064B     		ldr	r3, .L359
 3317 0010 064A     		ldr	r2, .L359+4
 3318 0012 0748     		ldr	r0, .L359+8
 3319 0014 FFF7FEFF 		bl	__assert_func
 3320              	.LVL372:
 3321              	.L358:
2083:Lib/FreeRTOS/Source/queue.c **** 
 3322              		.loc 1 2083 27 discriminator 2 view .LVU1078
2085:Lib/FreeRTOS/Source/queue.c ****     {
 3323              		.loc 1 2085 5 view .LVU1079
 3324 0018 FFF7FEFF 		bl	vPortEnterCritical
 3325              	.LVL373:
2087:Lib/FreeRTOS/Source/queue.c ****     }
 3326              		.loc 1 2087 9 view .LVU1080
2087:Lib/FreeRTOS/Source/queue.c ****     }
 3327              		.loc 1 2087 18 is_stmt 0 view .LVU1081
 3328 001c A46B     		ldr	r4, [r4, #56]
 3329              	.LVL374:
2089:Lib/FreeRTOS/Source/queue.c **** 
 3330              		.loc 1 2089 5 is_stmt 1 view .LVU1082
 3331 001e FFF7FEFF 		bl	vPortExitCritical
 3332              	.LVL375:
2091:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3333              		.loc 1 2091 5 view .LVU1083
2092:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3334              		.loc 1 2092 1 is_stmt 0 view .LVU1084
 3335 0022 2046     		mov	r0, r4
 3336 0024 10BD     		pop	{r4, pc}
 3337              	.LVL376:
 3338              	.L360:
2092:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3339              		.loc 1 2092 1 view .LVU1085
 3340 0026 00BF     		.align	2
 3341              	.L359:
 3342 0028 00000000 		.word	.LC0
 3343 002c 00000000 		.word	__func__.8
 3344 0030 02000000 		.word	.LC1
 3345              		.cfi_endproc
 3346              	.LFE19:
 3348              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 3349              		.align	1
 3350              		.global	uxQueueSpacesAvailable
 3351              		.syntax unified
 3352              		.thumb
 3353              		.thumb_func
 3355              	uxQueueSpacesAvailable:
ARM GAS  /tmp/ccTT1k9d.s 			page 122


 3356              	.LVL377:
 3357              	.LFB20:
2096:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3358              		.loc 1 2096 1 is_stmt 1 view -0
 3359              		.cfi_startproc
 3360              		@ args = 0, pretend = 0, frame = 0
 3361              		@ frame_needed = 0, uses_anonymous_args = 0
2097:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3362              		.loc 1 2097 5 view .LVU1087
2098:Lib/FreeRTOS/Source/queue.c **** 
 3363              		.loc 1 2098 5 view .LVU1088
2100:Lib/FreeRTOS/Source/queue.c **** 
 3364              		.loc 1 2100 5 view .LVU1089
2096:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3365              		.loc 1 2096 1 is_stmt 0 view .LVU1090
 3366 0000 10B5     		push	{r4, lr}
 3367              		.cfi_def_cfa_offset 8
 3368              		.cfi_offset 4, -8
 3369              		.cfi_offset 14, -4
2100:Lib/FreeRTOS/Source/queue.c **** 
 3370              		.loc 1 2100 5 view .LVU1091
 3371 0002 0446     		mov	r4, r0
 3372 0004 40B9     		cbnz	r0, .L362
2100:Lib/FreeRTOS/Source/queue.c **** 
 3373              		.loc 1 2100 5 is_stmt 1 discriminator 1 view .LVU1092
 3374 0006 FFF7FEFF 		bl	ulSetInterruptMask
 3375              	.LVL378:
2100:Lib/FreeRTOS/Source/queue.c **** 
 3376              		.loc 1 2100 5 discriminator 1 view .LVU1093
 3377 000a 40F63401 		movw	r1, #2100
 3378 000e 074B     		ldr	r3, .L363
 3379 0010 074A     		ldr	r2, .L363+4
 3380 0012 0848     		ldr	r0, .L363+8
 3381 0014 FFF7FEFF 		bl	__assert_func
 3382              	.LVL379:
 3383              	.L362:
2100:Lib/FreeRTOS/Source/queue.c **** 
 3384              		.loc 1 2100 28 discriminator 2 view .LVU1094
2102:Lib/FreeRTOS/Source/queue.c ****     {
 3385              		.loc 1 2102 5 view .LVU1095
 3386 0018 FFF7FEFF 		bl	vPortEnterCritical
 3387              	.LVL380:
2104:Lib/FreeRTOS/Source/queue.c ****     }
 3388              		.loc 1 2104 9 view .LVU1096
2104:Lib/FreeRTOS/Source/queue.c ****     }
 3389              		.loc 1 2104 47 is_stmt 0 view .LVU1097
 3390 001c A36B     		ldr	r3, [r4, #56]
2104:Lib/FreeRTOS/Source/queue.c ****     }
 3391              		.loc 1 2104 18 view .LVU1098
 3392 001e E46B     		ldr	r4, [r4, #60]
 3393              	.LVL381:
2104:Lib/FreeRTOS/Source/queue.c ****     }
 3394              		.loc 1 2104 18 view .LVU1099
 3395 0020 E41A     		subs	r4, r4, r3
 3396              	.LVL382:
2106:Lib/FreeRTOS/Source/queue.c **** 
 3397              		.loc 1 2106 5 is_stmt 1 view .LVU1100
ARM GAS  /tmp/ccTT1k9d.s 			page 123


 3398 0022 FFF7FEFF 		bl	vPortExitCritical
 3399              	.LVL383:
2108:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3400              		.loc 1 2108 5 view .LVU1101
2109:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3401              		.loc 1 2109 1 is_stmt 0 view .LVU1102
 3402 0026 2046     		mov	r0, r4
 3403 0028 10BD     		pop	{r4, pc}
 3404              	.LVL384:
 3405              	.L364:
2109:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3406              		.loc 1 2109 1 view .LVU1103
 3407 002a 00BF     		.align	2
 3408              	.L363:
 3409 002c 00000000 		.word	.LC0
 3410 0030 00000000 		.word	__func__.7
 3411 0034 02000000 		.word	.LC1
 3412              		.cfi_endproc
 3413              	.LFE20:
 3415              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3416              		.align	1
 3417              		.global	uxQueueMessagesWaitingFromISR
 3418              		.syntax unified
 3419              		.thumb
 3420              		.thumb_func
 3422              	uxQueueMessagesWaitingFromISR:
 3423              	.LVL385:
 3424              	.LFB21:
2113:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3425              		.loc 1 2113 1 is_stmt 1 view -0
 3426              		.cfi_startproc
 3427              		@ args = 0, pretend = 0, frame = 0
 3428              		@ frame_needed = 0, uses_anonymous_args = 0
2114:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3429              		.loc 1 2114 5 view .LVU1105
2115:Lib/FreeRTOS/Source/queue.c **** 
 3430              		.loc 1 2115 5 view .LVU1106
2117:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3431              		.loc 1 2117 5 view .LVU1107
2113:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
 3432              		.loc 1 2113 1 is_stmt 0 view .LVU1108
 3433 0000 08B5     		push	{r3, lr}
 3434              		.cfi_def_cfa_offset 8
 3435              		.cfi_offset 3, -8
 3436              		.cfi_offset 14, -4
2117:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3437              		.loc 1 2117 5 view .LVU1109
 3438 0002 40B9     		cbnz	r0, .L366
2117:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3439              		.loc 1 2117 5 is_stmt 1 discriminator 1 view .LVU1110
 3440 0004 FFF7FEFF 		bl	ulSetInterruptMask
 3441              	.LVL386:
2117:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3442              		.loc 1 2117 5 discriminator 1 view .LVU1111
 3443 0008 40F64501 		movw	r1, #2117
 3444 000c 034B     		ldr	r3, .L367
 3445 000e 044A     		ldr	r2, .L367+4
ARM GAS  /tmp/ccTT1k9d.s 			page 124


 3446 0010 0448     		ldr	r0, .L367+8
 3447 0012 FFF7FEFF 		bl	__assert_func
 3448              	.LVL387:
 3449              	.L366:
2117:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3450              		.loc 1 2117 28 discriminator 2 view .LVU1112
2118:Lib/FreeRTOS/Source/queue.c **** 
 3451              		.loc 1 2118 5 view .LVU1113
2118:Lib/FreeRTOS/Source/queue.c **** 
 3452              		.loc 1 2118 14 is_stmt 0 view .LVU1114
 3453 0016 806B     		ldr	r0, [r0, #56]
 3454              	.LVL388:
2120:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3455              		.loc 1 2120 5 is_stmt 1 view .LVU1115
2121:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3456              		.loc 1 2121 1 is_stmt 0 view .LVU1116
 3457 0018 08BD     		pop	{r3, pc}
 3458              	.L368:
 3459 001a 00BF     		.align	2
 3460              	.L367:
 3461 001c 00000000 		.word	.LC0
 3462 0020 00000000 		.word	__func__.6
 3463 0024 02000000 		.word	.LC1
 3464              		.cfi_endproc
 3465              	.LFE21:
 3467              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 3468              		.align	1
 3469              		.global	uxQueueGetQueueNumber
 3470              		.syntax unified
 3471              		.thumb
 3472              		.thumb_func
 3474              	uxQueueGetQueueNumber:
 3475              	.LVL389:
 3476              	.LFB23:
2169:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3477              		.loc 1 2169 5 is_stmt 1 view -0
 3478              		.cfi_startproc
 3479              		@ args = 0, pretend = 0, frame = 0
 3480              		@ frame_needed = 0, uses_anonymous_args = 0
 3481              		@ link register save eliminated.
2170:Lib/FreeRTOS/Source/queue.c ****     }
 3482              		.loc 1 2170 9 view .LVU1118
2171:Lib/FreeRTOS/Source/queue.c **** 
 3483              		.loc 1 2171 5 is_stmt 0 view .LVU1119
 3484 0000 806C     		ldr	r0, [r0, #72]
 3485              	.LVL390:
2171:Lib/FreeRTOS/Source/queue.c **** 
 3486              		.loc 1 2171 5 view .LVU1120
 3487 0002 7047     		bx	lr
 3488              		.cfi_endproc
 3489              	.LFE23:
 3491              		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 3492              		.align	1
 3493              		.global	vQueueSetQueueNumber
 3494              		.syntax unified
 3495              		.thumb
 3496              		.thumb_func
ARM GAS  /tmp/ccTT1k9d.s 			page 125


 3498              	vQueueSetQueueNumber:
 3499              	.LVL391:
 3500              	.LFB24:
2180:Lib/FreeRTOS/Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3501              		.loc 1 2180 5 is_stmt 1 view -0
 3502              		.cfi_startproc
 3503              		@ args = 0, pretend = 0, frame = 0
 3504              		@ frame_needed = 0, uses_anonymous_args = 0
 3505              		@ link register save eliminated.
2181:Lib/FreeRTOS/Source/queue.c ****     }
 3506              		.loc 1 2181 9 view .LVU1122
2181:Lib/FreeRTOS/Source/queue.c ****     }
 3507              		.loc 1 2181 49 is_stmt 0 view .LVU1123
 3508 0000 8164     		str	r1, [r0, #72]
2182:Lib/FreeRTOS/Source/queue.c **** 
 3509              		.loc 1 2182 5 view .LVU1124
 3510 0002 7047     		bx	lr
 3511              		.cfi_endproc
 3512              	.LFE24:
 3514              		.section	.text.ucQueueGetQueueType,"ax",%progbits
 3515              		.align	1
 3516              		.global	ucQueueGetQueueType
 3517              		.syntax unified
 3518              		.thumb
 3519              		.thumb_func
 3521              	ucQueueGetQueueType:
 3522              	.LVL392:
 3523              	.LFB25:
2190:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
 3524              		.loc 1 2190 5 is_stmt 1 view -0
 3525              		.cfi_startproc
 3526              		@ args = 0, pretend = 0, frame = 0
 3527              		@ frame_needed = 0, uses_anonymous_args = 0
 3528              		@ link register save eliminated.
2191:Lib/FreeRTOS/Source/queue.c ****     }
 3529              		.loc 1 2191 9 view .LVU1126
2192:Lib/FreeRTOS/Source/queue.c **** 
 3530              		.loc 1 2192 5 is_stmt 0 view .LVU1127
 3531 0000 90F84C00 		ldrb	r0, [r0, #76]	@ zero_extendqisi2
 3532              	.LVL393:
2192:Lib/FreeRTOS/Source/queue.c **** 
 3533              		.loc 1 2192 5 view .LVU1128
 3534 0004 7047     		bx	lr
 3535              		.cfi_endproc
 3536              	.LFE25:
 3538              		.section	.text.uxQueueGetQueueItemSize,"ax",%progbits
 3539              		.align	1
 3540              		.global	uxQueueGetQueueItemSize
 3541              		.syntax unified
 3542              		.thumb
 3543              		.thumb_func
 3545              	uxQueueGetQueueItemSize:
 3546              	.LVL394:
 3547              	.LFB26:
2198:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxItemSize;
 3548              		.loc 1 2198 1 is_stmt 1 view -0
 3549              		.cfi_startproc
ARM GAS  /tmp/ccTT1k9d.s 			page 126


 3550              		@ args = 0, pretend = 0, frame = 0
 3551              		@ frame_needed = 0, uses_anonymous_args = 0
 3552              		@ link register save eliminated.
2199:Lib/FreeRTOS/Source/queue.c **** }
 3553              		.loc 1 2199 5 view .LVU1130
2200:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3554              		.loc 1 2200 1 is_stmt 0 view .LVU1131
 3555 0000 006C     		ldr	r0, [r0, #64]
 3556              	.LVL395:
2200:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3557              		.loc 1 2200 1 view .LVU1132
 3558 0002 7047     		bx	lr
 3559              		.cfi_endproc
 3560              	.LFE26:
 3562              		.section	.text.uxQueueGetQueueLength,"ax",%progbits
 3563              		.align	1
 3564              		.global	uxQueueGetQueueLength
 3565              		.syntax unified
 3566              		.thumb
 3567              		.thumb_func
 3569              	uxQueueGetQueueLength:
 3570              	.LVL396:
 3571              	.LFB27:
2204:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxLength;
 3572              		.loc 1 2204 1 is_stmt 1 view -0
 3573              		.cfi_startproc
 3574              		@ args = 0, pretend = 0, frame = 0
 3575              		@ frame_needed = 0, uses_anonymous_args = 0
 3576              		@ link register save eliminated.
2205:Lib/FreeRTOS/Source/queue.c **** }
 3577              		.loc 1 2205 5 view .LVU1134
2206:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3578              		.loc 1 2206 1 is_stmt 0 view .LVU1135
 3579 0000 C06B     		ldr	r0, [r0, #60]
 3580              	.LVL397:
2206:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3581              		.loc 1 2206 1 view .LVU1136
 3582 0002 7047     		bx	lr
 3583              		.cfi_endproc
 3584              	.LFE27:
 3586              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 3587              		.align	1
 3588              		.global	xQueueIsQueueEmptyFromISR
 3589              		.syntax unified
 3590              		.thumb
 3591              		.thumb_func
 3593              	xQueueIsQueueEmptyFromISR:
 3594              	.LVL398:
 3595              	.LFB33:
2482:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3596              		.loc 1 2482 1 is_stmt 1 view -0
 3597              		.cfi_startproc
 3598              		@ args = 0, pretend = 0, frame = 0
 3599              		@ frame_needed = 0, uses_anonymous_args = 0
2483:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3600              		.loc 1 2483 5 view .LVU1138
2484:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/ccTT1k9d.s 			page 127


 3601              		.loc 1 2484 5 view .LVU1139
2486:Lib/FreeRTOS/Source/queue.c **** 
 3602              		.loc 1 2486 5 view .LVU1140
2482:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3603              		.loc 1 2482 1 is_stmt 0 view .LVU1141
 3604 0000 08B5     		push	{r3, lr}
 3605              		.cfi_def_cfa_offset 8
 3606              		.cfi_offset 3, -8
 3607              		.cfi_offset 14, -4
2486:Lib/FreeRTOS/Source/queue.c **** 
 3608              		.loc 1 2486 5 view .LVU1142
 3609 0002 40B9     		cbnz	r0, .L375
2486:Lib/FreeRTOS/Source/queue.c **** 
 3610              		.loc 1 2486 5 is_stmt 1 discriminator 1 view .LVU1143
 3611 0004 FFF7FEFF 		bl	ulSetInterruptMask
 3612              	.LVL399:
2486:Lib/FreeRTOS/Source/queue.c **** 
 3613              		.loc 1 2486 5 discriminator 1 view .LVU1144
 3614 0008 40F6B611 		movw	r1, #2486
 3615 000c 044B     		ldr	r3, .L376
 3616 000e 054A     		ldr	r2, .L376+4
 3617 0010 0548     		ldr	r0, .L376+8
 3618 0012 FFF7FEFF 		bl	__assert_func
 3619              	.LVL400:
 3620              	.L375:
2486:Lib/FreeRTOS/Source/queue.c **** 
 3621              		.loc 1 2486 28 discriminator 2 view .LVU1145
2488:Lib/FreeRTOS/Source/queue.c ****     {
 3622              		.loc 1 2488 5 view .LVU1146
2488:Lib/FreeRTOS/Source/queue.c ****     {
 3623              		.loc 1 2488 16 is_stmt 0 view .LVU1147
 3624 0016 806B     		ldr	r0, [r0, #56]
 3625              	.LVL401:
2497:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3626              		.loc 1 2497 5 is_stmt 1 view .LVU1148
2498:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3627              		.loc 1 2498 1 is_stmt 0 view .LVU1149
 3628 0018 B0FA80F0 		clz	r0, r0
 3629              	.LVL402:
2498:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 3630              		.loc 1 2498 1 view .LVU1150
 3631 001c 4009     		lsrs	r0, r0, #5
 3632 001e 08BD     		pop	{r3, pc}
 3633              	.L377:
 3634              		.align	2
 3635              	.L376:
 3636 0020 00000000 		.word	.LC0
 3637 0024 00000000 		.word	__func__.4
 3638 0028 02000000 		.word	.LC1
 3639              		.cfi_endproc
 3640              	.LFE33:
 3642              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 3643              		.align	1
 3644              		.global	xQueueIsQueueFullFromISR
 3645              		.syntax unified
 3646              		.thumb
 3647              		.thumb_func
ARM GAS  /tmp/ccTT1k9d.s 			page 128


 3649              	xQueueIsQueueFullFromISR:
 3650              	.LVL403:
 3651              	.LFB35:
2519:Lib/FreeRTOS/Source/queue.c **** }
2520:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2521:Lib/FreeRTOS/Source/queue.c **** 
2522:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2523:Lib/FreeRTOS/Source/queue.c **** {
 3652              		.loc 1 2523 1 is_stmt 1 view -0
 3653              		.cfi_startproc
 3654              		@ args = 0, pretend = 0, frame = 0
 3655              		@ frame_needed = 0, uses_anonymous_args = 0
2524:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3656              		.loc 1 2524 5 view .LVU1152
2525:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3657              		.loc 1 2525 5 view .LVU1153
2526:Lib/FreeRTOS/Source/queue.c **** 
2527:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3658              		.loc 1 2527 5 view .LVU1154
2523:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
 3659              		.loc 1 2523 1 is_stmt 0 view .LVU1155
 3660 0000 08B5     		push	{r3, lr}
 3661              		.cfi_def_cfa_offset 8
 3662              		.cfi_offset 3, -8
 3663              		.cfi_offset 14, -4
 3664              		.loc 1 2527 5 view .LVU1156
 3665 0002 40B9     		cbnz	r0, .L379
 3666              		.loc 1 2527 5 is_stmt 1 discriminator 1 view .LVU1157
 3667 0004 FFF7FEFF 		bl	ulSetInterruptMask
 3668              	.LVL404:
 3669              		.loc 1 2527 5 discriminator 1 view .LVU1158
 3670 0008 40F6DF11 		movw	r1, #2527
 3671 000c 054B     		ldr	r3, .L380
 3672 000e 064A     		ldr	r2, .L380+4
 3673 0010 0648     		ldr	r0, .L380+8
 3674 0012 FFF7FEFF 		bl	__assert_func
 3675              	.LVL405:
 3676              	.L379:
 3677              		.loc 1 2527 28 discriminator 2 view .LVU1159
2528:Lib/FreeRTOS/Source/queue.c **** 
2529:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 3678              		.loc 1 2529 5 view .LVU1160
 3679              		.loc 1 2529 16 is_stmt 0 view .LVU1161
 3680 0016 836B     		ldr	r3, [r0, #56]
 3681              	.LVL406:
2530:Lib/FreeRTOS/Source/queue.c ****     {
2531:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
2532:Lib/FreeRTOS/Source/queue.c ****     }
2533:Lib/FreeRTOS/Source/queue.c ****     else
2534:Lib/FreeRTOS/Source/queue.c ****     {
2535:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
2536:Lib/FreeRTOS/Source/queue.c ****     }
2537:Lib/FreeRTOS/Source/queue.c **** 
2538:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 3682              		.loc 1 2538 5 is_stmt 1 view .LVU1162
2529:Lib/FreeRTOS/Source/queue.c ****     {
 3683              		.loc 1 2529 7 is_stmt 0 view .LVU1163
ARM GAS  /tmp/ccTT1k9d.s 			page 129


 3684 0018 C06B     		ldr	r0, [r0, #60]
 3685              	.LVL407:
2539:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3686              		.loc 1 2539 1 view .LVU1164
 3687 001a C31A     		subs	r3, r0, r3
 3688              	.LVL408:
 3689              		.loc 1 2539 1 view .LVU1165
 3690 001c 5842     		rsbs	r0, r3, #0
 3691              		.loc 1 2539 1 view .LVU1166
 3692 001e 5841     		adcs	r0, r0, r3
 3693 0020 08BD     		pop	{r3, pc}
 3694              	.L381:
 3695 0022 00BF     		.align	2
 3696              	.L380:
 3697 0024 00000000 		.word	.LC0
 3698 0028 00000000 		.word	__func__.3
 3699 002c 02000000 		.word	.LC1
 3700              		.cfi_endproc
 3701              	.LFE35:
 3703              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 3704              		.align	1
 3705              		.global	vQueueAddToRegistry
 3706              		.syntax unified
 3707              		.thumb
 3708              		.thumb_func
 3710              	vQueueAddToRegistry:
 3711              	.LVL409:
 3712              	.LFB36:
2540:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2541:Lib/FreeRTOS/Source/queue.c **** 
2542:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2543:Lib/FreeRTOS/Source/queue.c **** 
2544:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
2545:Lib/FreeRTOS/Source/queue.c ****                              const void * pvItemToQueue,
2546:Lib/FreeRTOS/Source/queue.c ****                              TickType_t xTicksToWait )
2547:Lib/FreeRTOS/Source/queue.c ****     {
2548:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2549:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2550:Lib/FreeRTOS/Source/queue.c **** 
2551:Lib/FreeRTOS/Source/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2552:Lib/FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt removing something from the queue
2553:Lib/FreeRTOS/Source/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2554:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2555:Lib/FreeRTOS/Source/queue.c ****         {
2556:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2557:Lib/FreeRTOS/Source/queue.c ****             {
2558:Lib/FreeRTOS/Source/queue.c ****                 /* The queue is full - do we want to block or just leave without
2559:Lib/FreeRTOS/Source/queue.c ****                  * posting? */
2560:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2561:Lib/FreeRTOS/Source/queue.c ****                 {
2562:Lib/FreeRTOS/Source/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2563:Lib/FreeRTOS/Source/queue.c ****                      * return indicating that we need to block. */
2564:Lib/FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2565:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2566:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2567:Lib/FreeRTOS/Source/queue.c ****                 }
2568:Lib/FreeRTOS/Source/queue.c ****                 else
ARM GAS  /tmp/ccTT1k9d.s 			page 130


2569:Lib/FreeRTOS/Source/queue.c ****                 {
2570:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2571:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2572:Lib/FreeRTOS/Source/queue.c ****                 }
2573:Lib/FreeRTOS/Source/queue.c ****             }
2574:Lib/FreeRTOS/Source/queue.c ****         }
2575:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2576:Lib/FreeRTOS/Source/queue.c **** 
2577:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2578:Lib/FreeRTOS/Source/queue.c ****         {
2579:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2580:Lib/FreeRTOS/Source/queue.c ****             {
2581:Lib/FreeRTOS/Source/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2582:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2583:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2584:Lib/FreeRTOS/Source/queue.c **** 
2585:Lib/FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2586:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2587:Lib/FreeRTOS/Source/queue.c ****                 {
2588:Lib/FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2589:Lib/FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2590:Lib/FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2591:Lib/FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2592:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2593:Lib/FreeRTOS/Source/queue.c ****                     {
2594:Lib/FreeRTOS/Source/queue.c ****                         /* The co-routine waiting has a higher priority so record
2595:Lib/FreeRTOS/Source/queue.c ****                          * that a yield might be appropriate. */
2596:Lib/FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2597:Lib/FreeRTOS/Source/queue.c ****                     }
2598:Lib/FreeRTOS/Source/queue.c ****                     else
2599:Lib/FreeRTOS/Source/queue.c ****                     {
2600:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2601:Lib/FreeRTOS/Source/queue.c ****                     }
2602:Lib/FreeRTOS/Source/queue.c ****                 }
2603:Lib/FreeRTOS/Source/queue.c ****                 else
2604:Lib/FreeRTOS/Source/queue.c ****                 {
2605:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2606:Lib/FreeRTOS/Source/queue.c ****                 }
2607:Lib/FreeRTOS/Source/queue.c ****             }
2608:Lib/FreeRTOS/Source/queue.c ****             else
2609:Lib/FreeRTOS/Source/queue.c ****             {
2610:Lib/FreeRTOS/Source/queue.c ****                 xReturn = errQUEUE_FULL;
2611:Lib/FreeRTOS/Source/queue.c ****             }
2612:Lib/FreeRTOS/Source/queue.c ****         }
2613:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2614:Lib/FreeRTOS/Source/queue.c **** 
2615:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2616:Lib/FreeRTOS/Source/queue.c ****     }
2617:Lib/FreeRTOS/Source/queue.c **** 
2618:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2619:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2620:Lib/FreeRTOS/Source/queue.c **** 
2621:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2622:Lib/FreeRTOS/Source/queue.c **** 
2623:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2624:Lib/FreeRTOS/Source/queue.c ****                                 void * pvBuffer,
2625:Lib/FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
ARM GAS  /tmp/ccTT1k9d.s 			page 131


2626:Lib/FreeRTOS/Source/queue.c ****     {
2627:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2628:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2629:Lib/FreeRTOS/Source/queue.c **** 
2630:Lib/FreeRTOS/Source/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2631:Lib/FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt adding something to the queue
2632:Lib/FreeRTOS/Source/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2633:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2634:Lib/FreeRTOS/Source/queue.c ****         {
2635:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2636:Lib/FreeRTOS/Source/queue.c ****             {
2637:Lib/FreeRTOS/Source/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2638:Lib/FreeRTOS/Source/queue.c ****                  * leave with nothing? */
2639:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2640:Lib/FreeRTOS/Source/queue.c ****                 {
2641:Lib/FreeRTOS/Source/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2642:Lib/FreeRTOS/Source/queue.c ****                      * indicating that we need to block. */
2643:Lib/FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2644:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2645:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2646:Lib/FreeRTOS/Source/queue.c ****                 }
2647:Lib/FreeRTOS/Source/queue.c ****                 else
2648:Lib/FreeRTOS/Source/queue.c ****                 {
2649:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2650:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2651:Lib/FreeRTOS/Source/queue.c ****                 }
2652:Lib/FreeRTOS/Source/queue.c ****             }
2653:Lib/FreeRTOS/Source/queue.c ****             else
2654:Lib/FreeRTOS/Source/queue.c ****             {
2655:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2656:Lib/FreeRTOS/Source/queue.c ****             }
2657:Lib/FreeRTOS/Source/queue.c ****         }
2658:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2659:Lib/FreeRTOS/Source/queue.c **** 
2660:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2661:Lib/FreeRTOS/Source/queue.c ****         {
2662:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2663:Lib/FreeRTOS/Source/queue.c ****             {
2664:Lib/FreeRTOS/Source/queue.c ****                 /* Data is available from the queue. */
2665:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2666:Lib/FreeRTOS/Source/queue.c **** 
2667:Lib/FreeRTOS/Source/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2668:Lib/FreeRTOS/Source/queue.c ****                 {
2669:Lib/FreeRTOS/Source/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2670:Lib/FreeRTOS/Source/queue.c ****                 }
2671:Lib/FreeRTOS/Source/queue.c ****                 else
2672:Lib/FreeRTOS/Source/queue.c ****                 {
2673:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2674:Lib/FreeRTOS/Source/queue.c ****                 }
2675:Lib/FreeRTOS/Source/queue.c **** 
2676:Lib/FreeRTOS/Source/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2677:Lib/FreeRTOS/Source/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2678:Lib/FreeRTOS/Source/queue.c **** 
2679:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2680:Lib/FreeRTOS/Source/queue.c **** 
2681:Lib/FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2682:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
ARM GAS  /tmp/ccTT1k9d.s 			page 132


2683:Lib/FreeRTOS/Source/queue.c ****                 {
2684:Lib/FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2685:Lib/FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2686:Lib/FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2687:Lib/FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2688:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2689:Lib/FreeRTOS/Source/queue.c ****                     {
2690:Lib/FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2691:Lib/FreeRTOS/Source/queue.c ****                     }
2692:Lib/FreeRTOS/Source/queue.c ****                     else
2693:Lib/FreeRTOS/Source/queue.c ****                     {
2694:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2695:Lib/FreeRTOS/Source/queue.c ****                     }
2696:Lib/FreeRTOS/Source/queue.c ****                 }
2697:Lib/FreeRTOS/Source/queue.c ****                 else
2698:Lib/FreeRTOS/Source/queue.c ****                 {
2699:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2700:Lib/FreeRTOS/Source/queue.c ****                 }
2701:Lib/FreeRTOS/Source/queue.c ****             }
2702:Lib/FreeRTOS/Source/queue.c ****             else
2703:Lib/FreeRTOS/Source/queue.c ****             {
2704:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdFAIL;
2705:Lib/FreeRTOS/Source/queue.c ****             }
2706:Lib/FreeRTOS/Source/queue.c ****         }
2707:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2708:Lib/FreeRTOS/Source/queue.c **** 
2709:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2710:Lib/FreeRTOS/Source/queue.c ****     }
2711:Lib/FreeRTOS/Source/queue.c **** 
2712:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2713:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2714:Lib/FreeRTOS/Source/queue.c **** 
2715:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2716:Lib/FreeRTOS/Source/queue.c **** 
2717:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2718:Lib/FreeRTOS/Source/queue.c ****                                     const void * pvItemToQueue,
2719:Lib/FreeRTOS/Source/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2720:Lib/FreeRTOS/Source/queue.c ****     {
2721:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2722:Lib/FreeRTOS/Source/queue.c **** 
2723:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2724:Lib/FreeRTOS/Source/queue.c ****          * exit without doing anything. */
2725:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2726:Lib/FreeRTOS/Source/queue.c ****         {
2727:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2728:Lib/FreeRTOS/Source/queue.c **** 
2729:Lib/FreeRTOS/Source/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2730:Lib/FreeRTOS/Source/queue.c ****              * co-routine has not already been woken. */
2731:Lib/FreeRTOS/Source/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2732:Lib/FreeRTOS/Source/queue.c ****             {
2733:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2734:Lib/FreeRTOS/Source/queue.c ****                 {
2735:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2736:Lib/FreeRTOS/Source/queue.c ****                     {
2737:Lib/FreeRTOS/Source/queue.c ****                         return pdTRUE;
2738:Lib/FreeRTOS/Source/queue.c ****                     }
2739:Lib/FreeRTOS/Source/queue.c ****                     else
ARM GAS  /tmp/ccTT1k9d.s 			page 133


2740:Lib/FreeRTOS/Source/queue.c ****                     {
2741:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2742:Lib/FreeRTOS/Source/queue.c ****                     }
2743:Lib/FreeRTOS/Source/queue.c ****                 }
2744:Lib/FreeRTOS/Source/queue.c ****                 else
2745:Lib/FreeRTOS/Source/queue.c ****                 {
2746:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2747:Lib/FreeRTOS/Source/queue.c ****                 }
2748:Lib/FreeRTOS/Source/queue.c ****             }
2749:Lib/FreeRTOS/Source/queue.c ****             else
2750:Lib/FreeRTOS/Source/queue.c ****             {
2751:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2752:Lib/FreeRTOS/Source/queue.c ****             }
2753:Lib/FreeRTOS/Source/queue.c ****         }
2754:Lib/FreeRTOS/Source/queue.c ****         else
2755:Lib/FreeRTOS/Source/queue.c ****         {
2756:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2757:Lib/FreeRTOS/Source/queue.c ****         }
2758:Lib/FreeRTOS/Source/queue.c **** 
2759:Lib/FreeRTOS/Source/queue.c ****         return xCoRoutinePreviouslyWoken;
2760:Lib/FreeRTOS/Source/queue.c ****     }
2761:Lib/FreeRTOS/Source/queue.c **** 
2762:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2763:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2764:Lib/FreeRTOS/Source/queue.c **** 
2765:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2766:Lib/FreeRTOS/Source/queue.c **** 
2767:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2768:Lib/FreeRTOS/Source/queue.c ****                                        void * pvBuffer,
2769:Lib/FreeRTOS/Source/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2770:Lib/FreeRTOS/Source/queue.c ****     {
2771:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2772:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2773:Lib/FreeRTOS/Source/queue.c **** 
2774:Lib/FreeRTOS/Source/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2775:Lib/FreeRTOS/Source/queue.c ****          * not then just leave without doing anything. */
2776:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2777:Lib/FreeRTOS/Source/queue.c ****         {
2778:Lib/FreeRTOS/Source/queue.c ****             /* Copy the data from the queue. */
2779:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2780:Lib/FreeRTOS/Source/queue.c **** 
2781:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2782:Lib/FreeRTOS/Source/queue.c ****             {
2783:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2784:Lib/FreeRTOS/Source/queue.c ****             }
2785:Lib/FreeRTOS/Source/queue.c ****             else
2786:Lib/FreeRTOS/Source/queue.c ****             {
2787:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2788:Lib/FreeRTOS/Source/queue.c ****             }
2789:Lib/FreeRTOS/Source/queue.c **** 
2790:Lib/FreeRTOS/Source/queue.c ****             --( pxQueue->uxMessagesWaiting );
2791:Lib/FreeRTOS/Source/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2792:Lib/FreeRTOS/Source/queue.c **** 
2793:Lib/FreeRTOS/Source/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2794:Lib/FreeRTOS/Source/queue.c ****             {
2795:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2796:Lib/FreeRTOS/Source/queue.c ****                 {
ARM GAS  /tmp/ccTT1k9d.s 			page 134


2797:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2798:Lib/FreeRTOS/Source/queue.c ****                     {
2799:Lib/FreeRTOS/Source/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2800:Lib/FreeRTOS/Source/queue.c ****                     }
2801:Lib/FreeRTOS/Source/queue.c ****                     else
2802:Lib/FreeRTOS/Source/queue.c ****                     {
2803:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2804:Lib/FreeRTOS/Source/queue.c ****                     }
2805:Lib/FreeRTOS/Source/queue.c ****                 }
2806:Lib/FreeRTOS/Source/queue.c ****                 else
2807:Lib/FreeRTOS/Source/queue.c ****                 {
2808:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2809:Lib/FreeRTOS/Source/queue.c ****                 }
2810:Lib/FreeRTOS/Source/queue.c ****             }
2811:Lib/FreeRTOS/Source/queue.c ****             else
2812:Lib/FreeRTOS/Source/queue.c ****             {
2813:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2814:Lib/FreeRTOS/Source/queue.c ****             }
2815:Lib/FreeRTOS/Source/queue.c **** 
2816:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
2817:Lib/FreeRTOS/Source/queue.c ****         }
2818:Lib/FreeRTOS/Source/queue.c ****         else
2819:Lib/FreeRTOS/Source/queue.c ****         {
2820:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
2821:Lib/FreeRTOS/Source/queue.c ****         }
2822:Lib/FreeRTOS/Source/queue.c **** 
2823:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2824:Lib/FreeRTOS/Source/queue.c ****     }
2825:Lib/FreeRTOS/Source/queue.c **** 
2826:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2827:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2828:Lib/FreeRTOS/Source/queue.c **** 
2829:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2830:Lib/FreeRTOS/Source/queue.c **** 
2831:Lib/FreeRTOS/Source/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2832:Lib/FreeRTOS/Source/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2833:Lib/FreeRTOS/Source/queue.c ****     {
 3713              		.loc 1 2833 5 is_stmt 1 view -0
 3714              		.cfi_startproc
 3715              		@ args = 0, pretend = 0, frame = 0
 3716              		@ frame_needed = 0, uses_anonymous_args = 0
2834:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3717              		.loc 1 2834 9 view .LVU1168
2835:Lib/FreeRTOS/Source/queue.c ****         QueueRegistryItem_t * pxEntryToWrite = NULL;
 3718              		.loc 1 2835 9 view .LVU1169
2836:Lib/FreeRTOS/Source/queue.c **** 
2837:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 3719              		.loc 1 2837 9 view .LVU1170
2833:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3720              		.loc 1 2833 5 is_stmt 0 view .LVU1171
 3721 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3722              		.cfi_def_cfa_offset 24
 3723              		.cfi_offset 3, -24
 3724              		.cfi_offset 4, -20
 3725              		.cfi_offset 5, -16
 3726              		.cfi_offset 6, -12
 3727              		.cfi_offset 7, -8
ARM GAS  /tmp/ccTT1k9d.s 			page 135


 3728              		.cfi_offset 14, -4
 3729              		.loc 1 2837 9 view .LVU1172
 3730 0002 40B9     		cbnz	r0, .L383
 3731              		.loc 1 2837 9 is_stmt 1 discriminator 1 view .LVU1173
 3732 0004 FFF7FEFF 		bl	ulSetInterruptMask
 3733              	.LVL410:
 3734              		.loc 1 2837 9 discriminator 1 view .LVU1174
 3735 0008 40F61531 		movw	r1, #2837
 3736 000c 104B     		ldr	r3, .L396
 3737 000e 114A     		ldr	r2, .L396+4
 3738 0010 1148     		ldr	r0, .L396+8
 3739 0012 FFF7FEFF 		bl	__assert_func
 3740              	.LVL411:
 3741              	.L383:
 3742              		.loc 1 2837 31 discriminator 2 view .LVU1175
2838:Lib/FreeRTOS/Source/queue.c **** 
2839:Lib/FreeRTOS/Source/queue.c ****         if( pcQueueName != NULL )
 3743              		.loc 1 2839 9 view .LVU1176
 3744              		.loc 1 2839 11 is_stmt 0 view .LVU1177
 3745 0016 C9B1     		cbz	r1, .L382
2835:Lib/FreeRTOS/Source/queue.c **** 
 3746              		.loc 1 2835 31 view .LVU1178
 3747 0018 0023     		movs	r3, #0
 3748 001a 104A     		ldr	r2, .L396+12
2840:Lib/FreeRTOS/Source/queue.c ****         {
2841:Lib/FreeRTOS/Source/queue.c ****             /* See if there is an empty space in the registry.  A NULL name denotes
2842:Lib/FreeRTOS/Source/queue.c ****              * a free slot. */
2843:Lib/FreeRTOS/Source/queue.c ****             for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3749              		.loc 1 2843 21 view .LVU1179
 3750 001c 1D46     		mov	r5, r3
 3751 001e 1646     		mov	r6, r2
 3752 0020 0824     		movs	r4, #8
 3753              	.LVL412:
 3754              	.L388:
2844:Lib/FreeRTOS/Source/queue.c ****             {
2845:Lib/FreeRTOS/Source/queue.c ****                 /* Replace an existing entry if the queue is already in the registry. */
2846:Lib/FreeRTOS/Source/queue.c ****                 if( xQueue == xQueueRegistry[ ux ].xHandle )
 3755              		.loc 1 2846 17 is_stmt 1 view .LVU1180
 3756              		.loc 1 2846 19 is_stmt 0 view .LVU1181
 3757 0022 5768     		ldr	r7, [r2, #4]
 3758 0024 8742     		cmp	r7, r0
 3759 0026 04D1     		bne	.L385
2847:Lib/FreeRTOS/Source/queue.c ****                 {
2848:Lib/FreeRTOS/Source/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
 3760              		.loc 1 2848 21 is_stmt 1 view .LVU1182
 3761              		.loc 1 2848 36 is_stmt 0 view .LVU1183
 3762 0028 06EBC503 		add	r3, r6, r5, lsl #3
 3763              	.LVL413:
2849:Lib/FreeRTOS/Source/queue.c ****                     break;
 3764              		.loc 1 2849 21 is_stmt 1 view .LVU1184
2850:Lib/FreeRTOS/Source/queue.c ****                 }
2851:Lib/FreeRTOS/Source/queue.c ****                 /* Otherwise, store in the next empty location */
2852:Lib/FreeRTOS/Source/queue.c ****                 else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL )
2853:Lib/FreeRTOS/Source/queue.c ****                 {
2854:Lib/FreeRTOS/Source/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
2855:Lib/FreeRTOS/Source/queue.c ****                 }
2856:Lib/FreeRTOS/Source/queue.c ****                 else
ARM GAS  /tmp/ccTT1k9d.s 			page 136


2857:Lib/FreeRTOS/Source/queue.c ****                 {
2858:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2859:Lib/FreeRTOS/Source/queue.c ****                 }
2860:Lib/FreeRTOS/Source/queue.c ****             }
2861:Lib/FreeRTOS/Source/queue.c ****         }
2862:Lib/FreeRTOS/Source/queue.c **** 
2863:Lib/FreeRTOS/Source/queue.c ****         if( pxEntryToWrite != NULL )
 3765              		.loc 1 2863 9 view .LVU1185
 3766              	.L386:
2864:Lib/FreeRTOS/Source/queue.c ****         {
2865:Lib/FreeRTOS/Source/queue.c ****             /* Store the information on this queue. */
2866:Lib/FreeRTOS/Source/queue.c ****             pxEntryToWrite->pcQueueName = pcQueueName;
 3767              		.loc 1 2866 13 view .LVU1186
2867:Lib/FreeRTOS/Source/queue.c ****             pxEntryToWrite->xHandle = xQueue;
 3768              		.loc 1 2867 37 is_stmt 0 view .LVU1187
 3769 002c C3E90010 		strd	r1, r0, [r3]
 3770              	.LVL414:
2868:Lib/FreeRTOS/Source/queue.c **** 
2869:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
 3771              		.loc 1 2869 59 is_stmt 1 view .LVU1188
2870:Lib/FreeRTOS/Source/queue.c ****         }
2871:Lib/FreeRTOS/Source/queue.c ****     }
 3772              		.loc 1 2871 5 is_stmt 0 view .LVU1189
 3773 0030 0CE0     		b	.L382
 3774              	.LVL415:
 3775              	.L385:
2852:Lib/FreeRTOS/Source/queue.c ****                 {
 3776              		.loc 1 2852 22 is_stmt 1 view .LVU1190
2852:Lib/FreeRTOS/Source/queue.c ****                 {
 3777              		.loc 1 2852 24 is_stmt 0 view .LVU1191
 3778 0032 1BB9     		cbnz	r3, .L387
2852:Lib/FreeRTOS/Source/queue.c ****                 {
 3779              		.loc 1 2852 53 discriminator 1 view .LVU1192
 3780 0034 1768     		ldr	r7, [r2]
2854:Lib/FreeRTOS/Source/queue.c ****                 }
 3781              		.loc 1 2854 36 view .LVU1193
 3782 0036 002F     		cmp	r7, #0
 3783 0038 08BF     		it	eq
 3784 003a 1346     		moveq	r3, r2
 3785              	.LVL416:
 3786              	.L387:
2858:Lib/FreeRTOS/Source/queue.c ****                 }
 3787              		.loc 1 2858 45 is_stmt 1 view .LVU1194
2843:Lib/FreeRTOS/Source/queue.c ****             {
 3788              		.loc 1 2843 93 discriminator 2 view .LVU1195
2843:Lib/FreeRTOS/Source/queue.c ****             {
 3789              		.loc 1 2843 46 is_stmt 0 discriminator 1 view .LVU1196
 3790 003c 013C     		subs	r4, r4, #1
2843:Lib/FreeRTOS/Source/queue.c ****             {
 3791              		.loc 1 2843 93 discriminator 2 view .LVU1197
 3792 003e 05F10105 		add	r5, r5, #1
 3793              	.LVL417:
2843:Lib/FreeRTOS/Source/queue.c ****             {
 3794              		.loc 1 2843 46 is_stmt 1 discriminator 1 view .LVU1198
 3795 0042 02F10802 		add	r2, r2, #8
 3796 0046 ECD1     		bne	.L388
2863:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/ccTT1k9d.s 			page 137


 3797              		.loc 1 2863 9 view .LVU1199
2863:Lib/FreeRTOS/Source/queue.c ****         {
 3798              		.loc 1 2863 11 is_stmt 0 view .LVU1200
 3799 0048 002B     		cmp	r3, #0
 3800 004a EFD1     		bne	.L386
 3801              	.LVL418:
 3802              	.L382:
 3803              		.loc 1 2871 5 view .LVU1201
 3804 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3805              	.L397:
 3806 004e 00BF     		.align	2
 3807              	.L396:
 3808 0050 00000000 		.word	.LC0
 3809 0054 00000000 		.word	__func__.2
 3810 0058 02000000 		.word	.LC1
 3811 005c 00000000 		.word	xQueueRegistry
 3812              		.cfi_endproc
 3813              	.LFE36:
 3815              		.section	.text.pcQueueGetName,"ax",%progbits
 3816              		.align	1
 3817              		.global	pcQueueGetName
 3818              		.syntax unified
 3819              		.thumb
 3820              		.thumb_func
 3822              	pcQueueGetName:
 3823              	.LVL419:
 3824              	.LFB37:
2872:Lib/FreeRTOS/Source/queue.c **** 
2873:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2874:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2875:Lib/FreeRTOS/Source/queue.c **** 
2876:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2877:Lib/FreeRTOS/Source/queue.c **** 
2878:Lib/FreeRTOS/Source/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2879:Lib/FreeRTOS/Source/queue.c ****     {
 3825              		.loc 1 2879 5 is_stmt 1 view -0
 3826              		.cfi_startproc
 3827              		@ args = 0, pretend = 0, frame = 0
 3828              		@ frame_needed = 0, uses_anonymous_args = 0
2880:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3829              		.loc 1 2880 9 view .LVU1203
2881:Lib/FreeRTOS/Source/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
 3830              		.loc 1 2881 9 view .LVU1204
2882:Lib/FreeRTOS/Source/queue.c **** 
2883:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 3831              		.loc 1 2883 9 view .LVU1205
2884:Lib/FreeRTOS/Source/queue.c **** 
2885:Lib/FreeRTOS/Source/queue.c ****         /* Note there is nothing here to protect against another task adding or
2886:Lib/FreeRTOS/Source/queue.c ****          * removing entries from the registry while it is being searched. */
2887:Lib/FreeRTOS/Source/queue.c **** 
2888:Lib/FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3832              		.loc 1 2888 17 is_stmt 0 view .LVU1206
 3833 0000 0023     		movs	r3, #0
2879:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3834              		.loc 1 2879 5 view .LVU1207
 3835 0002 10B5     		push	{r4, lr}
 3836              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccTT1k9d.s 			page 138


 3837              		.cfi_offset 4, -8
 3838              		.cfi_offset 14, -4
2883:Lib/FreeRTOS/Source/queue.c **** 
 3839              		.loc 1 2883 9 view .LVU1208
 3840 0004 48B1     		cbz	r0, .L405
2889:Lib/FreeRTOS/Source/queue.c ****         {
2890:Lib/FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3841              		.loc 1 2890 37 view .LVU1209
 3842 0006 0822     		movs	r2, #8
 3843 0008 0B49     		ldr	r1, .L406
 3844              	.L399:
 3845              	.LVL420:
 3846              		.loc 1 2890 13 is_stmt 1 view .LVU1210
 3847              		.loc 1 2890 15 is_stmt 0 view .LVU1211
 3848 000a 51F83340 		ldr	r4, [r1, r3, lsl #3]
 3849 000e 8442     		cmp	r4, r0
 3850 0010 0CD1     		bne	.L400
2891:Lib/FreeRTOS/Source/queue.c ****             {
2892:Lib/FreeRTOS/Source/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
 3851              		.loc 1 2892 17 is_stmt 1 view .LVU1212
 3852              		.loc 1 2892 26 is_stmt 0 view .LVU1213
 3853 0012 0A4A     		ldr	r2, .L406+4
 3854 0014 52F83300 		ldr	r0, [r2, r3, lsl #3]
 3855              	.LVL421:
2893:Lib/FreeRTOS/Source/queue.c ****                 break;
 3856              		.loc 1 2893 17 is_stmt 1 view .LVU1214
 3857              	.L398:
2894:Lib/FreeRTOS/Source/queue.c ****             }
2895:Lib/FreeRTOS/Source/queue.c ****             else
2896:Lib/FreeRTOS/Source/queue.c ****             {
2897:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2898:Lib/FreeRTOS/Source/queue.c ****             }
2899:Lib/FreeRTOS/Source/queue.c ****         }
2900:Lib/FreeRTOS/Source/queue.c **** 
2901:Lib/FreeRTOS/Source/queue.c ****         return pcReturn;
2902:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3858              		.loc 1 2902 5 is_stmt 0 view .LVU1215
 3859 0018 10BD     		pop	{r4, pc}
 3860              	.LVL422:
 3861              	.L405:
2883:Lib/FreeRTOS/Source/queue.c **** 
 3862              		.loc 1 2883 9 is_stmt 1 discriminator 1 view .LVU1216
 3863 001a FFF7FEFF 		bl	ulSetInterruptMask
 3864              	.LVL423:
2883:Lib/FreeRTOS/Source/queue.c **** 
 3865              		.loc 1 2883 9 discriminator 1 view .LVU1217
 3866 001e 40F64331 		movw	r1, #2883
 3867 0022 074B     		ldr	r3, .L406+8
 3868 0024 074A     		ldr	r2, .L406+12
 3869 0026 0848     		ldr	r0, .L406+16
 3870 0028 FFF7FEFF 		bl	__assert_func
 3871              	.LVL424:
 3872              	.L400:
2897:Lib/FreeRTOS/Source/queue.c ****             }
 3873              		.loc 1 2897 41 view .LVU1218
2888:Lib/FreeRTOS/Source/queue.c ****         {
 3874              		.loc 1 2888 89 discriminator 2 view .LVU1219
ARM GAS  /tmp/ccTT1k9d.s 			page 139


2888:Lib/FreeRTOS/Source/queue.c ****         {
 3875              		.loc 1 2888 42 is_stmt 0 discriminator 1 view .LVU1220
 3876 002c 013A     		subs	r2, r2, #1
2888:Lib/FreeRTOS/Source/queue.c ****         {
 3877              		.loc 1 2888 89 discriminator 2 view .LVU1221
 3878 002e 03F10103 		add	r3, r3, #1
 3879              	.LVL425:
2888:Lib/FreeRTOS/Source/queue.c ****         {
 3880              		.loc 1 2888 42 is_stmt 1 discriminator 1 view .LVU1222
 3881 0032 EAD1     		bne	.L399
2881:Lib/FreeRTOS/Source/queue.c **** 
 3882              		.loc 1 2881 22 is_stmt 0 view .LVU1223
 3883 0034 0020     		movs	r0, #0
 3884              	.LVL426:
2901:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3885              		.loc 1 2901 9 is_stmt 1 view .LVU1224
2901:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 3886              		.loc 1 2901 16 is_stmt 0 view .LVU1225
 3887 0036 EFE7     		b	.L398
 3888              	.L407:
 3889              		.align	2
 3890              	.L406:
 3891 0038 04000000 		.word	xQueueRegistry+4
 3892 003c 00000000 		.word	xQueueRegistry
 3893 0040 00000000 		.word	.LC0
 3894 0044 00000000 		.word	__func__.1
 3895 0048 02000000 		.word	.LC1
 3896              		.cfi_endproc
 3897              	.LFE37:
 3899              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 3900              		.align	1
 3901              		.global	vQueueUnregisterQueue
 3902              		.syntax unified
 3903              		.thumb
 3904              		.thumb_func
 3906              	vQueueUnregisterQueue:
 3907              	.LVL427:
 3908              	.LFB38:
2903:Lib/FreeRTOS/Source/queue.c **** 
2904:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2905:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2906:Lib/FreeRTOS/Source/queue.c **** 
2907:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2908:Lib/FreeRTOS/Source/queue.c **** 
2909:Lib/FreeRTOS/Source/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2910:Lib/FreeRTOS/Source/queue.c ****     {
 3909              		.loc 1 2910 5 is_stmt 1 view -0
 3910              		.cfi_startproc
 3911              		@ args = 0, pretend = 0, frame = 0
 3912              		@ frame_needed = 0, uses_anonymous_args = 0
2911:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3913              		.loc 1 2911 9 view .LVU1227
2912:Lib/FreeRTOS/Source/queue.c **** 
2913:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 3914              		.loc 1 2913 9 view .LVU1228
2910:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
 3915              		.loc 1 2910 5 is_stmt 0 view .LVU1229
ARM GAS  /tmp/ccTT1k9d.s 			page 140


 3916 0000 38B5     		push	{r3, r4, r5, lr}
 3917              		.cfi_def_cfa_offset 16
 3918              		.cfi_offset 3, -16
 3919              		.cfi_offset 4, -12
 3920              		.cfi_offset 5, -8
 3921              		.cfi_offset 14, -4
2914:Lib/FreeRTOS/Source/queue.c **** 
2915:Lib/FreeRTOS/Source/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2916:Lib/FreeRTOS/Source/queue.c ****          * registry. */
2917:Lib/FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 3922              		.loc 1 2917 17 view .LVU1230
 3923 0002 0023     		movs	r3, #0
2913:Lib/FreeRTOS/Source/queue.c **** 
 3924              		.loc 1 2913 9 view .LVU1231
 3925 0004 68B1     		cbz	r0, .L415
2918:Lib/FreeRTOS/Source/queue.c ****         {
2919:Lib/FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 3926              		.loc 1 2919 37 view .LVU1232
 3927 0006 0822     		movs	r2, #8
 3928 0008 0D49     		ldr	r1, .L416
 3929              	.L409:
 3930              	.LVL428:
 3931              		.loc 1 2919 13 is_stmt 1 view .LVU1233
 3932              		.loc 1 2919 15 is_stmt 0 view .LVU1234
 3933 000a 51F83350 		ldr	r5, [r1, r3, lsl #3]
 3934              		.loc 1 2919 37 view .LVU1235
 3935 000e DC00     		lsls	r4, r3, #3
 3936              		.loc 1 2919 15 view .LVU1236
 3937 0010 8542     		cmp	r5, r0
 3938 0012 0FD1     		bne	.L410
2920:Lib/FreeRTOS/Source/queue.c ****             {
2921:Lib/FreeRTOS/Source/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2922:Lib/FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
 3939              		.loc 1 2922 17 is_stmt 1 view .LVU1237
 3940              		.loc 1 2922 50 is_stmt 0 view .LVU1238
 3941 0014 0021     		movs	r1, #0
 3942 0016 0B4A     		ldr	r2, .L416+4
 3943 0018 42F83310 		str	r1, [r2, r3, lsl #3]
2923:Lib/FreeRTOS/Source/queue.c **** 
2924:Lib/FreeRTOS/Source/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2925:Lib/FreeRTOS/Source/queue.c ****                  * appear in the registry twice if it is added, removed, then
2926:Lib/FreeRTOS/Source/queue.c ****                  * added again. */
2927:Lib/FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 3944              		.loc 1 2927 17 is_stmt 1 view .LVU1239
 3945              		.loc 1 2927 46 is_stmt 0 view .LVU1240
 3946 001c 2244     		add	r2, r2, r4
 3947 001e 5160     		str	r1, [r2, #4]
2928:Lib/FreeRTOS/Source/queue.c ****                 break;
 3948              		.loc 1 2928 17 is_stmt 1 view .LVU1241
 3949              	.L408:
2929:Lib/FreeRTOS/Source/queue.c ****             }
2930:Lib/FreeRTOS/Source/queue.c ****             else
2931:Lib/FreeRTOS/Source/queue.c ****             {
2932:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2933:Lib/FreeRTOS/Source/queue.c ****             }
2934:Lib/FreeRTOS/Source/queue.c ****         }
2935:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
ARM GAS  /tmp/ccTT1k9d.s 			page 141


 3950              		.loc 1 2935 5 is_stmt 0 view .LVU1242
 3951 0020 38BD     		pop	{r3, r4, r5, pc}
 3952              	.LVL429:
 3953              	.L415:
 3954              	.LBB59:
 3955              	.LBI59:
2909:Lib/FreeRTOS/Source/queue.c ****     {
 3956              		.loc 1 2909 10 is_stmt 1 view .LVU1243
 3957              	.LBB60:
2913:Lib/FreeRTOS/Source/queue.c **** 
 3958              		.loc 1 2913 9 discriminator 1 view .LVU1244
 3959 0022 FFF7FEFF 		bl	ulSetInterruptMask
 3960              	.LVL430:
2913:Lib/FreeRTOS/Source/queue.c **** 
 3961              		.loc 1 2913 9 discriminator 1 view .LVU1245
 3962 0026 40F66131 		movw	r1, #2913
 3963 002a 074B     		ldr	r3, .L416+8
 3964 002c 074A     		ldr	r2, .L416+12
 3965 002e 0848     		ldr	r0, .L416+16
 3966 0030 FFF7FEFF 		bl	__assert_func
 3967              	.LVL431:
 3968              	.L410:
2913:Lib/FreeRTOS/Source/queue.c **** 
 3969              		.loc 1 2913 9 is_stmt 0 discriminator 1 view .LVU1246
 3970              	.LBE60:
 3971              	.LBE59:
2932:Lib/FreeRTOS/Source/queue.c ****             }
 3972              		.loc 1 2932 41 is_stmt 1 view .LVU1247
2917:Lib/FreeRTOS/Source/queue.c ****         {
 3973              		.loc 1 2917 89 discriminator 2 view .LVU1248
2917:Lib/FreeRTOS/Source/queue.c ****         {
 3974              		.loc 1 2917 42 is_stmt 0 discriminator 1 view .LVU1249
 3975 0034 013A     		subs	r2, r2, #1
2917:Lib/FreeRTOS/Source/queue.c ****         {
 3976              		.loc 1 2917 89 discriminator 2 view .LVU1250
 3977 0036 03F10103 		add	r3, r3, #1
 3978              	.LVL432:
2917:Lib/FreeRTOS/Source/queue.c ****         {
 3979              		.loc 1 2917 42 is_stmt 1 discriminator 1 view .LVU1251
 3980 003a E6D1     		bne	.L409
 3981 003c F0E7     		b	.L408
 3982              	.L417:
 3983 003e 00BF     		.align	2
 3984              	.L416:
 3985 0040 04000000 		.word	xQueueRegistry+4
 3986 0044 00000000 		.word	xQueueRegistry
 3987 0048 00000000 		.word	.LC0
 3988 004c 00000000 		.word	__func__.0
 3989 0050 02000000 		.word	.LC1
 3990              		.cfi_endproc
 3991              	.LFE38:
 3993              		.section	.text.vQueueDelete,"ax",%progbits
 3994              		.align	1
 3995              		.global	vQueueDelete
 3996              		.syntax unified
 3997              		.thumb
 3998              		.thumb_func
ARM GAS  /tmp/ccTT1k9d.s 			page 142


 4000              	vQueueDelete:
 4001              	.LVL433:
 4002              	.LFB22:
2125:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 4003              		.loc 1 2125 1 view -0
 4004              		.cfi_startproc
 4005              		@ args = 0, pretend = 0, frame = 0
 4006              		@ frame_needed = 0, uses_anonymous_args = 0
2126:Lib/FreeRTOS/Source/queue.c **** 
 4007              		.loc 1 2126 5 view .LVU1253
2128:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4008              		.loc 1 2128 5 view .LVU1254
2125:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 4009              		.loc 1 2125 1 is_stmt 0 view .LVU1255
 4010 0000 08B5     		push	{r3, lr}
 4011              		.cfi_def_cfa_offset 8
 4012              		.cfi_offset 3, -8
 4013              		.cfi_offset 14, -4
2128:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4014              		.loc 1 2128 5 view .LVU1256
 4015 0002 40B9     		cbnz	r0, .L419
2128:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4016              		.loc 1 2128 5 is_stmt 1 discriminator 1 view .LVU1257
 4017 0004 FFF7FEFF 		bl	ulSetInterruptMask
 4018              	.LVL434:
2128:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4019              		.loc 1 2128 5 discriminator 1 view .LVU1258
 4020 0008 4FF40561 		mov	r1, #2128
 4021 000c 044B     		ldr	r3, .L420
 4022 000e 054A     		ldr	r2, .L420+4
 4023 0010 0548     		ldr	r0, .L420+8
 4024 0012 FFF7FEFF 		bl	__assert_func
 4025              	.LVL435:
 4026              	.L419:
2128:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
 4027              		.loc 1 2128 28 discriminator 2 view .LVU1259
2129:Lib/FreeRTOS/Source/queue.c **** 
 4028              		.loc 1 2129 33 view .LVU1260
2133:Lib/FreeRTOS/Source/queue.c ****     }
 4029              		.loc 1 2133 9 view .LVU1261
2163:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 4030              		.loc 1 2163 1 is_stmt 0 view .LVU1262
 4031 0016 BDE80840 		pop	{r3, lr}
 4032              		.cfi_restore 14
 4033              		.cfi_restore 3
 4034              		.cfi_def_cfa_offset 0
2133:Lib/FreeRTOS/Source/queue.c ****     }
 4035              		.loc 1 2133 9 view .LVU1263
 4036 001a FFF7FEBF 		b	vQueueUnregisterQueue
 4037              	.LVL436:
 4038              	.L421:
2133:Lib/FreeRTOS/Source/queue.c ****     }
 4039              		.loc 1 2133 9 view .LVU1264
 4040 001e 00BF     		.align	2
 4041              	.L420:
 4042 0020 00000000 		.word	.LC0
 4043 0024 00000000 		.word	__func__.5
ARM GAS  /tmp/ccTT1k9d.s 			page 143


 4044 0028 02000000 		.word	.LC1
 4045              		.cfi_endproc
 4046              	.LFE22:
 4048              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 4049              		.align	1
 4050              		.global	vQueueWaitForMessageRestricted
 4051              		.syntax unified
 4052              		.thumb
 4053              		.thumb_func
 4055              	vQueueWaitForMessageRestricted:
 4056              	.LVL437:
 4057              	.LFB39:
2936:Lib/FreeRTOS/Source/queue.c **** 
2937:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2938:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2939:Lib/FreeRTOS/Source/queue.c **** 
2940:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2941:Lib/FreeRTOS/Source/queue.c **** 
2942:Lib/FreeRTOS/Source/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2943:Lib/FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait,
2944:Lib/FreeRTOS/Source/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2945:Lib/FreeRTOS/Source/queue.c ****     {
 4058              		.loc 1 2945 5 is_stmt 1 view -0
 4059              		.cfi_startproc
 4060              		@ args = 0, pretend = 0, frame = 0
 4061              		@ frame_needed = 0, uses_anonymous_args = 0
2946:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 4062              		.loc 1 2946 9 view .LVU1266
2945:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 4063              		.loc 1 2945 5 is_stmt 0 view .LVU1267
 4064 0000 70B5     		push	{r4, r5, r6, lr}
 4065              		.cfi_def_cfa_offset 16
 4066              		.cfi_offset 4, -16
 4067              		.cfi_offset 5, -12
 4068              		.cfi_offset 6, -8
 4069              		.cfi_offset 14, -4
2945:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 4070              		.loc 1 2945 5 view .LVU1268
 4071 0002 0446     		mov	r4, r0
 4072              	.LVL438:
2947:Lib/FreeRTOS/Source/queue.c **** 
2948:Lib/FreeRTOS/Source/queue.c ****         /* This function should not be called by application code hence the
2949:Lib/FreeRTOS/Source/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2950:Lib/FreeRTOS/Source/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2951:Lib/FreeRTOS/Source/queue.c ****          * It can result in vListInsert() being called on a list that can only
2952:Lib/FreeRTOS/Source/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2953:Lib/FreeRTOS/Source/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2954:Lib/FreeRTOS/Source/queue.c ****          * section. */
2955:Lib/FreeRTOS/Source/queue.c **** 
2956:Lib/FreeRTOS/Source/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
2957:Lib/FreeRTOS/Source/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2958:Lib/FreeRTOS/Source/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2959:Lib/FreeRTOS/Source/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2960:Lib/FreeRTOS/Source/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2961:Lib/FreeRTOS/Source/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2962:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 4073              		.loc 1 2962 9 is_stmt 1 view .LVU1269
ARM GAS  /tmp/ccTT1k9d.s 			page 144


2945:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 4074              		.loc 1 2945 5 is_stmt 0 view .LVU1270
 4075 0004 0D46     		mov	r5, r1
 4076 0006 1646     		mov	r6, r2
 4077              		.loc 1 2962 9 view .LVU1271
 4078 0008 FFF7FEFF 		bl	vPortEnterCritical
 4079              	.LVL439:
 4080              		.loc 1 2962 9 is_stmt 1 discriminator 1 view .LVU1272
 4081 000c 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 4082 0010 FF2B     		cmp	r3, #255
 4083              		.loc 1 2962 9 discriminator 1 view .LVU1273
 4084 0012 04BF     		itt	eq
 4085 0014 0023     		moveq	r3, #0
 4086 0016 84F84430 		strbeq	r3, [r4, #68]
 4087              		.loc 1 2962 9 discriminator 3 view .LVU1274
 4088 001a 94F84530 		ldrb	r3, [r4, #69]	@ zero_extendqisi2
 4089 001e FF2B     		cmp	r3, #255
 4090              		.loc 1 2962 9 discriminator 4 view .LVU1275
 4091 0020 04BF     		itt	eq
 4092 0022 0023     		moveq	r3, #0
 4093 0024 84F84530 		strbeq	r3, [r4, #69]
 4094              		.loc 1 2962 9 discriminator 6 view .LVU1276
 4095 0028 FFF7FEFF 		bl	vPortExitCritical
 4096              	.LVL440:
2963:Lib/FreeRTOS/Source/queue.c **** 
2964:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4097              		.loc 1 2964 9 view .LVU1277
 4098              		.loc 1 2964 20 is_stmt 0 view .LVU1278
 4099 002c A36B     		ldr	r3, [r4, #56]
 4100              		.loc 1 2964 11 view .LVU1279
 4101 002e 2BB9     		cbnz	r3, .L425
2965:Lib/FreeRTOS/Source/queue.c ****         {
2966:Lib/FreeRTOS/Source/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2967:Lib/FreeRTOS/Source/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
 4102              		.loc 1 2967 13 is_stmt 1 view .LVU1280
 4103 0030 3246     		mov	r2, r6
 4104 0032 2946     		mov	r1, r5
 4105 0034 04F12400 		add	r0, r4, #36
 4106 0038 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 4107              	.LVL441:
 4108              	.L425:
2968:Lib/FreeRTOS/Source/queue.c ****         }
2969:Lib/FreeRTOS/Source/queue.c ****         else
2970:Lib/FreeRTOS/Source/queue.c ****         {
2971:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 4109              		.loc 1 2971 37 view .LVU1281
2972:Lib/FreeRTOS/Source/queue.c ****         }
2973:Lib/FreeRTOS/Source/queue.c **** 
2974:Lib/FreeRTOS/Source/queue.c ****         prvUnlockQueue( pxQueue );
 4110              		.loc 1 2974 9 view .LVU1282
 4111 003c 2046     		mov	r0, r4
2975:Lib/FreeRTOS/Source/queue.c ****     }
 4112              		.loc 1 2975 5 is_stmt 0 view .LVU1283
 4113 003e BDE87040 		pop	{r4, r5, r6, lr}
 4114              		.cfi_restore 14
 4115              		.cfi_restore 6
 4116              		.cfi_restore 5
ARM GAS  /tmp/ccTT1k9d.s 			page 145


 4117              		.cfi_restore 4
 4118              		.cfi_def_cfa_offset 0
 4119              	.LVL442:
2974:Lib/FreeRTOS/Source/queue.c ****     }
 4120              		.loc 1 2974 9 view .LVU1284
 4121 0042 FFF7FEBF 		b	prvUnlockQueue
 4122              	.LVL443:
2974:Lib/FreeRTOS/Source/queue.c ****     }
 4123              		.loc 1 2974 9 view .LVU1285
 4124              		.cfi_endproc
 4125              	.LFE39:
 4127              		.section	.rodata.__func__.0,"a"
 4130              	__func__.0:
 4131 0000 76517565 		.ascii	"vQueueUnregisterQueue\000"
 4131      7565556E 
 4131      72656769 
 4131      73746572 
 4131      51756575 
 4132              		.section	.rodata.__func__.1,"a"
 4135              	__func__.1:
 4136 0000 70635175 		.ascii	"pcQueueGetName\000"
 4136      65756547 
 4136      65744E61 
 4136      6D6500
 4137              		.section	.rodata.__func__.2,"a"
 4140              	__func__.2:
 4141 0000 76517565 		.ascii	"vQueueAddToRegistry\000"
 4141      75654164 
 4141      64546F52 
 4141      65676973 
 4141      74727900 
 4142              		.section	.rodata.__func__.3,"a"
 4145              	__func__.3:
 4146 0000 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 4146      75654973 
 4146      51756575 
 4146      6546756C 
 4146      6C46726F 
 4147              		.section	.rodata.__func__.4,"a"
 4150              	__func__.4:
 4151 0000 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 4151      75654973 
 4151      51756575 
 4151      65456D70 
 4151      74794672 
 4152              		.section	.rodata.__func__.5,"a"
 4155              	__func__.5:
 4156 0000 76517565 		.ascii	"vQueueDelete\000"
 4156      75654465 
 4156      6C657465 
 4156      00
 4157              		.section	.rodata.__func__.6,"a"
 4160              	__func__.6:
 4161 0000 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 4161      6575654D 
 4161      65737361 
 4161      67657357 
ARM GAS  /tmp/ccTT1k9d.s 			page 146


 4161      61697469 
 4162              		.section	.rodata.__func__.7,"a"
 4165              	__func__.7:
 4166 0000 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 4166      65756553 
 4166      70616365 
 4166      73417661 
 4166      696C6162 
 4167              		.section	.rodata.__func__.8,"a"
 4170              	__func__.8:
 4171 0000 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 4171      6575654D 
 4171      65737361 
 4171      67657357 
 4171      61697469 
 4172              		.section	.rodata.__func__.9,"a"
 4175              	__func__.9:
 4176 0000 78517565 		.ascii	"xQueuePeekFromISR\000"
 4176      75655065 
 4176      656B4672 
 4176      6F6D4953 
 4176      5200
 4177              		.section	.rodata.__func__.10,"a"
 4180              	__func__.10:
 4181 0000 78517565 		.ascii	"xQueueReceiveFromISR\000"
 4181      75655265 
 4181      63656976 
 4181      6546726F 
 4181      6D495352 
 4182              		.section	.rodata.__func__.11,"a"
 4185              	__func__.11:
 4186 0000 78517565 		.ascii	"xQueuePeek\000"
 4186      75655065 
 4186      656B00
 4187              		.section	.rodata.__func__.12,"a"
 4190              	__func__.12:
 4191 0000 78517565 		.ascii	"xQueueSemaphoreTake\000"
 4191      75655365 
 4191      6D617068 
 4191      6F726554 
 4191      616B6500 
 4192              		.section	.rodata.__func__.13,"a"
 4195              	__func__.13:
 4196 0000 78517565 		.ascii	"xQueueReceive\000"
 4196      75655265 
 4196      63656976 
 4196      6500
 4197              		.section	.rodata.__func__.14,"a"
 4200              	__func__.14:
 4201 0000 78517565 		.ascii	"xQueueGiveFromISR\000"
 4201      75654769 
 4201      76654672 
 4201      6F6D4953 
 4201      5200
 4202              		.section	.rodata.__func__.15,"a"
 4205              	__func__.15:
 4206 0000 78517565 		.ascii	"xQueueGenericSendFromISR\000"
ARM GAS  /tmp/ccTT1k9d.s 			page 147


 4206      75654765 
 4206      6E657269 
 4206      6353656E 
 4206      6446726F 
 4207              		.section	.rodata.__func__.16,"a"
 4210              	__func__.16:
 4211 0000 78517565 		.ascii	"xQueueGenericSend\000"
 4211      75654765 
 4211      6E657269 
 4211      6353656E 
 4211      6400
 4212              		.section	.rodata.__func__.17,"a"
 4215              	__func__.17:
 4216 0000 78517565 		.ascii	"xQueueCreateCountingSemaphoreStatic\000"
 4216      75654372 
 4216      65617465 
 4216      436F756E 
 4216      74696E67 
 4217              		.section	.rodata.__func__.18,"a"
 4220              	__func__.18:
 4221 0000 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 4221      75655461 
 4221      6B654D75 
 4221      74657852 
 4221      65637572 
 4222              		.section	.rodata.__func__.19,"a"
 4225              	__func__.19:
 4226 0000 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 4226      75654769 
 4226      76654D75 
 4226      74657852 
 4226      65637572 
 4227              		.section	.rodata.__func__.20,"a"
 4230              	__func__.20:
 4231 0000 78517565 		.ascii	"xQueueGetMutexHolderFromISR\000"
 4231      75654765 
 4231      744D7574 
 4231      6578486F 
 4231      6C646572 
 4232              		.section	.rodata.__func__.21,"a"
 4235              	__func__.21:
 4236 0000 78517565 		.ascii	"xQueueGetMutexHolder\000"
 4236      75654765 
 4236      744D7574 
 4236      6578486F 
 4236      6C646572 
 4237              		.section	.rodata.__func__.22,"a"
 4240              	__func__.22:
 4241 0000 78517565 		.ascii	"xQueueGenericGetStaticBuffers\000"
 4241      75654765 
 4241      6E657269 
 4241      63476574 
 4241      53746174 
 4242              		.section	.rodata.__func__.23,"a"
 4245              	__func__.23:
 4246 0000 78517565 		.ascii	"xQueueGenericCreateStatic\000"
 4246      75654765 
ARM GAS  /tmp/ccTT1k9d.s 			page 148


 4246      6E657269 
 4246      63437265 
 4246      61746553 
 4247              		.section	.rodata.__func__.24,"a"
 4250              	__func__.24:
 4251 0000 78517565 		.ascii	"xQueueGenericReset\000"
 4251      75654765 
 4251      6E657269 
 4251      63526573 
 4251      657400
 4252              		.global	xQueueRegistry
 4253              		.section	.bss.xQueueRegistry,"aw",%nobits
 4254              		.align	2
 4257              	xQueueRegistry:
 4258 0000 00000000 		.space	64
 4258      00000000 
 4258      00000000 
 4258      00000000 
 4258      00000000 
 4259              		.text
 4260              	.Letext0:
 4261              		.file 2 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4262              		.file 3 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4263              		.file 4 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4264              		.file 5 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 4265              		.file 6 "Lib/FreeRTOS/Source/include/FreeRTOS.h"
 4266              		.file 7 "Lib/FreeRTOS/Source/include/list.h"
 4267              		.file 8 "Lib/FreeRTOS/Source/include/task.h"
 4268              		.file 9 "Lib/FreeRTOS/Source/include/queue.h"
 4269              		.file 10 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4270              		.file 11 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4271              		.file 12 "<built-in>"
ARM GAS  /tmp/ccTT1k9d.s 			page 149


DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/ccTT1k9d.s:26     .text.prvIsQueueEmpty:00000000 $t
     /tmp/ccTT1k9d.s:31     .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/ccTT1k9d.s:67     .text.prvCopyDataToQueue:00000000 $t
     /tmp/ccTT1k9d.s:72     .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/ccTT1k9d.s:214    .text.prvCopyDataFromQueue:00000000 $t
     /tmp/ccTT1k9d.s:219    .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/ccTT1k9d.s:284    .text.prvUnlockQueue:00000000 $t
     /tmp/ccTT1k9d.s:289    .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/ccTT1k9d.s:437    .text.xQueueGenericReset:00000000 $t
     /tmp/ccTT1k9d.s:443    .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/ccTT1k9d.s:575    .text.xQueueGenericReset:00000088 $d
     /tmp/ccTT1k9d.s:4250   .rodata.__func__.24:00000000 __func__.24
     /tmp/ccTT1k9d.s:582    .text.xQueueGenericCreateStatic:00000000 $t
     /tmp/ccTT1k9d.s:588    .text.xQueueGenericCreateStatic:00000000 xQueueGenericCreateStatic
     /tmp/ccTT1k9d.s:734    .text.xQueueGenericCreateStatic:0000006c $d
     /tmp/ccTT1k9d.s:4245   .rodata.__func__.23:00000000 __func__.23
     /tmp/ccTT1k9d.s:741    .text.xQueueGenericGetStaticBuffers:00000000 $t
     /tmp/ccTT1k9d.s:747    .text.xQueueGenericGetStaticBuffers:00000000 xQueueGenericGetStaticBuffers
     /tmp/ccTT1k9d.s:813    .text.xQueueGenericGetStaticBuffers:00000034 $d
     /tmp/ccTT1k9d.s:4240   .rodata.__func__.22:00000000 __func__.22
     /tmp/ccTT1k9d.s:820    .text.xQueueGetMutexHolder:00000000 $t
     /tmp/ccTT1k9d.s:826    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
     /tmp/ccTT1k9d.s:885    .text.xQueueGetMutexHolder:00000030 $d
     /tmp/ccTT1k9d.s:4235   .rodata.__func__.21:00000000 __func__.21
     /tmp/ccTT1k9d.s:892    .text.xQueueGetMutexHolderFromISR:00000000 $t
     /tmp/ccTT1k9d.s:898    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
     /tmp/ccTT1k9d.s:948    .text.xQueueGetMutexHolderFromISR:00000024 $d
     /tmp/ccTT1k9d.s:4230   .rodata.__func__.20:00000000 __func__.20
     /tmp/ccTT1k9d.s:955    .text.xQueueCreateCountingSemaphoreStatic:00000000 $t
     /tmp/ccTT1k9d.s:961    .text.xQueueCreateCountingSemaphoreStatic:00000000 xQueueCreateCountingSemaphoreStatic
     /tmp/ccTT1k9d.s:1026   .text.xQueueCreateCountingSemaphoreStatic:00000034 $d
     /tmp/ccTT1k9d.s:4215   .rodata.__func__.17:00000000 __func__.17
     /tmp/ccTT1k9d.s:1033   .text.xQueueGenericSend:00000000 $t
     /tmp/ccTT1k9d.s:1039   .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/ccTT1k9d.s:1347   .text.xQueueGenericSend:00000138 $d
     /tmp/ccTT1k9d.s:4210   .rodata.__func__.16:00000000 __func__.16
     /tmp/ccTT1k9d.s:1354   .text.xQueueCreateMutexStatic:00000000 $t
     /tmp/ccTT1k9d.s:1360   .text.xQueueCreateMutexStatic:00000000 xQueueCreateMutexStatic
     /tmp/ccTT1k9d.s:1435   .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/ccTT1k9d.s:1441   .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/ccTT1k9d.s:1518   .text.xQueueGiveMutexRecursive:00000040 $d
     /tmp/ccTT1k9d.s:4225   .rodata.__func__.19:00000000 __func__.19
     /tmp/ccTT1k9d.s:1525   .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/ccTT1k9d.s:1531   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/ccTT1k9d.s:1738   .text.xQueueGenericSendFromISR:000000c4 $d
     /tmp/ccTT1k9d.s:4205   .rodata.__func__.15:00000000 __func__.15
     /tmp/ccTT1k9d.s:1745   .text.xQueueGiveFromISR:00000000 $t
     /tmp/ccTT1k9d.s:1751   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
     /tmp/ccTT1k9d.s:1949   .text.xQueueGiveFromISR:000000ac $d
     /tmp/ccTT1k9d.s:4200   .rodata.__func__.14:00000000 __func__.14
     /tmp/ccTT1k9d.s:1957   .text.xQueueReceive:00000000 $t
     /tmp/ccTT1k9d.s:1963   .text.xQueueReceive:00000000 xQueueReceive
     /tmp/ccTT1k9d.s:2228   .text.xQueueReceive:00000114 $d
     /tmp/ccTT1k9d.s:4195   .rodata.__func__.13:00000000 __func__.13
     /tmp/ccTT1k9d.s:2235   .text.xQueueSemaphoreTake:00000000 $t
ARM GAS  /tmp/ccTT1k9d.s 			page 150


     /tmp/ccTT1k9d.s:2241   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
     /tmp/ccTT1k9d.s:2575   .text.xQueueSemaphoreTake:00000140 $d
     /tmp/ccTT1k9d.s:4190   .rodata.__func__.12:00000000 __func__.12
     /tmp/ccTT1k9d.s:2583   .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/ccTT1k9d.s:2589   .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/ccTT1k9d.s:2666   .text.xQueueTakeMutexRecursive:00000044 $d
     /tmp/ccTT1k9d.s:4220   .rodata.__func__.18:00000000 __func__.18
     /tmp/ccTT1k9d.s:2673   .text.xQueuePeek:00000000 $t
     /tmp/ccTT1k9d.s:2679   .text.xQueuePeek:00000000 xQueuePeek
     /tmp/ccTT1k9d.s:2949   .text.xQueuePeek:00000110 $d
     /tmp/ccTT1k9d.s:4185   .rodata.__func__.11:00000000 __func__.11
     /tmp/ccTT1k9d.s:2956   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/ccTT1k9d.s:2962   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/ccTT1k9d.s:3141   .text.xQueueReceiveFromISR:000000a4 $d
     /tmp/ccTT1k9d.s:4180   .rodata.__func__.10:00000000 __func__.10
     /tmp/ccTT1k9d.s:3151   .text.xQueuePeekFromISR:00000000 $t
     /tmp/ccTT1k9d.s:3157   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/ccTT1k9d.s:3281   .text.xQueuePeekFromISR:00000068 $d
     /tmp/ccTT1k9d.s:4175   .rodata.__func__.9:00000000 __func__.9
     /tmp/ccTT1k9d.s:3288   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/ccTT1k9d.s:3294   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/ccTT1k9d.s:3342   .text.uxQueueMessagesWaiting:00000028 $d
     /tmp/ccTT1k9d.s:4170   .rodata.__func__.8:00000000 __func__.8
     /tmp/ccTT1k9d.s:3349   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/ccTT1k9d.s:3355   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/ccTT1k9d.s:3409   .text.uxQueueSpacesAvailable:0000002c $d
     /tmp/ccTT1k9d.s:4165   .rodata.__func__.7:00000000 __func__.7
     /tmp/ccTT1k9d.s:3416   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/ccTT1k9d.s:3422   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/ccTT1k9d.s:3461   .text.uxQueueMessagesWaitingFromISR:0000001c $d
     /tmp/ccTT1k9d.s:4160   .rodata.__func__.6:00000000 __func__.6
     /tmp/ccTT1k9d.s:3468   .text.uxQueueGetQueueNumber:00000000 $t
     /tmp/ccTT1k9d.s:3474   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
     /tmp/ccTT1k9d.s:3492   .text.vQueueSetQueueNumber:00000000 $t
     /tmp/ccTT1k9d.s:3498   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
     /tmp/ccTT1k9d.s:3515   .text.ucQueueGetQueueType:00000000 $t
     /tmp/ccTT1k9d.s:3521   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
     /tmp/ccTT1k9d.s:3539   .text.uxQueueGetQueueItemSize:00000000 $t
     /tmp/ccTT1k9d.s:3545   .text.uxQueueGetQueueItemSize:00000000 uxQueueGetQueueItemSize
     /tmp/ccTT1k9d.s:3563   .text.uxQueueGetQueueLength:00000000 $t
     /tmp/ccTT1k9d.s:3569   .text.uxQueueGetQueueLength:00000000 uxQueueGetQueueLength
     /tmp/ccTT1k9d.s:3587   .text.xQueueIsQueueEmptyFromISR:00000000 $t
     /tmp/ccTT1k9d.s:3593   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/ccTT1k9d.s:3636   .text.xQueueIsQueueEmptyFromISR:00000020 $d
     /tmp/ccTT1k9d.s:4150   .rodata.__func__.4:00000000 __func__.4
     /tmp/ccTT1k9d.s:3643   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/ccTT1k9d.s:3649   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/ccTT1k9d.s:3697   .text.xQueueIsQueueFullFromISR:00000024 $d
     /tmp/ccTT1k9d.s:4145   .rodata.__func__.3:00000000 __func__.3
     /tmp/ccTT1k9d.s:3704   .text.vQueueAddToRegistry:00000000 $t
     /tmp/ccTT1k9d.s:3710   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/ccTT1k9d.s:3808   .text.vQueueAddToRegistry:00000050 $d
     /tmp/ccTT1k9d.s:4140   .rodata.__func__.2:00000000 __func__.2
     /tmp/ccTT1k9d.s:4257   .bss.xQueueRegistry:00000000 xQueueRegistry
     /tmp/ccTT1k9d.s:3816   .text.pcQueueGetName:00000000 $t
     /tmp/ccTT1k9d.s:3822   .text.pcQueueGetName:00000000 pcQueueGetName
     /tmp/ccTT1k9d.s:3891   .text.pcQueueGetName:00000038 $d
ARM GAS  /tmp/ccTT1k9d.s 			page 151


     /tmp/ccTT1k9d.s:4135   .rodata.__func__.1:00000000 __func__.1
     /tmp/ccTT1k9d.s:3900   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/ccTT1k9d.s:3906   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/ccTT1k9d.s:3985   .text.vQueueUnregisterQueue:00000040 $d
     /tmp/ccTT1k9d.s:4130   .rodata.__func__.0:00000000 __func__.0
     /tmp/ccTT1k9d.s:3994   .text.vQueueDelete:00000000 $t
     /tmp/ccTT1k9d.s:4000   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/ccTT1k9d.s:4042   .text.vQueueDelete:00000020 $d
     /tmp/ccTT1k9d.s:4155   .rodata.__func__.5:00000000 __func__.5
     /tmp/ccTT1k9d.s:4049   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/ccTT1k9d.s:4055   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
     /tmp/ccTT1k9d.s:4254   .bss.xQueueRegistry:00000000 $d
                           .group:00000000 wm4.0.c552ae9005b0f2cca11872fae5d4b7f2
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.newlib.h.27.4b972ceed5d01f491020c20f1e546cab
                           .group:00000000 wm4.features.h.22.9dfb1293666eb4caf24cccb81c86a551
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.185.882514a1a6169ceba9142f401cbe27c6
                           .group:00000000 wm4.stddef.h.39.794fa375de48dda278c4aebb5c74aa5b
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4.cdefs.h.49.70fc7af612f78ddcace70fdd90b5623b
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.FreeRTOSConfig.h.59.2629c72cff9e6dbe880a2dc225eae516
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.queue.h.68.219f47fba8b59640449b84d04c5bd6d8

UNDEFINED SYMBOLS
vPortEnterCritical
vPortExitCritical
xTaskPriorityDisinherit
ARM GAS  /tmp/ccTT1k9d.s 			page 152


memcpy
xTaskRemoveFromEventList
vTaskMissedYield
ulSetInterruptMask
__assert_func
vPortYield
vListInitialise
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
xTaskGetCurrentTaskHandle
vPortValidateInterruptPriority
vClearInterruptMask
uxTaskGetNumberOfTasks
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
vTaskPlaceOnEventListRestricted
