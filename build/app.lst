ARM GAS  /tmp/ccbfgvbk.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 4
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"app.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Src/app.c"
  25              		.section	.text.LL_Buffer_addr_start,"ax",%progbits
  26              		.align	1
  27              		.syntax unified
  28              		.thumb
  29              		.thumb_func
  31              	LL_Buffer_addr_start:
  32              	.LVL0:
  33              	.LFB3354:
  34              		.file 2 "Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h"
   1:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** /**
   2:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
   3:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @file    ll_aton_NN_interface.h
   4:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @author  SRA Artificial Intelligence & Embedded Architectures
   5:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @brief   Interface that defines a NN generated by the AtoNN Compiler.
   6:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
   7:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @attention
   8:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
   9:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * Copyright (c) 2024 STMicroelectronics.
  10:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * All rights reserved.
  11:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
  12:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * This software is licensed under terms that can be found in the LICENSE file
  13:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * in the root directory of this software component.
  14:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * If no LICENSE file comes with this software, it is provided AS-IS.
  15:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
  16:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
  17:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  */
  18:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  19:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifndef __LL_ATON_NN_INTERFACE_H
  20:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #define __LL_ATON_NN_INTERFACE_H
  21:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  22:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifdef __cplusplus
  23:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** extern "C"
  24:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 2


  25:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif
  26:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  27:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <assert.h>
  28:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stdbool.h>
  29:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stddef.h>
  30:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stdint.h>
  31:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  32:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_config.h"
  33:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  34:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_attributes.h"
  35:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_util.h"
  36:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  37:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup User I/O Return Values & Callback Event Types
  38:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
  39:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  40:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  41:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum LL_ATON_User_IO_Result
  42:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  43:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_NOERROR,     /**< */
  44:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_ALIGN, /**< */
  45:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_SIZE,  /**< */
  46:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_INDEX, /**< */
  47:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_ATON_User_IO_Result_t;
  48:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  49:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum LL_ATON_RT_Callbacktype
  50:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  51:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_PRE_START,  /**< Callback called before start_epoch_block */
  52:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_POST_START, /**< Callback called after start_epoch_block */
  53:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_PRE_END,    /**< Callback called before end_epoch_block */
  54:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_POST_END,   /**< Callback called after end_epoch_block */
  55:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_NN_Init,    /**< Callback called after `LL_ATON_RT_Init_Network`,
  56:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                          *     NOTE: 3rd parameter passed is `NULL` */
  57:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_NN_DeInit,  /**< Callback called after `LL_ATON_RT_DeInit_Network`,
  58:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                          *     NOTE: 3rd parameter passed is `NULL` */
  59:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_RT_Init,    /**< Callback called after `LL_ATON_RT_RuntimeInit` */
  60:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_RT_Deinit,  /**< Callback called before `LL_ATON_RT_RuntimeDeInit` */
  61:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_ATON_RT_Callbacktype_t;
  62:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  63:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
  64:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
  65:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  66:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  67:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types for Epoch Blocks
  68:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
  69:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  70:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  71:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /* this is needed to avoid some compilers (e.g. KEIL) that observe a strict semantic about conver
  72:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * pointers to integers in cost initializers
  73:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  74:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef union
  75:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  76:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     unsigned char *p;
  77:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uintptr_t i;
  78:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } __LL_address_t;
  79:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  80:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*EpochBlock_FuncPtr_t)(const void *epoch_block);
  81:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 3


  82:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
  83:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  84:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_NONE = 0x0,                 /**< */
  85:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_epoch_start = (0x1 << 0),   /**< First EpochBlock of an Epoch */
  86:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_epoch_end = (0x1 << 1),     /**< Last EpochBlock of an Epoch */
  87:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_blob = (0x1 << 2),          /**< Item is an Epoch Blob */
  88:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_last_eb = (0x1 << 3),       /**< Last EpochBlock */
  89:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_pure_hw = (0x1 << 4),       /**< Pure HW EpochBlock */
  90:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_pure_sw = (0x1 << 5),       /**< Pure SW EpochBlock */
  91:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_hybrid = (0x1 << 6),        /**< Hybrid EpochBlock (i.e. mixed HW/SW) */
  92:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_internal = (0x1 << 7),      /**< ATON lib internal EpochBlock (used to impleme
  93:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_blob_encrypted = (0x1 << 8) /**< The blob is encrypted and must be decrypted o
  94:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } EpochBlock_Flags_t;
  95:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  96:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
  97:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  98:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_FuncPtr_t start_epoch_block; /**< Method to execute the EpochBlock */
  99:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_FuncPtr_t end_epoch_block;   /**< Method to be executed when the EpochBlock ends */
 100:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uintptr_t blob_address;                 /**< Blob address (in case this EpochBlock represents a
 101:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t wait_mask;                     /**< Mask needed to check when an EpochBlock ends
 102:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                              *    - if epoch blob: number (not bitmask) of epoch co
 103:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                              *    - otherwise: bitmask with all output streaming en
 104:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t flags;                         /**< EpochBlock flags */
 105:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifdef LL_ATON_EB_DBG_INFO
 106:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int16_t epoch_num;             /**< Epoch number / First epoch number within blob */
 107:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int16_t last_epoch_num;        /**< Epoch number / Last epoch number within blob */
 108:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t in_streng_mask;       /**< Debug information about input streaming engines used in epo
 109:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t out_streng_mask;      /**< Debug information about output streaming engines used in ep
 110:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint64_t estimated_npu_cycles; /**< Debug information estimates for NPU cycles in epoch w/o mem
 111:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint64_t estimated_tot_cycles; /**< Debug information estimates for NPU cycles in epoch w/ memo
 112:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                             // LL_ATON_EB_DBG_INFO
 113:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } EpochBlock_ItemTypeDef;
 114:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef EpochBlock_ItemTypeDef LL_ATON_RT_EpochBlockItem_t;
 115:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 116:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 117:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 118:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 119:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 120:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Declarations for User Callbacks
 121:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 122:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 123:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 124:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 125:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the last one of an array of `const EpochBlock_ItemType
 126:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 127:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 128:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb);
 129:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 130:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 131:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the first EpochBlock of an Epoch
 132:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 133:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 134:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb);
 135:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 136:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 137:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the last EpochBlock of an Epoch
 138:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
ARM GAS  /tmp/ccbfgvbk.s 			page 4


 139:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 140:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochEnd(const EpochBlock_ItemTypeDef *eb);
 141:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 142:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 143:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the an Epoch Blob
 144:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 145:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 146:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb);
 147:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 148:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 149:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if - in case this epoch is a blob (see above) - the blob is encrypted
 150:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 151:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 152:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsBlobEncrypted(const EpochBlock_ItemTypeDef *eb);
 153:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 154:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 155:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is pure SW epoch
 156:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 157:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 158:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureSW(const EpochBlock_ItemTypeDef *eb);
 159:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 160:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 161:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is a pure HW or mixed SW/HW epoch
 162:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 163:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 164:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb);
 165:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 166:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 167:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is a hybrid epoch
 168:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 169:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 170:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb);
 171:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 172:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 173:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is an internal epoch
 174:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 175:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 176:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb);
 177:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 178:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 179:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Returns the Epoch controller id to use
 180:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 181:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 182:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb);
 183:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 184:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 185:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Returns the address of the configuration of the epoch controller (the blob address)
 186:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 187:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 188:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb);
 189:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 190:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 191:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer types definition
 192:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 193:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 194:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 195:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
ARM GAS  /tmp/ccbfgvbk.s 			page 5


 196:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 197:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 198:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types for Input, Output, and Internal Buffers
 199:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 200:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 201:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 202:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
 203:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 204:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UNDEFINED = 0,
 205:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FLOAT = 1,
 206:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT2 = 2,
 207:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT2 = 3,
 208:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT4 = 4,
 209:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT4 = 5,
 210:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT8 = 6,
 211:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT8 = 7,
 212:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT16 = 8,
 213:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT16 = 9,
 214:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT32 = 10,
 215:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT64 = 11,
 216:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_STRING = 12,
 217:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_BOOL = 13,
 218:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FLOAT16 = 14,
 219:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_DOUBLE = 15,
 220:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT32 = 16,
 221:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT64 = 17,
 222:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_COMPLEX64 = 18,
 223:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_COMPLEX128 = 19,
 224:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_BFLOAT16 = 20,
 225:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FXP = 100 // AtoNN specific
 226:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } Buffer_DataType_TypeDef;
 227:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 228:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 229:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer Channel position
 230:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 231:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 232:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
 233:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 234:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_UNDEFINED = 0, /**< No channel present */
 235:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_First = 1,     /**< Channel First         ( ...B C H W )*/
 236:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_Last = 2,      /**< Channel Last          ( ...B H W C ) */
 237:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_Mixed = 3,     /**< Channel with Batch(b) ( ...B C/b H W b ) */
 238:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } Buffer_CHPos_TypeDef;
 239:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 240:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 241:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer definition
 242:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 243:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 244:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 245:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const char *name;             /**< Buffer name. NULL if end of list */
 246:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     __LL_address_t addr_base;     /**< Buffer base address */
 247:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_start;        /**< Offset of the buffer start address from the base address */
 248:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_end;          /**< Offset of the buffer end address from the base address
 249:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (first bytes address beyond buffer length) */
 250:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_limit;        /**< Offset of the limiter address from the base address,
 251:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (needed for configuring streaming engines) */
 252:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t is_user_allocated;    /**< */
ARM GAS  /tmp/ccbfgvbk.s 			page 6


 253:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t is_param;             /**< */
 254:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t epoch;               /**< */
 255:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t batch;               /**< */
 256:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const uint32_t *mem_shape;    /**< shape as seen by the user in memory (only valid for input/ou
 257:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t mem_ndims;           /**< Number of dimensions of mem_shape (Length of mem_shape) */
 258:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     Buffer_CHPos_TypeDef chpos;   /**< Position  of channels dimension in mem shape */
 259:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     Buffer_DataType_TypeDef type; /**< */
 260:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int8_t Qm;                    /**< */
 261:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int8_t Qn;                    /**< */
 262:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t Qunsigned;            /**< */
 263:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t ndims;                /**< */
 264:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t nbits;                /**< */
 265:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t per_channel;          /**< */
 266:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const uint32_t *shape;        /**< */
 267:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const float *scale;           /**< */
 268:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const int16_t *offset;        /**< This can become int8 or uint8 based on the Qunsigned field.
 269:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (This field Must have the same format of the quantized value
 270:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_Buffer_InfoTypeDef;
 271:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 272:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 273:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 274:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 275:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 276:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Declarations for Buffer Analysis
 277:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 278:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 279:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 280:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 281:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the base address of the mem pool the buffer is allocated in
 282:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 283:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 284:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf);
 285:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 286:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 287:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the start address of the buffer
 288:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 289:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 290:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf);
 291:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 292:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 293:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the end address of the buffer
 294:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 295:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 296:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_end(const LL_Buffer_InfoTypeDef *buf);
 297:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 298:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 299:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the limit address of the buffer
 300:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 301:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 302:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_limit(const LL_Buffer_InfoTypeDef *buf);
 303:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 304:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 305:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the length of the buffer
 306:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 307:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 308:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf);
 309:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 7


 310:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 311:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the buffer elements number of bits
 312:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 313:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 314:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_bits(const LL_Buffer_InfoTypeDef *buf);
 315:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 316:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 317:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 318:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 319:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 320:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types and Declaration Macros for ATON Runtime Execution & User AP
 321:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 322:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 323:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 324:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   struct __nn_instance_struct; // forward declaration
 325:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct __nn_instance_struct NN_Instance_TypeDef;
 326:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 327:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** /**
 328:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @brief Declare the function prototypes for named NN interface functions generated by the AtoNN c
 329:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @param network_name name of the network as provided by option `--network-name`
 330:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  */
 331:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #define LL_ATON_DECLARE_NAMED_NN_PROTOS(network_name)                                              
 332:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern bool LL_ATON_EC_Network_Init_##network_name(void);                                        
 333:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern bool LL_ATON_EC_Inference_Init_##network_name(void);                                      
 334:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_##network_name(uint32_t num, void *
 335:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                                                uint32_t size);     
 336:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern void *LL_ATON_Get_User_Input_Buffer_##network_name(uint32_t num);                         
 337:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_##network_name(uint32_t num, void 
 338:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                                                 uint32_t size);    
 339:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern void *LL_ATON_Get_User_Output_Buffer_##network_name(uint32_t num);                        
 340:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_##network_name(void);               
 341:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_##network_name(void);            
 342:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_##network_name(void);             
 343:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_##network_name(void);
 344:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 345:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 346:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief  Type definitions for NN interface functions
 347:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 348:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef bool (*NN_EC_Hook_TypeDef)(void);
 349:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef LL_ATON_User_IO_Result_t (*NN_InputSetter_TypeDef)(uint32_t num, void *buffer, uint32_t s
 350:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void *(*NN_InputGetter_TypeDef)(uint32_t num);
 351:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef LL_ATON_User_IO_Result_t (*NN_OutputSetter_TypeDef)(uint32_t num, void *buffer, uint32_t 
 352:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void *(*NN_OutputGetter_TypeDef)(uint32_t num);
 353:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef const EpochBlock_ItemTypeDef *(*NN_EpochBlockItems_TypeDef)(void);
 354:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef const LL_Buffer_InfoTypeDef *(*NN_Buffers_Info_TypeDef)(void);
 355:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 356:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*TraceRuntime_FuncPtr_t)(LL_ATON_RT_Callbacktype_t ctype);
 357:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 358:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*TraceEpochBlock_FuncPtr_t)(LL_ATON_RT_Callbacktype_t ctype, const NN_Instance_Type
 359:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                             const EpochBlock_ItemTypeDef *epoch_block);
 360:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 361:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 362:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 363:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const char *network_name;
 364:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EC_Hook_TypeDef ec_network_init;
 365:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EC_Hook_TypeDef ec_inference_init;
 366:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_InputSetter_TypeDef input_setter;
ARM GAS  /tmp/ccbfgvbk.s 			page 8


 367:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_InputGetter_TypeDef input_getter;
 368:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_OutputSetter_TypeDef output_setter;
 369:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_OutputGetter_TypeDef output_getter;
 370:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EpochBlockItems_TypeDef epoch_block_items;
 371:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef output_buffers_info;
 372:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef input_buffers_info;
 373:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef internal_buffers_info;
 374:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } NN_Interface_TypeDef;
 375:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 376:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 377:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 378:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile current_epoch_block; // pointer to current epoch block
 379:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile first_epoch_block;   // pointer to first epoch block in 
 380:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile next_epoch_block;    // pointer to epoch block to be ins
 381:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 382:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile saved_current_epoch_block; // pointer to saved current e
 383:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef
 384:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****         *volatile saved_first_epoch_block; // pointer to saved first epoch block in current epoch l
 385:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 386:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     bool inference_started; // inference has been started
 387:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 388:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
 389:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t triggered_events;        // currently triggered events/IRQs in current epoch
 390:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile bool current_epoch_block_started; // has current epoch block already been started
 391:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                                         // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
 392:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 393:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifndef NDEBUG
 394:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t
 395:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****         nr_of_epoch_blocks; // number of epoch blocks in network (includes also terminating empty e
 396:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t saved_nr_of_epoch_blocks; // number of epoch blocks in saved network (include
 397:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                 // empty epoch block)
 398:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                                          // NDEBUG
 399:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 400:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     TraceEpochBlock_FuncPtr_t epoch_callback_function; // epoch callback function
 401:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 402:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #if defined(LL_ATON_RT_RELOC)
 403:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t inst_reloc;
 404:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif
 405:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 406:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } NN_Execution_State_TypeDef;
 407:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 408:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   struct __nn_instance_struct
 409:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 410:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const NN_Interface_TypeDef *network;
 411:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Execution_State_TypeDef exec_state;
 412:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   };
 413:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 414:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 415:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 416:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 417:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 418:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Inline Implementations
 419:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 420:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 421:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 422:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb)
 423:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
ARM GAS  /tmp/ccbfgvbk.s 			page 9


 424:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_last_eb) != 0);
 425:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 426:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 427:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb)
 428:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 429:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
 430:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 431:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 432:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochEnd(const EpochBlock_ItemTypeDef *eb)
 433:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 434:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_epoch_end) != 0);
 435:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 436:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 437:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb)
 438:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 439:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_blob) != 0);
 440:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 441:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 442:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsBlobEncrypted(const EpochBlock_ItemTypeDef *eb)
 443:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 444:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_blob_encrypted) != 0);
 445:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 446:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 447:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureSW(const EpochBlock_ItemTypeDef *eb)
 448:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 449:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_pure_sw) != 0);
 450:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 451:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 452:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb)
 453:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 454:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
 455:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 456:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 457:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb)
 458:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 459:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_hybrid) != 0);
 460:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 461:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 462:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb)
 463:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 464:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_internal) != 0);
 465:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 466:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 467:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
 468:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 469:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
 470:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return eb->wait_mask;
 471:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 472:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 473:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb)
 474:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 475:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
 476:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return eb->blob_address;
 477:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 478:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 479:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
 480:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
ARM GAS  /tmp/ccbfgvbk.s 			page 10


 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     if (buf->is_user_allocated)
 482:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       unsigned char **tmp = (unsigned char **)buf->addr_base.p;
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
 485:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 486:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return buf->addr_base.p;
 487:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 488:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 489:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
 490:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  35              		.loc 2 490 3 view -0
  36              		.cfi_startproc
  37              		@ args = 0, pretend = 0, frame = 0
  38              		@ frame_needed = 0, uses_anonymous_args = 0
  39              		@ link register save eliminated.
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_start;
  40              		.loc 2 491 5 view .LVU1
  41              	.LBB119:
  42              	.LBI119:
 479:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  43              		.loc 2 479 32 view .LVU2
  44              	.LBB120:
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
  45              		.loc 2 481 5 view .LVU3
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
  46              		.loc 2 481 8 is_stmt 0 view .LVU4
  47 0000 027D     		ldrb	r2, [r0, #20]	@ zero_extendqisi2
  48              	.LBB121:
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
  49              		.loc 2 483 23 view .LVU5
  50 0002 4368     		ldr	r3, [r0, #4]
  51              	.LBE121:
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
  52              		.loc 2 481 8 view .LVU6
  53 0004 02B1     		cbz	r2, .L2
  54              	.LBB122:
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
  55              		.loc 2 483 7 is_stmt 1 view .LVU7
  56              	.LVL1:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
  57              		.loc 2 484 7 view .LVU8
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
  58              		.loc 2 484 14 is_stmt 0 view .LVU9
  59 0006 1B68     		ldr	r3, [r3]
  60              	.LVL2:
  61              	.L2:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
  62              		.loc 2 484 14 view .LVU10
  63              	.LBE122:
  64              	.LBE120:
  65              	.LBE119:
  66              		.loc 2 491 37 discriminator 1 view .LVU11
  67 0008 8068     		ldr	r0, [r0, #8]
  68              	.LVL3:
 492:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
  69              		.loc 2 492 3 view .LVU12
  70 000a 1844     		add	r0, r0, r3
ARM GAS  /tmp/ccbfgvbk.s 			page 11


  71 000c 7047     		bx	lr
  72              		.cfi_endproc
  73              	.LFE3354:
  75              		.section	.text.clamp_point,"ax",%progbits
  76              		.align	1
  77              		.syntax unified
  78              		.thumb
  79              		.thumb_func
  81              	clamp_point:
  82              	.LVL4:
  83              	.LFB7380:
   1:Src/app.c     **** /**
   2:Src/app.c     ****   ******************************************************************************
   3:Src/app.c     ****   * @file    app.c
   4:Src/app.c     ****   * @author  MDG Application Team
   5:Src/app.c     ****   ******************************************************************************
   6:Src/app.c     ****   * @attention
   7:Src/app.c     ****   *
   8:Src/app.c     ****   * Copyright (c) 2024 STMicroelectronics.
   9:Src/app.c     ****   * All rights reserved.
  10:Src/app.c     ****   *
  11:Src/app.c     ****   * This software is licensed under terms that can be found in the LICENSE file
  12:Src/app.c     ****   * in the root directory of this software component.
  13:Src/app.c     ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  14:Src/app.c     ****   *
  15:Src/app.c     ****   ******************************************************************************
  16:Src/app.c     ****   */
  17:Src/app.c     **** 
  18:Src/app.c     **** /*TODO: DECLARE MODELS 
  19:Src/app.c     **** //LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(yolo_detector);
  20:Src/app.c     **** //static roi_t rois[YOLO_MAX_NB];
  21:Src/app.c     **** //LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(face_landmark);
  22:Src/app.c     **** //static ld_point_t fl_landmarks[1[FL_LANDMARK_NB]; // Use new constants
  23:Src/app.c     **** */
  24:Src/app.c     **** /*TODO: REMOVE ROTATION LOGICS AS DMS WILL NOT USE IT
  25:Src/app.c     ****  * NOTE THAT ROTATION LOGIC IS USED FOR N6 BOARD 
  26:Src/app.c     **** */
  27:Src/app.c     **** #include "app.h"
  28:Src/app.c     **** 
  29:Src/app.c     **** #include <stdint.h>
  30:Src/app.c     **** #include <stdio.h>
  31:Src/app.c     **** 
  32:Src/app.c     **** #include "app_cam.h"
  33:Src/app.c     **** #include "app_config.h"
  34:Src/app.c     **** #include "IPL_resize.h"
  35:Src/app.c     **** #include "app_postprocess.h"
  36:Src/app.c     **** #include "isp_api.h"
  37:Src/app.c     **** #include "ld.h"
  38:Src/app.c     **** #include "ll_aton_runtime.h"
  39:Src/app.c     **** #include "cmw_camera.h"
  40:Src/app.c     **** #include "scrl.h"
  41:Src/app.c     **** #ifdef STM32N6570_DK_REV
  42:Src/app.c     **** #include "stm32n6570_discovery.h"
  43:Src/app.c     **** #else
  44:Src/app.c     **** #include "stm32n6xx_nucleo.h"
  45:Src/app.c     **** #endif
  46:Src/app.c     **** #include "stm32_lcd.h"
ARM GAS  /tmp/ccbfgvbk.s 			page 12


  47:Src/app.c     **** #include "stm32_lcd_ex.h"
  48:Src/app.c     **** #include "stm32n6xx_hal.h"
  49:Src/app.c     **** #include "FreeRTOS.h"
  50:Src/app.c     **** #include "task.h"
  51:Src/app.c     **** #include "semphr.h"
  52:Src/app.c     **** #include "utils.h"
  53:Src/app.c     **** 
  54:Src/app.c     **** #define FREERTOS_PRIORITY(p) ((UBaseType_t)((int)tskIDLE_PRIORITY + configMAX_PRIORITIES / 2 + (p))
  55:Src/app.c     **** 
  56:Src/app.c     **** #ifndef M_PI
  57:Src/app.c     **** #define M_PI 3.14159265358979323846
  58:Src/app.c     **** #endif
  59:Src/app.c     **** 
  60:Src/app.c     **** #include "nema_core.h"
  61:Src/app.c     **** #include "nema_error.h"
  62:Src/app.c     **** void nema_enable_tiling(int);
  63:Src/app.c     **** 
  64:Src/app.c     **** #define LCD_FG_WIDTH LCD_BG_WIDTH
  65:Src/app.c     **** #define LCD_FG_HEIGHT LCD_BG_HEIGHT
  66:Src/app.c     **** 
  67:Src/app.c     **** #define CACHE_OP(__op__) do { \
  68:Src/app.c     ****   if (is_cache_enable()) { \
  69:Src/app.c     ****     __op__; \
  70:Src/app.c     ****   } \
  71:Src/app.c     **** } while (0)
  72:Src/app.c     **** 
  73:Src/app.c     **** #define DBG_INFO 0
  74:Src/app.c     **** #define USE_FILTERED_TS 1
  75:Src/app.c     **** 
  76:Src/app.c     **** #define BQUEUE_MAX_BUFFERS 2
  77:Src/app.c     **** #define CPU_LOAD_HISTORY_DEPTH 8
  78:Src/app.c     **** 
  79:Src/app.c     **** #define DISPLAY_BUFFER_NB (DISPLAY_DELAY + 2)
  80:Src/app.c     **** 
  81:Src/app.c     **** /* palm detector */
  82:Src/app.c     **** #define PD_MAX_HAND_NB 1
  83:Src/app.c     **** #define YOLO_MAX_NB 20
  84:Src/app.c     **** 
  85:Src/app.c     **** typedef float app_v3_t[3];
  86:Src/app.c     **** 
  87:Src/app.c     **** /**
  88:Src/app.c     ****  * @brief Defines a Region Of Interest (ROI).
  89:Src/app.c     ****  * @details This is a key structure used to pass the location of a detected object
  90:Src/app.c     ****  * (like a hand or face) to the next stage of the pipeline.
  91:Src/app.c     ****  */
  92:Src/app.c     **** typedef struct {
  93:Src/app.c     ****   float cx;
  94:Src/app.c     ****   float cy;
  95:Src/app.c     ****   float w;
  96:Src/app.c     ****   float h;
  97:Src/app.c     ****   float rotation;
  98:Src/app.c     **** } roi_t;
  99:Src/app.c     **** 
 100:Src/app.c     **** #define UTIL_LCD_COLOR_TRANSPARENT 0
 101:Src/app.c     **** 
 102:Src/app.c     **** #ifdef STM32N6570_DK_REV
 103:Src/app.c     **** #define LCD_FONT Font20
ARM GAS  /tmp/ccbfgvbk.s 			page 13


 104:Src/app.c     **** #define DISK_RADIUS 2
 105:Src/app.c     **** #else
 106:Src/app.c     **** #define LCD_FONT Font12
 107:Src/app.c     **** #define DISK_RADIUS 1
 108:Src/app.c     **** #endif
 109:Src/app.c     **** 
 110:Src/app.c     **** /**
 111:Src/app.c     ****  * @brief A simple rectangle definition using top-left corner and size.
 112:Src/app.c     ****  */
 113:Src/app.c     **** typedef struct
 114:Src/app.c     **** {
 115:Src/app.c     ****   uint32_t X0;
 116:Src/app.c     ****   uint32_t Y0;
 117:Src/app.c     ****   uint32_t XSize;
 118:Src/app.c     ****   uint32_t YSize;
 119:Src/app.c     **** } Rectangle_TypeDef;
 120:Src/app.c     **** 
 121:Src/app.c     **** /**
 122:Src/app.c     ****  * @brief A thread-safe buffer queue for passing data between tasks (e.g., camera and NN).
 123:Src/app.c     ****  * @details Implements a classic producer-consumer model using semaphores.
 124:Src/app.c     ****  */
 125:Src/app.c     **** typedef struct {
 126:Src/app.c     ****   SemaphoreHandle_t free;         /* Signals that a buffer is free for writing. */
 127:Src/app.c     ****   StaticSemaphore_t free_buffer;
 128:Src/app.c     ****   SemaphoreHandle_t ready;        /* Signals that a buffer is ready for reading. */
 129:Src/app.c     ****   StaticSemaphore_t ready_buffer; 
 130:Src/app.c     ****   int buffer_nb;                  /* Total number of buffers in the queue. */
 131:Src/app.c     ****   uint8_t *buffers[BQUEUE_MAX_BUFFERS];
 132:Src/app.c     ****   int free_idx;          /* Index of the next free buffer. */ 
 133:Src/app.c     ****   int ready_idx;        /* Index of the next ready buffer. */
 134:Src/app.c     **** } bqueue_t;
 135:Src/app.c     **** 
 136:Src/app.c     **** /**
 137:Src/app.c     ****  * @brief Holds data for calculating CPU load.
 138:Src/app.c     ****  */
 139:Src/app.c     **** 
 140:Src/app.c     **** typedef struct {
 141:Src/app.c     ****   uint64_t current_total;
 142:Src/app.c     ****   uint64_t current_thread_total;
 143:Src/app.c     ****   uint64_t prev_total;
 144:Src/app.c     ****   uint64_t prev_thread_total;
 145:Src/app.c     ****   struct {
 146:Src/app.c     ****     uint64_t total;
 147:Src/app.c     ****     uint64_t thread;
 148:Src/app.c     ****     uint32_t tick;
 149:Src/app.c     ****   } history[CPU_LOAD_HISTORY_DEPTH];
 150:Src/app.c     **** } cpuload_info_t;
 151:Src/app.c     **** 
 152:Src/app.c     **** /**
 153:Src/app.c     ****  * @brief Holds all information for a single detected hand/face instance.
 154:Src/app.c     ****  * @details This is the main data structure linking the output of the first model
 155:Src/app.c     ****  * to the input of the second, and finally to the display.
 156:Src/app.c     ****  */
 157:Src/app.c     **** typedef struct {
 158:Src/app.c     ****   int is_valid;             /* Flag to check if the detection in this struct is current. */
 159:Src/app.c     ****   pd_pp_box_t pd_hands;     /* Palm Detector raw output. */
 160:Src/app.c     ****   roi_t roi;            /* Region of Interest for the detected hand. */
ARM GAS  /tmp/ccbfgvbk.s 			page 14


 161:Src/app.c     ****   ld_point_t ld_landmarks[LD_LANDMARK_NB];        /* Final output from the landmark model */
 162:Src/app.c     **** } hand_info_t;
 163:Src/app.c     **** 
 164:Src/app.c     **** /**
 165:Src/app.c     ****  * @brief Holds all information for a single detected hand/face instance.
 166:Src/app.c     ****  * @details This is the main data structure linking the output of the first model
 167:Src/app.c     ****  * to the input of the second, and finally to the display.
 168:Src/app.c     ****  */
 169:Src/app.c     **** typedef struct {
 170:Src/app.c     ****   int is_valid;             /* Flag to check if the detection in this struct is current. */
 171:Src/app.c     ****   pd_pp_box_t pd_hands;     /* Palm Detector raw output. */
 172:Src/app.c     ****   roi_t roi;            /* Region of Interest for the detected hand. */
 173:Src/app.c     ****   ld_point_t ld_landmarks[LD_LANDMARK_NB];        /* Final output from the landmark model */
 174:Src/app.c     **** } face_info_t;
 175:Src/app.c     **** 
 176:Src/app.c     **** 
 177:Src/app.c     **** /**
 178:Src/app.c     ****  * @brief Aggregates all information needed by the display thread to render one frame.
 179:Src/app.c     ****  */
 180:Src/app.c     **** typedef struct {
 181:Src/app.c     ****   float nn_period_ms;
 182:Src/app.c     ****   uint32_t pd_ms;
 183:Src/app.c     ****   uint32_t yolo_ms;
 184:Src/app.c     ****   uint32_t hl_ms;
 185:Src/app.c     ****   uint32_t pp_ms;
 186:Src/app.c     ****   uint32_t disp_ms;
 187:Src/app.c     ****   int is_ld_displayed;    /* Toggle for showing landmarks. */
 188:Src/app.c     ****   int is_pd_displayed;    /* Toggle for showing palm detector boxes. */
 189:Src/app.c     ****   int pd_hand_nb;       /* Number of valid hands detected by the palm detector. */
 190:Src/app.c     ****   int nb_faces;
 191:Src/app.c     ****   float pd_max_prob;      /* Maximum confidence score of the detected hands. */
 192:Src/app.c     ****   hand_info_t hands[PD_MAX_HAND_NB];  /* Array of detected hands. */
 193:Src/app.c     ****   face_info_t faces[YOLO_MAX_NB];
 194:Src/app.c     **** } display_info_t;
 195:Src/app.c     **** 
 196:Src/app.c     **** /**
 197:Src/app.c     ****  * @brief A wrapper for the display_info_t struct to make it thread-safe.
 198:Src/app.c     ****  */
 199:Src/app.c     **** typedef struct {
 200:Src/app.c     ****   SemaphoreHandle_t update;         /* Semaphore to signal that new info is ready. */
 201:Src/app.c     ****   StaticSemaphore_t update_buffer;  
 202:Src/app.c     ****   SemaphoreHandle_t lock;           /* Mutex to protect access to the 'info' struct. */
 203:Src/app.c     ****   StaticSemaphore_t lock_buffer;
 204:Src/app.c     ****   display_info_t info;
 205:Src/app.c     **** } display_t;
 206:Src/app.c     **** 
 207:Src/app.c     **** /**
 208:Src/app.c     ****  * @brief Encapsulates all data related to the Palm Detector (PD) model.
 209:Src/app.c     ****  * @details This will be adapted for our Face Detector (FD) model.
 210:Src/app.c     ****  */
 211:Src/app.c     **** typedef struct {
 212:Src/app.c     ****   uint32_t nn_in_len;       /* Size of the model's input tensor. */
 213:Src/app.c     ****   float *prob_out;          /* Output probabilities for each detected hand. */
 214:Src/app.c     ****   uint32_t prob_out_len;
 215:Src/app.c     ****   float *boxes_out;         /* Pointer to the bounding box output tensor. */
 216:Src/app.c     ****   uint32_t boxes_out_len;
 217:Src/app.c     ****   pd_model_pp_static_param_t static_param;    /* Parameters for post-processing. */
ARM GAS  /tmp/ccbfgvbk.s 			page 15


 218:Src/app.c     ****   pd_postprocess_out_t pd_out;    /* Struct to hold post-processing results. */
 219:Src/app.c     **** } pd_model_info_t;
 220:Src/app.c     **** 
 221:Src/app.c     **** /**
 222:Src/app.c     ****  * @brief Encapsulates all data related to the YOLO model.
 223:Src/app.c     ****  * @details This struct holds pointers to the model's raw output and contains the
 224:Src/app.c     ****  * necessary parameters and buffers for the YOLOv8 post-processing library.
 225:Src/app.c     ****  */
 226:Src/app.c     **** typedef struct {
 227:Src/app.c     ****   void* nn_in;                  // Pointer to the input tensor buffer (the image)
 228:Src/app.c     ****   size_t nn_in_len;             // Length of the input tensor buffer in bytes
 229:Src/app.c     **** 
 230:Src/app.c     ****   int8_t* raw_output_tensor;    // Pointer to the raw output from the NPU
 231:Src/app.c     ****   size_t raw_output_len;        // Length of the raw output buffer in bytes
 232:Src/app.c     **** 
 233:Src/app.c     ****   od_pp_out_t pp_output;        // Struct to hold the final, processed output (bounding boxes)
 234:Src/app.c     ****   yolov8_pp_static_param_t pp_params; // Static parameters for the YOLOv8 post-processing
 235:Src/app.c     **** 
 236:Src/app.c     **** } yolo_model_info_t;
 237:Src/app.c     **** 
 238:Src/app.c     **** 
 239:Src/app.c     **** /**
 240:Src/app.c     ****  * @brief Encapsulates all data related to the Hand Landmark (HL) model.
 241:Src/app.c     ****  * @details This will be adapted for our Face Landmark model.
 242:Src/app.c     ****  */
 243:Src/app.c     **** typedef struct {
 244:Src/app.c     ****   uint8_t *nn_in;       /* Pointer to the model's input tensor. */
 245:Src/app.c     ****   uint32_t nn_in_len;
 246:Src/app.c     ****   float *prob_out;      /* Pointer to the landmark presence probability output. */
 247:Src/app.c     ****   uint32_t prob_out_len;
 248:Src/app.c     ****   float *landmarks_out; /* Pointer to the landmark coordinates output tensor. */
 249:Src/app.c     ****   uint32_t landmarks_out_len;
 250:Src/app.c     **** } hl_model_info_t;
 251:Src/app.c     **** 
 252:Src/app.c     **** /**
 253:Src/app.c     ****  * @brief Encapsulates all data related to the Face Landmark model.
 254:Src/app.c     ****  */
 255:Src/app.c     **** typedef struct {
 256:Src/app.c     ****   uint8_t *nn_in;       /* Pointer to the model's input tensor. */
 257:Src/app.c     ****   uint32_t nn_in_len;
 258:Src/app.c     ****   float *prob_out;      /* Pointer to the landmark presence probability output. */
 259:Src/app.c     ****   uint32_t prob_out_len;
 260:Src/app.c     ****   float *landmarks_out; /* Pointer to the landmark coordinates output tensor. */
 261:Src/app.c     ****   uint32_t landmarks_out_len;
 262:Src/app.c     **** } fl_model_info_t;
 263:Src/app.c     **** 
 264:Src/app.c     **** 
 265:Src/app.c     **** /**
 266:Src/app.c     ****  * @brief A simple structure to manage a UI button's state and callback.
 267:Src/app.c     ****  */
 268:Src/app.c     **** typedef struct {
 269:Src/app.c     ****   Button_TypeDef button_id;
 270:Src/app.c     ****   int prev_state;
 271:Src/app.c     ****   void (*on_click_handler)(void *cb_args);
 272:Src/app.c     ****   void *cb_args;
 273:Src/app.c     **** } button_t;
 274:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 16


 275:Src/app.c     **** /* Globals */
 276:Src/app.c     **** 
 277:Src/app.c     **** /* Rectangle definitions for the full background and foreground layers. */
 278:Src/app.c     **** static Rectangle_TypeDef lcd_bg_area = {
 279:Src/app.c     ****   .X0 = 0,
 280:Src/app.c     ****   .Y0 = 0,
 281:Src/app.c     ****   .XSize = LCD_BG_WIDTH,
 282:Src/app.c     ****   .YSize = LCD_BG_HEIGHT,
 283:Src/app.c     **** };
 284:Src/app.c     **** 
 285:Src/app.c     **** static Rectangle_TypeDef lcd_fg_area = {
 286:Src/app.c     ****   .X0 = 0,
 287:Src/app.c     ****   .Y0 = 0,
 288:Src/app.c     ****   .XSize = LCD_FG_WIDTH,
 289:Src/app.c     ****   .YSize = LCD_FG_HEIGHT,
 290:Src/app.c     **** };
 291:Src/app.c     **** 
 292:Src/app.c     **** /* The main display buffers. This is a set of 3+ full-frame buffers for smooth video.
 293:Src/app.c     ****    ALIGN_32 ensures 32-byte alignment for performance (DMA/cache).
 294:Src/app.c     ****    IN_PSRAM places this large buffer in external PSRAM. */
 295:Src/app.c     **** /* Lcd Background Buffer */
 296:Src/app.c     **** static uint8_t lcd_bg_buffer[DISPLAY_BUFFER_NB][LCD_BG_WIDTH * LCD_BG_HEIGHT * DISPLAY_BPP] ALIGN_3
 297:Src/app.c     **** static int lcd_bg_buffer_disp_idx = 1;
 298:Src/app.c     **** static int lcd_bg_buffer_capt_idx = 0;
 299:Src/app.c     **** /* Lcd Foreground Buffer */
 300:Src/app.c     **** static uint8_t lcd_fg_buffer[2][LCD_FG_WIDTH * LCD_FG_HEIGHT* 2] ALIGN_32 IN_PSRAM;
 301:Src/app.c     **** static int lcd_fg_buffer_rd_idx;
 302:Src/app.c     **** static display_t disp = {
 303:Src/app.c     ****   .info.is_ld_displayed = 1,
 304:Src/app.c     ****   .info.is_pd_displayed = 0,
 305:Src/app.c     **** };
 306:Src/app.c     **** static cpuload_info_t cpu_load;
 307:Src/app.c     **** /* screen buffer */
 308:Src/app.c     **** static uint8_t screen_buffer[LCD_BG_WIDTH * LCD_BG_HEIGHT * 2] ALIGN_32 IN_PSRAM;
 309:Src/app.c     **** 
 310:Src/app.c     **** /* model */
 311:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(palm_detector);
 312:Src/app.c     ****  /* Declare the necessary runtime instances and global buffers to hold outputs */
 313:Src/app.c     ****  /* palm detector */
 314:Src/app.c     **** static roi_t rois[PD_MAX_HAND_NB];
 315:Src/app.c     ****  /* hand landmark */
 316:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(hand_landmark);
 317:Src/app.c     **** static ld_point_t ld_landmarks[PD_MAX_HAND_NB][LD_LANDMARK_NB];
 318:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(yolo_detector);
 319:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(face_landmark);
 320:Src/app.c     **** static roi_t rois_yolo[YOLO_MAX_NB];
 321:Src/app.c     **** static ld_point_t fl_landmarks[1][FL_LANDMARK_NB]; // Use new constants
 322:Src/app.c     **** /* Counters for frame synchronization. */
 323:Src/app.c     **** static uint32_t frame_event_nb;
 324:Src/app.c     **** static volatile uint32_t frame_event_nb_for_resize;
 325:Src/app.c     **** 
 326:Src/app.c     **** /*TODO: UPDATE THE DEFINED MACROS UNDER app.h
 327:Src/app.c     **** * OR postprocess_conf.h which defines the postprocessing type, we should be able to define it to YO
 328:Src/app.c     **** */
 329:Src/app.c     ****  /* nn input buffers */
 330:Src/app.c     **** static uint8_t nn_input_buffers[2][NN_WIDTH * NN_HEIGHT * NN_BPP] ALIGN_32 IN_PSRAM;
 331:Src/app.c     **** static bqueue_t nn_input_queue;
ARM GAS  /tmp/ccbfgvbk.s 			page 17


 332:Src/app.c     **** 
 333:Src/app.c     **** /* --- RTOS Task (Thread) Declarations --- */
 334:Src/app.c     **** /* Statically allocates the memory for the three main application tasks and their stacks. */static 
 335:Src/app.c     **** static StackType_t nn_thread_stack[2 * configMINIMAL_STACK_SIZE];
 336:Src/app.c     **** static StaticTask_t dp_thread;
 337:Src/app.c     **** static StackType_t dp_thread_stack[2 *configMINIMAL_STACK_SIZE];
 338:Src/app.c     **** static StaticTask_t isp_thread;
 339:Src/app.c     **** static StackType_t isp_thread_stack[2 *configMINIMAL_STACK_SIZE];
 340:Src/app.c     **** static SemaphoreHandle_t isp_sem;
 341:Src/app.c     **** static StaticSemaphore_t isp_sem_buffer;
 342:Src/app.c     **** 
 343:Src/app.c     **** static GFXMMU_HandleTypeDef hgfxmmu;
 344:Src/app.c     **** static nema_cmdlist_t cl;
 345:Src/app.c     **** 
 346:Src/app.c     **** static int is_cache_enable()
 347:Src/app.c     **** {
 348:Src/app.c     **** #if defined(USE_DCACHE)
 349:Src/app.c     ****   return 1;
 350:Src/app.c     **** #else
 351:Src/app.c     ****   return 0;
 352:Src/app.c     **** #endif
 353:Src/app.c     **** }
 354:Src/app.c     **** 
 355:Src/app.c     **** /* THESE FUNCTIONS ARE TO BE DEPRECIATED*/
 356:Src/app.c     **** 
 357:Src/app.c     **** /** HELPER FUNCTIONS
 358:Src/app.c     ****  * @brief Normalizes an angle to the range [-PI, PI].
 359:Src/app.c     ****  * @param angle The input angle in radians.
 360:Src/app.c     ****  * @return The equivalent angle within the range [-PI, PI].
 361:Src/app.c     ****  */
 362:Src/app.c     **** static float pd_normalize_angle(float angle)
 363:Src/app.c     **** {
 364:Src/app.c     ****   return angle - 2 * M_PI * floorf((angle - (-M_PI)) / (2 * M_PI));
 365:Src/app.c     **** }
 366:Src/app.c     **** 
 367:Src/app.c     **** static float pd_cook_rotation(float angle)
 368:Src/app.c     **** {
 369:Src/app.c     ****   return angle;
 370:Src/app.c     **** }
 371:Src/app.c     **** 
 372:Src/app.c     **** static float pd_compute_rotation(pd_pp_box_t *box)
 373:Src/app.c     **** {
 374:Src/app.c     ****   float x0, y0, x1, y1;
 375:Src/app.c     ****   float rotation;
 376:Src/app.c     **** 
 377:Src/app.c     ****   x0 = box->pKps[0].x;
 378:Src/app.c     ****   y0 = box->pKps[0].y;
 379:Src/app.c     ****   x1 = box->pKps[2].x;
 380:Src/app.c     ****   y1 = box->pKps[2].y;
 381:Src/app.c     **** 
 382:Src/app.c     ****   rotation = M_PI * 0.5 - atan2f(-(y1 - y0), x1 - x0);
 383:Src/app.c     **** 
 384:Src/app.c     ****   return pd_cook_rotation(pd_normalize_angle(rotation));
 385:Src/app.c     **** }
 386:Src/app.c     **** /* END OF DEPRECIATED FUNCTIONS */
 387:Src/app.c     **** 
 388:Src/app.c     **** /* TO WRITE EQUIVALENT FOR YOLO FACE DETECTOR*/
ARM GAS  /tmp/ccbfgvbk.s 			page 18


 389:Src/app.c     **** 
 390:Src/app.c     **** /**
 391:Src/app.c     ****  * @brief Converts normalized AI model coordinates (0.0 to 1.0) to screen pixel coordinates.
 392:Src/app.c     ****  * @details The AI model outputs coordinates relative to its square input buffer. This
 393:Src/app.c     ****  * function scales them to match the final display resolution.
 394:Src/app.c     ****  * @param box Pointer to the detection box with normalized coordinates.
 395:Src/app.c     ****  */
 396:Src/app.c     **** static void cvt_pd_coord_to_screen_coord(pd_pp_box_t *box)
 397:Src/app.c     **** {
 398:Src/app.c     ****   int i;
 399:Src/app.c     **** 
 400:Src/app.c     ****   /* This is not a typo. Since screen aspect ratio was conserved. We really want to use LCD_BG_WIDT
 401:Src/app.c     ****    * y positions.
 402:Src/app.c     ****    */
 403:Src/app.c     **** 
 404:Src/app.c     ****   box->x_center *= LCD_BG_WIDTH;
 405:Src/app.c     ****   box->y_center *= LCD_BG_WIDTH;
 406:Src/app.c     ****   box->width *= LCD_BG_WIDTH;
 407:Src/app.c     ****   box->height *= LCD_BG_WIDTH;
 408:Src/app.c     ****   for (i = 0; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++) {
 409:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 410:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 411:Src/app.c     ****   }
 412:Src/app.c     **** }
 413:Src/app.c     **** 
 414:Src/app.c     **** /**
 415:Src/app.c     ****  * @brief Adjusts a Region of Interest (ROI) by shifting its center and scaling its size.
 416:Src/app.c     ****  * @details This is used to create the final input for the second model. It takes the
 417:Src/app.c     ****  * initial detection, shifts it, and scales it up to ensure the full object (e.g.,
 418:Src/app.c     ****  * the whole hand, not just the palm) is included. It also makes the ROI a square.
 419:Src/app.c     ****  */
 420:Src/app.c     **** static void roi_shift_and_scale(roi_t *roi, float shift_x, float shift_y, float scale_x, float scal
 421:Src/app.c     **** {
 422:Src/app.c     ****   float long_side;
 423:Src/app.c     ****   float sx, sy;
 424:Src/app.c     **** 
 425:Src/app.c     ****   sx = (roi->w * shift_x * cos(roi->rotation) - roi->h * shift_y * sin(roi->rotation));
 426:Src/app.c     ****   sy = (roi->w * shift_x * sin(roi->rotation) + roi->h * shift_y * cos(roi->rotation));
 427:Src/app.c     **** 
 428:Src/app.c     ****   roi->cx += sx;
 429:Src/app.c     ****   roi->cy += sy;
 430:Src/app.c     **** 
 431:Src/app.c     ****   long_side = MAX(roi->w, roi->h);
 432:Src/app.c     ****   roi->w = long_side;
 433:Src/app.c     ****   roi->h = long_side;
 434:Src/app.c     **** 
 435:Src/app.c     ****   roi->w *= scale_x;
 436:Src/app.c     ****   roi->h *= scale_y;
 437:Src/app.c     **** }
 438:Src/app.c     **** 
 439:Src/app.c     **** /* TO WRITE EQUIVALENT FUNCTION FOR YOLO FACE DETECTOR
 440:Src/app.c     ****  * WHICH HANDLES THE MULTI-CLASS OUTPUT OF THE YOLO DETECTOR
 441:Src/app.c     ****  * AND CONVERTS IT INTO A PROPER FACE ROI FOR THE LANDMARK MODEL.
 442:Src/app.c     **** */
 443:Src/app.c     **** /**
 444:Src/app.c     ****  * @brief Converts the output of the first model (detector) into an ROI for the second model.
 445:Src/app.c     ****  * @details This is the core "glue" function between the two AI models. It takes the raw
ARM GAS  /tmp/ccbfgvbk.s 			page 19


 446:Src/app.c     ****  * palm/face detection and transforms it into a properly scaled, rotated, and positioned
 447:Src/app.c     ****  * ROI that the second (landmark) model can use.
 448:Src/app.c     ****  * @param box The raw output from the palm/face detector.
 449:Src/app.c     ****  * @param roi The ROI structure to be filled for the landmark model.
 450:Src/app.c     ****  */
 451:Src/app.c     **** static void pd_box_to_roi(pd_pp_box_t *box,  roi_t *roi)
 452:Src/app.c     **** {
 453:Src/app.c     ****   const float shift_x = 0;
 454:Src/app.c     ****   const float shift_y = -0.5;
 455:Src/app.c     ****   const float scale = 2.6;
 456:Src/app.c     **** 
 457:Src/app.c     ****   roi->cx = box->x_center;
 458:Src/app.c     ****   roi->cy = box->y_center;
 459:Src/app.c     ****   roi->w = box->width;
 460:Src/app.c     ****   roi->h = box->height;
 461:Src/app.c     ****   roi->rotation = pd_compute_rotation(box);
 462:Src/app.c     **** 
 463:Src/app.c     ****   roi_shift_and_scale(roi, shift_x, shift_y, scale, scale);
 464:Src/app.c     **** 
 465:Src/app.c     **** }
 466:Src/app.c     **** 
 467:Src/app.c     **** /**
 468:Src/app.c     ****  * @brief A utility function to copy data from one detection box struct to another.
 469:Src/app.c     ****  * TODO: ADAPT INTO COPYING FD BOXES
 470:Src/app.c     ****  */
 471:Src/app.c     **** static void copy_pd_box(pd_pp_box_t *dst, pd_pp_box_t *src)
 472:Src/app.c     **** {
 473:Src/app.c     ****   int i;
 474:Src/app.c     **** 
 475:Src/app.c     ****   dst->prob = src->prob;
 476:Src/app.c     ****   dst->x_center = src->x_center;
 477:Src/app.c     ****   dst->y_center = src->y_center;
 478:Src/app.c     ****   dst->width = src->width;
 479:Src/app.c     ****   dst->height = src->height;
 480:Src/app.c     ****   for (i = 0 ; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++)
 481:Src/app.c     ****     dst->pKps[i] = src->pKps[i];
 482:Src/app.c     **** }
 483:Src/app.c     **** 
 484:Src/app.c     **** /**
 485:Src/app.c     ****  * @brief Initializes a hardware button using the Board Support Package (BSP).
 486:Src/app.c     ****  * @param on_click_handler Function pointer to call when the button is pressed.
 487:Src/app.c     ****  */
 488:Src/app.c     **** static void button_init(button_t *b, Button_TypeDef id, void (*on_click_handler)(void *), void *cb_
 489:Src/app.c     **** {
 490:Src/app.c     ****   int ret;
 491:Src/app.c     **** 
 492:Src/app.c     ****   ret = BSP_PB_Init(id, BUTTON_MODE_GPIO);
 493:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 494:Src/app.c     **** 
 495:Src/app.c     ****   b->button_id = id;
 496:Src/app.c     ****   b->on_click_handler = on_click_handler;
 497:Src/app.c     ****   b->prev_state = 0;
 498:Src/app.c     ****   b->cb_args = cb_args;
 499:Src/app.c     **** }
 500:Src/app.c     **** 
 501:Src/app.c     **** /**
 502:Src/app.c     ****  * @brief Polls a button's state and triggers its callback on a press event.
ARM GAS  /tmp/ccbfgvbk.s 			page 20


 503:Src/app.c     ****  * @details This should be called periodically in a UI or main task.
 504:Src/app.c     ****  */
 505:Src/app.c     **** static void button_process(button_t *b)
 506:Src/app.c     **** {
 507:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 508:Src/app.c     **** 
 509:Src/app.c     ****   if (state != b->prev_state && state && b->on_click_handler)
 510:Src/app.c     ****     b->on_click_handler(b->cb_args);
 511:Src/app.c     **** 
 512:Src/app.c     ****   b->prev_state = state;
 513:Src/app.c     **** }
 514:Src/app.c     **** 
 515:Src/app.c     **** /**
 516:Src/app.c     ****  * @brief Initializes the CPU load tracking structure.
 517:Src/app.c     ****  */
 518:Src/app.c     **** static void cpuload_init(cpuload_info_t *cpu_load)
 519:Src/app.c     **** {
 520:Src/app.c     ****   memset(cpu_load, 0, sizeof(cpuload_info_t));
 521:Src/app.c     **** }
 522:Src/app.c     **** 
 523:Src/app.c     **** /**
 524:Src/app.c     ****  * @brief Updates the CPU load history with a new data point.
 525:Src/app.c     ****  * @details Uses FreeRTOS's runtime counters to get total time and idle time.
 526:Src/app.c     ****  */
 527:Src/app.c     **** static void cpuload_update(cpuload_info_t *cpu_load)
 528:Src/app.c     **** {
 529:Src/app.c     ****   int i;
 530:Src/app.c     **** 
 531:Src/app.c     ****   cpu_load->history[1] = cpu_load->history[0];
 532:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 533:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 534:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 535:Src/app.c     **** 
 536:Src/app.c     ****   if (cpu_load->history[1].tick - cpu_load->history[2].tick < 1000)
 537:Src/app.c     ****     return ;
 538:Src/app.c     **** 
 539:Src/app.c     ****   for (i = 0; i < CPU_LOAD_HISTORY_DEPTH - 2; i++)
 540:Src/app.c     ****     cpu_load->history[CPU_LOAD_HISTORY_DEPTH - 1 - i] = cpu_load->history[CPU_LOAD_HISTORY_DEPTH - 
 541:Src/app.c     **** }
 542:Src/app.c     **** 
 543:Src/app.c     **** /**
 544:Src/app.c     ****  * @brief Calculates CPU load percentages over different time windows.
 545:Src/app.c     ****  */
 546:Src/app.c     **** static void cpuload_get_info(cpuload_info_t *cpu_load, float *cpu_load_last, float *cpu_load_last_s
 547:Src/app.c     ****                              float *cpu_load_last_five_seconds)
 548:Src/app.c     **** {
 549:Src/app.c     ****   if (cpu_load_last)
 550:Src/app.c     ****     *cpu_load_last = 100.0 * (cpu_load->history[0].thread - cpu_load->history[1].thread) /
 551:Src/app.c     ****                      (cpu_load->history[0].total - cpu_load->history[1].total);
 552:Src/app.c     ****   if (cpu_load_last_second)
 553:Src/app.c     ****     *cpu_load_last_second = 100.0 * (cpu_load->history[2].thread - cpu_load->history[3].thread) /
 554:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 555:Src/app.c     ****   if (cpu_load_last_five_seconds)
 556:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 557:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[7].total);
 558:Src/app.c     **** }
 559:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 21


 560:Src/app.c     **** /**
 561:Src/app.c     ****  * @brief Initializes a thread-safe buffer queue (bqueue).
 562:Src/app.c     ****  * @details Creates the FreeRTOS semaphores needed for producer-consumer synchronization.
 563:Src/app.c     ****  * @return 0 on success, -1 on failure.
 564:Src/app.c     ****  */
 565:Src/app.c     **** static int bqueue_init(bqueue_t *bq, int buffer_nb, uint8_t **buffers)
 566:Src/app.c     **** {
 567:Src/app.c     ****   int i;
 568:Src/app.c     **** 
 569:Src/app.c     ****   if (buffer_nb > BQUEUE_MAX_BUFFERS)
 570:Src/app.c     ****     return -1;
 571:Src/app.c     **** 
 572:Src/app.c     ****   bq->free = xSemaphoreCreateCountingStatic(buffer_nb, buffer_nb, &bq->free_buffer);
 573:Src/app.c     ****   if (!bq->free)
 574:Src/app.c     ****     goto free_sem_error;
 575:Src/app.c     ****   bq->ready = xSemaphoreCreateCountingStatic(buffer_nb, 0, &bq->ready_buffer);
 576:Src/app.c     ****   if (!bq->ready)
 577:Src/app.c     ****     goto ready_sem_error;
 578:Src/app.c     **** 
 579:Src/app.c     ****   bq->buffer_nb = buffer_nb;
 580:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 581:Src/app.c     ****     assert(buffers[i]);
 582:Src/app.c     ****     bq->buffers[i] = buffers[i];
 583:Src/app.c     ****   }
 584:Src/app.c     ****   bq->free_idx = 0;
 585:Src/app.c     ****   bq->ready_idx = 0;
 586:Src/app.c     **** 
 587:Src/app.c     ****   return 0;
 588:Src/app.c     **** 
 589:Src/app.c     **** ready_sem_error:
 590:Src/app.c     ****   vSemaphoreDelete(bq->free);
 591:Src/app.c     **** free_sem_error:
 592:Src/app.c     ****   return -1;
 593:Src/app.c     **** }
 594:Src/app.c     **** 
 595:Src/app.c     **** /**
 596:Src/app.c     ****  * @brief Gets a free buffer from the queue for a producer to write to.
 597:Src/app.c     ****  * @param is_blocking If true, will wait indefinitely for a free buffer.
 598:Src/app.c     ****  * @return Pointer to a free buffer, or NULL if non-blocking and none are available.
 599:Src/app.c     ****  */
 600:Src/app.c     **** static uint8_t *bqueue_get_free(bqueue_t *bq, int is_blocking)
 601:Src/app.c     **** {
 602:Src/app.c     ****   uint8_t *res;
 603:Src/app.c     ****   int ret;
 604:Src/app.c     **** 
 605:Src/app.c     ****   ret = xSemaphoreTake(bq->free, is_blocking ? portMAX_DELAY : 0);
 606:Src/app.c     ****   if (ret == pdFALSE)
 607:Src/app.c     ****     return NULL;
 608:Src/app.c     **** 
 609:Src/app.c     ****   res = bq->buffers[bq->free_idx];
 610:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 611:Src/app.c     **** 
 612:Src/app.c     ****   return res;
 613:Src/app.c     **** }
 614:Src/app.c     **** 
 615:Src/app.c     **** /**
 616:Src/app.c     ****  * @brief Returns a buffer to the free pool (used by a consumer).
ARM GAS  /tmp/ccbfgvbk.s 			page 22


 617:Src/app.c     ****  */
 618:Src/app.c     **** static void bqueue_put_free(bqueue_t *bq)
 619:Src/app.c     **** {
 620:Src/app.c     ****   int ret;
 621:Src/app.c     **** 
 622:Src/app.c     ****   ret = xSemaphoreGive(bq->free);
 623:Src/app.c     ****   assert(ret == pdTRUE);
 624:Src/app.c     **** }
 625:Src/app.c     **** 
 626:Src/app.c     **** /**
 627:Src/app.c     ****  * @brief Gets a ready buffer from the queue for a consumer to read from.
 628:Src/app.c     ****  * @details This function will block until a buffer is ready.
 629:Src/app.c     ****  * @return Pointer to a ready buffer.
 630:Src/app.c     ****  */
 631:Src/app.c     **** static uint8_t *bqueue_get_ready(bqueue_t *bq)
 632:Src/app.c     **** {
 633:Src/app.c     ****   uint8_t *res;
 634:Src/app.c     ****   int ret;
 635:Src/app.c     **** 
 636:Src/app.c     ****   ret = xSemaphoreTake(bq->ready, portMAX_DELAY);
 637:Src/app.c     ****   assert(ret == pdTRUE);
 638:Src/app.c     **** 
 639:Src/app.c     ****   res = bq->buffers[bq->ready_idx];
 640:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 641:Src/app.c     **** 
 642:Src/app.c     ****   return res;
 643:Src/app.c     **** }
 644:Src/app.c     **** 
 645:Src/app.c     **** /**
 646:Src/app.c     ****  * @brief Puts a buffer into the ready pool (used by a producer).
 647:Src/app.c     ****  * @details Handles being called from an Interrupt Service Routine (ISR).
 648:Src/app.c     ****  */
 649:Src/app.c     **** static void bqueue_put_ready(bqueue_t *bq)
 650:Src/app.c     **** {
 651:Src/app.c     ****   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 652:Src/app.c     ****   int ret;
 653:Src/app.c     **** 
 654:Src/app.c     ****   if (xPortIsInsideInterrupt()) {
 655:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 656:Src/app.c     ****     assert(ret == pdTRUE);
 657:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 658:Src/app.c     ****   } else {
 659:Src/app.c     ****     ret = xSemaphoreGive(bq->ready);
 660:Src/app.c     ****     assert(ret == pdTRUE);
 661:Src/app.c     ****   }
 662:Src/app.c     **** }
 663:Src/app.c     **** 
 664:Src/app.c     **** /**
 665:Src/app.c     ****  * @brief Updates the display controller to show a new background buffer.
 666:Src/app.c     ****  * @details This function directly interacts with the screen layer driver to perform
 667:Src/app.c     ****  * a "flip," making the newly rendered frame visible.
 668:Src/app.c     ****  * @param next_disp_idx The index of the buffer in lcd_bg_buffer to display.
 669:Src/app.c     ****  */
 670:Src/app.c     **** static void reload_bg_layer(int next_disp_idx)
 671:Src/app.c     **** {
 672:Src/app.c     ****   int ret;
 673:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 23


 674:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_bg_buffer[next_disp_idx], SCRL_LAYER_0);
 675:Src/app.c     ****   assert(ret == 0);
 676:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 677:Src/app.c     ****   assert(ret == 0);
 678:Src/app.c     **** 
 679:Src/app.c     ****   ret = SRCL_Update();
 680:Src/app.c     ****   assert(ret == 0);
 681:Src/app.c     **** }
 682:Src/app.c     **** 
 683:Src/app.c     **** /**
 684:Src/app.c     ****  * @brief Frame event callback for the main display pipe (Pipe 1).
 685:Src/app.c     ****  * @details This function is triggered by a hardware interrupt every time the DCMIPP
 686:Src/app.c     ****  * has finished writing a new video frame for the display. It implements
 687:Src/app.c     ****  * a triple-buffering scheme for smooth, tear-free video.
 688:Src/app.c     ****  */
 689:Src/app.c     **** static void app_main_pipe_frame_event()
 690:Src/app.c     **** {
 691:Src/app.c     ****   /* Calculate the indices for the next display buffer and next capture buffer in a circular manner
 692:Src/app.c     ****   int next_disp_idx = (lcd_bg_buffer_disp_idx + 1) % DISPLAY_BUFFER_NB;
 693:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 694:Src/app.c     ****   int ret;
 695:Src/app.c     **** 
 696:Src/app.c     ****   /* Tell the DCMIPP hardware where to write the *next* frame it captures. */
 697:Src/app.c     ****   ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE1,
 698:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 699:Src/app.c     ****   assert(ret == HAL_OK);
 700:Src/app.c     **** 
 701:Src/app.c     ****   /* Update the global indices to track the buffers. */
 702:Src/app.c     ****   reload_bg_layer(next_disp_idx);
 703:Src/app.c     ****   lcd_bg_buffer_disp_idx = next_disp_idx;
 704:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 705:Src/app.c     **** 
 706:Src/app.c     ****   frame_event_nb++;
 707:Src/app.c     **** }
 708:Src/app.c     **** 
 709:Src/app.c     **** /**
 710:Src/app.c     ****  * @brief Frame event callback for the ancillary NN pipe (Pipe 2).
 711:Src/app.c     ****  * @details This function is triggered by a hardware interrupt every time the DCMIPP
 712:Src/app.c     ****  * has finished writing a new, smaller frame for the AI model.
 713:Src/app.c     ****  */
 714:Src/app.c     **** static void app_ancillary_pipe_frame_event()
 715:Src/app.c     **** {
 716:Src/app.c     ****   uint8_t *next_buffer;
 717:Src/app.c     ****   int ret;
 718:Src/app.c     **** 
 719:Src/app.c     ****   next_buffer = bqueue_get_free(&nn_input_queue, 0);
 720:Src/app.c     ****   if (next_buffer) {
 721:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 722:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 723:Src/app.c     ****     assert(ret == HAL_OK);
 724:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 725:Src/app.c     ****     frame_event_nb_for_resize = frame_event_nb - 1;
 726:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 727:Src/app.c     ****   }
 728:Src/app.c     **** }
 729:Src/app.c     **** 
 730:Src/app.c     **** /**
ARM GAS  /tmp/ccbfgvbk.s 			page 24


 731:Src/app.c     ****  * @brief VSYNC event callback for the display.
 732:Src/app.c     ****  * @details This is triggered by a hardware interrupt at the start of each vertical
 733:Src/app.c     ****  * blanking interval of the display. It's used to synchronize the camera's
 734:Src/app.c     ****  * Image Signal Processing (ISP) task with the display refresh rate.
 735:Src/app.c     ****  */
 736:Src/app.c     **** static void app_main_pipe_vsync_event()
 737:Src/app.c     **** {
 738:Src/app.c     ****   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 739:Src/app.c     ****   int ret;
 740:Src/app.c     **** 
 741:Src/app.c     ****   ret = xSemaphoreGiveFromISR(isp_sem, &xHigherPriorityTaskWoken);
 742:Src/app.c     ****   if (ret == pdTRUE)
 743:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 744:Src/app.c     **** }
 745:Src/app.c     **** 
 746:Src/app.c     **** /**
 747:Src/app.c     ****  * @brief Clamps a 2D point to ensure it's within the screen boundaries.
 748:Src/app.c     ****  * @return 1 if the point was moved, 0 otherwise.
 749:Src/app.c     ****  */
 750:Src/app.c     **** static int clamp_point(int *x, int *y)
 751:Src/app.c     **** {
  84              		.loc 1 751 1 is_stmt 1 view -0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
 752:Src/app.c     ****   int xi = *x;
  88              		.loc 1 752 3 view .LVU14
  89              		.loc 1 752 7 is_stmt 0 view .LVU15
  90 0000 0368     		ldr	r3, [r0]
  91              	.LVL5:
 753:Src/app.c     ****   int yi = *y;
  92              		.loc 1 753 3 is_stmt 1 view .LVU16
 751:Src/app.c     ****   int xi = *x;
  93              		.loc 1 751 1 is_stmt 0 view .LVU17
  94 0002 10B5     		push	{r4, lr}
  95              		.cfi_def_cfa_offset 8
  96              		.cfi_offset 4, -8
  97              		.cfi_offset 14, -4
 754:Src/app.c     **** 
 755:Src/app.c     ****   if (*x < 0)
  98              		.loc 1 755 6 view .LVU18
  99 0004 002B     		cmp	r3, #0
 756:Src/app.c     ****     *x = 0;
 100              		.loc 1 756 8 view .LVU19
 101 0006 B8BF     		it	lt
 102 0008 0024     		movlt	r4, #0
 753:Src/app.c     **** 
 103              		.loc 1 753 7 view .LVU20
 104 000a 0A68     		ldr	r2, [r1]
 105              	.LVL6:
 755:Src/app.c     ****     *x = 0;
 106              		.loc 1 755 3 is_stmt 1 view .LVU21
 107              		.loc 1 756 5 view .LVU22
 108              		.loc 1 756 8 is_stmt 0 view .LVU23
 109 000c B8BF     		it	lt
 110 000e 0460     		strlt	r4, [r0]
 757:Src/app.c     ****   if (*y < 0)
ARM GAS  /tmp/ccbfgvbk.s 			page 25


 111              		.loc 1 757 3 is_stmt 1 view .LVU24
 112              		.loc 1 757 6 is_stmt 0 view .LVU25
 113 0010 0C68     		ldr	r4, [r1]
 114 0012 002C     		cmp	r4, #0
 758:Src/app.c     ****     *y = 0;
 115              		.loc 1 758 5 is_stmt 1 view .LVU26
 116              		.loc 1 758 8 is_stmt 0 view .LVU27
 117 0014 BCBF     		itt	lt
 118 0016 0024     		movlt	r4, #0
 119 0018 0C60     		strlt	r4, [r1]
 759:Src/app.c     ****   if (*x >= lcd_bg_area.XSize)
 120              		.loc 1 759 3 is_stmt 1 view .LVU28
 121              		.loc 1 759 6 is_stmt 0 view .LVU29
 122 001a 0468     		ldr	r4, [r0]
 123 001c B4F5487F 		cmp	r4, #800
 760:Src/app.c     ****     *x = lcd_bg_area.XSize - 1;
 124              		.loc 1 760 5 is_stmt 1 view .LVU30
 125              		.loc 1 760 8 is_stmt 0 view .LVU31
 126 0020 24BF     		itt	cs
 127 0022 40F21F34 		movwcs	r4, #799
 128 0026 0460     		strcs	r4, [r0]
 761:Src/app.c     ****   if (*y >= lcd_bg_area.YSize)
 129              		.loc 1 761 3 is_stmt 1 view .LVU32
 130              		.loc 1 761 6 is_stmt 0 view .LVU33
 131 0028 0C68     		ldr	r4, [r1]
 132 002a B4F5F07F 		cmp	r4, #480
 762:Src/app.c     ****     *y = lcd_bg_area.YSize - 1;
 133              		.loc 1 762 5 is_stmt 1 view .LVU34
 134              		.loc 1 762 8 is_stmt 0 view .LVU35
 135 002e 24BF     		itt	cs
 136 0030 40F2DF14 		movwcs	r4, #479
 137 0034 0C60     		strcs	r4, [r1]
 763:Src/app.c     **** 
 764:Src/app.c     ****   return (xi != *x) || (yi != *y);
 138              		.loc 1 764 3 is_stmt 1 view .LVU36
 139              		.loc 1 764 21 is_stmt 0 view .LVU37
 140 0036 0068     		ldr	r0, [r0]
 141              	.LVL7:
 142              		.loc 1 764 21 view .LVU38
 143 0038 9842     		cmp	r0, r3
 144 003a 04D1     		bne	.L12
 145              		.loc 1 764 21 discriminator 2 view .LVU39
 146 003c 0868     		ldr	r0, [r1]
 147 003e 801A     		subs	r0, r0, r2
 148 0040 18BF     		it	ne
 149 0042 0120     		movne	r0, #1
 150              	.L6:
 765:Src/app.c     **** }
 151              		.loc 1 765 1 view .LVU40
 152 0044 10BD     		pop	{r4, pc}
 153              	.L12:
 764:Src/app.c     **** }
 154              		.loc 1 764 21 discriminator 3 view .LVU41
 155 0046 0120     		movs	r0, #1
 764:Src/app.c     **** }
 156              		.loc 1 764 21 view .LVU42
 157 0048 FCE7     		b	.L6
ARM GAS  /tmp/ccbfgvbk.s 			page 26


 158              		.cfi_endproc
 159              	.LFE7380:
 161              		.section	.rodata.isp_thread_fct.str1.1,"aMS",%progbits,1
 162              	.LC1:
 163 0000 72657420 		.ascii	"ret == pdTRUE\000"
 163      3D3D2070 
 163      64545255 
 163      4500
 164              	.LC2:
 165 000e 5372632F 		.ascii	"Src/app.c\000"
 165      6170702E 
 165      6300
 166              		.section	.text.isp_thread_fct,"ax",%progbits
 167              		.align	1
 168              		.syntax unified
 169              		.thumb
 170              		.thumb_func
 172              	isp_thread_fct:
 173              	.LVL8:
 174              	.LFB7411:
 766:Src/app.c     **** 
 767:Src/app.c     **** /**
 768:Src/app.c     ****  * @brief Clamps a 2D point, keeping a minimum margin from the screen edges.
 769:Src/app.c     ****  * @return 1 if the point was moved, 0 otherwise.
 770:Src/app.c     ****  */
 771:Src/app.c     **** static int clamp_point_with_margin(int *x, int *y, int margin)
 772:Src/app.c     **** {
 773:Src/app.c     ****   int xi = *x;
 774:Src/app.c     ****   int yi = *y;
 775:Src/app.c     **** 
 776:Src/app.c     ****   if (*x < margin)
 777:Src/app.c     ****     *x = margin;
 778:Src/app.c     ****   if (*y < margin)
 779:Src/app.c     ****     *y = margin;
 780:Src/app.c     ****   if (*x >= lcd_bg_area.XSize - margin)
 781:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 782:Src/app.c     ****   if (*y >= lcd_bg_area.YSize - margin)
 783:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 784:Src/app.c     **** 
 785:Src/app.c     ****   return (xi != *x) || (yi != *y);
 786:Src/app.c     **** }
 787:Src/app.c     **** 
 788:Src/app.c     **** /**
 789:Src/app.c     ****  * @brief Draws the output of the first model (palm/face detector).
 790:Src/app.c     ****  * @param hand Pointer to the raw detection box data.
 791:Src/app.c     ****  */
 792:Src/app.c     **** static void display_pd_hand(pd_pp_box_t *hand)
 793:Src/app.c     **** {
 794:Src/app.c     ****   int xc, yc;
 795:Src/app.c     ****   int x0, y0;
 796:Src/app.c     ****   int x1, y1;
 797:Src/app.c     ****   int w, h;
 798:Src/app.c     ****   int i;
 799:Src/app.c     **** 
 800:Src/app.c     ****   /* display box around palm */
 801:Src/app.c     ****   xc = (int)hand->x_center;
 802:Src/app.c     ****   yc = (int)hand->y_center;
ARM GAS  /tmp/ccbfgvbk.s 			page 27


 803:Src/app.c     ****   w = (int)hand->width;
 804:Src/app.c     ****   h = (int)hand->height;
 805:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 806:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 807:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 808:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 809:Src/app.c     ****   clamp_point(&x0, &y0);
 810:Src/app.c     ****   clamp_point(&x1, &y1);
 811:Src/app.c     ****   UTIL_LCD_DrawRect(x0, y0, x1 - x0, y1 - y0, UTIL_LCD_COLOR_GREEN);
 812:Src/app.c     **** 
 813:Src/app.c     ****   /* display palm key points */
 814:Src/app.c     ****   for (i = 0; i < 7; i++) {
 815:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 816:Src/app.c     **** 
 817:Src/app.c     ****     x0 = (int)hand->pKps[i].x;
 818:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 819:Src/app.c     ****     clamp_point(&x0, &y0);
 820:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 821:Src/app.c     ****   }
 822:Src/app.c     **** }
 823:Src/app.c     **** 
 824:Src/app.c     **** /**
 825:Src/app.c     ****  * @brief Rotates a 2D point around the origin.
 826:Src/app.c     ****  */
 827:Src/app.c     **** static void rotate_point(float pt[2], float rotation)
 828:Src/app.c     **** {
 829:Src/app.c     ****   float x = pt[0];
 830:Src/app.c     ****   float y = pt[1];
 831:Src/app.c     **** 
 832:Src/app.c     ****   pt[0] = cos(rotation) * x - sin(rotation) * y;
 833:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 834:Src/app.c     **** }
 835:Src/app.c     **** 
 836:Src/app.c     **** /**
 837:Src/app.c     ****  * @brief Calculates the four corner coordinates of a rotated ROI rectangle.
 838:Src/app.c     ****  */
 839:Src/app.c     **** static void roi_to_corners(roi_t *roi, float corners[4][2])
 840:Src/app.c     **** {
 841:Src/app.c     ****   const float corners_init[4][2] = {
 842:Src/app.c     ****     {-roi->w / 2, -roi->h / 2},
 843:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 844:Src/app.c     ****     { roi->w / 2,  roi->h / 2},
 845:Src/app.c     ****     {-roi->w / 2,  roi->h / 2},
 846:Src/app.c     ****   };
 847:Src/app.c     ****   int i;
 848:Src/app.c     **** 
 849:Src/app.c     ****   memcpy(corners, corners_init, sizeof(corners_init));
 850:Src/app.c     ****   /* rotate */
 851:Src/app.c     ****   for (i = 0; i < 4; i++)
 852:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 853:Src/app.c     **** 
 854:Src/app.c     ****   /* shift */
 855:Src/app.c     ****   for (i = 0; i < 4; i++) {
 856:Src/app.c     ****     corners[i][0] += roi->cx;
 857:Src/app.c     ****     corners[i][1] += roi->cy;
 858:Src/app.c     ****   }
 859:Src/app.c     **** }
ARM GAS  /tmp/ccbfgvbk.s 			page 28


 860:Src/app.c     **** 
 861:Src/app.c     **** /**
 862:Src/app.c     ****  * @brief Clamps all four corners of a rectangle to the screen boundaries.
 863:Src/app.c     ****  */
 864:Src/app.c     **** static int clamp_corners(float corners_in[4][2], int corners_out[4][2])
 865:Src/app.c     **** {
 866:Src/app.c     ****   int is_clamp = 0;
 867:Src/app.c     ****   int i;
 868:Src/app.c     **** 
 869:Src/app.c     ****   for (i = 0; i < 4; i++) {
 870:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 871:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 872:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 873:Src/app.c     ****   }
 874:Src/app.c     **** 
 875:Src/app.c     ****   return is_clamp;
 876:Src/app.c     **** }
 877:Src/app.c     **** 
 878:Src/app.c     **** /**
 879:Src/app.c     ****  * @brief Draws the rotated red ROI box for debugging purposes.
 880:Src/app.c     ****  * @details This shows the exact region that was cropped and sent to the second model.
 881:Src/app.c     ****  */
 882:Src/app.c     **** static void display_roi(roi_t *roi)
 883:Src/app.c     **** {
 884:Src/app.c     ****   float corners_f[4][2];
 885:Src/app.c     ****   int corners[4][2];
 886:Src/app.c     ****   int is_clamp;
 887:Src/app.c     ****   int i;
 888:Src/app.c     **** 
 889:Src/app.c     ****   /* compute box corners */
 890:Src/app.c     ****   roi_to_corners(roi, corners_f);
 891:Src/app.c     **** 
 892:Src/app.c     ****   /* clamp */
 893:Src/app.c     ****   is_clamp = clamp_corners(corners_f, corners);
 894:Src/app.c     ****   if (is_clamp)
 895:Src/app.c     ****     return ;
 896:Src/app.c     **** 
 897:Src/app.c     ****   /* display */
 898:Src/app.c     ****   for (i = 0; i < 4; i++)
 899:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 900:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 901:Src/app.c     **** }
 902:Src/app.c     **** 
 903:Src/app.c     **** /**
 904:Src/app.c     ****  * @brief Decodes a landmark's relative coordinates into absolute screen coordinates.
 905:Src/app.c     ****  * @details The landmark model outputs coordinates relative to the ROI (0.0 to 1.0).
 906:Src/app.c     ****  * This function transforms them back into the main screen's coordinate space by
 907:Src/app.c     ****  * applying the ROI's translation, scaling, and rotation.
 908:Src/app.c     ****  * @param roi The Region of Interest that was used as input for the landmark model.
 909:Src/app.c     ****  * @param lm The landmark point with relative coordinates.
 910:Src/app.c     ****  * @param decoded The landmark point with absolute screen coordinates (output).
 911:Src/app.c     ****  */
 912:Src/app.c     **** static void decode_ld_landmark(roi_t *roi, ld_point_t *lm, ld_point_t *decoded)
 913:Src/app.c     **** {
 914:Src/app.c     ****   float rotation = roi->rotation;
 915:Src/app.c     ****   float w = roi->w;
 916:Src/app.c     ****   float h = roi->h;
ARM GAS  /tmp/ccbfgvbk.s 			page 29


 917:Src/app.c     **** 
 918:Src/app.c     ****   decoded->x = roi->cx + (lm->x - 0.5) * w * cos(rotation) - (lm->y - 0.5) * h * sin(rotation);
 919:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 920:Src/app.c     **** }
 921:Src/app.c     **** 
 922:Src/app.c     **** /**
 923:Src/app.c     ****  * @brief Draws the output of the second model (hand/face landmarks).
 924:Src/app.c     ****  */
 925:Src/app.c     **** static void display_ld_hand(hand_info_t *hand)
 926:Src/app.c     **** {
 927:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 928:Src/app.c     ****   roi_t *roi = &hand->roi;
 929:Src/app.c     ****   int x[LD_LANDMARK_NB];
 930:Src/app.c     ****   int y[LD_LANDMARK_NB];
 931:Src/app.c     ****   int is_clamped[LD_LANDMARK_NB];
 932:Src/app.c     ****   ld_point_t decoded;
 933:Src/app.c     ****   int i;
 934:Src/app.c     **** 
 935:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++) {
 936:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 937:Src/app.c     ****     x[i] = (int)decoded.x;
 938:Src/app.c     ****     y[i] = (int)decoded.y;
 939:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 940:Src/app.c     ****   }
 941:Src/app.c     **** 
 942:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++) {
 943:Src/app.c     ****     if (is_clamped[i])
 944:Src/app.c     ****       continue;
 945:Src/app.c     ****     UTIL_LCD_FillCircle(x[i], y[i], disk_radius, UTIL_LCD_COLOR_YELLOW);
 946:Src/app.c     ****   }
 947:Src/app.c     **** 
 948:Src/app.c     ****   for (i = 0; i < LD_BINDING_NB; i++) {
 949:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 950:Src/app.c     ****       continue;
 951:Src/app.c     ****     UTIL_LCD_DrawLine(x[ld_bindings_idx[i][0]], y[ld_bindings_idx[i][0]],
 952:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
 953:Src/app.c     ****                       UTIL_LCD_COLOR_BLACK);
 954:Src/app.c     ****   }
 955:Src/app.c     **** }
 956:Src/app.c     **** 
 957:Src/app.c     **** /**
 958:Src/app.c     ****  * @brief Main drawing wrapper to display all info for a single detected hand/face.
 959:Src/app.c     ****  * @details Checks UI toggles to decide whether to draw the bounding box and/or the landmarks.
 960:Src/app.c     ****  */
 961:Src/app.c     **** void display_hand(display_info_t *info, hand_info_t *hand)
 962:Src/app.c     **** {
 963:Src/app.c     ****   if (info->is_pd_displayed) {
 964:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 965:Src/app.c     ****     display_roi(&hand->roi);
 966:Src/app.c     ****   }
 967:Src/app.c     ****   if (info->is_ld_displayed)
 968:Src/app.c     ****     display_ld_hand(hand);
 969:Src/app.c     **** }
 970:Src/app.c     **** 
 971:Src/app.c     **** /**
 972:Src/app.c     ****  * @brief Renders the entire UI overlay for one frame.
 973:Src/app.c     ****  * @details This is the main function called by the display task. It clears the
ARM GAS  /tmp/ccbfgvbk.s 			page 30


 974:Src/app.c     ****  * overlay, draws performance stats, and then draws the AI model results.
 975:Src/app.c     ****  * @param info The main display structure containing all data to be rendered.
 976:Src/app.c     ****  */
 977:Src/app.c     **** static void Display_NetworkOutput(display_info_t *info)
 978:Src/app.c     **** {
 979:Src/app.c     ****   float cpu_load_one_second;
 980:Src/app.c     ****   int line_nb = 0;
 981:Src/app.c     ****   float nn_fps;
 982:Src/app.c     ****   int i;
 983:Src/app.c     **** 
 984:Src/app.c     ****   /* clear previous ui */
 985:Src/app.c     ****   UTIL_LCD_FillRect(lcd_fg_area.X0, lcd_fg_area.Y0, lcd_fg_area.XSize, lcd_fg_area.YSize, 0x0000000
 986:Src/app.c     **** 
 987:Src/app.c     ****   /* cpu load */
 988:Src/app.c     ****   cpuload_update(&cpu_load);
 989:Src/app.c     ****   cpuload_get_info(&cpu_load, NULL, &cpu_load_one_second, NULL);
 990:Src/app.c     **** 
 991:Src/app.c     ****   /* draw metrics */
 992:Src/app.c     ****   nn_fps = 1000.0 / info->nn_period_ms;
 993:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 994:Src/app.c     ****   line_nb += 1;
 995:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "   %.1f%%", cpu_load_one_second);
 996:Src/app.c     ****   line_nb += 2;
 997:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Inferences");
 998:Src/app.c     ****   line_nb += 1;
 999:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " pd %2ums", info->pd_ms);
1000:Src/app.c     ****   line_nb += 1;
1001:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " hl %2ums", info->hl_ms);
1002:Src/app.c     ****   line_nb += 2;
1003:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "  %.1f FPS", nn_fps);
1004:Src/app.c     ****   line_nb += 2;
1005:Src/app.c     ****   if (DBG_INFO) {
1006:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Display");
1007:Src/app.c     ****     line_nb += 1;
1008:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "   %ums", info->disp_ms);
1009:Src/app.c     ****     line_nb += 1;
1010:Src/app.c     ****   }
1011:Src/app.c     **** 
1012:Src/app.c     ****   /* display palm detector output */
1013:Src/app.c     ****   for (i = 0; i < info->pd_hand_nb; i++) {
1014:Src/app.c     ****     if (info->hands[i].is_valid)
1015:Src/app.c     ****       display_hand(info, &info->hands[i]);
1016:Src/app.c     ****   }
1017:Src/app.c     **** 
1018:Src/app.c     ****   if (DBG_INFO)
1019:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
1020:Src/app.c     **** }
1021:Src/app.c     **** 
1022:Src/app.c     **** /**
1023:Src/app.c     ****  * @brief Initializes the Palm Detector model and its post-processor.
1024:Src/app.c     ****  * @details This function gets memory addresses for the model's output tensors
1025:Src/app.c     ****  * (where the NPU writes its results) and prepares the software-based
1026:Src/app.c     ****  * post-processing library. This is for the FIRST model in the sequence.
1027:Src/app.c     ****  * @param info Pointer to the palm detector model info structure to be filled.
1028:Src/app.c     ****  */
1029:Src/app.c     **** static void palm_detector_init(pd_model_info_t *info)
1030:Src/app.c     **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 31


1031:Src/app.c     ****   /* Get pointers to the model's output and input buffer information from the AI library. */
1032:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_palm_detector();
1033:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_palm_detector();
1034:Src/app.c     ****   int ret;
1035:Src/app.c     **** 
1036:Src/app.c     ****   /* Store pointers and sizes for the model's input and output tensors. */
1037:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1038:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[0]);
1039:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[0]);
1040:Src/app.c     ****   assert(info->prob_out_len == AI_PD_MODEL_PP_TOTAL_DETECTIONS * sizeof(float));
1041:Src/app.c     ****   info->boxes_out = (float *) LL_Buffer_addr_start(&nn_out_info[1]);
1042:Src/app.c     ****   info->boxes_out_len = LL_Buffer_len(&nn_out_info[1]);
1043:Src/app.c     ****   assert(info->boxes_out_len == AI_PD_MODEL_PP_TOTAL_DETECTIONS * sizeof(float) * 18);
1044:Src/app.c     **** 
1045:Src/app.c     ****   /* Initialize the post-processing library with model-specific parameters (e.g., anchor boxes). */
1046:Src/app.c     ****   ret = app_postprocess_init(&info->static_param);
1047:Src/app.c     ****   assert(ret == AI_PD_POSTPROCESS_ERROR_NO);
1048:Src/app.c     **** }
1049:Src/app.c     **** 
1050:Src/app.c     **** /**
1051:Src/app.c     ****  * @brief Initializes the YOLOv8 Detector model and its post-processor parameters.
1052:Src/app.c     ****  * @details This function gets the memory address for the model's single raw output
1053:Src/app.c     ****  * tensor and configures the parameters for the YOLOv8 post-processing library.
1054:Src/app.c     ****  * @param info Pointer to the yolo_detector_info_t structure to be filled.
1055:Src/app.c     ****  */
1056:Src/app.c     **** static void yolo_detector_init(yolo_model_info_t *info)
1057:Src/app.c     **** {
1058:Src/app.c     ****   /* Get pointers to the info structures for the model's I/O buffers. */
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_yolo_detector();
1060:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
1061:Src/app.c     **** 
1062:Src/app.c     ****   /* --- Get I/O Buffer Addresses --- */
1063:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1064:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1065:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
1066:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
1067:Src/app.c     **** 
1068:Src/app.c     ****   /* --- Initialize the Post-Processing Parameters --- */
1069:Src/app.c     ****   /* Call the generic init function. It will populate the pp_params struct
1070:Src/app.c     ****      with the correct default values from the pre-processor defines. */
1071:Src/app.c     ****   app_postprocess_init(&info->pp_params);
1072:Src/app.c     **** }
1073:Src/app.c     **** 
1074:Src/app.c     **** /**
1075:Src/app.c     ****  * @brief Runs one inference of the YOLOv8 Detector model.
1076:Src/app.c     ****  * @details This function runs the NPU inference, calls the YOLOv8 post-processing
1077:Src/app.c     ****  * library, filters the results for faces (class ID 2), and prepares the
1078:Src/app.c     ****  * Regions of Interest (ROIs) for the next stage.
1079:Src/app.c     ****  * @param buffer Pointer to the input image from the camera.
1080:Src/app.c     ****  * @param info Pointer to the initialized yolo_detector_info_t structure.
1081:Src/app.c     ****  * @param yolo_exec_time Pointer to store the execution time of this stage.
1082:Src/app.c     ****  * @return The number of *faces* detected.
1083:Src/app.c     ****  */
1084:Src/app.c     **** static int yolo_detector_run(uint8_t *buffer, yolo_model_info_t *info, uint32_t *yolo_exec_time)
1085:Src/app.c     **** {
1086:Src/app.c     ****   uint32_t start_ts;
1087:Src/app.c     ****   int total_detections;
ARM GAS  /tmp/ccbfgvbk.s 			page 32


1088:Src/app.c     ****   int face_nb = 0; /* This will count only the faces we find. */
1089:Src/app.c     ****   int ret;
1090:Src/app.c     **** 
1091:Src/app.c     ****   start_ts = HAL_GetTick();
1092:Src/app.c     **** 
1093:Src/app.c     ****   /* --- 1. Run Inference --- */
1094:Src/app.c     ****   ret = LL_ATON_Set_User_Input_Buffer_yolo_detector(0, buffer, info->nn_in_len);
1095:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
1096:Src/app.c     **** 
1097:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_yolo_detector);
1098:Src/app.c     **** 
1099:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->raw_output_tensor, info->raw_output_len));
1100:Src/app.c     **** 
1101:Src/app.c     ****   /* --- 2. Run Post-Processing via Wrapper --- */
1102:Src/app.c     ****   /* Call the generic post-processing wrapper. It will internally call the correct INT8 function. *
1103:Src/app.c     ****   ret = app_postprocess_run((void * []){info->raw_output_tensor}, 1, &info->pp_output, &info->pp_pa
1104:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
1105:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
1106:Src/app.c     **** 
1107:Src/app.c     ****   /* --- 3. Filter for Faces & Prepare ROIs --- */
1108:Src/app.c     ****   for (int i = 0; i < total_detections; i++)
1109:Src/app.c     ****   {
1110:Src/app.c     ****     /* Check if the detected object is a face (class ID 2). */
1111:Src/app.c     ****     if (info->pp_output.pOutBuff[i].class_index == 2)
1112:Src/app.c     ****     {
1113:Src/app.c     ****       pd_pp_box_t temp_box = {0};
1114:Src/app.c     ****       temp_box.x_center = info->pp_output.pOutBuff[i].x_center;
1115:Src/app.c     ****       temp_box.y_center = info->pp_output.pOutBuff[i].y_center;
1116:Src/app.c     ****       temp_box.width    = info->pp_output.pOutBuff[i].width;
1117:Src/app.c     ****       temp_box.height   = info->pp_output.pOutBuff[i].height;
1118:Src/app.c     ****       temp_box.prob     = info->pp_output.pOutBuff[i].conf;
1119:Src/app.c     **** 
1120:Src/app.c     ****       cvt_pd_coord_to_screen_coord(&temp_box);
1121:Src/app.c     ****       pd_box_to_roi(&temp_box, &rois[face_nb]);
1122:Src/app.c     **** 
1123:Src/app.c     ****       face_nb++; /* Increment the count of found faces. */
1124:Src/app.c     ****       if (face_nb >= YOLO_MAX_NB) { break; } /* Stop if we've reached our limit. */
1125:Src/app.c     ****     }
1126:Src/app.c     ****   }
1127:Src/app.c     **** 
1128:Src/app.c     ****   *yolo_exec_time = HAL_GetTick() - start_ts;
1129:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
1130:Src/app.c     **** }
1131:Src/app.c     ****  
1132:Src/app.c     **** /**
1133:Src/app.c     ****  * @brief Initializes the Face Landmark model.
1134:Src/app.c     ****  * @details This function gets memory addresses for the model's input and output
1135:Src/app.c     ****  * tensors. It is configured based on analysis of the Python post-processing script.
1136:Src/app.c     ****  * @param info Pointer to the face landmark model info structure to be filled.
1137:Src/app.c     ****  * @note The indices for nn_out_info have been updated to match the model's
1138:Src/app.c     ****  * actual output order: [0] for score, [1] for landmarks.
1139:Src/app.c     ****  */
1140:Src/app.c     **** static void face_landmark_init(fl_model_info_t *info)
1141:Src/app.c     **** {
1142:Src/app.c     ****   // Get pointers to the info structures for the model's input/output buffers
1143:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_face_landmark();
1144:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_face_landmark();
ARM GAS  /tmp/ccbfgvbk.s 			page 33


1145:Src/app.c     **** 
1146:Src/app.c     ****   // --- INPUT TENSOR ---
1147:Src/app.c     ****   // The input is the image buffer for the model to process.
1148:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1149:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1150:Src/app.c     **** 
1151:Src/app.c     ****   // --- OUTPUT TENSORS (Order corrected based on Python analysis) ---
1152:Src/app.c     **** 
1153:Src/app.c     ****   // Output 0: Presence Score
1154:Src/app.c     ****   // This buffer will contain a single float indicating the confidence that a face was detected.
1155:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[0]);
1156:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[0]);
1157:Src/app.c     **** 
1158:Src/app.c     ****   // Output 1: Landmarks
1159:Src/app.c     ****   // This buffer contains the raw coordinates for all 468 facial landmarks.
1160:Src/app.c     ****   // Even if post-processing only uses x and y, we must map the full 3D output buffer.
1161:Src/app.c     ****   info->landmarks_out = (float *) LL_Buffer_addr_start(&nn_out_info[1]);
1162:Src/app.c     ****   info->landmarks_out_len = LL_Buffer_len(&nn_out_info[1]);
1163:Src/app.c     **** }
1164:Src/app.c     **** 
1165:Src/app.c     **** 
1166:Src/app.c     **** /**
1167:Src/app.c     ****  * @brief Runs one inference of the Palm Detector model.
1168:Src/app.c     ****  * @param buffer Pointer to the input image from the camera.
1169:Src/app.c     ****  * @param info Pointer to the initialized model info structure.
1170:Src/app.c     ****  * @param pd_exec_time Pointer to store the execution time of this stage.
1171:Src/app.c     ****  * @return The number of hands/faces detected.
1172:Src/app.c     ****  */
1173:Src/app.c     **** static int palm_detector_run(uint8_t *buffer, pd_model_info_t *info, uint32_t *pd_exec_time)
1174:Src/app.c     **** {
1175:Src/app.c     ****   uint32_t start_ts;
1176:Src/app.c     ****   int hand_nb;
1177:Src/app.c     ****   int ret;
1178:Src/app.c     ****   int i;
1179:Src/app.c     **** 
1180:Src/app.c     ****   start_ts = HAL_GetTick();
1181:Src/app.c     ****   /* Set the input buffer for the NPU. */
1182:Src/app.c     ****   /* Note that we don't need to clean/invalidate those input buffers since they are only access in 
1183:Src/app.c     ****   ret = LL_ATON_Set_User_Input_Buffer_palm_detector(0, buffer, info->nn_in_len);
1184:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
1185:Src/app.c     **** 
1186:Src/app.c     ****   /* Trigger the NPU to run the inference. This is a blocking call. */
1187:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_palm_detector);
1188:Src/app.c     **** 
1189:Src/app.c     ****   /* Run software post-processing to decode the raw NPU output into human-readable boxes and scores
1190:Src/app.c     ****   ret = app_postprocess_run((void * []){info->prob_out, info->boxes_out}, 2, &info->pd_out, &info->
1191:Src/app.c     ****   assert(ret == AI_PD_POSTPROCESS_ERROR_NO);
1192:Src/app.c     ****   hand_nb = MIN(info->pd_out.box_nb, PD_MAX_HAND_NB);
1193:Src/app.c     **** 
1194:Src/app.c     ****   /* For each detected hand/face, convert its coordinates and generate an ROI for the next model. *
1195:Src/app.c     ****   for (i = 0; i < hand_nb; i++) {
1196:Src/app.c     ****     cvt_pd_coord_to_screen_coord(&info->pd_out.pOutData[i]);
1197:Src/app.c     ****     pd_box_to_roi(&info->pd_out.pOutData[i], &rois[i]);
1198:Src/app.c     ****   }
1199:Src/app.c     **** 
1200:Src/app.c     ****   /* Discard nn_out region (used by pp_outputs variables) to avoid Dcache evictions during nn infer
1201:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->prob_out, info->prob_out_len));
ARM GAS  /tmp/ccbfgvbk.s 			page 34


1202:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->boxes_out, info->boxes_out_len));
1203:Src/app.c     **** 
1204:Src/app.c     ****   *pd_exec_time = HAL_GetTick() - start_ts;
1205:Src/app.c     **** 
1206:Src/app.c     ****   return hand_nb;
1207:Src/app.c     **** }
1208:Src/app.c     **** 
1209:Src/app.c     **** /**
1210:Src/app.c     ****  * @brief Initializes the Hand Landmark model.
1211:Src/app.c     ****  * @details This function gets memory addresses for the SECOND model's input and output
1212:Src/app.c     ****  * tensors, allowing the application to prepare the input and read the results.
1213:Src/app.c     ****  * @param info Pointer to the hand landmark model info structure to be filled.
1214:Src/app.c     ****  */
1215:Src/app.c     **** static void hand_landmark_init(hl_model_info_t *info)
1216:Src/app.c     **** {
1217:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_hand_landmark();
1218:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_hand_landmark();
1219:Src/app.c     **** 
1220:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1221:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1222:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[2]);
1223:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[2]);
1224:Src/app.c     ****   assert(info->prob_out_len == sizeof(float));
1225:Src/app.c     ****   info->landmarks_out = (float *) LL_Buffer_addr_start(&nn_out_info[3]);
1226:Src/app.c     ****   info->landmarks_out_len = LL_Buffer_len(&nn_out_info[3]);
1227:Src/app.c     ****   assert(info->landmarks_out_len == sizeof(float) * 63);
1228:Src/app.c     **** }
1229:Src/app.c     **** 
1230:Src/app.c     **** 
1231:Src/app.c     **** static void app_transform(nema_matrix3x3_t t, app_v3_t v)
1232:Src/app.c     **** {
1233:Src/app.c     ****   app_v3_t r;
1234:Src/app.c     ****   int i;
1235:Src/app.c     **** 
1236:Src/app.c     ****   for (i = 0; i < 3; i++)
1237:Src/app.c     ****     r[i] = t[i][0] * v[0] + t[i][1] * v[1] + t[i][2] * v[2];
1238:Src/app.c     **** 
1239:Src/app.c     ****   for (i = 0; i < 3; i++)
1240:Src/app.c     ****     v[i] = r[i];
1241:Src/app.c     **** }
1242:Src/app.c     **** /**
1243:Src/app.c     ****  * @brief Prepares the landmark model's input using the NEMA GPU.
1244:Src/app.c     ****  * @details This function offloads the entire crop, rotate, and resize operation to
1245:Src/app.c     ****  * the hardware accelerator. It builds a transformation matrix and submits it
1246:Src/app.c     ****  * to the GPU, which is much faster than the CPU-based version.
1247:Src/app.c     ****  * @return 0 on success.
1248:Src/app.c     ****  */
1249:Src/app.c     **** static int hand_landmark_prepare_input(uint8_t *buffer, roi_t *roi, hl_model_info_t *info)
1250:Src/app.c     **** {
1251:Src/app.c     ****   app_v3_t vertex[] = {
1252:Src/app.c     ****     {           0,             0, 1},
1253:Src/app.c     ****     {LCD_BG_WIDTH,             0, 1},
1254:Src/app.c     ****     {LCD_BG_WIDTH, LCD_BG_HEIGHT, 1},
1255:Src/app.c     ****     {           0, LCD_BG_HEIGHT, 1},
1256:Src/app.c     ****   };
1257:Src/app.c     ****   GFXMMU_BuffersTypeDef buffers = { 0 };
1258:Src/app.c     ****   nema_matrix3x3_t t;
ARM GAS  /tmp/ccbfgvbk.s 			page 35


1259:Src/app.c     ****   int ret;
1260:Src/app.c     ****   int i;
1261:Src/app.c     **** 
1262:Src/app.c     ****   buffers.Buf0Address = (uint32_t) info->nn_in;
1263:Src/app.c     ****   ret = HAL_GFXMMU_ModifyBuffers(&hgfxmmu, &buffers);
1264:Src/app.c     ****   assert(ret == HAL_OK);
1265:Src/app.c     **** 
1266:Src/app.c     ****   /* bind destination texture */
1267:Src/app.c     ****   nema_bind_dst_tex(GFXMMU_VIRTUAL_BUFFER0_BASE, LD_WIDTH, LD_HEIGHT, NEMA_RGBA8888, -1);
1268:Src/app.c     ****   nema_set_clip(0, 0, LD_WIDTH, LD_HEIGHT);
1269:Src/app.c     ****   nema_clear(0);
1270:Src/app.c     ****   /* bind source texture */
1271:Src/app.c     ****   nema_bind_src_tex((uintptr_t) buffer, LCD_BG_WIDTH, LCD_BG_HEIGHT, NEMA_RGBA8888, -1, NEMA_FILTER
1272:Src/app.c     ****   nema_enable_tiling(1);
1273:Src/app.c     ****   nema_set_blend_blit(NEMA_BL_SRC);
1274:Src/app.c     **** 
1275:Src/app.c     ****   /* let's go */
1276:Src/app.c     ****   nema_mat3x3_load_identity(t);
1277:Src/app.c     ****   nema_mat3x3_translate(t, -roi->cx, -roi->cy);
1278:Src/app.c     ****   nema_mat3x3_rotate(t, nema_rad_to_deg(-roi->rotation));
1279:Src/app.c     ****   nema_mat3x3_scale(t, LD_WIDTH / roi->w, LD_HEIGHT / roi->h);
1280:Src/app.c     ****   nema_mat3x3_translate(t, LD_WIDTH / 2, LD_HEIGHT / 2);
1281:Src/app.c     ****   for (i = 0 ; i < 4; i++)
1282:Src/app.c     ****     app_transform(t, vertex[i]);
1283:Src/app.c     ****   nema_blit_quad_fit(vertex[0][0], vertex[0][1], vertex[1][0], vertex[1][1],
1284:Src/app.c     ****                      vertex[2][0], vertex[2][1], vertex[3][0], vertex[3][1]);
1285:Src/app.c     **** 
1286:Src/app.c     ****   nema_cl_submit(&cl);
1287:Src/app.c     ****   nema_cl_wait(&cl);
1288:Src/app.c     ****   HAL_ICACHE_Invalidate();
1289:Src/app.c     **** 
1290:Src/app.c     ****   assert(!nema_get_error());
1291:Src/app.c     **** 
1292:Src/app.c     ****   return 0;
1293:Src/app.c     **** }
1294:Src/app.c     **** 
1295:Src/app.c     **** /**
1296:Src/app.c     ****  * @brief Runs one inference of the Hand Landmark model.
1297:Src/app.c     ****  * @param buffer Pointer to the source display buffer (for cropping).
1298:Src/app.c     ****  * @param info Pointer to the initialized landmark model info.
1299:Src/app.c     ****  * @param roi The Region of Interest to process.
1300:Src/app.c     ****  * @param ld_landmarks Output array to store the final landmark coordinates.
1301:Src/app.c     ****  * @return 1 if a hand was found and landmarks are valid, 0 otherwise.
1302:Src/app.c     ****  */
1303:Src/app.c     **** static int hand_landmark_run(uint8_t *buffer, hl_model_info_t *info, roi_t *roi,
1304:Src/app.c     ****                              ld_point_t ld_landmarks[LD_LANDMARK_NB])
1305:Src/app.c     **** {
1306:Src/app.c     ****   int is_clamped;
1307:Src/app.c     ****   int is_valid;
1308:Src/app.c     **** 
1309:Src/app.c     ****   is_clamped = hand_landmark_prepare_input(buffer, roi, info);
1310:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(info->nn_in, info->nn_in_len));
1311:Src/app.c     ****   if (is_clamped)
1312:Src/app.c     ****     return 0;
1313:Src/app.c     **** 
1314:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_hand_landmark);
1315:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 36


1316:Src/app.c     ****   is_valid = ld_post_process(info->prob_out, info->landmarks_out, ld_landmarks);
1317:Src/app.c     **** 
1318:Src/app.c     ****   /* Discard nn_out region (used by pp_input and pp_outputs variables) to avoid Dcache evictions du
1319:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->prob_out, info->prob_out_len));
1320:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->landmarks_out, info->landmarks_out_len));
1321:Src/app.c     **** 
1322:Src/app.c     ****   return is_valid;
1323:Src/app.c     **** }
1324:Src/app.c     **** 
1325:Src/app.c     **** 
1326:Src/app.c     **** /**
1327:Src/app.c     ****  * @brief Initializes the NEMA GPU and its associated drivers.
1328:Src/app.c     ****  */
1329:Src/app.c     **** static void app_rot_init(hl_model_info_t *info)
1330:Src/app.c     **** {
1331:Src/app.c     ****   GFXMMU_PackingTypeDef packing = { 0 };
1332:Src/app.c     ****   int ret;
1333:Src/app.c     **** 
1334:Src/app.c     ****   printf("init nema\n");
1335:Src/app.c     ****   nema_init();
1336:Src/app.c     ****   assert(!nema_get_error());
1337:Src/app.c     ****   nema_ext_hold_enable(2);
1338:Src/app.c     ****   nema_ext_hold_irq_enable(2);
1339:Src/app.c     ****   nema_ext_hold_enable(3);
1340:Src/app.c     ****   nema_ext_hold_irq_enable(3);
1341:Src/app.c     ****   printf("init nema DONE %s\n", nema_get_sw_device_name());
1342:Src/app.c     **** 
1343:Src/app.c     ****   hgfxmmu.Instance = GFXMMU;
1344:Src/app.c     ****   hgfxmmu.Init.BlockSize = GFXMMU_12BYTE_BLOCKS;
1345:Src/app.c     ****   hgfxmmu.Init.AddressTranslation = DISABLE;
1346:Src/app.c     ****   ret = HAL_GFXMMU_Init(&hgfxmmu);
1347:Src/app.c     ****   assert(ret == HAL_OK);
1348:Src/app.c     **** 
1349:Src/app.c     ****   packing.Buffer0Activation = ENABLE;
1350:Src/app.c     ****   packing.Buffer0Mode       = GFXMMU_PACKING_MSB_REMOVE;
1351:Src/app.c     ****   packing.DefaultAlpha      = 0xff;
1352:Src/app.c     ****   ret = HAL_GFXMMU_ConfigPacking(&hgfxmmu, &packing);
1353:Src/app.c     ****   assert(ret == HAL_OK);
1354:Src/app.c     **** 
1355:Src/app.c     ****   cl = nema_cl_create_sized(8192);
1356:Src/app.c     ****   nema_cl_bind_circular(&cl);
1357:Src/app.c     **** }
1358:Src/app.c     **** 
1359:Src/app.c     **** /**
1360:Src/app.c     ****  * @brief Computes the rotation based on the final landmark points.
1361:Src/app.c     ****  * @details Uses landmark points 0 and 9 (e.g., wrist and middle finger base)
1362:Src/app.c     ****  * for a potentially more stable rotation estimate than the first model.
1363:Src/app.c     ****  */
1364:Src/app.c     **** static float ld_compute_rotation(ld_point_t lm[LD_LANDMARK_NB])
1365:Src/app.c     **** {
1366:Src/app.c     ****   float x0, y0, x1, y1;
1367:Src/app.c     ****   float rotation;
1368:Src/app.c     **** 
1369:Src/app.c     ****   x0 = lm[0].x;
1370:Src/app.c     ****   y0 = lm[0].y;
1371:Src/app.c     ****   x1 = lm[9].x;
1372:Src/app.c     ****   y1 = lm[9].y;
ARM GAS  /tmp/ccbfgvbk.s 			page 37


1373:Src/app.c     **** 
1374:Src/app.c     ****   rotation = M_PI * 0.5 - atan2f(-(y1 - y0), x1 - x0);
1375:Src/app.c     **** 
1376:Src/app.c     ****   return pd_cook_rotation(pd_normalize_angle(rotation));
1377:Src/app.c     **** }
1378:Src/app.c     **** 
1379:Src/app.c     **** /**
1380:Src/app.c     ****  * @brief Creates a new, tighter ROI based on the detected landmarks.
1381:Src/app.c     ****  * @details This is used to update the ROI for tracking in the next frame.
1382:Src/app.c     ****  */
1383:Src/app.c     **** static void ld_to_roi(ld_point_t lm[LD_LANDMARK_NB], roi_t *roi, pd_pp_box_t *next_pd)
1384:Src/app.c     **** {
1385:Src/app.c     ****   const int pd_to_ld_idx[AI_PD_MODEL_PP_NB_KEYPOINTS] = {0, 5, 9, 13, 17, 1, 2};
1386:Src/app.c     ****   const int indices[] = {0, 1, 2, 3, 5, 6, 9, 10, 13, 14, 17, 18};
1387:Src/app.c     ****   float max_x, max_y, min_x, min_y;
1388:Src/app.c     ****   int i;
1389:Src/app.c     **** 
1390:Src/app.c     ****   max_x = max_y = -10000;
1391:Src/app.c     ****   min_x = min_y =  10000;
1392:Src/app.c     **** 
1393:Src/app.c     ****   roi->rotation = ld_compute_rotation(lm);
1394:Src/app.c     **** 
1395:Src/app.c     ****   for (i = 0; i < ARRAY_NB(indices); i++) {
1396:Src/app.c     ****     max_x = MAX(max_x, lm[indices[i]].x);
1397:Src/app.c     ****     max_y = MAX(max_y, lm[indices[i]].y);
1398:Src/app.c     ****     min_x = MIN(min_x, lm[indices[i]].x);
1399:Src/app.c     ****     min_y = MIN(min_y, lm[indices[i]].y);
1400:Src/app.c     ****   }
1401:Src/app.c     **** 
1402:Src/app.c     ****   roi->cx = (max_x + min_x) / 2;
1403:Src/app.c     ****   roi->cy = (max_y + min_y) / 2;
1404:Src/app.c     ****   roi->w = (max_x - min_x);
1405:Src/app.c     ****   roi->h = (max_y - min_y);
1406:Src/app.c     **** 
1407:Src/app.c     ****   next_pd->x_center = roi->cx;
1408:Src/app.c     ****   next_pd->y_center = roi->cy;
1409:Src/app.c     ****   next_pd->width = roi->w;
1410:Src/app.c     ****   next_pd->height = roi->h;
1411:Src/app.c     ****   for (i = 0; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++) {
1412:Src/app.c     ****     next_pd->pKps[i].x = lm[pd_to_ld_idx[i]].x;
1413:Src/app.c     ****     next_pd->pKps[i].y = lm[pd_to_ld_idx[i]].y;
1414:Src/app.c     ****   }
1415:Src/app.c     **** }
1416:Src/app.c     **** 
1417:Src/app.c     **** /**
1418:Src/app.c     ****  * @brief Computes the predicted ROI for the next frame to enable tracking.
1419:Src/app.c     ****  * @details This is the core of the tracking logic. Instead of running the slow
1420:Src/app.c     ****  * detector on every frame, we use the landmarks from the current frame to predict
1421:Src/app.c     ****  * where the hand/face will be in the next frame. We then only need to run the
1422:Src/app.c     ****  * fast landmark model on that small predicted ROI.
1423:Src/app.c     ****  */
1424:Src/app.c     **** static void compute_next_roi(roi_t *src, ld_point_t lm_in[LD_LANDMARK_NB], roi_t *next, pd_pp_box_t
1425:Src/app.c     **** {
1426:Src/app.c     ****   const float shift_x = 0;
1427:Src/app.c     ****   const float shift_y = -0.1;
1428:Src/app.c     ****   const float scale = 2.0;
1429:Src/app.c     ****   ld_point_t lm[LD_LANDMARK_NB];
ARM GAS  /tmp/ccbfgvbk.s 			page 38


1430:Src/app.c     ****   roi_t roi;
1431:Src/app.c     ****   int i;
1432:Src/app.c     **** 
1433:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++)
1434:Src/app.c     ****     decode_ld_landmark(src, &lm_in[i], &lm[i]);
1435:Src/app.c     **** 
1436:Src/app.c     ****   ld_to_roi(lm, &roi, next_pd);
1437:Src/app.c     ****   roi_shift_and_scale(&roi, shift_x, shift_y, scale, scale);
1438:Src/app.c     **** 
1439:Src/app.c     ****   *next = roi;
1440:Src/app.c     **** }
1441:Src/app.c     **** 
1442:Src/app.c     **** /**
1443:Src/app.c     ****  * @brief The main function for the Neural Network processing thread.
1444:Src/app.c     ****  * @details This is the entry point for the FreeRTOS task that handles all AI inference.
1445:Src/app.c     ****  * It will contain a `while(1)` loop to process frames as they become available.
1446:Src/app.c     ****  */
1447:Src/app.c     **** static void nn_thread_fct_backup(void *arg)
1448:Src/app.c     **** {
1449:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
1450:Src/app.c     ****   float nn_period_filtered_ms = 0;
1451:Src/app.c     ****   float pd_filtered_ms = 0;
1452:Src/app.c     ****   float ld_filtered_ms = 0;
1453:Src/app.c     **** 
1454:Src/app.c     ****   /* Model-specific info structures. */
1455:Src/app.c     ****   hl_model_info_t hl_info;
1456:Src/app.c     ****   pd_model_info_t pd_info;
1457:Src/app.c     ****   yolo_model_info_t yolo_info;
1458:Src/app.c     **** 
1459:Src/app.c     ****   /* Timing variables. */
1460:Src/app.c     ****   uint32_t nn_period_ms;
1461:Src/app.c     ****   uint32_t nn_period[2];
1462:Src/app.c     ****   uint8_t *nn_pipe_dst;
1463:Src/app.c     **** 
1464:Src/app.c     ****   /* Structs for holding tracking information between frames. */
1465:Src/app.c     ****   pd_pp_point_t box_next_keypoints[AI_PD_MODEL_PP_NB_KEYPOINTS];
1466:Src/app.c     ****   pd_pp_box_t box_next;
1467:Src/app.c     ****   od_pp_out_t boxes_next[YOLO_MAX_NB];
1468:Src/app.c     **** 
1469:Src/app.c     **** 
1470:Src/app.c     ****   int is_tracking = 0;
1471:Src/app.c     ****   roi_t roi_next;
1472:Src/app.c     ****   uint32_t pd_ms;
1473:Src/app.c     ****   uint32_t hl_ms;
1474:Src/app.c     ****   uint32_t yolo_ms;
1475:Src/app.c     ****   uint32_t fl_ms;
1476:Src/app.c     ****   int ret;
1477:Src/app.c     ****   int j;
1478:Src/app.c     ****   int temp = 0;
1479:Src/app.c     **** 
1480:Src/app.c     ****   /* Current tracking algo only support single hand */
1481:Src/app.c     ****   assert(PD_MAX_HAND_NB == 1);
1482:Src/app.c     **** 
1483:Src/app.c     ****   /* setup models buffer info */
1484:Src/app.c     ****   palm_detector_init(&pd_info);
1485:Src/app.c     ****   box_next.pKps = box_next_keypoints;
1486:Src/app.c     ****   hand_landmark_init(&hl_info);
ARM GAS  /tmp/ccbfgvbk.s 			page 39


1487:Src/app.c     ****   app_rot_init(&hl_info);
1488:Src/app.c     ****   yolo_detector_init(&yolo_info);
1489:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
1490:Src/app.c     ****   nn_period[1] = HAL_GetTick();
1491:Src/app.c     **** 
1492:Src/app.c     ****   /* Get an initial free buffer and start the camera's NN pipe. */
1493:Src/app.c     ****   nn_pipe_dst = bqueue_get_free(&nn_input_queue, 0);
1494:Src/app.c     ****   assert(nn_pipe_dst);
1495:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
1496:Src/app.c     ****   while (1)
1497:Src/app.c     ****   {
1498:Src/app.c     ****     uint8_t *capture_buffer;
1499:Src/app.c     ****     int idx_for_resize;
1500:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
1501:Src/app.c     ****     nn_period[0] = nn_period[1];
1502:Src/app.c     ****     nn_period[1] = HAL_GetTick();
1503:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
1504:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
1505:Src/app.c     ****     
1506:Src/app.c     ****     /* Block and wait for a new NN frame to be ready from the camera. */
1507:Src/app.c     ****     capture_buffer = bqueue_get_ready(&nn_input_queue);
1508:Src/app.c     ****     assert(capture_buffer);
1509:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
1510:Src/app.c     **** 
1511:Src/app.c     ****     /* --- Core Tracking Logic --- */
1512:Src/app.c     ****     /* If we are NOT currently tracking an object, run the full-frame detector. */
1513:Src/app.c     ****     if (!is_tracking) {
1514:Src/app.c     ****       is_tracking = palm_detector_run(capture_buffer, &pd_info, &pd_ms);
1515:Src/app.c     ****       box_next.prob = pd_info.pd_out.pOutData[0].prob;
1516:Src/app.c     ****     } else {
1517:Src/app.c     ****       rois[0] = roi_next;
1518:Src/app.c     ****       copy_pd_box(&pd_info.pd_out.pOutData[0], &box_next);
1519:Src/app.c     ****       pd_ms = 0;
1520:Src/app.c     ****     }
1521:Src/app.c     ****     pd_filtered_ms = USE_FILTERED_TS ? (7 * pd_filtered_ms + pd_ms) / 8 : pd_ms;
1522:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
1523:Src/app.c     **** 
1524:Src/app.c     ****     /* then run hand landmark detector if needed */
1525:Src/app.c     ****     if (is_tracking) {
1526:Src/app.c     ****       hl_ms = HAL_GetTick();
1527:Src/app.c     ****       /* Run the landmark model. Note it uses the main display buffer for cropping. */
1528:Src/app.c     ****       is_tracking = hand_landmark_run(lcd_bg_buffer[idx_for_resize], &hl_info, &rois[0], ld_landmar
1529:Src/app.c     ****       /* Invalidate this buffer region as the CPU/GPU may have read from it. */
1530:Src/app.c     ****       CACHE_OP(SCB_InvalidateDCache_by_Addr(lcd_bg_buffer[idx_for_resize], sizeof(lcd_bg_buffer[idx
1531:Src/app.c     **** 
1532:Src/app.c     ****       /* If landmarks were successfully found, predict the ROI for the NEXT frame. */
1533:Src/app.c     ****       if (is_tracking)
1534:Src/app.c     ****         compute_next_roi(&rois[0], ld_landmarks[0], &roi_next, &box_next);
1535:Src/app.c     ****       hl_ms = HAL_GetTick() - hl_ms;
1536:Src/app.c     ****     } else {
1537:Src/app.c     ****       /* If no object is being tracked, skip landmarking. */
1538:Src/app.c     ****       hl_ms = 0;
1539:Src/app.c     ****     }
1540:Src/app.c     ****     ld_filtered_ms = USE_FILTERED_TS ? (7 * ld_filtered_ms + hl_ms) / 8 : hl_ms;
1541:Src/app.c     **** 
1542:Src/app.c     ****     /* update display stats */
1543:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
ARM GAS  /tmp/ccbfgvbk.s 			page 40


1544:Src/app.c     ****     assert(ret == pdTRUE);
1545:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms;
1546:Src/app.c     ****     disp.info.hl_ms = is_tracking ? (int)ld_filtered_ms : 0;
1547:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
1548:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking;
1549:Src/app.c     ****     disp.info.pd_max_prob = pd_info.pd_out.pOutData[0].prob;
1550:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
1551:Src/app.c     ****     copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]);
1552:Src/app.c     ****     disp.info.hands[0].roi = rois[0];
1553:Src/app.c     ****     for (j = 0; j < LD_LANDMARK_NB; j++)
1554:Src/app.c     ****       disp.info.hands[0].ld_landmarks[j] = ld_landmarks[0][j];
1555:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1556:Src/app.c     ****     assert(ret == pdTRUE);
1557:Src/app.c     **** 
1558:Src/app.c     ****     /* It's possible xqueue is empty if display is slow. So don't check error code that may by pdFA
1559:Src/app.c     ****     xSemaphoreGive(disp.update);
1560:Src/app.c     ****   }
1561:Src/app.c     **** }
1562:Src/app.c     **** 
1563:Src/app.c     **** static void nn_thread_fct(void *arg)
1564:Src/app.c     **** {
1565:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
1566:Src/app.c     ****   float nn_period_filtered_ms = 0;
1567:Src/app.c     ****   float pd_filtered_ms = 0;
1568:Src/app.c     ****   float ld_filtered_ms = 0;
1569:Src/app.c     **** 
1570:Src/app.c     ****   /* Model-specific info structures. */
1571:Src/app.c     ****   //hl_model_info_t hl_info; // Disabled
1572:Src/app.c     ****   // pd_model_info_t pd_info; // Disabled
1573:Src/app.c     ****   yolo_model_info_t yolo_info; // Disabled
1574:Src/app.c     ****   fl_model_info_t fl_info;
1575:Src/app.c     ****   /* Timing variables. */
1576:Src/app.c     ****   uint32_t nn_period_ms;
1577:Src/app.c     ****   uint32_t nn_period[2];
1578:Src/app.c     ****   uint8_t *nn_pipe_dst;
1579:Src/app.c     **** 
1580:Src/app.c     ****   /* Structs for holding tracking information between frames. */
1581:Src/app.c     ****   pd_pp_point_t box_next_keypoints[AI_PD_MODEL_PP_NB_KEYPOINTS];
1582:Src/app.c     ****   pd_pp_box_t box_next;
1583:Src/app.c     ****   od_pp_out_t boxes_next[YOLO_MAX_NB]; // Unused for now
1584:Src/app.c     **** 
1585:Src/app.c     **** 
1586:Src/app.c     ****   int is_tracking = 0;
1587:Src/app.c     ****   roi_t roi_next;
1588:Src/app.c     ****   uint32_t pd_ms;
1589:Src/app.c     ****   uint32_t hl_ms;
1590:Src/app.c     ****   uint32_t yolo_ms;
1591:Src/app.c     ****   // uint32_t fl_ms; // Unused for now
1592:Src/app.c     ****   int ret;
1593:Src/app.c     ****   int j;
1594:Src/app.c     ****   // int temp = 0; // Unused for now
1595:Src/app.c     **** 
1596:Src/app.c     ****   /* Current tracking algo only support single hand */
1597:Src/app.c     ****   assert(PD_MAX_HAND_NB == 1);
1598:Src/app.c     **** 
1599:Src/app.c     ****   /* setup models buffer info */
1600:Src/app.c     ****   // palm_detector_init(&pd_info); // Disabled
ARM GAS  /tmp/ccbfgvbk.s 			page 41


1601:Src/app.c     ****   box_next.pKps = box_next_keypoints;
1602:Src/app.c     ****   // hand_landmark_init(&hl_info); // Disabled
1603:Src/app.c     ****   //app_rot_init(&hl_info);       // Disabled
1604:Src/app.c     ****   yolo_detector_init(&yolo_info); // Disabled
1605:Src/app.c     ****   face_landmark_init(&fl_info);
1606:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
1607:Src/app.c     ****   nn_period[1] = HAL_GetTick();
1608:Src/app.c     **** 
1609:Src/app.c     ****   /* Get an initial free buffer and start the camera's NN pipe. */
1610:Src/app.c     ****   nn_pipe_dst = bqueue_get_free(&nn_input_queue, 0);
1611:Src/app.c     ****   assert(nn_pipe_dst);
1612:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
1613:Src/app.c     ****   while (1)
1614:Src/app.c     ****   {
1615:Src/app.c     ****     uint8_t *capture_buffer;
1616:Src/app.c     ****     int idx_for_resize;
1617:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
1618:Src/app.c     ****     nn_period[0] = nn_period[1];
1619:Src/app.c     ****     nn_period[1] = HAL_GetTick();
1620:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
1621:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
1622:Src/app.c     ****     
1623:Src/app.c     ****     /* Block and wait for a new NN frame to be ready from the camera. */
1624:Src/app.c     ****     capture_buffer = bqueue_get_ready(&nn_input_queue);
1625:Src/app.c     ****     assert(capture_buffer);
1626:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
1627:Src/app.c     **** 
1628:Src/app.c     ****     /* --- Core Tracking Logic --- */
1629:Src/app.c     ****     /* If we are NOT currently tracking an object, run the full-frame detector. */
1630:Src/app.c     ****     if (!is_tracking) {
1631:Src/app.c     ****       /* --- ALL MODEL CALLS ARE REMOVED FOR THIS TEST --- */
1632:Src/app.c     ****       int nb_faces = yolo_detector_run(capture_buffer, &yolo_info, &yolo_ms);
1633:Src/app.c     ****       LL_ATON_RT_Main(&NN_Instance_face_landmark);
1634:Src/app.c     ****       /* --- Force tracking to be ON and create a dummy box --- */
1635:Src/app.c     ****       is_tracking = 0;
1636:Src/app.c     ****       pd_ms = 0; // Set dummy timing
1637:Src/app.c     ****     } else {
1638:Src/app.c     ****       rois[0] = roi_next;
1639:Src/app.c     ****       // copy_pd_box(&pd_info.pd_out.pOutData[0], &box_next); // Disabled
1640:Src/app.c     ****       pd_ms = 0;
1641:Src/app.c     ****     }
1642:Src/app.c     ****     pd_filtered_ms = USE_FILTERED_TS ? (7 * pd_filtered_ms + pd_ms) / 8 : pd_ms;
1643:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
1644:Src/app.c     **** 
1645:Src/app.c     ****     /* then run hand landmark detector if needed */
1646:Src/app.c     ****     if (is_tracking) {
1647:Src/app.c     ****       /* --- Hand landmarking is disabled for this test --- */
1648:Src/app.c     ****       hl_ms = 0; // Set to 0 since it's disabled
1649:Src/app.c     ****     } else {
1650:Src/app.c     ****       /* If no object is being tracked, skip landmarking. */
1651:Src/app.c     ****       hl_ms = 0;
1652:Src/app.c     ****     }
1653:Src/app.c     ****     ld_filtered_ms = USE_FILTERED_TS ? (7 * ld_filtered_ms + hl_ms) / 8 : hl_ms;
1654:Src/app.c     **** 
1655:Src/app.c     ****     /* update display stats */
1656:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
1657:Src/app.c     ****     assert(ret == pdTRUE);
ARM GAS  /tmp/ccbfgvbk.s 			page 42


1658:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
1659:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
1660:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
1661:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
1662:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
1663:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
1664:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
1665:Src/app.c     ****     if (is_tracking)
1666:Src/app.c     ****     {
1667:Src/app.c     ****       disp.info.hands[0].roi = rois[0]; /* Show the dummy ROI */
1668:Src/app.c     ****     }
1669:Src/app.c     ****     /* Landmark drawing is disabled */
1670:Src/app.c     ****     // for (j = 0; j < LD_LANDMARK_NB; j++)
1671:Src/app.c     ****     //   disp.info.hands[0].ld_landmarks[j] = ld_landmarks[0][j];
1672:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1673:Src/app.c     ****     assert(ret == pdTRUE);
1674:Src/app.c     **** 
1675:Src/app.c     ****     /* It's possible xqueue is empty if display is slow. So don't check error code that may by pdFA
1676:Src/app.c     ****     xSemaphoreGive(disp.update);
1677:Src/app.c     ****   }
1678:Src/app.c     **** }
1679:Src/app.c     **** 
1680:Src/app.c     **** /**
1681:Src/app.c     ****  * @brief Sets the memory address for the foreground layer for the next draw operation.
1682:Src/app.c     ****  * @details Part of a double-buffering scheme for the UI overlay. This function prepares
1683:Src/app.c     ****  * the off-screen buffer for drawing.
1684:Src/app.c     ****  */
1685:Src/app.c     **** static void dp_update_drawing_area()
1686:Src/app.c     **** {
1687:Src/app.c     ****   int ret;
1688:Src/app.c     **** 
1689:Src/app.c     ****   __disable_irq();
1690:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_fg_buffer[lcd_fg_buffer_rd_idx], SCRL_LAYER_1);
1691:Src/app.c     ****   assert(ret == HAL_OK);
1692:Src/app.c     ****   __enable_irq();
1693:Src/app.c     **** }
1694:Src/app.c     **** 
1695:Src/app.c     **** /**
1696:Src/app.c     ****  * @brief Commits the newly drawn foreground buffer to the display.
1697:Src/app.c     ****  * @details This "flips" the foreground buffers, making the newly drawn UI visible.
1698:Src/app.c     ****  */
1699:Src/app.c     **** static void dp_commit_drawing_area()
1700:Src/app.c     **** {
1701:Src/app.c     ****   int ret;
1702:Src/app.c     **** 
1703:Src/app.c     ****   __disable_irq();
1704:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_1);
1705:Src/app.c     ****   assert(ret == HAL_OK);
1706:Src/app.c     ****   __enable_irq();
1707:Src/app.c     ****   lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
1708:Src/app.c     **** }
1709:Src/app.c     **** 
1710:Src/app.c     **** /**
1711:Src/app.c     ****  * @brief Callback function to toggle the landmark display.
1712:Src/app.c     ****  */
1713:Src/app.c     **** static void on_ld_toggle_button_click(void *args)
1714:Src/app.c     **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 43


1715:Src/app.c     ****   display_t *disp = (display_t *) args;
1716:Src/app.c     ****   int ret;
1717:Src/app.c     **** 
1718:Src/app.c     ****   ret = xSemaphoreTake(disp->lock, portMAX_DELAY);
1719:Src/app.c     ****   assert(ret == pdTRUE);
1720:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
1721:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
1722:Src/app.c     ****   assert(ret == pdTRUE);
1723:Src/app.c     **** }
1724:Src/app.c     **** 
1725:Src/app.c     **** /**
1726:Src/app.c     ****  * @brief Callback function to toggle the bounding box display.
1727:Src/app.c     ****  */
1728:Src/app.c     **** static void on_pd_toggle_button_click(void *args)
1729:Src/app.c     **** {
1730:Src/app.c     ****   display_t *disp = (display_t *) args;
1731:Src/app.c     ****   int ret;
1732:Src/app.c     **** 
1733:Src/app.c     ****   ret = xSemaphoreTake(disp->lock, portMAX_DELAY);
1734:Src/app.c     ****   assert(ret == pdTRUE);
1735:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
1736:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
1737:Src/app.c     ****   assert(ret == pdTRUE);
1738:Src/app.c     **** }
1739:Src/app.c     **** 
1740:Src/app.c     **** /**
1741:Src/app.c     ****  * @brief The main function for the Display Processor (DP) thread.
1742:Src/app.c     ****  * @details This task waits for a signal from the NN thread, then wakes up to
1743:Src/app.c     ****  * draw the entire UI overlay for one frame.
1744:Src/app.c     ****  */
1745:Src/app.c     **** static void dp_thread_fct(void *arg)
1746:Src/app.c     **** {
1747:Src/app.c     ****   button_t ld_toggle_button;
1748:Src/app.c     ****   button_t hd_toggle_button;
1749:Src/app.c     ****   uint32_t disp_ms = 0;
1750:Src/app.c     ****   display_info_t info;
1751:Src/app.c     ****   uint32_t ts;
1752:Src/app.c     ****   int ret;
1753:Src/app.c     **** 
1754:Src/app.c     **** #ifdef STM32N6570_DK_REV
1755:Src/app.c     ****   button_init(&ld_toggle_button, BUTTON_USER1, on_ld_toggle_button_click, &disp);
1756:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_TAMP, on_pd_toggle_button_click, &disp);
1757:Src/app.c     **** #else
1758:Src/app.c     ****   button_init(&ld_toggle_button, BUTTON_USER, on_ld_toggle_button_click, &disp);
1759:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_USER, on_pd_toggle_button_click, &disp);
1760:Src/app.c     **** #endif
1761:Src/app.c     ****   while (1)
1762:Src/app.c     ****   {
1763:Src/app.c     ****     ret = xSemaphoreTake(disp.update, portMAX_DELAY);
1764:Src/app.c     ****     assert(ret == pdTRUE);
1765:Src/app.c     **** 
1766:Src/app.c     ****     button_process(&ld_toggle_button);
1767:Src/app.c     ****     button_process(&hd_toggle_button);
1768:Src/app.c     **** 
1769:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
1770:Src/app.c     ****     assert(ret == pdTRUE);
1771:Src/app.c     ****     info = disp.info;
ARM GAS  /tmp/ccbfgvbk.s 			page 44


1772:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1773:Src/app.c     ****     assert(ret == pdTRUE);
1774:Src/app.c     ****     info.disp_ms = disp_ms;
1775:Src/app.c     **** 
1776:Src/app.c     ****     ts = HAL_GetTick();
1777:Src/app.c     ****     dp_update_drawing_area();
1778:Src/app.c     ****     Display_NetworkOutput(&info);
1779:Src/app.c     ****     SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_WIDTH * LCD_FG_HEIGHT* 2);
1780:Src/app.c     ****     dp_commit_drawing_area();
1781:Src/app.c     ****     disp_ms = HAL_GetTick() - ts;
1782:Src/app.c     ****   }
1783:Src/app.c     **** }
1784:Src/app.c     **** 
1785:Src/app.c     **** /**
1786:Src/app.c     ****  * @brief The main function for the Image Signal Processor (ISP) thread.
1787:Src/app.c     ****  * @details This task waits for the VSYNC signal and then runs the camera's
1788:Src/app.c     ****  * periodic processing functions (e.g., auto-exposure, auto-white-balance).
1789:Src/app.c     ****  */
1790:Src/app.c     **** static void isp_thread_fct(void *arg)
1791:Src/app.c     **** {
 175              		.loc 1 1791 1 is_stmt 1 view -0
 176              		.cfi_startproc
 177              		@ args = 0, pretend = 0, frame = 0
 178              		@ frame_needed = 0, uses_anonymous_args = 0
 179              		.loc 1 1791 1 is_stmt 0 view .LVU44
 180 0000 10B5     		push	{r4, lr}
 181              		.cfi_def_cfa_offset 8
 182              		.cfi_offset 4, -8
 183              		.cfi_offset 14, -4
1792:Src/app.c     ****   int ret;
1793:Src/app.c     **** 
1794:Src/app.c     ****   while (1) {
1795:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 184              		.loc 1 1795 11 view .LVU45
 185 0002 094C     		ldr	r4, .L16
 186              	.LVL9:
 187              	.L15:
1792:Src/app.c     ****   int ret;
 188              		.loc 1 1792 3 is_stmt 1 view .LVU46
1794:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 189              		.loc 1 1794 3 view .LVU47
 190              		.loc 1 1795 5 view .LVU48
 191              		.loc 1 1795 11 is_stmt 0 view .LVU49
 192 0004 4FF0FF31 		mov	r1, #-1
 193 0008 2068     		ldr	r0, [r4]
 194 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 195              	.LVL10:
1796:Src/app.c     ****     assert(ret == pdTRUE);
 196              		.loc 1 1796 5 is_stmt 1 view .LVU50
 197 000e 0128     		cmp	r0, #1
 198 0010 06D0     		beq	.L14
 199              		.loc 1 1796 5 is_stmt 0 discriminator 1 view .LVU51
 200 0012 40F20471 		movw	r1, #1796
 201 0016 054B     		ldr	r3, .L16+4
 202 0018 054A     		ldr	r2, .L16+8
 203 001a 0648     		ldr	r0, .L16+12
 204              	.LVL11:
ARM GAS  /tmp/ccbfgvbk.s 			page 45


 205              		.loc 1 1796 5 discriminator 1 view .LVU52
 206 001c FFF7FEFF 		bl	__assert_func
 207              	.LVL12:
 208              	.L14:
1797:Src/app.c     **** 
1798:Src/app.c     ****     CAM_IspUpdate();
 209              		.loc 1 1798 5 is_stmt 1 view .LVU53
 210 0020 FFF7FEFF 		bl	CAM_IspUpdate
 211              	.LVL13:
1794:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 212              		.loc 1 1794 9 view .LVU54
1795:Src/app.c     ****     assert(ret == pdTRUE);
 213              		.loc 1 1795 9 is_stmt 0 view .LVU55
 214 0024 EEE7     		b	.L15
 215              	.L17:
 216 0026 00BF     		.align	2
 217              	.L16:
 218 0028 00000000 		.word	isp_sem
 219 002c 00000000 		.word	.LC1
 220 0030 00000000 		.word	__func__.16
 221 0034 0E000000 		.word	.LC2
 222              		.cfi_endproc
 223              	.LFE7411:
 225              		.section	.text.on_pd_toggle_button_click,"ax",%progbits
 226              		.align	1
 227              		.syntax unified
 228              		.thumb
 229              		.thumb_func
 231              	on_pd_toggle_button_click:
 232              	.LVL14:
 233              	.LFB7409:
1729:Src/app.c     ****   display_t *disp = (display_t *) args;
 234              		.loc 1 1729 1 is_stmt 1 view -0
 235              		.cfi_startproc
 236              		@ args = 0, pretend = 0, frame = 0
 237              		@ frame_needed = 0, uses_anonymous_args = 0
1730:Src/app.c     ****   int ret;
 238              		.loc 1 1730 3 view .LVU57
1731:Src/app.c     **** 
 239              		.loc 1 1731 3 view .LVU58
1733:Src/app.c     ****   assert(ret == pdTRUE);
 240              		.loc 1 1733 3 view .LVU59
1729:Src/app.c     ****   display_t *disp = (display_t *) args;
 241              		.loc 1 1729 1 is_stmt 0 view .LVU60
 242 0000 10B5     		push	{r4, lr}
 243              		.cfi_def_cfa_offset 8
 244              		.cfi_offset 4, -8
 245              		.cfi_offset 14, -4
1733:Src/app.c     ****   assert(ret == pdTRUE);
 246              		.loc 1 1733 9 view .LVU61
 247 0002 4FF0FF31 		mov	r1, #-1
1729:Src/app.c     ****   display_t *disp = (display_t *) args;
 248              		.loc 1 1729 1 view .LVU62
 249 0006 0446     		mov	r4, r0
1733:Src/app.c     ****   assert(ret == pdTRUE);
 250              		.loc 1 1733 9 view .LVU63
 251 0008 406D     		ldr	r0, [r0, #84]
ARM GAS  /tmp/ccbfgvbk.s 			page 46


 252              	.LVL15:
1733:Src/app.c     ****   assert(ret == pdTRUE);
 253              		.loc 1 1733 9 view .LVU64
 254 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 255              	.LVL16:
1734:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
 256              		.loc 1 1734 3 is_stmt 1 view .LVU65
 257 000e 0128     		cmp	r0, #1
 258 0010 06D0     		beq	.L19
1734:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
 259              		.loc 1 1734 3 is_stmt 0 discriminator 1 view .LVU66
 260 0012 40F2C661 		movw	r1, #1734
 261 0016 0D4B     		ldr	r3, .L22
 262 0018 0D4A     		ldr	r2, .L22+4
 263              	.L21:
1737:Src/app.c     **** }
 264              		.loc 1 1737 3 discriminator 1 view .LVU67
 265 001a 0E48     		ldr	r0, .L22+8
 266              	.LVL17:
1737:Src/app.c     **** }
 267              		.loc 1 1737 3 discriminator 1 view .LVU68
 268 001c FFF7FEFF 		bl	__assert_func
 269              	.LVL18:
 270              	.L19:
1735:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 271              		.loc 1 1735 3 is_stmt 1 view .LVU69
1735:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 272              		.loc 1 1735 32 is_stmt 0 view .LVU70
 273 0020 D4F8C430 		ldr	r3, [r4, #196]
1736:Src/app.c     ****   assert(ret == pdTRUE);
 274              		.loc 1 1736 9 view .LVU71
 275 0024 606D     		ldr	r0, [r4, #84]
 276              	.LVL19:
1735:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 277              		.loc 1 1735 32 view .LVU72
 278 0026 B3FA83F3 		clz	r3, r3
 279 002a 5B09     		lsrs	r3, r3, #5
1735:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 280              		.loc 1 1735 30 view .LVU73
 281 002c C4F8C430 		str	r3, [r4, #196]
1736:Src/app.c     ****   assert(ret == pdTRUE);
 282              		.loc 1 1736 3 is_stmt 1 view .LVU74
1736:Src/app.c     ****   assert(ret == pdTRUE);
 283              		.loc 1 1736 9 is_stmt 0 view .LVU75
 284 0030 0023     		movs	r3, #0
 285 0032 1A46     		mov	r2, r3
 286 0034 1946     		mov	r1, r3
 287 0036 FFF7FEFF 		bl	xQueueGenericSend
 288              	.LVL20:
1737:Src/app.c     **** }
 289              		.loc 1 1737 3 is_stmt 1 view .LVU76
 290 003a 0128     		cmp	r0, #1
 291 003c 04D0     		beq	.L18
1737:Src/app.c     **** }
 292              		.loc 1 1737 3 is_stmt 0 discriminator 1 view .LVU77
 293 003e 40F2C961 		movw	r1, #1737
 294 0042 024B     		ldr	r3, .L22
ARM GAS  /tmp/ccbfgvbk.s 			page 47


 295 0044 024A     		ldr	r2, .L22+4
 296 0046 E8E7     		b	.L21
 297              	.L18:
1738:Src/app.c     **** 
 298              		.loc 1 1738 1 view .LVU78
 299 0048 10BD     		pop	{r4, pc}
 300              	.LVL21:
 301              	.L23:
1738:Src/app.c     **** 
 302              		.loc 1 1738 1 view .LVU79
 303 004a 00BF     		.align	2
 304              	.L22:
 305 004c 00000000 		.word	.LC1
 306 0050 00000000 		.word	__func__.14
 307 0054 0E000000 		.word	.LC2
 308              		.cfi_endproc
 309              	.LFE7409:
 311              		.section	.text.on_ld_toggle_button_click,"ax",%progbits
 312              		.align	1
 313              		.syntax unified
 314              		.thumb
 315              		.thumb_func
 317              	on_ld_toggle_button_click:
 318              	.LVL22:
 319              	.LFB7408:
1714:Src/app.c     ****   display_t *disp = (display_t *) args;
 320              		.loc 1 1714 1 is_stmt 1 view -0
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 0
 323              		@ frame_needed = 0, uses_anonymous_args = 0
1715:Src/app.c     ****   int ret;
 324              		.loc 1 1715 3 view .LVU81
1716:Src/app.c     **** 
 325              		.loc 1 1716 3 view .LVU82
1718:Src/app.c     ****   assert(ret == pdTRUE);
 326              		.loc 1 1718 3 view .LVU83
1714:Src/app.c     ****   display_t *disp = (display_t *) args;
 327              		.loc 1 1714 1 is_stmt 0 view .LVU84
 328 0000 10B5     		push	{r4, lr}
 329              		.cfi_def_cfa_offset 8
 330              		.cfi_offset 4, -8
 331              		.cfi_offset 14, -4
1718:Src/app.c     ****   assert(ret == pdTRUE);
 332              		.loc 1 1718 9 view .LVU85
 333 0002 4FF0FF31 		mov	r1, #-1
1714:Src/app.c     ****   display_t *disp = (display_t *) args;
 334              		.loc 1 1714 1 view .LVU86
 335 0006 0446     		mov	r4, r0
1718:Src/app.c     ****   assert(ret == pdTRUE);
 336              		.loc 1 1718 9 view .LVU87
 337 0008 406D     		ldr	r0, [r0, #84]
 338              	.LVL23:
1718:Src/app.c     ****   assert(ret == pdTRUE);
 339              		.loc 1 1718 9 view .LVU88
 340 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 341              	.LVL24:
1719:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
ARM GAS  /tmp/ccbfgvbk.s 			page 48


 342              		.loc 1 1719 3 is_stmt 1 view .LVU89
 343 000e 0128     		cmp	r0, #1
 344 0010 06D0     		beq	.L25
1719:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
 345              		.loc 1 1719 3 is_stmt 0 discriminator 1 view .LVU90
 346 0012 40F2B761 		movw	r1, #1719
 347 0016 0D4B     		ldr	r3, .L28
 348 0018 0D4A     		ldr	r2, .L28+4
 349              	.L27:
1722:Src/app.c     **** }
 350              		.loc 1 1722 3 discriminator 1 view .LVU91
 351 001a 0E48     		ldr	r0, .L28+8
 352              	.LVL25:
1722:Src/app.c     **** }
 353              		.loc 1 1722 3 discriminator 1 view .LVU92
 354 001c FFF7FEFF 		bl	__assert_func
 355              	.LVL26:
 356              	.L25:
1720:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 357              		.loc 1 1720 3 is_stmt 1 view .LVU93
1720:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 358              		.loc 1 1720 32 is_stmt 0 view .LVU94
 359 0020 D4F8C030 		ldr	r3, [r4, #192]
1721:Src/app.c     ****   assert(ret == pdTRUE);
 360              		.loc 1 1721 9 view .LVU95
 361 0024 606D     		ldr	r0, [r4, #84]
 362              	.LVL27:
1720:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 363              		.loc 1 1720 32 view .LVU96
 364 0026 B3FA83F3 		clz	r3, r3
 365 002a 5B09     		lsrs	r3, r3, #5
1720:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 366              		.loc 1 1720 30 view .LVU97
 367 002c C4F8C030 		str	r3, [r4, #192]
1721:Src/app.c     ****   assert(ret == pdTRUE);
 368              		.loc 1 1721 3 is_stmt 1 view .LVU98
1721:Src/app.c     ****   assert(ret == pdTRUE);
 369              		.loc 1 1721 9 is_stmt 0 view .LVU99
 370 0030 0023     		movs	r3, #0
 371 0032 1A46     		mov	r2, r3
 372 0034 1946     		mov	r1, r3
 373 0036 FFF7FEFF 		bl	xQueueGenericSend
 374              	.LVL28:
1722:Src/app.c     **** }
 375              		.loc 1 1722 3 is_stmt 1 view .LVU100
 376 003a 0128     		cmp	r0, #1
 377 003c 04D0     		beq	.L24
1722:Src/app.c     **** }
 378              		.loc 1 1722 3 is_stmt 0 discriminator 1 view .LVU101
 379 003e 40F2BA61 		movw	r1, #1722
 380 0042 024B     		ldr	r3, .L28
 381 0044 024A     		ldr	r2, .L28+4
 382 0046 E8E7     		b	.L27
 383              	.L24:
1723:Src/app.c     **** 
 384              		.loc 1 1723 1 view .LVU102
 385 0048 10BD     		pop	{r4, pc}
ARM GAS  /tmp/ccbfgvbk.s 			page 49


 386              	.LVL29:
 387              	.L29:
1723:Src/app.c     **** 
 388              		.loc 1 1723 1 view .LVU103
 389 004a 00BF     		.align	2
 390              	.L28:
 391 004c 00000000 		.word	.LC1
 392 0050 00000000 		.word	__func__.13
 393 0054 0E000000 		.word	.LC2
 394              		.cfi_endproc
 395              	.LFE7408:
 397              		.section	.text.button_process,"ax",%progbits
 398              		.align	1
 399              		.syntax unified
 400              		.thumb
 401              		.thumb_func
 403              	button_process:
 404              	.LVL30:
 405              	.LFB7367:
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 406              		.loc 1 506 1 is_stmt 1 view -0
 407              		.cfi_startproc
 408              		@ args = 0, pretend = 0, frame = 0
 409              		@ frame_needed = 0, uses_anonymous_args = 0
 507:Src/app.c     **** 
 410              		.loc 1 507 3 view .LVU105
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 411              		.loc 1 506 1 is_stmt 0 view .LVU106
 412 0000 38B5     		push	{r3, r4, r5, lr}
 413              		.cfi_def_cfa_offset 16
 414              		.cfi_offset 3, -16
 415              		.cfi_offset 4, -12
 416              		.cfi_offset 5, -8
 417              		.cfi_offset 14, -4
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 418              		.loc 1 506 1 view .LVU107
 419 0002 0446     		mov	r4, r0
 507:Src/app.c     **** 
 420              		.loc 1 507 15 view .LVU108
 421 0004 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 422              	.LVL31:
 507:Src/app.c     **** 
 423              		.loc 1 507 15 view .LVU109
 424 0006 FFF7FEFF 		bl	BSP_PB_GetState
 425              	.LVL32:
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 426              		.loc 1 509 6 view .LVU110
 427 000a 6368     		ldr	r3, [r4, #4]
 507:Src/app.c     **** 
 428              		.loc 1 507 15 view .LVU111
 429 000c 0546     		mov	r5, r0
 430              	.LVL33:
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 431              		.loc 1 509 3 is_stmt 1 view .LVU112
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 432              		.loc 1 509 6 is_stmt 0 view .LVU113
 433 000e 8342     		cmp	r3, r0
ARM GAS  /tmp/ccbfgvbk.s 			page 50


 434 0010 04D0     		beq	.L31
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 435              		.loc 1 509 30 discriminator 1 view .LVU114
 436 0012 18B1     		cbz	r0, .L31
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 437              		.loc 1 509 43 discriminator 2 view .LVU115
 438 0014 A368     		ldr	r3, [r4, #8]
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 439              		.loc 1 509 39 discriminator 2 view .LVU116
 440 0016 0BB1     		cbz	r3, .L31
 510:Src/app.c     **** 
 441              		.loc 1 510 5 is_stmt 1 view .LVU117
 442 0018 E068     		ldr	r0, [r4, #12]
 443              	.LVL34:
 510:Src/app.c     **** 
 444              		.loc 1 510 5 is_stmt 0 view .LVU118
 445 001a 9847     		blx	r3
 446              	.LVL35:
 447              	.L31:
 512:Src/app.c     **** }
 448              		.loc 1 512 3 is_stmt 1 view .LVU119
 512:Src/app.c     **** }
 449              		.loc 1 512 17 is_stmt 0 view .LVU120
 450 001c 6560     		str	r5, [r4, #4]
 513:Src/app.c     **** 
 451              		.loc 1 513 1 view .LVU121
 452 001e 38BD     		pop	{r3, r4, r5, pc}
 513:Src/app.c     **** 
 453              		.loc 1 513 1 view .LVU122
 454              		.cfi_endproc
 455              	.LFE7367:
 457              		.section	.rodata.button_init.part.0.str1.1,"aMS",%progbits,1
 458              	.LC3:
 459 0000 72657420 		.ascii	"ret == BSP_ERROR_NONE\000"
 459      3D3D2042 
 459      53505F45 
 459      52524F52 
 459      5F4E4F4E 
 460              		.section	.text.button_init.part.0,"ax",%progbits
 461              		.align	1
 462              		.syntax unified
 463              		.thumb
 464              		.thumb_func
 466              	button_init.part.0:
 467              	.LFB7416:
 488:Src/app.c     **** {
 468              		.loc 1 488 13 is_stmt 1 view -0
 469              		.cfi_startproc
 470              		@ Volatile: function does not return.
 471              		@ args = 0, pretend = 0, frame = 0
 472              		@ frame_needed = 0, uses_anonymous_args = 0
 473              	.LVL36:
 488:Src/app.c     **** {
 474              		.loc 1 488 13 is_stmt 0 view .LVU124
 475 0000 08B5     		push	{r3, lr}
 476              		.cfi_def_cfa_offset 8
 477              		.cfi_offset 3, -8
ARM GAS  /tmp/ccbfgvbk.s 			page 51


 478              		.cfi_offset 14, -4
 493:Src/app.c     **** 
 479              		.loc 1 493 3 discriminator 1 view .LVU125
 480 0002 40F2ED11 		movw	r1, #493
 481 0006 024B     		ldr	r3, .L39
 482 0008 024A     		ldr	r2, .L39+4
 483 000a 0348     		ldr	r0, .L39+8
 484 000c FFF7FEFF 		bl	__assert_func
 485              	.LVL37:
 486              	.L40:
 487              		.align	2
 488              	.L39:
 489 0010 00000000 		.word	.LC3
 490 0014 00000000 		.word	__func__.12
 491 0018 0E000000 		.word	.LC2
 492              		.cfi_endproc
 493              	.LFE7416:
 495              		.section	.text.display_ld_hand,"ax",%progbits
 496              		.align	1
 497              		.syntax unified
 498              		.thumb
 499              		.thumb_func
 501              	display_ld_hand:
 502              	.LVL38:
 503              	.LFB7388:
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 504              		.loc 1 926 1 is_stmt 1 view -0
 505              		.cfi_startproc
 506              		@ args = 0, pretend = 0, frame = 256
 507              		@ frame_needed = 0, uses_anonymous_args = 0
 927:Src/app.c     ****   roi_t *roi = &hand->roi;
 508              		.loc 1 927 3 view .LVU127
 928:Src/app.c     ****   int x[LD_LANDMARK_NB];
 509              		.loc 1 928 3 view .LVU128
 929:Src/app.c     ****   int y[LD_LANDMARK_NB];
 510              		.loc 1 929 3 view .LVU129
 930:Src/app.c     ****   int is_clamped[LD_LANDMARK_NB];
 511              		.loc 1 930 3 view .LVU130
 931:Src/app.c     ****   ld_point_t decoded;
 512              		.loc 1 931 3 view .LVU131
 932:Src/app.c     ****   int i;
 513              		.loc 1 932 3 view .LVU132
 933:Src/app.c     **** 
 514              		.loc 1 933 3 view .LVU133
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 515              		.loc 1 935 3 view .LVU134
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 516              		.loc 1 935 17 discriminator 1 view .LVU135
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 517              		.loc 1 926 1 is_stmt 0 view .LVU136
 518 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 519              		.cfi_def_cfa_offset 36
 520              		.cfi_offset 4, -36
 521              		.cfi_offset 5, -32
 522              		.cfi_offset 6, -28
 523              		.cfi_offset 7, -24
 524              		.cfi_offset 8, -20
ARM GAS  /tmp/ccbfgvbk.s 			page 52


 525              		.cfi_offset 9, -16
 526              		.cfi_offset 10, -12
 527              		.cfi_offset 11, -8
 528              		.cfi_offset 14, -4
 529 0004 2DED0A8B 		vpush.64	{d8, d9, d10, d11, d12}
 530              		.cfi_def_cfa_offset 76
 531              		.cfi_offset 80, -76
 532              		.cfi_offset 81, -72
 533              		.cfi_offset 82, -68
 534              		.cfi_offset 83, -64
 535              		.cfi_offset 84, -60
 536              		.cfi_offset 85, -56
 537              		.cfi_offset 86, -52
 538              		.cfi_offset 87, -48
 539              		.cfi_offset 88, -44
 540              		.cfi_offset 89, -40
 541              	.LBB127:
 542              	.LBB128:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 543              		.loc 1 918 46 view .LVU137
 544 0008 90ED0BCA 		vldr.32	s24, [r0, #44]
 545 000c B7EECCCA 		vcvt.f64.f32	d12, s24
 546              	.LBE128:
 547              	.LBE127:
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 548              		.loc 1 926 1 view .LVU138
 549 0010 C3B0     		sub	sp, sp, #268
 550              		.cfi_def_cfa_offset 344
 551              	.LBB133:
 552              	.LBB129:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 553              		.loc 1 918 46 view .LVU139
 554 0012 B0EE4C0B 		vmov.f64	d0, d12
 555              	.LBE129:
 556              	.LBE133:
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 557              		.loc 1 926 1 view .LVU140
 558 0016 0446     		mov	r4, r0
 559              	.LBB134:
 560              	.LBB130:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 561              		.loc 1 918 19 view .LVU141
 562 0018 90ED07AA 		vldr.32	s20, [r0, #28]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 563              		.loc 1 918 40 view .LVU142
 564 001c 90ED09BA 		vldr.32	s22, [r0, #36]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 565              		.loc 1 918 46 view .LVU143
 566 0020 FFF7FEFF 		bl	cos
 567              	.LVL39:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 568              		.loc 1 918 46 view .LVU144
 569 0024 B0EE408B 		vmov.f64	d8, d0
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 570              		.loc 1 918 82 discriminator 1 view .LVU145
 571 0028 B0EE4C0B 		vmov.f64	d0, d12
 572 002c FFF7FEFF 		bl	sin
ARM GAS  /tmp/ccbfgvbk.s 			page 53


 573              	.LVL40:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 574              		.loc 1 918 76 discriminator 1 view .LVU146
 575 0030 94ED0A9A 		vldr.32	s18, [r4, #40]
 919:Src/app.c     **** }
 576              		.loc 1 919 19 view .LVU147
 577 0034 94ED086A 		vldr.32	s12, [r4, #32]
 578 0038 2DAD     		add	r5, sp, #180
 579 003a 18A8     		add	r0, sp, #96
 580 003c 0DF10C0C 		add	ip, sp, #12
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 581              		.loc 1 918 19 view .LVU148
 582 0040 B7EECAAA 		vcvt.f64.f32	d10, s20
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 583              		.loc 1 918 40 view .LVU149
 584 0044 B7EECBBA 		vcvt.f64.f32	d11, s22
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 585              		.loc 1 918 76 discriminator 1 view .LVU150
 586 0048 B7EEC99A 		vcvt.f64.f32	d9, s18
 919:Src/app.c     **** }
 587              		.loc 1 919 19 view .LVU151
 588 004c B7EEC66A 		vcvt.f64.f32	d6, s12
 589 0050 AE46     		mov	lr, r5
 590 0052 0646     		mov	r6, r0
 591 0054 6746     		mov	r7, ip
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 592              		.loc 1 918 33 view .LVU152
 593 0056 B6EE005B 		vmov.f64	d5, #5.0e-1
 594              	.LBE130:
 595              	.LBE134:
 596              	.LBB135:
 597              	.LBB136:
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 598              		.loc 1 780 6 view .LVU153
 599 005a 40F21D39 		movw	r9, #797
 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 600              		.loc 1 782 6 view .LVU154
 601 005e 40F2DD18 		movw	r8, #477
 785:Src/app.c     **** }
 602              		.loc 1 785 21 discriminator 3 view .LVU155
 603 0062 1521     		movs	r1, #21
 604              	.LVL41:
 605              	.L43:
 785:Src/app.c     **** }
 606              		.loc 1 785 21 discriminator 3 view .LVU156
 607              	.LBE136:
 608              	.LBE135:
 936:Src/app.c     ****     x[i] = (int)decoded.x;
 609              		.loc 1 936 5 is_stmt 1 view .LVU157
 610              	.LBB141:
 611              	.LBI127:
 912:Src/app.c     **** {
 612              		.loc 1 912 13 view .LVU158
 613              	.LBB131:
 914:Src/app.c     ****   float w = roi->w;
 614              		.loc 1 914 3 view .LVU159
 915:Src/app.c     ****   float h = roi->h;
ARM GAS  /tmp/ccbfgvbk.s 			page 54


 615              		.loc 1 915 3 view .LVU160
 916:Src/app.c     **** 
 616              		.loc 1 916 3 view .LVU161
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 617              		.loc 1 918 3 view .LVU162
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 618              		.loc 1 918 29 is_stmt 0 view .LVU163
 619 0064 94ED0C3A 		vldr.32	s6, [r4, #48]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 620              		.loc 1 918 65 discriminator 1 view .LVU164
 621 0068 94ED0D4A 		vldr.32	s8, [r4, #52]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 622              		.loc 1 918 29 view .LVU165
 623 006c B7EEC33A 		vcvt.f64.f32	d3, s6
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 624              		.loc 1 918 65 discriminator 1 view .LVU166
 625 0070 B7EEC44A 		vcvt.f64.f32	d4, s8
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 626              		.loc 1 918 33 view .LVU167
 627 0074 33EE453B 		vsub.f64	d3, d3, d5
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 628              		.loc 1 918 24 discriminator 1 view .LVU168
 629 0078 B0EE4A7B 		vmov.f64	d7, d10
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 630              		.loc 1 918 40 view .LVU169
 631 007c 23EE0B3B 		vmul.f64	d3, d3, d11
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 632              		.loc 1 918 69 discriminator 1 view .LVU170
 633 0080 34EE454B 		vsub.f64	d4, d4, d5
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 634              		.loc 1 918 24 discriminator 1 view .LVU171
 635 0084 A3EE087B 		vfma.f64	d7, d3, d8
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 636              		.loc 1 918 76 discriminator 1 view .LVU172
 637 0088 24EE094B 		vmul.f64	d4, d4, d9
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 638              		.loc 1 918 60 discriminator 2 view .LVU173
 639 008c A4EE407B 		vfms.f64	d7, d4, d0
 640 0090 F7EEC72B 		vcvt.f32.f64	s5, d7
 919:Src/app.c     **** }
 641              		.loc 1 919 3 is_stmt 1 view .LVU174
 919:Src/app.c     **** }
 642              		.loc 1 919 24 is_stmt 0 discriminator 1 view .LVU175
 643 0094 B0EE467B 		vmov.f64	d7, d6
 644 0098 A3EE007B 		vfma.f64	d7, d3, d0
 919:Src/app.c     **** }
 645              		.loc 1 919 60 discriminator 2 view .LVU176
 646 009c A8EE047B 		vfma.f64	d7, d8, d4
 647              	.LVL42:
 919:Src/app.c     **** }
 648              		.loc 1 919 60 discriminator 2 view .LVU177
 649              	.LBE131:
 650              	.LBE141:
 937:Src/app.c     ****     y[i] = (int)decoded.y;
 651              		.loc 1 937 5 is_stmt 1 view .LVU178
 937:Src/app.c     ****     y[i] = (int)decoded.y;
 652              		.loc 1 937 12 is_stmt 0 view .LVU179
ARM GAS  /tmp/ccbfgvbk.s 			page 55


 653 00a0 FDEEE24A 		vcvt.s32.f32	s9, s5
 654 00a4 14EE90AA 		vmov	r10, s9	@ int
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 655              		.loc 1 938 5 is_stmt 1 view .LVU180
 656              	.LBB142:
 657              	.LBB132:
 919:Src/app.c     **** }
 658              		.loc 1 919 60 is_stmt 0 discriminator 2 view .LVU181
 659 00a8 B7EEC77B 		vcvt.f32.f64	s14, d7
 660              	.LBE132:
 661              	.LBE142:
 662              	.LBB143:
 663              	.LBB137:
 776:Src/app.c     ****     *x = margin;
 664              		.loc 1 776 6 view .LVU182
 665 00ac 5246     		mov	r2, r10
 666              	.LBE137:
 667              	.LBE143:
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 668              		.loc 1 938 12 view .LVU183
 669 00ae FDEEC77A 		vcvt.s32.f32	s15, s14
 670              	.LBB144:
 671              	.LBB138:
 776:Src/app.c     ****     *x = margin;
 672              		.loc 1 776 6 view .LVU184
 673 00b2 022A     		cmp	r2, #2
 674 00b4 B8BF     		it	lt
 675 00b6 0222     		movlt	r2, #2
 676              	.LBE138:
 677              	.LBE144:
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 678              		.loc 1 938 12 view .LVU185
 679 00b8 17EE903A 		vmov	r3, s15	@ int
 939:Src/app.c     ****   }
 680              		.loc 1 939 5 is_stmt 1 view .LVU186
 681              	.LVL43:
 682              	.LBB145:
 683              	.LBI135:
 771:Src/app.c     **** {
 684              		.loc 1 771 12 view .LVU187
 685              	.LBB139:
 773:Src/app.c     ****   int yi = *y;
 686              		.loc 1 773 3 view .LVU188
 774:Src/app.c     **** 
 687              		.loc 1 774 3 view .LVU189
 776:Src/app.c     ****     *x = margin;
 688              		.loc 1 776 3 view .LVU190
 778:Src/app.c     ****     *y = margin;
 689              		.loc 1 778 3 view .LVU191
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 690              		.loc 1 780 3 view .LVU192
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 691              		.loc 1 780 6 is_stmt 0 view .LVU193
 692 00bc 4A45     		cmp	r2, r9
 693 00be A8BF     		it	ge
 694 00c0 4A46     		movge	r2, r9
 778:Src/app.c     ****     *y = margin;
ARM GAS  /tmp/ccbfgvbk.s 			page 56


 695              		.loc 1 778 6 view .LVU194
 696 00c2 022B     		cmp	r3, #2
 697 00c4 9B46     		mov	fp, r3
 698 00c6 B8BF     		it	lt
 699 00c8 4FF0020B 		movlt	fp, #2
 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 700              		.loc 1 782 6 view .LVU195
 701 00cc C345     		cmp	fp, r8
 702 00ce A8BF     		it	ge
 703 00d0 C346     		movge	fp, r8
 785:Src/app.c     **** }
 704              		.loc 1 785 21 discriminator 2 view .LVU196
 705 00d2 B3EB0B03 		subs	r3, r3, fp
 706              	.LVL44:
 785:Src/app.c     **** }
 707              		.loc 1 785 21 discriminator 2 view .LVU197
 708 00d6 18BF     		it	ne
 709 00d8 0123     		movne	r3, #1
 710 00da 9245     		cmp	r10, r2
 711 00dc 18BF     		it	ne
 712 00de 0123     		movne	r3, #1
 713              	.LBE139:
 714              	.LBE145:
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 715              		.loc 1 935 17 discriminator 1 view .LVU198
 716 00e0 0139     		subs	r1, r1, #1
 717 00e2 4CF8042B 		str	r2, [ip], #4
 718              	.LBB146:
 719              	.LBB140:
 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 720              		.loc 1 782 3 is_stmt 1 view .LVU199
 721 00e6 40F804BB 		str	fp, [r0], #4
 785:Src/app.c     **** }
 722              		.loc 1 785 3 view .LVU200
 723              	.LVL45:
 785:Src/app.c     **** }
 724              		.loc 1 785 3 is_stmt 0 view .LVU201
 725              	.LBE140:
 726              	.LBE146:
 939:Src/app.c     ****   }
 727              		.loc 1 939 19 discriminator 1 view .LVU202
 728 00ea 4EF8043B 		str	r3, [lr], #4
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 729              		.loc 1 935 36 is_stmt 1 discriminator 3 view .LVU203
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 730              		.loc 1 935 17 discriminator 1 view .LVU204
 731 00ee 04F10804 		add	r4, r4, #8
 732 00f2 B7D1     		bne	.L43
 942:Src/app.c     ****     if (is_clamped[i])
 733              		.loc 1 942 10 is_stmt 0 view .LVU205
 734 00f4 0024     		movs	r4, #0
 735              	.L45:
 736              	.LVL46:
 943:Src/app.c     ****       continue;
 737              		.loc 1 943 5 is_stmt 1 view .LVU206
 943:Src/app.c     ****       continue;
 738              		.loc 1 943 19 is_stmt 0 view .LVU207
ARM GAS  /tmp/ccbfgvbk.s 			page 57


 739 00f6 55F8043B 		ldr	r3, [r5], #4
 943:Src/app.c     ****       continue;
 740              		.loc 1 943 8 view .LVU208
 741 00fa 43B9     		cbnz	r3, .L44
 945:Src/app.c     ****   }
 742              		.loc 1 945 5 is_stmt 1 view .LVU209
 743 00fc 6FF0FF03 		mvn	r3, #255
 744 0100 0222     		movs	r2, #2
 745 0102 56F82410 		ldr	r1, [r6, r4, lsl #2]
 746 0106 57F82400 		ldr	r0, [r7, r4, lsl #2]
 747 010a FFF7FEFF 		bl	UTIL_LCD_FillCircle
 748              	.LVL47:
 749              	.L44:
 942:Src/app.c     ****     if (is_clamped[i])
 750              		.loc 1 942 36 discriminator 2 view .LVU210
 751 010e 0134     		adds	r4, r4, #1
 752              	.LVL48:
 942:Src/app.c     ****     if (is_clamped[i])
 753              		.loc 1 942 17 discriminator 1 view .LVU211
 754 0110 152C     		cmp	r4, #21
 755 0112 F0D1     		bne	.L45
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 756              		.loc 1 948 10 is_stmt 0 view .LVU212
 757 0114 0025     		movs	r5, #0
 951:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
 758              		.loc 1 951 5 view .LVU213
 759 0116 4FF07F46 		mov	r6, #-16777216
 760 011a 124C     		ldr	r4, .L52
 761              	.LVL49:
 762              	.L47:
 949:Src/app.c     ****       continue;
 763              		.loc 1 949 5 is_stmt 1 view .LVU214
 949:Src/app.c     ****       continue;
 764              		.loc 1 949 38 is_stmt 0 view .LVU215
 765 011c 2068     		ldr	r0, [r4]
 949:Src/app.c     ****       continue;
 766              		.loc 1 949 19 view .LVU216
 767 011e 42AB     		add	r3, sp, #264
 768 0120 03EB8000 		add	r0, r3, r0, lsl #2
 949:Src/app.c     ****       continue;
 769              		.loc 1 949 8 view .LVU217
 770 0124 50F8543C 		ldr	r3, [r0, #-84]
 771 0128 8BB9     		cbnz	r3, .L46
 949:Src/app.c     ****       continue;
 772              		.loc 1 949 75 discriminator 2 view .LVU218
 773 012a 6268     		ldr	r2, [r4, #4]
 949:Src/app.c     ****       continue;
 774              		.loc 1 949 56 discriminator 2 view .LVU219
 775 012c 42AB     		add	r3, sp, #264
 776 012e 03EB8202 		add	r2, r3, r2, lsl #2
 949:Src/app.c     ****       continue;
 777              		.loc 1 949 43 discriminator 2 view .LVU220
 778 0132 52F8543C 		ldr	r3, [r2, #-84]
 779 0136 53B9     		cbnz	r3, .L46
 951:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
 780              		.loc 1 951 5 is_stmt 1 view .LVU221
 781 0138 0096     		str	r6, [sp]
ARM GAS  /tmp/ccbfgvbk.s 			page 58


 782 013a 52F8A83C 		ldr	r3, [r2, #-168]
 783 013e 50F8A81C 		ldr	r1, [r0, #-168]
 784 0142 52F8FC2C 		ldr	r2, [r2, #-252]
 785 0146 50F8FC0C 		ldr	r0, [r0, #-252]
 786 014a FFF7FEFF 		bl	UTIL_LCD_DrawLine
 787              	.LVL50:
 788              	.L46:
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 789              		.loc 1 948 35 discriminator 2 view .LVU222
 790 014e 0135     		adds	r5, r5, #1
 791              	.LVL51:
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 792              		.loc 1 948 17 discriminator 1 view .LVU223
 793 0150 152D     		cmp	r5, #21
 794 0152 04F10804 		add	r4, r4, #8
 795 0156 E1D1     		bne	.L47
 955:Src/app.c     **** 
 796              		.loc 1 955 1 is_stmt 0 view .LVU224
 797 0158 43B0     		add	sp, sp, #268
 798              		.cfi_def_cfa_offset 76
 799              		@ sp needed
 800 015a BDEC0A8B 		vldm	sp!, {d8-d12}
 801              		.cfi_restore 88
 802              		.cfi_restore 89
 803              		.cfi_restore 86
 804              		.cfi_restore 87
 805              		.cfi_restore 84
 806              		.cfi_restore 85
 807              		.cfi_restore 82
 808              		.cfi_restore 83
 809              		.cfi_restore 80
 810              		.cfi_restore 81
 811              		.cfi_def_cfa_offset 36
 812 015e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 813              	.LVL52:
 814              	.L53:
 955:Src/app.c     **** 
 815              		.loc 1 955 1 view .LVU225
 816 0162 00BF     		.align	2
 817              	.L52:
 818 0164 00000000 		.word	ld_bindings_idx
 819              		.cfi_endproc
 820              	.LFE7388:
 822              		.section	.rodata.nn_thread_fct.str1.1,"aMS",%progbits,1
 823              	.LC4:
 824 0000 6E6E5F70 		.ascii	"nn_pipe_dst\000"
 824      6970655F 
 824      64737400 
 825              	.LC5:
 826 000c 63617074 		.ascii	"capture_buffer\000"
 826      7572655F 
 826      62756666 
 826      657200
 827              	.LC6:
 828 001b 72657420 		.ascii	"ret == LL_ATON_User_IO_NOERROR\000"
 828      3D3D204C 
 828      4C5F4154 
ARM GAS  /tmp/ccbfgvbk.s 			page 59


 828      4F4E5F55 
 828      7365725F 
 829              	.LC7:
 830 003a 72657420 		.ascii	"ret == AI_OD_POSTPROCESS_ERROR_NO\000"
 830      3D3D2041 
 830      495F4F44 
 830      5F504F53 
 830      5450524F 
 831              		.section	.text.nn_thread_fct,"ax",%progbits
 832              		.align	1
 833              		.syntax unified
 834              		.thumb
 835              		.thumb_func
 837              	nn_thread_fct:
 838              	.LVL53:
 839              	.LFB7405:
1564:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
 840              		.loc 1 1564 1 is_stmt 1 view -0
 841              		.cfi_startproc
 842              		@ args = 0, pretend = 0, frame = 64
 843              		@ frame_needed = 0, uses_anonymous_args = 0
1566:Src/app.c     ****   float pd_filtered_ms = 0;
 844              		.loc 1 1566 3 view .LVU227
1567:Src/app.c     ****   float ld_filtered_ms = 0;
 845              		.loc 1 1567 3 view .LVU228
1568:Src/app.c     **** 
 846              		.loc 1 1568 3 view .LVU229
1573:Src/app.c     ****   fl_model_info_t fl_info;
 847              		.loc 1 1573 3 view .LVU230
1574:Src/app.c     ****   /* Timing variables. */
 848              		.loc 1 1574 3 view .LVU231
1576:Src/app.c     ****   uint32_t nn_period[2];
 849              		.loc 1 1576 3 view .LVU232
1577:Src/app.c     ****   uint8_t *nn_pipe_dst;
 850              		.loc 1 1577 3 view .LVU233
1578:Src/app.c     **** 
 851              		.loc 1 1578 3 view .LVU234
1581:Src/app.c     ****   pd_pp_box_t box_next;
 852              		.loc 1 1581 3 view .LVU235
1582:Src/app.c     ****   od_pp_out_t boxes_next[YOLO_MAX_NB]; // Unused for now
 853              		.loc 1 1582 3 view .LVU236
1583:Src/app.c     **** 
 854              		.loc 1 1583 3 view .LVU237
1586:Src/app.c     ****   roi_t roi_next;
 855              		.loc 1 1586 3 view .LVU238
1587:Src/app.c     ****   uint32_t pd_ms;
 856              		.loc 1 1587 3 view .LVU239
1588:Src/app.c     ****   uint32_t hl_ms;
 857              		.loc 1 1588 3 view .LVU240
1589:Src/app.c     ****   uint32_t yolo_ms;
 858              		.loc 1 1589 3 view .LVU241
1590:Src/app.c     ****   // uint32_t fl_ms; // Unused for now
 859              		.loc 1 1590 3 view .LVU242
1592:Src/app.c     ****   int j;
 860              		.loc 1 1592 3 view .LVU243
1593:Src/app.c     ****   // int temp = 0; // Unused for now
 861              		.loc 1 1593 3 view .LVU244
ARM GAS  /tmp/ccbfgvbk.s 			page 60


1597:Src/app.c     **** 
 862              		.loc 1 1597 3 view .LVU245
1601:Src/app.c     ****   // hand_landmark_init(&hl_info); // Disabled
 863              		.loc 1 1601 3 view .LVU246
1604:Src/app.c     ****   face_landmark_init(&fl_info);
 864              		.loc 1 1604 3 view .LVU247
1564:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
 865              		.loc 1 1564 1 is_stmt 0 view .LVU248
 866 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 867              		.cfi_def_cfa_offset 32
 868              		.cfi_offset 4, -32
 869              		.cfi_offset 5, -28
 870              		.cfi_offset 6, -24
 871              		.cfi_offset 7, -20
 872              		.cfi_offset 8, -16
 873              		.cfi_offset 9, -12
 874              		.cfi_offset 10, -8
 875              		.cfi_offset 14, -4
 876 0004 2DED028B 		vpush.64	{d8}
 877              		.cfi_def_cfa_offset 40
 878              		.cfi_offset 80, -40
 879              		.cfi_offset 81, -36
 880 0008 90B0     		sub	sp, sp, #64
 881              		.cfi_def_cfa_offset 104
 882              	.LVL54:
 883              	.LBB203:
 884              	.LBI203:
1056:Src/app.c     **** {
 885              		.loc 1 1056 13 is_stmt 1 view .LVU249
 886              	.LBB204:
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
 887              		.loc 1 1059 3 view .LVU250
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
 888              		.loc 1 1059 46 is_stmt 0 view .LVU251
 889 000a FFF7FEFF 		bl	LL_ATON_Output_Buffers_Info_yolo_detector
 890              	.LVL55:
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
 891              		.loc 1 1059 46 view .LVU252
 892 000e 0446     		mov	r4, r0
 893              	.LVL56:
1060:Src/app.c     **** 
 894              		.loc 1 1060 3 is_stmt 1 view .LVU253
1060:Src/app.c     **** 
 895              		.loc 1 1060 45 is_stmt 0 view .LVU254
 896 0010 FFF7FEFF 		bl	LL_ATON_Input_Buffers_Info_yolo_detector
 897              	.LVL57:
1060:Src/app.c     **** 
 898              		.loc 1 1060 45 view .LVU255
 899 0014 0146     		mov	r1, r0
 900              	.LVL58:
1063:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 901              		.loc 1 1063 3 is_stmt 1 view .LVU256
1063:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 902              		.loc 1 1063 17 is_stmt 0 view .LVU257
 903 0016 FFF7FEFF 		bl	LL_Buffer_addr_start
 904              	.LVL59:
 905              	.LBB205:
ARM GAS  /tmp/ccbfgvbk.s 			page 61


 906              	.LBB206:
 493:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 494:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_end(const LL_Buffer_InfoTypeDef *buf)
 495:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 496:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_end;
 497:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 498:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 499:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_limit(const LL_Buffer_InfoTypeDef *buf)
 500:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 501:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_limit;
 502:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 503:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 504:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
 505:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 506:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return buf->offset_end - buf->offset_start;
 907              		.loc 2 506 28 view .LVU258
 908 001a D1E90223 		ldrd	r2, r3, [r1, #8]
 909              	.LBE206:
 910              	.LBE205:
1063:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 911              		.loc 1 1063 15 discriminator 1 view .LVU259
 912 001e 0290     		str	r0, [sp, #8]
1064:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
 913              		.loc 1 1064 3 is_stmt 1 view .LVU260
 914              	.LVL60:
 915              	.LBB208:
 916              	.LBI205:
 504:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 917              		.loc 2 504 26 view .LVU261
 918              	.LBB207:
 919              		.loc 2 506 5 view .LVU262
 920              		.loc 2 506 28 is_stmt 0 view .LVU263
 921 0020 9B1A     		subs	r3, r3, r2
 922              	.LBE207:
 923              	.LBE208:
1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 924              		.loc 1 1065 40 view .LVU264
 925 0022 2046     		mov	r0, r4
1064:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
 926              		.loc 1 1064 19 discriminator 1 view .LVU265
 927 0024 0393     		str	r3, [sp, #12]
1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 928              		.loc 1 1065 3 is_stmt 1 view .LVU266
1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 929              		.loc 1 1065 40 is_stmt 0 view .LVU267
 930 0026 FFF7FEFF 		bl	LL_Buffer_addr_start
 931              	.LVL61:
 932              	.LBB209:
 933              	.LBB210:
 934              		.loc 2 506 28 view .LVU268
 935 002a D4E90223 		ldrd	r2, r3, [r4, #8]
 936              	.LBE210:
 937              	.LBE209:
1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 938              		.loc 1 1065 27 discriminator 1 view .LVU269
 939 002e 0490     		str	r0, [sp, #16]
1066:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 62


 940              		.loc 1 1066 3 is_stmt 1 view .LVU270
 941              	.LVL62:
 942              	.LBB212:
 943              	.LBI209:
 504:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 944              		.loc 2 504 26 view .LVU271
 945              	.LBB211:
 946              		.loc 2 506 5 view .LVU272
 947              		.loc 2 506 28 is_stmt 0 view .LVU273
 948 0030 9B1A     		subs	r3, r3, r2
 949              	.LBE211:
 950              	.LBE212:
1071:Src/app.c     **** }
 951              		.loc 1 1071 3 view .LVU274
 952 0032 08A8     		add	r0, sp, #32
1066:Src/app.c     **** 
 953              		.loc 1 1066 24 discriminator 1 view .LVU275
 954 0034 0593     		str	r3, [sp, #20]
1071:Src/app.c     **** }
 955              		.loc 1 1071 3 is_stmt 1 view .LVU276
 956 0036 FFF7FEFF 		bl	app_postprocess_init
 957              	.LVL63:
1071:Src/app.c     **** }
 958              		.loc 1 1071 3 is_stmt 0 view .LVU277
 959              	.LBE204:
 960              	.LBE203:
1605:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
 961              		.loc 1 1605 3 is_stmt 1 view .LVU278
 962              	.LBB213:
 963              	.LBI213:
1140:Src/app.c     **** {
 964              		.loc 1 1140 13 view .LVU279
 965              	.LBB214:
1143:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_face_landmark();
 966              		.loc 1 1143 3 view .LVU280
1143:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_face_landmark();
 967              		.loc 1 1143 46 is_stmt 0 view .LVU281
 968 003a FFF7FEFF 		bl	LL_ATON_Output_Buffers_Info_face_landmark
 969              	.LVL64:
1144:Src/app.c     **** 
 970              		.loc 1 1144 3 is_stmt 1 view .LVU282
1144:Src/app.c     **** 
 971              		.loc 1 1144 45 is_stmt 0 view .LVU283
 972 003e FFF7FEFF 		bl	LL_ATON_Input_Buffers_Info_face_landmark
 973              	.LVL65:
1148:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 974              		.loc 1 1148 3 is_stmt 1 view .LVU284
1149:Src/app.c     **** 
 975              		.loc 1 1149 3 view .LVU285
1155:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[0]);
 976              		.loc 1 1155 3 view .LVU286
1156:Src/app.c     **** 
 977              		.loc 1 1156 3 view .LVU287
1161:Src/app.c     ****   info->landmarks_out_len = LL_Buffer_len(&nn_out_info[1]);
 978              		.loc 1 1161 3 view .LVU288
1162:Src/app.c     **** }
 979              		.loc 1 1162 3 view .LVU289
ARM GAS  /tmp/ccbfgvbk.s 			page 63


1162:Src/app.c     **** }
 980              		.loc 1 1162 3 is_stmt 0 view .LVU290
 981              	.LBE214:
 982              	.LBE213:
1607:Src/app.c     **** 
 983              		.loc 1 1607 3 is_stmt 1 view .LVU291
1607:Src/app.c     **** 
 984              		.loc 1 1607 18 is_stmt 0 view .LVU292
 985 0042 FFF7FEFF 		bl	HAL_GetTick
 986              	.LVL66:
 987              	.LBB215:
 988              	.LBB216:
 605:Src/app.c     ****   if (ret == pdFALSE)
 989              		.loc 1 605 9 view .LVU293
 990 0046 864C     		ldr	r4, .L80
 991              	.LBE216:
 992              	.LBE215:
1607:Src/app.c     **** 
 993              		.loc 1 1607 18 view .LVU294
 994 0048 0546     		mov	r5, r0
 995              	.LVL67:
1610:Src/app.c     ****   assert(nn_pipe_dst);
 996              		.loc 1 1610 3 is_stmt 1 view .LVU295
 997              	.LBB219:
 998              	.LBI215:
 600:Src/app.c     **** {
 999              		.loc 1 600 17 view .LVU296
 1000              	.LBB217:
 602:Src/app.c     ****   int ret;
 1001              		.loc 1 602 3 view .LVU297
 603:Src/app.c     **** 
 1002              		.loc 1 603 3 view .LVU298
 605:Src/app.c     ****   if (ret == pdFALSE)
 1003              		.loc 1 605 3 view .LVU299
 605:Src/app.c     ****   if (ret == pdFALSE)
 1004              		.loc 1 605 9 is_stmt 0 discriminator 4 view .LVU300
 1005 004a 0021     		movs	r1, #0
 1006 004c 2068     		ldr	r0, [r4]
 1007              	.LVL68:
 605:Src/app.c     ****   if (ret == pdFALSE)
 1008              		.loc 1 605 9 discriminator 4 view .LVU301
 1009 004e FFF7FEFF 		bl	xQueueSemaphoreTake
 1010              	.LVL69:
 606:Src/app.c     ****     return NULL;
 1011              		.loc 1 606 3 is_stmt 1 view .LVU302
 606:Src/app.c     ****     return NULL;
 1012              		.loc 1 606 6 is_stmt 0 view .LVU303
 1013 0052 30B9     		cbnz	r0, .L55
 1014              	.LVL70:
 1015              	.L56:
 606:Src/app.c     ****     return NULL;
 1016              		.loc 1 606 6 view .LVU304
 1017              	.LBE217:
 1018              	.LBE219:
1611:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
 1019              		.loc 1 1611 3 discriminator 1 view .LVU305
 1020 0054 40F24B61 		movw	r1, #1611
ARM GAS  /tmp/ccbfgvbk.s 			page 64


 1021 0058 824B     		ldr	r3, .L80+4
 1022 005a 834A     		ldr	r2, .L80+8
 1023              	.LVL71:
 1024              	.L79:
 1025              	.LBB220:
 1026              	.LBB221:
 1027              	.LBB222:
 637:Src/app.c     **** 
 1028              		.loc 1 637 3 discriminator 1 view .LVU306
 1029 005c 8348     		ldr	r0, .L80+12
 1030 005e FFF7FEFF 		bl	__assert_func
 1031              	.LVL72:
 1032              	.L55:
 637:Src/app.c     **** 
 1033              		.loc 1 637 3 discriminator 1 view .LVU307
 1034              	.LBE222:
 1035              	.LBE221:
 1036              	.LBE220:
 1037              	.LBB259:
 1038              	.LBB218:
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1039              		.loc 1 609 3 is_stmt 1 view .LVU308
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1040              		.loc 1 609 23 is_stmt 0 view .LVU309
 1041 0062 D4F8B430 		ldr	r3, [r4, #180]
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1042              		.loc 1 609 7 view .LVU310
 1043 0066 04EB8302 		add	r2, r4, r3, lsl #2
 1044 006a D2F8AC00 		ldr	r0, [r2, #172]
 1045              	.LVL73:
 610:Src/app.c     **** 
 1046              		.loc 1 610 3 is_stmt 1 view .LVU311
 610:Src/app.c     **** 
 1047              		.loc 1 610 37 is_stmt 0 view .LVU312
 1048 006e D4F8A820 		ldr	r2, [r4, #168]
 610:Src/app.c     **** 
 1049              		.loc 1 610 32 view .LVU313
 1050 0072 0133     		adds	r3, r3, #1
 610:Src/app.c     **** 
 1051              		.loc 1 610 37 view .LVU314
 1052 0074 93FBF2F1 		sdiv	r1, r3, r2
 1053 0078 02FB1133 		mls	r3, r2, r1, r3
 610:Src/app.c     **** 
 1054              		.loc 1 610 16 view .LVU315
 1055 007c C4F8B430 		str	r3, [r4, #180]
 612:Src/app.c     **** }
 1056              		.loc 1 612 3 is_stmt 1 view .LVU316
 1057              	.LVL74:
 612:Src/app.c     **** }
 1058              		.loc 1 612 3 is_stmt 0 view .LVU317
 1059              	.LBE218:
 1060              	.LBE259:
1611:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
 1061              		.loc 1 1611 3 is_stmt 1 view .LVU318
 1062 0080 0028     		cmp	r0, #0
 1063 0082 E7D0     		beq	.L56
1612:Src/app.c     ****   while (1)
ARM GAS  /tmp/ccbfgvbk.s 			page 65


 1064              		.loc 1 1612 3 view .LVU319
1566:Src/app.c     ****   float pd_filtered_ms = 0;
 1065              		.loc 1 1566 9 is_stmt 0 view .LVU320
 1066 0084 9FED7A8A 		vldr.32	s16, .L80+16
1612:Src/app.c     ****   while (1)
 1067              		.loc 1 1612 3 view .LVU321
 1068 0088 0021     		movs	r1, #0
 1069 008a FFF7FEFF 		bl	CAM_NNPipe_Start
 1070              	.LVL75:
1612:Src/app.c     ****   while (1)
 1071              		.loc 1 1612 3 view .LVU322
 1072 008e 18EE108A 		vmov	r8, s16
 1073              	.LBB260:
1621:Src/app.c     ****     
 1074              		.loc 1 1621 27 view .LVU323
 1075 0092 DFED788A 		vldr.32	s17, .L80+20
1626:Src/app.c     **** 
 1076              		.loc 1 1626 48 view .LVU324
 1077 0096 DFF80C92 		ldr	r9, .L80+68
 1078              	.LBB225:
 1079              	.LBB226:
 1080              	.LBB227:
1097:Src/app.c     **** 
 1081              		.loc 1 1097 3 view .LVU325
 1082 009a DFF80CA2 		ldr	r10, .L80+72
 1083              	.LVL76:
 1084              	.L70:
1097:Src/app.c     **** 
 1085              		.loc 1 1097 3 view .LVU326
 1086              	.LBE227:
 1087              	.LBE226:
 1088              	.LBE225:
 1089              	.LBE260:
1613:Src/app.c     ****   {
 1090              		.loc 1 1613 3 is_stmt 1 view .LVU327
 1091              	.LBB261:
1615:Src/app.c     ****     int idx_for_resize;
 1092              		.loc 1 1615 5 view .LVU328
1616:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
 1093              		.loc 1 1616 5 view .LVU329
1618:Src/app.c     ****     nn_period[1] = HAL_GetTick();
 1094              		.loc 1 1618 5 view .LVU330
1619:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1095              		.loc 1 1619 5 view .LVU331
1619:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1096              		.loc 1 1619 20 is_stmt 0 view .LVU332
 1097 009e FFF7FEFF 		bl	HAL_GetTick
 1098              	.LVL77:
1620:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
 1099              		.loc 1 1620 18 view .LVU333
 1100 00a2 431B     		subs	r3, r0, r5
 1101 00a4 07EE903A 		vmov	s15, r3	@ int
1621:Src/app.c     ****     
 1102              		.loc 1 1621 75 view .LVU334
 1103 00a8 B2EE0E7A 		vmov.f32	s14, #1.5e+1
 1104 00ac F8EE677A 		vcvt.f32.u32	s15, s15
 1105 00b0 E8EE077A 		vfma.f32	s15, s16, s14
ARM GAS  /tmp/ccbfgvbk.s 			page 66


1619:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1106              		.loc 1 1619 20 view .LVU335
 1107 00b4 0746     		mov	r7, r0
 1108              	.LVL78:
1620:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
 1109              		.loc 1 1620 5 is_stmt 1 view .LVU336
1621:Src/app.c     ****     
 1110              		.loc 1 1621 5 view .LVU337
 1111              	.LBB253:
 1112              	.LBB223:
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1113              		.loc 1 636 9 is_stmt 0 view .LVU338
 1114 00b6 4FF0FF31 		mov	r1, #-1
 1115 00ba 606D     		ldr	r0, [r4, #84]
 1116              	.LVL79:
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1117              		.loc 1 636 9 view .LVU339
 1118              	.LBE223:
 1119              	.LBE253:
1621:Src/app.c     ****     
 1120              		.loc 1 1621 27 view .LVU340
 1121 00bc 27EEA88A 		vmul.f32	s16, s15, s17
 1122              	.LVL80:
1624:Src/app.c     ****     assert(capture_buffer);
 1123              		.loc 1 1624 5 is_stmt 1 view .LVU341
 1124              	.LBB254:
 1125              	.LBI221:
 631:Src/app.c     **** {
 1126              		.loc 1 631 17 view .LVU342
 1127              	.LBB224:
 633:Src/app.c     ****   int ret;
 1128              		.loc 1 633 3 view .LVU343
 634:Src/app.c     **** 
 1129              		.loc 1 634 3 view .LVU344
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1130              		.loc 1 636 3 view .LVU345
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1131              		.loc 1 636 9 is_stmt 0 view .LVU346
 1132 00c0 FFF7FEFF 		bl	xQueueSemaphoreTake
 1133              	.LVL81:
 637:Src/app.c     **** 
 1134              		.loc 1 637 3 view .LVU347
 1135 00c4 0128     		cmp	r0, #1
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1136              		.loc 1 636 9 view .LVU348
 1137 00c6 0546     		mov	r5, r0
 1138              	.LVL82:
 637:Src/app.c     **** 
 1139              		.loc 1 637 3 is_stmt 1 view .LVU349
 1140 00c8 04D0     		beq	.L57
 637:Src/app.c     **** 
 1141              		.loc 1 637 3 is_stmt 0 discriminator 1 view .LVU350
 1142 00ca 40F27D21 		movw	r1, #637
 1143 00ce 6A4B     		ldr	r3, .L80+24
 1144 00d0 6A4A     		ldr	r2, .L80+28
 1145 00d2 C3E7     		b	.L79
 1146              	.L57:
ARM GAS  /tmp/ccbfgvbk.s 			page 67


 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1147              		.loc 1 639 3 is_stmt 1 view .LVU351
 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1148              		.loc 1 639 23 is_stmt 0 view .LVU352
 1149 00d4 D4F8B830 		ldr	r3, [r4, #184]
 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1150              		.loc 1 639 7 view .LVU353
 1151 00d8 04EB8302 		add	r2, r4, r3, lsl #2
 1152 00dc D2F8AC60 		ldr	r6, [r2, #172]
 1153              	.LVL83:
 640:Src/app.c     **** 
 1154              		.loc 1 640 3 is_stmt 1 view .LVU354
 640:Src/app.c     **** 
 1155              		.loc 1 640 39 is_stmt 0 view .LVU355
 1156 00e0 D4F8A820 		ldr	r2, [r4, #168]
 640:Src/app.c     **** 
 1157              		.loc 1 640 34 view .LVU356
 1158 00e4 0133     		adds	r3, r3, #1
 640:Src/app.c     **** 
 1159              		.loc 1 640 39 view .LVU357
 1160 00e6 93FBF2F1 		sdiv	r1, r3, r2
 1161 00ea 02FB1133 		mls	r3, r2, r1, r3
 640:Src/app.c     **** 
 1162              		.loc 1 640 17 view .LVU358
 1163 00ee C4F8B830 		str	r3, [r4, #184]
 642:Src/app.c     **** }
 1164              		.loc 1 642 3 is_stmt 1 view .LVU359
 1165              	.LVL84:
 642:Src/app.c     **** }
 1166              		.loc 1 642 3 is_stmt 0 view .LVU360
 1167              	.LBE224:
 1168              	.LBE254:
1625:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
 1169              		.loc 1 1625 5 is_stmt 1 view .LVU361
 1170 00f2 26B9     		cbnz	r6, .L58
1625:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
 1171              		.loc 1 1625 5 is_stmt 0 discriminator 1 view .LVU362
 1172 00f4 40F25961 		movw	r1, #1625
 1173 00f8 614B     		ldr	r3, .L80+32
 1174 00fa 5B4A     		ldr	r2, .L80+8
 1175 00fc AEE7     		b	.L79
 1176              	.L58:
1626:Src/app.c     **** 
 1177              		.loc 1 1626 5 is_stmt 1 view .LVU363
1626:Src/app.c     **** 
 1178              		.loc 1 1626 48 is_stmt 0 view .LVU364
 1179 00fe D9F80030 		ldr	r3, [r9]
 1180              	.LVL85:
1630:Src/app.c     ****       /* --- ALL MODEL CALLS ARE REMOVED FOR THIS TEST --- */
 1181              		.loc 1 1630 5 is_stmt 1 view .LVU365
 1182              	.LBB255:
1632:Src/app.c     ****       LL_ATON_RT_Main(&NN_Instance_face_landmark);
 1183              		.loc 1 1632 7 view .LVU366
 1184              	.LBB251:
 1185              	.LBI226:
1084:Src/app.c     **** {
 1186              		.loc 1 1084 12 view .LVU367
ARM GAS  /tmp/ccbfgvbk.s 			page 68


 1187              	.LBB249:
1086:Src/app.c     ****   int total_detections;
 1188              		.loc 1 1086 3 view .LVU368
1087:Src/app.c     ****   int face_nb = 0; /* This will count only the faces we find. */
 1189              		.loc 1 1087 3 view .LVU369
1088:Src/app.c     ****   int ret;
 1190              		.loc 1 1088 3 view .LVU370
1089:Src/app.c     **** 
 1191              		.loc 1 1089 3 view .LVU371
1091:Src/app.c     **** 
 1192              		.loc 1 1091 3 view .LVU372
1091:Src/app.c     **** 
 1193              		.loc 1 1091 14 is_stmt 0 view .LVU373
 1194 0102 FFF7FEFF 		bl	HAL_GetTick
 1195              	.LVL86:
1094:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
 1196              		.loc 1 1094 3 is_stmt 1 view .LVU374
1094:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
 1197              		.loc 1 1094 9 is_stmt 0 view .LVU375
 1198 0106 3146     		mov	r1, r6
 1199 0108 0020     		movs	r0, #0
 1200 010a 039A     		ldr	r2, [sp, #12]
 1201 010c FFF7FEFF 		bl	LL_ATON_Set_User_Input_Buffer_yolo_detector
 1202              	.LVL87:
1095:Src/app.c     **** 
 1203              		.loc 1 1095 3 is_stmt 1 view .LVU376
 1204 0110 20B1     		cbz	r0, .L59
1095:Src/app.c     **** 
 1205              		.loc 1 1095 3 is_stmt 0 discriminator 1 view .LVU377
 1206 0112 40F24741 		movw	r1, #1095
 1207 0116 5B4B     		ldr	r3, .L80+36
 1208 0118 5B4A     		ldr	r2, .L80+40
 1209 011a 9FE7     		b	.L79
 1210              	.L59:
1097:Src/app.c     **** 
 1211              		.loc 1 1097 3 is_stmt 1 view .LVU378
 1212 011c 5046     		mov	r0, r10
 1213              	.LVL88:
1097:Src/app.c     **** 
 1214              		.loc 1 1097 3 is_stmt 0 view .LVU379
 1215 011e FFF7FEFF 		bl	LL_ATON_RT_Main
 1216              	.LVL89:
1099:Src/app.c     **** 
 1217              		.loc 1 1099 3 is_stmt 1 view .LVU380
1099:Src/app.c     **** 
 1218              		.loc 1 1099 3 view .LVU381
1099:Src/app.c     **** 
 1219              		.loc 1 1099 3 discriminator 1 view .LVU382
 1220 0122 059A     		ldr	r2, [sp, #20]
 1221              	.LVL90:
 1222              	.LBB228:
 1223              	.LBI228:
 1224              		.file 3 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h"
   1:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /******************************************************************************
   2:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @file     cachel1_armv7.h
   3:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @brief    CMSIS Level 1 Cache API for Armv7-M and later
   4:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @version  V1.0.3
ARM GAS  /tmp/ccbfgvbk.s 			page 69


   5:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @date     17. March 2023
   6:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  ******************************************************************************/
   7:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /*
   8:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Copyright (c) 2020-2021 Arm Limited. All rights reserved.
   9:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  10:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  12:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * not use this file except in compliance with the License.
  14:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * You may obtain a copy of the License at
  15:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  16:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  18:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * See the License for the specific language governing permissions and
  22:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * limitations under the License.
  23:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  */
  24:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  25:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #if   defined ( __ICCARM__ )
  26:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #elif defined (__clang__)
  28:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #pragma clang system_header    /* treat file as system include file */
  29:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  30:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  31:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef ARM_CACHEL1_ARMV7_H
  32:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define ARM_CACHEL1_ARMV7_H
  33:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  34:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  35:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \ingroup  CMSIS_Core_FunctionInterface
  36:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \defgroup CMSIS_Core_CacheFunctions Cache Functions
  37:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief    Functions that configure Instruction and Data cache.
  38:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   @{
  39:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  */
  40:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  41:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /* Cache Size ID Register Macros */
  42:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Po
  43:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos     
  44:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  45:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef __SCB_DCACHE_LINE_SIZE
  46:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define __SCB_DCACHE_LINE_SIZE  32U /*!< Cortex-M7 cache line size is fixed to 32 bytes (8 words). 
  47:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  48:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  49:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef __SCB_ICACHE_LINE_SIZE
  50:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define __SCB_ICACHE_LINE_SIZE  32U /*!< Cortex-M7 cache line size is fixed to 32 bytes (8 words). 
  51:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  52:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  53:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  54:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Enable I-Cache
  55:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns on I-Cache
  56:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  57:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_EnableICache (void)
  58:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  59:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  60:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
  61:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 70


  62:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  63:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  64:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  65:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  66:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  67:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  68:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  69:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  70:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
  71:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
  72:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  73:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  74:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  75:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Disable I-Cache
  76:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns off I-Cache
  77:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  78:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_DisableICache (void)
  79:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  80:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  81:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  82:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  83:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
  84:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  85:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  86:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  87:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
  88:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
  89:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  90:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  91:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  92:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Invalidate I-Cache
  93:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates I-Cache
  94:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  95:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateICache (void)
  96:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  97:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  98:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  99:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 100:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;
 101:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 102:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 103:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 104:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 105:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 106:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 107:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 108:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   I-Cache Invalidate by address
 109:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates I-Cache for the given address.
 110:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            I-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.
 111:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            I-Cache memory blocks which are part of given address + given size are invalidated.
 112:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 113:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   isize   size of memory block (in number of bytes)
 114:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 115:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateICache_by_Addr (volatile void *addr, int32_t isize)
 116:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 117:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
 118:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( isize > 0 ) {
ARM GAS  /tmp/ccbfgvbk.s 			page 71


 119:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = isize + (((uint32_t)addr) & (__SCB_ICACHE_LINE_SIZE - 1U));
 120:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_ICACHE_LINE_SIZE - 1U) */;
 121:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 122:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 123:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 124:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 125:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->ICIMVAU = op_addr;             /* register accepts only 32byte aligned values, only bi
 126:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_ICACHE_LINE_SIZE;
 127:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_ICACHE_LINE_SIZE;
 128:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 129:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 130:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 131:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 132:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 133:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 134:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 135:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 136:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 137:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 138:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Enable D-Cache
 139:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns on D-Cache
 140:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 141:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_EnableDCache (void)
 142:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 143:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 144:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 145:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 146:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 147:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 148:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 149:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 150:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 151:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 152:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 153:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 154:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 155:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* invalidate D-Cache */
 156:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 157:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 158:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 159:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 160:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 161:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 162:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 163:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 164:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 165:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 166:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 167:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 168:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 169:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 170:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 171:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 172:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 173:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 174:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 175:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 72


 176:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 177:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 178:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Disable D-Cache
 179:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns off D-Cache
 180:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 181:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_DisableDCache (void)
 182:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 183:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 184:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     struct {
 185:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 186:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 187:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 188:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } locals
 189:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if ((defined(__GNUC__) || defined(__clang__)) && !defined(__OPTIMIZE__))
 190:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        __ALIGNED(__SCB_DCACHE_LINE_SIZE)
 191:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 192:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ;
 193:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 194:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 195:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 196:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 197:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
 198:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 199:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 200:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if !defined(__OPTIMIZE__)
 201:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       /*
 202:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * For the endless loop issue with no optimization builds.
 203:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * More details, see https://github.com/ARM-software/CMSIS_5/issues/620
 204:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        *
 205:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * The issue only happens when local variables are in stack. If
 206:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * local variables are saved in general purpose register, then the function
 207:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * is OK.
 208:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        *
 209:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * When local variables are in stack, after disabling the cache, flush the
 210:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * local variables cache line for data consistency.
 211:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        */
 212:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       /* Clean and invalidate the local variable cache. */
 213:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if defined(__ICCARM__)
 214:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     /* As we can't align the stack to the cache line size, invalidate each of the variables */
 215:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.sets;
 216:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.ways;
 217:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.ccsidr;
 218:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #else
 219:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals;
 220:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 221:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 222:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 223:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 224:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 225:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     locals.ccsidr = SCB->CCSIDR;
 226:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean & invalidate D-Cache */
 227:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     locals.sets = (uint32_t)(CCSIDR_SETS(locals.ccsidr));
 228:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 229:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       locals.ways = (uint32_t)(CCSIDR_WAYS(locals.ccsidr));
 230:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 231:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCISW = (((locals.sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 232:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                        ((locals.ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
ARM GAS  /tmp/ccbfgvbk.s 			page 73


 233:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 234:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 235:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 236:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (locals.ways-- != 0U);
 237:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(locals.sets-- != 0U);
 238:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 239:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 240:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 241:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 242:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 243:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 244:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 245:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 246:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Invalidate D-Cache
 247:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates D-Cache
 248:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 249:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateDCache (void)
 250:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 251:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 252:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 253:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 254:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 255:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 256:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 257:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 259:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 261:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* invalidate D-Cache */
 262:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 263:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 264:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 265:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 266:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 267:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 268:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 270:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 273:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 274:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 275:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 276:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 277:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 278:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 279:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 280:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 281:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Clean D-Cache
 282:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans D-Cache
 283:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 284:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanDCache (void)
 285:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 286:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 287:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 288:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 289:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
ARM GAS  /tmp/ccbfgvbk.s 			page 74


 290:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 291:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 292:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 293:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 294:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 295:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 296:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean D-Cache */
 297:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 298:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 299:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 300:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 301:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 302:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
 303:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 304:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 305:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 306:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 307:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 308:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 309:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 310:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 311:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 312:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 313:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 314:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 315:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 316:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Clean & Invalidate D-Cache
 317:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans and Invalidates D-Cache
 318:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 319:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache (void)
 320:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 321:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 322:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 323:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 324:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 325:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 326:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 327:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 328:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 329:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 330:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 331:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean & invalidate D-Cache */
 332:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 333:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 334:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 335:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 336:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 337:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
 338:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 339:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 340:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 341:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 342:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 343:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 344:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 345:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 346:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
ARM GAS  /tmp/ccbfgvbk.s 			page 75


 347:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 348:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 349:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 350:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 351:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Invalidate by address
 352:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates D-Cache for the given address.
 353:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.
 354:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are invalidated.
 355:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 356:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
 357:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 358:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
 1225              		.loc 3 358 27 view .LVU383
 1226              	.LBB229:
 359:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 360:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 361:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 1227              		.loc 3 361 5 view .LVU384
 1228              		.loc 3 361 8 is_stmt 0 view .LVU385
 1229 0124 002A     		cmp	r2, #0
 1230 0126 1BDD     		ble	.L60
 1231              	.LBB230:
 362:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 1232              		.loc 3 362 8 is_stmt 1 view .LVU386
 1233              		.loc 3 362 36 is_stmt 0 view .LVU387
 1234 0128 049B     		ldr	r3, [sp, #16]
 1235              		.loc 3 362 52 view .LVU388
 1236 012a 03F01F01 		and	r1, r3, #31
 1237              		.loc 3 362 32 view .LVU389
 1238 012e 1144     		add	r1, r1, r2
 1239              	.LVL91:
 363:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 1240              		.loc 3 363 7 is_stmt 1 view .LVU390
 364:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 365:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 1241              		.loc 3 365 7 view .LVU391
 1242              	.LBB231:
 1243              	.LBI231:
 1244              		.file 4 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h"
   1:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.4.1
   5:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     27. May 2021
   6:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
   9:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
ARM GAS  /tmp/ccbfgvbk.s 			page 76


  19:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE
  50:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  52:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
ARM GAS  /tmp/ccbfgvbk.s 			page 77


  76:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 130:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 78


 133:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 141:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 163:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 166:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(".vectors")))
 183:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
 186:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_SEAL
 187:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_SEAL              __StackSeal
 188:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 189:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 79


 190:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __TZ_STACK_SEAL_SIZE
 191:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __TZ_STACK_SEAL_SIZE      8U
 192:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 193:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __TZ_STACK_SEAL_VALUE
 195:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL
 196:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 197:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 198:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {
 200:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   *((uint64_t *)stackTop) = __TZ_STACK_SEAL_VALUE;
 201:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 202:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 203:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 204:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 205:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 206:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 207:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 208:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 209:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** */
 210:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 211:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 212:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 213:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 214:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 215:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 216:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 217:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 218:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 219:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 220:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 221:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 222:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 223:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 224:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 225:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 226:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 227:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 228:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 229:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 230:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 231:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 232:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 233:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 234:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi":::"memory")
 235:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 236:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 238:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 239:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 240:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 241:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 242:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe":::"memory")
 243:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 244:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 245:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 246:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
ARM GAS  /tmp/ccbfgvbk.s 			page 80


 247:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 248:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 249:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 250:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 253:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 254:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 255:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 256:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 257:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 259:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 261:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 262:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 263:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 264:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 265:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 266:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 267:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 268:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 1245              		.loc 4 269 27 view .LVU392
 1246              	.LBB232:
 270:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 1247              		.loc 4 271 3 view .LVU393
 1248              		.syntax unified
 1249              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1250 0130 BFF34F8F 		dsb 0xF
 1251              	@ 0 "" 2
 1252              		.thumb
 1253              		.syntax unified
 1254              	.LBE232:
 1255              	.LBE231:
 366:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 371:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 1256              		.loc 3 371 25 is_stmt 0 discriminator 1 view .LVU394
 1257 0134 DA43     		mvns	r2, r3
 1258              	.LVL92:
 1259              		.loc 3 371 25 discriminator 1 view .LVU395
 1260 0136 5E18     		adds	r6, r3, r1
 1261              	.LVL93:
 1262              		.loc 3 371 25 discriminator 1 view .LVU396
 1263 0138 3244     		add	r2, r2, r6
 1264 013a 2039     		subs	r1, r1, #32
 1265              	.LVL94:
 1266              		.loc 3 371 25 discriminator 1 view .LVU397
 1267 013c 5209     		lsrs	r2, r2, #5
 1268 013e 2031     		adds	r1, r1, #32
 1269              	.LVL95:
 1270              		.loc 3 371 25 discriminator 1 view .LVU398
ARM GAS  /tmp/ccbfgvbk.s 			page 81


 1271 0140 02F1010E 		add	lr, r2, #1
 1272 0144 D8BF     		it	le
 1273 0146 AE46     		movle	lr, r5
 1274 0148 4EF001E0 		dls	lr, lr
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1275              		.loc 3 368 22 view .LVU399
 1276 014c 4F48     		ldr	r0, .L80+44
 1277              	.LVL96:
 1278              	.L61:
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 1279              		.loc 3 367 7 is_stmt 1 view .LVU400
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1280              		.loc 3 368 9 view .LVU401
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1281              		.loc 3 368 22 is_stmt 0 view .LVU402
 1282 014e C0F85C32 		str	r3, [r0, #604]
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 1283              		.loc 3 369 9 is_stmt 1 view .LVU403
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 1284              		.loc 3 369 17 is_stmt 0 view .LVU404
 1285 0152 2033     		adds	r3, r3, #32
 1286              	.LVL97:
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 1287              		.loc 3 370 9 is_stmt 1 view .LVU405
 1288              		.loc 3 371 25 discriminator 1 view .LVU406
 1289 0154 0FF005C8 		le	lr, .L61
 372:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 373:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 1290              		.loc 3 373 7 view .LVU407
 1291              	.LBB233:
 1292              	.LBI233:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1293              		.loc 4 269 27 view .LVU408
 1294              	.LBB234:
 1295              		.loc 4 271 3 view .LVU409
 1296              		.syntax unified
 1297              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1298 0158 BFF34F8F 		dsb 0xF
 1299              	@ 0 "" 2
 1300              		.thumb
 1301              		.syntax unified
 1302              	.LBE234:
 1303              	.LBE233:
 374:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 1304              		.loc 3 374 7 view .LVU410
 1305              	.LBB235:
 1306              	.LBI235:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1307              		.loc 4 258 27 view .LVU411
 1308              	.LBB236:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1309              		.loc 4 260 3 view .LVU412
 1310              		.syntax unified
 1311              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1312 015c BFF36F8F 		isb 0xF
 1313              	@ 0 "" 2
 1314              	.LVL98:
ARM GAS  /tmp/ccbfgvbk.s 			page 82


 1315              		.thumb
 1316              		.syntax unified
 1317              	.L60:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1318              		.loc 4 260 3 is_stmt 0 view .LVU413
 1319              	.LBE236:
 1320              	.LBE235:
 1321              	.LBE230:
 1322              	.LBE229:
 1323              	.LBE228:
1099:Src/app.c     **** 
 1324              		.loc 1 1099 3 is_stmt 1 discriminator 3 view .LVU414
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1325              		.loc 1 1103 3 view .LVU415
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1326              		.loc 1 1103 40 is_stmt 0 view .LVU416
 1327 0160 049B     		ldr	r3, [sp, #16]
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1328              		.loc 1 1103 9 view .LVU417
 1329 0162 0121     		movs	r1, #1
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1330              		.loc 1 1103 40 view .LVU418
 1331 0164 0193     		str	r3, [sp, #4]
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1332              		.loc 1 1103 9 view .LVU419
 1333 0166 06AA     		add	r2, sp, #24
 1334 0168 08AB     		add	r3, sp, #32
 1335 016a 01A8     		add	r0, sp, #4
 1336 016c FFF7FEFF 		bl	app_postprocess_run
 1337              	.LVL99:
1104:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
 1338              		.loc 1 1104 3 is_stmt 1 view .LVU420
 1339 0170 20B1     		cbz	r0, .L62
1104:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
 1340              		.loc 1 1104 3 is_stmt 0 discriminator 1 view .LVU421
 1341 0172 4FF48A61 		mov	r1, #1104
 1342 0176 464B     		ldr	r3, .L80+48
 1343 0178 434A     		ldr	r2, .L80+40
 1344 017a 6FE7     		b	.L79
 1345              	.L62:
1105:Src/app.c     **** 
 1346              		.loc 1 1105 3 is_stmt 1 view .LVU422
 1347              	.LBB237:
1111:Src/app.c     ****     {
 1348              		.loc 1 1111 24 is_stmt 0 view .LVU423
 1349 017c DDE90631 		ldrd	r3, r1, [sp, #24]
 1350 0180 8842     		cmp	r0, r1
1111:Src/app.c     ****     {
 1351              		.loc 1 1111 36 view .LVU424
 1352 0182 03F11402 		add	r2, r3, #20
 1353 0186 4FF01805 		mov	r5, #24
 1354 018a 01F10103 		add	r3, r1, #1
 1355 018e 02DC     		bgt	.L75
 1356 0190 B1F1004F 		cmp	r1, #-2147483648
 1357 0194 00D1     		bne	.L63
 1358              	.L75:
 1359 0196 0123     		movs	r3, #1
ARM GAS  /tmp/ccbfgvbk.s 			page 83


 1360              	.LVL100:
 1361              	.L63:
1108:Src/app.c     ****   {
 1362              		.loc 1 1108 21 is_stmt 1 discriminator 1 view .LVU425
 1363 0198 013B     		subs	r3, r3, #1
 1364 019a 11D1     		bne	.L66
 1365              	.LBE237:
1128:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
 1366              		.loc 1 1128 3 view .LVU426
1128:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
 1367              		.loc 1 1128 21 is_stmt 0 view .LVU427
 1368 019c FFF7FEFF 		bl	HAL_GetTick
 1369              	.LVL101:
1129:Src/app.c     **** }
 1370              		.loc 1 1129 3 is_stmt 1 view .LVU428
1129:Src/app.c     **** }
 1371              		.loc 1 1129 3 is_stmt 0 view .LVU429
 1372              	.LBE249:
 1373              	.LBE251:
1633:Src/app.c     ****       /* --- Force tracking to be ON and create a dummy box --- */
 1374              		.loc 1 1633 7 is_stmt 1 view .LVU430
 1375 01a0 3C48     		ldr	r0, .L80+52
 1376 01a2 FFF7FEFF 		bl	LL_ATON_RT_Main
 1377              	.LVL102:
1635:Src/app.c     ****       pd_ms = 0; // Set dummy timing
 1378              		.loc 1 1635 7 view .LVU431
1636:Src/app.c     ****     } else {
 1379              		.loc 1 1636 7 view .LVU432
1636:Src/app.c     ****     } else {
 1380              		.loc 1 1636 7 is_stmt 0 view .LVU433
 1381              	.LBE255:
1642:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
 1382              		.loc 1 1642 5 is_stmt 1 view .LVU434
1643:Src/app.c     **** 
 1383              		.loc 1 1643 5 view .LVU435
 1384              	.LBB256:
 1385              	.LBI256:
 618:Src/app.c     **** {
 1386              		.loc 1 618 13 view .LVU436
 1387              	.LBB257:
 620:Src/app.c     **** 
 1388              		.loc 1 620 3 view .LVU437
 622:Src/app.c     ****   assert(ret == pdTRUE);
 1389              		.loc 1 622 3 view .LVU438
 622:Src/app.c     ****   assert(ret == pdTRUE);
 1390              		.loc 1 622 9 is_stmt 0 view .LVU439
 1391 01a6 0023     		movs	r3, #0
 1392 01a8 2068     		ldr	r0, [r4]
 1393 01aa 1A46     		mov	r2, r3
 1394 01ac 1946     		mov	r1, r3
 1395 01ae FFF7FEFF 		bl	xQueueGenericSend
 1396              	.LVL103:
 623:Src/app.c     **** }
 1397              		.loc 1 623 3 is_stmt 1 view .LVU440
 1398 01b2 0128     		cmp	r0, #1
 1399 01b4 24D0     		beq	.L67
 623:Src/app.c     **** }
ARM GAS  /tmp/ccbfgvbk.s 			page 84


 1400              		.loc 1 623 3 is_stmt 0 discriminator 1 view .LVU441
 1401 01b6 40F26F21 		movw	r1, #623
 1402 01ba 2F4B     		ldr	r3, .L80+24
 1403 01bc 364A     		ldr	r2, .L80+56
 1404 01be 4DE7     		b	.L79
 1405              	.LVL104:
 1406              	.L66:
 623:Src/app.c     **** }
 1407              		.loc 1 623 3 discriminator 1 view .LVU442
 1408              	.LBE257:
 1409              	.LBE256:
 1410              	.LBB258:
 1411              	.LBB252:
 1412              	.LBB250:
 1413              	.LBB248:
1111:Src/app.c     ****     {
 1414              		.loc 1 1111 5 is_stmt 1 view .LVU443
1111:Src/app.c     ****     {
 1415              		.loc 1 1111 36 is_stmt 0 view .LVU444
 1416 01c0 05FB00F1 		mul	r1, r5, r0
1111:Src/app.c     ****     {
 1417              		.loc 1 1111 8 view .LVU445
 1418 01c4 5158     		ldr	r1, [r2, r1]
 1419 01c6 0229     		cmp	r1, #2
 1420 01c8 18D1     		bne	.L64
 1421              	.LBB238:
 1422              	.LBB239:
 1423              	.LBB240:
 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1424              		.loc 1 409 20 view .LVU446
 1425 01ca 4FF0070E 		mov	lr, #7
 1426              	.LBE240:
 1427              	.LBE239:
 1428              	.LBE238:
 1429 01ce 0023     		movs	r3, #0
 1430              	.LBB247:
 1431              	.LBB242:
 1432              	.LBB241:
 1433 01d0 9FED327A 		vldr.32	s14, .L80+60
 1434 01d4 4EF001E0 		dls	lr, lr
 1435              	.L65:
 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1436              		.loc 1 409 5 is_stmt 1 view .LVU447
 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1437              		.loc 1 409 20 is_stmt 0 view .LVU448
 1438 01d8 D3ED007A 		vldr.32	s15, [r3]
 1439 01dc 67EE877A 		vmul.f32	s15, s15, s14
 1440 01e0 C3ED007A 		vstr.32	s15, [r3]
 410:Src/app.c     ****   }
 1441              		.loc 1 410 5 is_stmt 1 view .LVU449
 410:Src/app.c     ****   }
 1442              		.loc 1 410 20 is_stmt 0 view .LVU450
 1443 01e4 D3ED017A 		vldr.32	s15, [r3, #4]
 1444 01e8 67EE877A 		vmul.f32	s15, s15, s14
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1445              		.loc 1 408 17 discriminator 1 view .LVU451
 1446 01ec 0833     		adds	r3, r3, #8
ARM GAS  /tmp/ccbfgvbk.s 			page 85


 410:Src/app.c     ****   }
 1447              		.loc 1 410 20 view .LVU452
 1448 01ee 43ED017A 		vstr.32	s15, [r3, #-4]
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1449              		.loc 1 408 49 is_stmt 1 discriminator 3 view .LVU453
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1450              		.loc 1 408 17 discriminator 1 view .LVU454
 1451 01f2 0FF00FC8 		le	lr, .L65
 1452              	.LBE241:
 1453              	.LBE242:
1121:Src/app.c     **** 
 1454              		.loc 1 1121 7 view .LVU455
 1455              	.LVL105:
 1456              	.LBB243:
 1457              	.LBI243:
 451:Src/app.c     **** {
 1458              		.loc 1 451 13 view .LVU456
 1459              	.LBB244:
 453:Src/app.c     ****   const float shift_y = -0.5;
 1460              		.loc 1 453 3 view .LVU457
 454:Src/app.c     ****   const float scale = 2.6;
 1461              		.loc 1 454 3 view .LVU458
 455:Src/app.c     **** 
 1462              		.loc 1 455 3 view .LVU459
 457:Src/app.c     ****   roi->cy = box->y_center;
 1463              		.loc 1 457 3 view .LVU460
 458:Src/app.c     ****   roi->w = box->width;
 1464              		.loc 1 458 3 view .LVU461
 459:Src/app.c     ****   roi->h = box->height;
 1465              		.loc 1 459 3 view .LVU462
 460:Src/app.c     ****   roi->rotation = pd_compute_rotation(box);
 1466              		.loc 1 460 3 view .LVU463
 461:Src/app.c     **** 
 1467              		.loc 1 461 3 view .LVU464
 1468              	.LBB245:
 1469              	.LBI245:
 372:Src/app.c     **** {
 1470              		.loc 1 372 14 view .LVU465
 1471              	.LBB246:
 374:Src/app.c     ****   float rotation;
 1472              		.loc 1 374 3 view .LVU466
 375:Src/app.c     **** 
 1473              		.loc 1 375 3 view .LVU467
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1474              		.loc 1 377 3 view .LVU468
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1475              		.loc 1 377 6 is_stmt 0 view .LVU469
 1476 01f6 0023     		movs	r3, #0
 1477 01f8 1B68     		ldr	r3, [r3]	@ float
 1478 01fa FFDE     		.inst	0xdeff
 1479              	.LVL106:
 1480              	.L64:
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1481              		.loc 1 377 6 view .LVU470
 1482              	.LBE246:
 1483              	.LBE245:
 1484              	.LBE244:
ARM GAS  /tmp/ccbfgvbk.s 			page 86


 1485              	.LBE243:
 1486              	.LBE247:
1108:Src/app.c     ****   {
 1487              		.loc 1 1108 42 is_stmt 1 discriminator 2 view .LVU471
 1488 01fc 0130     		adds	r0, r0, #1
 1489              	.LVL107:
1108:Src/app.c     ****   {
 1490              		.loc 1 1108 42 is_stmt 0 discriminator 2 view .LVU472
 1491 01fe CBE7     		b	.L63
 1492              	.LVL108:
 1493              	.L67:
1108:Src/app.c     ****   {
 1494              		.loc 1 1108 42 discriminator 2 view .LVU473
 1495              	.LBE248:
 1496              	.LBE250:
 1497              	.LBE252:
 1498              	.LBE258:
1646:Src/app.c     ****       /* --- Hand landmarking is disabled for this test --- */
 1499              		.loc 1 1646 5 is_stmt 1 view .LVU474
1651:Src/app.c     ****     }
 1500              		.loc 1 1651 7 view .LVU475
1653:Src/app.c     **** 
 1501              		.loc 1 1653 5 view .LVU476
1656:Src/app.c     ****     assert(ret == pdTRUE);
 1502              		.loc 1 1656 5 view .LVU477
1656:Src/app.c     ****     assert(ret == pdTRUE);
 1503              		.loc 1 1656 11 is_stmt 0 view .LVU478
 1504 0200 274D     		ldr	r5, .L80+64
 1505 0202 4FF0FF31 		mov	r1, #-1
 1506 0206 686D     		ldr	r0, [r5, #84]
 1507 0208 FFF7FEFF 		bl	xQueueSemaphoreTake
 1508              	.LVL109:
1657:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
 1509              		.loc 1 1657 5 is_stmt 1 view .LVU479
 1510 020c 0128     		cmp	r0, #1
 1511 020e 04D0     		beq	.L68
1657:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
 1512              		.loc 1 1657 5 is_stmt 0 discriminator 1 view .LVU480
 1513 0210 40F27961 		movw	r1, #1657
 1514 0214 184B     		ldr	r3, .L80+24
 1515 0216 144A     		ldr	r2, .L80+8
 1516 0218 20E7     		b	.L79
 1517              	.L68:
1658:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1518              		.loc 1 1658 5 is_stmt 1 view .LVU481
1658:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1519              		.loc 1 1658 21 is_stmt 0 discriminator 4 view .LVU482
 1520 021a 0026     		movs	r6, #0
1672:Src/app.c     ****     assert(ret == pdTRUE);
 1521              		.loc 1 1672 11 view .LVU483
 1522 021c 686D     		ldr	r0, [r5, #84]
 1523              	.LVL110:
1672:Src/app.c     ****     assert(ret == pdTRUE);
 1524              		.loc 1 1672 11 view .LVU484
 1525 021e 3346     		mov	r3, r6
 1526 0220 3246     		mov	r2, r6
 1527 0222 3146     		mov	r1, r6
ARM GAS  /tmp/ccbfgvbk.s 			page 87


1660:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
 1528              		.loc 1 1660 28 view .LVU485
 1529 0224 85ED2A8A 		vstr.32	s16, [r5, #168]
1658:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1530              		.loc 1 1658 21 discriminator 4 view .LVU486
 1531 0228 C5F8AC60 		str	r6, [r5, #172]
1659:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
 1532              		.loc 1 1659 5 is_stmt 1 view .LVU487
1659:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
 1533              		.loc 1 1659 21 is_stmt 0 view .LVU488
 1534 022c C5F8B460 		str	r6, [r5, #180]
1660:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
 1535              		.loc 1 1660 5 is_stmt 1 view .LVU489
1661:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
 1536              		.loc 1 1661 5 view .LVU490
1661:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
 1537              		.loc 1 1661 26 is_stmt 0 view .LVU491
 1538 0230 C5F8C860 		str	r6, [r5, #200]
1662:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
 1539              		.loc 1 1662 5 is_stmt 1 view .LVU492
1662:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
 1540              		.loc 1 1662 27 is_stmt 0 view .LVU493
 1541 0234 C5F8D080 		str	r8, [r5, #208]	@ float
1663:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
 1542              		.loc 1 1663 5 is_stmt 1 view .LVU494
1663:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
 1543              		.loc 1 1663 33 is_stmt 0 view .LVU495
 1544 0238 C5F8D460 		str	r6, [r5, #212]
1665:Src/app.c     ****     {
 1545              		.loc 1 1665 5 is_stmt 1 view .LVU496
1672:Src/app.c     ****     assert(ret == pdTRUE);
 1546              		.loc 1 1672 5 view .LVU497
1672:Src/app.c     ****     assert(ret == pdTRUE);
 1547              		.loc 1 1672 11 is_stmt 0 view .LVU498
 1548 023c FFF7FEFF 		bl	xQueueGenericSend
 1549              	.LVL111:
1673:Src/app.c     **** 
 1550              		.loc 1 1673 5 is_stmt 1 view .LVU499
 1551 0240 0128     		cmp	r0, #1
 1552 0242 04D0     		beq	.L69
1673:Src/app.c     **** 
 1553              		.loc 1 1673 5 is_stmt 0 discriminator 1 view .LVU500
 1554 0244 40F28961 		movw	r1, #1673
 1555 0248 0B4B     		ldr	r3, .L80+24
 1556 024a 074A     		ldr	r2, .L80+8
 1557 024c 06E7     		b	.L79
 1558              	.L69:
1676:Src/app.c     ****   }
 1559              		.loc 1 1676 5 is_stmt 1 view .LVU501
 1560 024e 2868     		ldr	r0, [r5]
 1561              	.LVL112:
1676:Src/app.c     ****   }
 1562              		.loc 1 1676 5 is_stmt 0 view .LVU502
 1563 0250 3346     		mov	r3, r6
 1564 0252 3246     		mov	r2, r6
 1565 0254 3146     		mov	r1, r6
 1566 0256 FFF7FEFF 		bl	xQueueGenericSend
ARM GAS  /tmp/ccbfgvbk.s 			page 88


 1567              	.LVL113:
 1568              	.LBE261:
1613:Src/app.c     ****   {
 1569              		.loc 1 1613 9 is_stmt 1 view .LVU503
 1570              	.LBB262:
1619:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1571              		.loc 1 1619 18 is_stmt 0 discriminator 1 view .LVU504
 1572 025a 3D46     		mov	r5, r7
 1573              	.LBE262:
1614:Src/app.c     ****     uint8_t *capture_buffer;
 1574              		.loc 1 1614 3 view .LVU505
 1575 025c 1FE7     		b	.L70
 1576              	.L81:
 1577 025e 00BF     		.align	2
 1578              	.L80:
 1579 0260 00000000 		.word	nn_input_queue
 1580 0264 00000000 		.word	.LC4
 1581 0268 00000000 		.word	__func__.9
 1582 026c 0E000000 		.word	.LC2
 1583 0270 00000000 		.word	0
 1584 0274 0000803D 		.word	1031798784
 1585 0278 00000000 		.word	.LC1
 1586 027c 00000000 		.word	__func__.8
 1587 0280 0C000000 		.word	.LC5
 1588 0284 1B000000 		.word	.LC6
 1589 0288 00000000 		.word	__func__.7
 1590 028c 00ED00E0 		.word	-536810240
 1591 0290 3A000000 		.word	.LC7
 1592 0294 00000000 		.word	NN_Instance_face_landmark
 1593 0298 00000000 		.word	__func__.6
 1594 029c 00004844 		.word	1145569280
 1595 02a0 00000000 		.word	disp
 1596 02a4 00000000 		.word	frame_event_nb_for_resize
 1597 02a8 00000000 		.word	NN_Instance_yolo_detector
 1598              		.cfi_endproc
 1599              	.LFE7405:
 1601              		.section	.text.display_hand,"ax",%progbits
 1602              		.align	1
 1603              		.global	display_hand
 1604              		.syntax unified
 1605              		.thumb
 1606              		.thumb_func
 1608              	display_hand:
 1609              	.LVL114:
 1610              	.LFB7389:
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1611              		.loc 1 962 1 is_stmt 1 view -0
 1612              		.cfi_startproc
 1613              		@ args = 0, pretend = 0, frame = 72
 1614              		@ frame_needed = 0, uses_anonymous_args = 0
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1615              		.loc 1 963 3 view .LVU507
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1616              		.loc 1 962 1 is_stmt 0 view .LVU508
 1617 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1618              		.cfi_def_cfa_offset 32
 1619              		.cfi_offset 4, -32
ARM GAS  /tmp/ccbfgvbk.s 			page 89


 1620              		.cfi_offset 5, -28
 1621              		.cfi_offset 6, -24
 1622              		.cfi_offset 7, -20
 1623              		.cfi_offset 8, -16
 1624              		.cfi_offset 9, -12
 1625              		.cfi_offset 10, -8
 1626              		.cfi_offset 14, -4
 1627 0004 2DED048B 		vpush.64	{d8, d9}
 1628              		.cfi_def_cfa_offset 48
 1629              		.cfi_offset 80, -48
 1630              		.cfi_offset 81, -44
 1631              		.cfi_offset 82, -40
 1632              		.cfi_offset 83, -36
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1633              		.loc 1 963 6 view .LVU509
 1634 0008 C369     		ldr	r3, [r0, #28]
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1635              		.loc 1 962 1 view .LVU510
 1636 000a 0546     		mov	r5, r0
 1637 000c 0C46     		mov	r4, r1
 1638 000e 94B0     		sub	sp, sp, #80
 1639              		.cfi_def_cfa_offset 128
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1640              		.loc 1 963 6 view .LVU511
 1641 0010 002B     		cmp	r3, #0
 1642 0012 00F0FD80 		beq	.L83
 964:Src/app.c     ****     display_roi(&hand->roi);
 1643              		.loc 1 964 5 is_stmt 1 view .LVU512
 1644              	.LVL115:
 1645              	.LBB274:
 1646              	.LBI274:
 792:Src/app.c     **** {
 1647              		.loc 1 792 13 view .LVU513
 1648              	.LBB275:
 794:Src/app.c     ****   int x0, y0;
 1649              		.loc 1 794 3 view .LVU514
 795:Src/app.c     ****   int x1, y1;
 1650              		.loc 1 795 3 view .LVU515
 796:Src/app.c     ****   int w, h;
 1651              		.loc 1 796 3 view .LVU516
 797:Src/app.c     ****   int i;
 1652              		.loc 1 797 3 view .LVU517
 798:Src/app.c     **** 
 1653              		.loc 1 798 3 view .LVU518
 801:Src/app.c     ****   yc = (int)hand->y_center;
 1654              		.loc 1 801 3 view .LVU519
 801:Src/app.c     ****   yc = (int)hand->y_center;
 1655              		.loc 1 801 6 is_stmt 0 view .LVU520
 1656 0016 D1ED027A 		vldr.32	s15, [r1, #8]
 1657 001a FDEEE77A 		vcvt.s32.f32	s15, s15
 1658 001e 17EE900A 		vmov	r0, s15	@ int
 1659              	.LVL116:
 802:Src/app.c     ****   w = (int)hand->width;
 1660              		.loc 1 802 3 is_stmt 1 view .LVU521
 802:Src/app.c     ****   w = (int)hand->width;
 1661              		.loc 1 802 6 is_stmt 0 view .LVU522
 1662 0022 D1ED037A 		vldr.32	s15, [r1, #12]
ARM GAS  /tmp/ccbfgvbk.s 			page 90


 1663 0026 FDEEE77A 		vcvt.s32.f32	s15, s15
 1664 002a 17EE901A 		vmov	r1, s15	@ int
 1665              	.LVL117:
 803:Src/app.c     ****   h = (int)hand->height;
 1666              		.loc 1 803 3 is_stmt 1 view .LVU523
 804:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 1667              		.loc 1 804 3 view .LVU524
 804:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 1668              		.loc 1 804 5 is_stmt 0 view .LVU525
 1669 002e D4ED057A 		vldr.32	s15, [r4, #20]
 1670 0032 FDEEE77A 		vcvt.s32.f32	s15, s15
 1671 0036 17EE903A 		vmov	r3, s15	@ int
 1672              	.LVL118:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1673              		.loc 1 805 3 is_stmt 1 view .LVU526
 803:Src/app.c     ****   h = (int)hand->height;
 1674              		.loc 1 803 5 is_stmt 0 view .LVU527
 1675 003a D4ED047A 		vldr.32	s15, [r4, #16]
 1676 003e FDEEE77A 		vcvt.s32.f32	s15, s15
 1677 0042 17EE902A 		vmov	r2, s15	@ int
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1678              		.loc 1 805 16 view .LVU528
 1679 0046 0132     		adds	r2, r2, #1
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1680              		.loc 1 805 21 view .LVU529
 1681 0048 02EBD272 		add	r2, r2, r2, lsr #31
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1682              		.loc 1 806 16 view .LVU530
 1683 004c 0133     		adds	r3, r3, #1
 1684              	.LVL119:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1685              		.loc 1 805 21 view .LVU531
 1686 004e 5210     		asrs	r2, r2, #1
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1687              		.loc 1 806 21 view .LVU532
 1688 0050 03EBD373 		add	r3, r3, r3, lsr #31
 1689              	.LVL120:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1690              		.loc 1 805 21 view .LVU533
 1691 0054 5242     		rsbs	r2, r2, #0
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1692              		.loc 1 806 21 view .LVU534
 1693 0056 5B10     		asrs	r3, r3, #1
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1694              		.loc 1 805 11 view .LVU535
 1695 0058 8618     		adds	r6, r0, r2
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1696              		.loc 1 806 21 view .LVU536
 1697 005a 5B42     		rsbs	r3, r3, #0
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1698              		.loc 1 807 6 view .LVU537
 1699 005c 801A     		subs	r0, r0, r2
 1700              	.LVL121:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1701              		.loc 1 805 6 view .LVU538
 1702 005e 0296     		str	r6, [sp, #8]
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
ARM GAS  /tmp/ccbfgvbk.s 			page 91


 1703              		.loc 1 806 3 is_stmt 1 view .LVU539
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1704              		.loc 1 806 11 is_stmt 0 view .LVU540
 1705 0060 CE18     		adds	r6, r1, r3
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1706              		.loc 1 808 6 view .LVU541
 1707 0062 C91A     		subs	r1, r1, r3
 1708              	.LVL122:
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1709              		.loc 1 807 6 view .LVU542
 1710 0064 0490     		str	r0, [sp, #16]
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1711              		.loc 1 808 6 view .LVU543
 1712 0066 0C91     		str	r1, [sp, #48]
 809:Src/app.c     ****   clamp_point(&x1, &y1);
 1713              		.loc 1 809 3 view .LVU544
 1714 0068 02A8     		add	r0, sp, #8
 1715 006a 03A9     		add	r1, sp, #12
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1716              		.loc 1 806 6 view .LVU545
 1717 006c 0396     		str	r6, [sp, #12]
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1718              		.loc 1 807 3 is_stmt 1 view .LVU546
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1719              		.loc 1 808 3 view .LVU547
 809:Src/app.c     ****   clamp_point(&x1, &y1);
 1720              		.loc 1 809 3 view .LVU548
 1721 006e FFF7FEFF 		bl	clamp_point
 1722              	.LVL123:
 810:Src/app.c     ****   UTIL_LCD_DrawRect(x0, y0, x1 - x0, y1 - y0, UTIL_LCD_COLOR_GREEN);
 1723              		.loc 1 810 3 view .LVU549
 1724 0072 0CA9     		add	r1, sp, #48
 1725 0074 04A8     		add	r0, sp, #16
 1726 0076 FFF7FEFF 		bl	clamp_point
 1727              	.LVL124:
 811:Src/app.c     **** 
 1728              		.loc 1 811 3 view .LVU550
 1729 007a DDE90201 		ldrd	r0, r1, [sp, #8]
 1730 007e 4FF0FF23 		mov	r3, #-16711936
 1731 0082 049A     		ldr	r2, [sp, #16]
 1732 0084 0093     		str	r3, [sp]
 1733 0086 0C9B     		ldr	r3, [sp, #48]
 1734 0088 121A     		subs	r2, r2, r0
 1735 008a 5B1A     		subs	r3, r3, r1
 1736 008c FFF7FEFF 		bl	UTIL_LCD_DrawRect
 1737              	.LVL125:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1738              		.loc 1 814 3 view .LVU551
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1739              		.loc 1 814 17 discriminator 1 view .LVU552
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1740              		.loc 1 814 10 is_stmt 0 view .LVU553
 1741 0090 0026     		movs	r6, #0
 1742              	.LBB276:
 815:Src/app.c     **** 
 1743              		.loc 1 815 62 discriminator 3 view .LVU554
 1744 0092 DFF8A081 		ldr	r8, .L103+4
ARM GAS  /tmp/ccbfgvbk.s 			page 92


 1745 0096 664F     		ldr	r7, .L103
 1746              	.LVL126:
 1747              	.L85:
 815:Src/app.c     **** 
 1748              		.loc 1 815 5 is_stmt 1 view .LVU555
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1749              		.loc 1 817 25 is_stmt 0 view .LVU556
 1750 0098 A269     		ldr	r2, [r4, #24]
 815:Src/app.c     **** 
 1751              		.loc 1 815 62 discriminator 3 view .LVU557
 1752 009a 36F00203 		bics	r3, r6, #2
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1753              		.loc 1 817 25 view .LVU558
 1754 009e 02EBC602 		add	r2, r2, r6, lsl #3
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1755              		.loc 1 817 10 view .LVU559
 1756 00a2 D2ED007A 		vldr.32	s15, [r2]
 1757 00a6 FDEEE77A 		vcvt.s32.f32	s15, s15
 1758 00aa CDED027A 		vstr.32	s15, [sp, #8]	@ int
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1759              		.loc 1 818 10 view .LVU560
 1760 00ae D2ED017A 		vldr.32	s15, [r2, #4]
 815:Src/app.c     **** 
 1761              		.loc 1 815 62 discriminator 3 view .LVU561
 1762 00b2 0CBF     		ite	eq
 1763 00b4 C146     		moveq	r9, r8
 1764 00b6 B946     		movne	r9, r7
 1765              	.LVL127:
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1766              		.loc 1 817 5 is_stmt 1 view .LVU562
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1767              		.loc 1 818 5 view .LVU563
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1768              		.loc 1 818 10 is_stmt 0 view .LVU564
 1769 00b8 FDEEE77A 		vcvt.s32.f32	s15, s15
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1770              		.loc 1 819 5 view .LVU565
 1771 00bc 03A9     		add	r1, sp, #12
 1772 00be 02A8     		add	r0, sp, #8
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1773              		.loc 1 818 10 view .LVU566
 1774 00c0 CDED037A 		vstr.32	s15, [sp, #12]	@ int
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1775              		.loc 1 819 5 is_stmt 1 view .LVU567
 1776              	.LBE276:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1777              		.loc 1 814 23 is_stmt 0 discriminator 2 view .LVU568
 1778 00c4 0136     		adds	r6, r6, #1
 1779              	.LVL128:
 1780              	.LBB277:
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1781              		.loc 1 819 5 view .LVU569
 1782 00c6 FFF7FEFF 		bl	clamp_point
 1783              	.LVL129:
 820:Src/app.c     ****   }
 1784              		.loc 1 820 5 is_stmt 1 view .LVU570
 1785 00ca DDE90201 		ldrd	r0, r1, [sp, #8]
ARM GAS  /tmp/ccbfgvbk.s 			page 93


 1786 00ce 4B46     		mov	r3, r9
 1787 00d0 0222     		movs	r2, #2
 1788 00d2 FFF7FEFF 		bl	UTIL_LCD_FillCircle
 1789              	.LVL130:
 1790              	.LBE277:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1791              		.loc 1 814 23 discriminator 2 view .LVU571
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1792              		.loc 1 814 17 discriminator 1 view .LVU572
 1793 00d6 072E     		cmp	r6, #7
 1794 00d8 DED1     		bne	.L85
 1795              	.LVL131:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1796              		.loc 1 814 17 is_stmt 0 discriminator 1 view .LVU573
 1797              	.LBE275:
 1798              	.LBE274:
 965:Src/app.c     ****   }
 1799              		.loc 1 965 5 is_stmt 1 view .LVU574
 1800              	.LBB278:
 1801              	.LBI278:
 882:Src/app.c     **** {
 1802              		.loc 1 882 13 view .LVU575
 1803              	.LBB279:
 884:Src/app.c     ****   int corners[4][2];
 1804              		.loc 1 884 3 view .LVU576
 885:Src/app.c     ****   int is_clamp;
 1805              		.loc 1 885 3 view .LVU577
 886:Src/app.c     ****   int i;
 1806              		.loc 1 886 3 view .LVU578
 887:Src/app.c     **** 
 1807              		.loc 1 887 3 view .LVU579
 890:Src/app.c     **** 
 1808              		.loc 1 890 3 view .LVU580
 1809              	.LBB280:
 1810              	.LBI280:
 839:Src/app.c     **** {
 1811              		.loc 1 839 13 view .LVU581
 1812              	.LBB281:
 841:Src/app.c     ****     {-roi->w / 2, -roi->h / 2},
 1813              		.loc 1 841 3 view .LVU582
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1814              		.loc 1 842 14 is_stmt 0 view .LVU583
 1815 00da F6EE006A 		vmov.f32	s13, #5.0e-1
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1816              		.loc 1 842 6 view .LVU584
 1817 00de D4ED097A 		vldr.32	s15, [r4, #36]
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1818              		.loc 1 842 19 view .LVU585
 1819 00e2 94ED0A7A 		vldr.32	s14, [r4, #40]
 1820              	.LBB282:
 1821              	.LBB283:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1822              		.loc 1 832 11 view .LVU586
 1823 00e6 94ED0B9A 		vldr.32	s18, [r4, #44]
 1824              	.LBE283:
 1825              	.LBE282:
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
ARM GAS  /tmp/ccbfgvbk.s 			page 94


 1826              		.loc 1 842 14 view .LVU587
 1827 00ea 67EEE67A 		vnmul.f32	s15, s15, s13
 1828              	.LVL132:
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1829              		.loc 1 842 27 view .LVU588
 1830 00ee 27EE667A 		vnmul.f32	s14, s14, s13
 1831              	.LVL133:
 1832              	.LBB289:
 1833              	.LBB284:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1834              		.loc 1 832 11 view .LVU589
 1835 00f2 B7EEC99A 		vcvt.f64.f32	d9, s18
 1836 00f6 B1EE676A 		vneg.f32	s12, s15
 1837              	.LVL134:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1838              		.loc 1 832 11 view .LVU590
 1839 00fa F1EE476A 		vneg.f32	s13, s14
 1840              	.LVL135:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1841              		.loc 1 832 11 view .LVU591
 1842              	.LBE284:
 1843              	.LBE289:
 847:Src/app.c     **** 
 1844              		.loc 1 847 3 is_stmt 1 view .LVU592
 849:Src/app.c     ****   /* rotate */
 1845              		.loc 1 849 3 view .LVU593
 1846              	.LBB290:
 1847              	.LBB285:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1848              		.loc 1 832 11 is_stmt 0 view .LVU594
 1849 00fe B0EE490B 		vmov.f64	d0, d9
 1850              	.LBE285:
 1851              	.LBE290:
 849:Src/app.c     ****   /* rotate */
 1852              		.loc 1 849 3 view .LVU595
 1853 0102 CDED047A 		vstr.32	s15, [sp, #16]
 1854 0106 8DED057A 		vstr.32	s14, [sp, #20]
 1855 010a 8DED066A 		vstr.32	s12, [sp, #24]
 1856 010e 8DED077A 		vstr.32	s14, [sp, #28]
 1857 0112 8DED086A 		vstr.32	s12, [sp, #32]
 1858 0116 CDED096A 		vstr.32	s13, [sp, #36]
 1859 011a CDED0A7A 		vstr.32	s15, [sp, #40]
 1860 011e CDED0B6A 		vstr.32	s13, [sp, #44]
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1861              		.loc 1 851 3 is_stmt 1 view .LVU596
 1862              	.LVL136:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1863              		.loc 1 851 17 discriminator 1 view .LVU597
 1864              	.LBB291:
 1865              	.LBB286:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1866              		.loc 1 832 11 is_stmt 0 view .LVU598
 1867 0122 FFF7FEFF 		bl	cos
 1868              	.LVL137:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1869              		.loc 1 832 11 view .LVU599
 1870 0126 B0EE408B 		vmov.f64	d8, d0
ARM GAS  /tmp/ccbfgvbk.s 			page 95


 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1871              		.loc 1 832 31 discriminator 1 view .LVU600
 1872 012a B0EE490B 		vmov.f64	d0, d9
 1873 012e FFF7FEFF 		bl	sin
 1874              	.LVL138:
 1875              	.LBE286:
 1876              	.LBE291:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1877              		.loc 1 851 10 view .LVU601
 1878 0132 4FF0040E 		mov	lr, #4
 1879 0136 0DF11009 		add	r9, sp, #16
 1880              	.LVL139:
 1881              	.LBB292:
 1882              	.LBB287:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1883              		.loc 1 832 31 discriminator 1 view .LVU602
 1884 013a 4B46     		mov	r3, r9
 1885              	.LBE287:
 1886              	.LBE292:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1887              		.loc 1 851 10 view .LVU603
 1888 013c 4EF001E0 		dls	lr, lr
 1889              	.LVL140:
 1890              	.L86:
 852:Src/app.c     **** 
 1891              		.loc 1 852 5 is_stmt 1 view .LVU604
 1892              	.LBB293:
 1893              	.LBI282:
 827:Src/app.c     **** {
 1894              		.loc 1 827 13 view .LVU605
 1895              	.LBB288:
 829:Src/app.c     ****   float y = pt[1];
 1896              		.loc 1 829 3 view .LVU606
 830:Src/app.c     **** 
 1897              		.loc 1 830 3 view .LVU607
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1898              		.loc 1 832 3 view .LVU608
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1899              		.loc 1 832 45 is_stmt 0 discriminator 2 view .LVU609
 1900 0140 93ED017A 		vldr.32	s14, [r3, #4]
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1901              		.loc 1 832 25 discriminator 1 view .LVU610
 1902 0144 93ED005A 		vldr.32	s10, [r3]
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1903              		.loc 1 832 45 discriminator 2 view .LVU611
 1904 0148 B7EEC77A 		vcvt.f64.f32	d7, s14
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1905              		.loc 1 832 25 discriminator 1 view .LVU612
 1906 014c B7EEC55A 		vcvt.f64.f32	d5, s10
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1907              		.loc 1 832 29 discriminator 2 view .LVU613
 1908 0150 27EE406B 		vnmul.f64	d6, d7, d0
 833:Src/app.c     **** }
 1909              		.loc 1 833 45 discriminator 2 view .LVU614
 1910 0154 28EE077B 		vmul.f64	d7, d8, d7
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1911              		.loc 1 832 29 discriminator 2 view .LVU615
ARM GAS  /tmp/ccbfgvbk.s 			page 96


 1912 0158 A8EE056B 		vfma.f64	d6, d8, d5
 833:Src/app.c     **** }
 1913              		.loc 1 833 29 discriminator 2 view .LVU616
 1914 015c A5EE007B 		vfma.f64	d7, d5, d0
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1915              		.loc 1 832 29 discriminator 2 view .LVU617
 1916 0160 B7EEC66B 		vcvt.f32.f64	s12, d6
 833:Src/app.c     **** }
 1917              		.loc 1 833 29 discriminator 2 view .LVU618
 1918 0164 B7EEC77B 		vcvt.f32.f64	s14, d7
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1919              		.loc 1 832 29 discriminator 2 view .LVU619
 1920 0168 83ED006A 		vstr.32	s12, [r3]
 1921              	.LVL141:
 833:Src/app.c     **** }
 1922              		.loc 1 833 3 is_stmt 1 view .LVU620
 833:Src/app.c     **** }
 1923              		.loc 1 833 29 is_stmt 0 discriminator 2 view .LVU621
 1924 016c 83ED017A 		vstr.32	s14, [r3, #4]
 1925              	.LVL142:
 833:Src/app.c     **** }
 1926              		.loc 1 833 29 discriminator 2 view .LVU622
 1927              	.LBE288:
 1928              	.LBE293:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1929              		.loc 1 851 23 is_stmt 1 discriminator 3 view .LVU623
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 1930              		.loc 1 851 17 discriminator 1 view .LVU624
 1931 0170 0833     		adds	r3, r3, #8
 1932 0172 0FF01BC8 		le	lr, .L86
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1933              		.loc 1 855 10 is_stmt 0 view .LVU625
 1934 0176 4FF0040E 		mov	lr, #4
 856:Src/app.c     ****     corners[i][1] += roi->cy;
 1935              		.loc 1 856 25 view .LVU626
 1936 017a D4ED076A 		vldr.32	s13, [r4, #28]
 857:Src/app.c     ****   }
 1937              		.loc 1 857 25 view .LVU627
 1938 017e 94ED087A 		vldr.32	s14, [r4, #32]
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1939              		.loc 1 855 10 view .LVU628
 1940 0182 4EF001E0 		dls	lr, lr
 857:Src/app.c     ****   }
 1941              		.loc 1 857 25 view .LVU629
 1942 0186 04AB     		add	r3, sp, #16
 1943              	.L87:
 856:Src/app.c     ****     corners[i][1] += roi->cy;
 1944              		.loc 1 856 5 is_stmt 1 view .LVU630
 856:Src/app.c     ****     corners[i][1] += roi->cy;
 1945              		.loc 1 856 19 is_stmt 0 view .LVU631
 1946 0188 D3ED007A 		vldr.32	s15, [r3]
 1947 018c 77EEA67A 		vadd.f32	s15, s15, s13
 1948 0190 C3ED007A 		vstr.32	s15, [r3]
 857:Src/app.c     ****   }
 1949              		.loc 1 857 5 is_stmt 1 view .LVU632
 857:Src/app.c     ****   }
 1950              		.loc 1 857 19 is_stmt 0 view .LVU633
ARM GAS  /tmp/ccbfgvbk.s 			page 97


 1951 0194 D3ED017A 		vldr.32	s15, [r3, #4]
 1952 0198 77EE877A 		vadd.f32	s15, s15, s14
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1953              		.loc 1 855 17 discriminator 1 view .LVU634
 1954 019c 0833     		adds	r3, r3, #8
 857:Src/app.c     ****   }
 1955              		.loc 1 857 19 view .LVU635
 1956 019e 43ED017A 		vstr.32	s15, [r3, #-4]
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1957              		.loc 1 855 23 is_stmt 1 discriminator 3 view .LVU636
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1958              		.loc 1 855 17 discriminator 1 view .LVU637
 1959 01a2 0FF00FC8 		le	lr, .L87
 1960              	.LBE281:
 1961              	.LBE280:
 1962              	.LBB295:
 1963              	.LBB296:
 866:Src/app.c     ****   int i;
 1964              		.loc 1 866 7 is_stmt 0 view .LVU638
 1965 01a6 0026     		movs	r6, #0
 866:Src/app.c     ****   int i;
 1966              		.loc 1 866 7 view .LVU639
 1967 01a8 0CAF     		add	r7, sp, #48
 1968              	.LBE296:
 1969              	.LBE295:
 1970              	.LBB298:
 1971              	.LBB294:
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 1972              		.loc 1 855 17 discriminator 1 view .LVU640
 1973 01aa B846     		mov	r8, r7
 1974              	.LBE294:
 1975              	.LBE298:
 1976              	.LBB299:
 1977              	.LBB297:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 1978              		.loc 1 869 10 view .LVU641
 1979 01ac B246     		mov	r10, r6
 1980              	.LVL143:
 1981              	.L88:
 870:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 1982              		.loc 1 870 5 is_stmt 1 view .LVU642
 870:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 1983              		.loc 1 870 25 is_stmt 0 view .LVU643
 1984 01ae D9ED007A 		vldr.32	s15, [r9]
 1985 01b2 FDEEE77A 		vcvt.s32.f32	s15, s15
 1986 01b6 C8ED007A 		vstr.32	s15, [r8]	@ int
 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 1987              		.loc 1 871 5 is_stmt 1 view .LVU644
 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 1988              		.loc 1 871 25 is_stmt 0 view .LVU645
 1989 01ba D9ED017A 		vldr.32	s15, [r9, #4]
 1990 01be FDEEE77A 		vcvt.s32.f32	s15, s15
 1991 01c2 4146     		mov	r1, r8
 1992 01c4 17EE903A 		vmov	r3, s15	@ int
 872:Src/app.c     ****   }
 1993              		.loc 1 872 17 view .LVU646
 1994 01c8 4046     		mov	r0, r8
ARM GAS  /tmp/ccbfgvbk.s 			page 98


 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 1995              		.loc 1 871 25 view .LVU647
 1996 01ca 41F8043F 		str	r3, [r1, #4]!
 872:Src/app.c     ****   }
 1997              		.loc 1 872 5 is_stmt 1 view .LVU648
 872:Src/app.c     ****   }
 1998              		.loc 1 872 17 is_stmt 0 view .LVU649
 1999 01ce FFF7FEFF 		bl	clamp_point
 2000              	.LVL144:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2001              		.loc 1 869 23 discriminator 3 view .LVU650
 2002 01d2 0AF1010A 		add	r10, r10, #1
 2003              	.LVL145:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2004              		.loc 1 869 17 discriminator 1 view .LVU651
 2005 01d6 BAF1040F 		cmp	r10, #4
 872:Src/app.c     ****   }
 2006              		.loc 1 872 14 discriminator 1 view .LVU652
 2007 01da 46EA0006 		orr	r6, r6, r0
 2008              	.LVL146:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2009              		.loc 1 869 23 is_stmt 1 discriminator 3 view .LVU653
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2010              		.loc 1 869 17 discriminator 1 view .LVU654
 2011 01de 09F10809 		add	r9, r9, #8
 2012 01e2 08F10808 		add	r8, r8, #8
 2013 01e6 E2D1     		bne	.L88
 875:Src/app.c     **** }
 2014              		.loc 1 875 3 view .LVU655
 2015              	.LVL147:
 875:Src/app.c     **** }
 2016              		.loc 1 875 3 is_stmt 0 view .LVU656
 2017              	.LBE297:
 2018              	.LBE299:
 894:Src/app.c     ****     return ;
 2019              		.loc 1 894 3 is_stmt 1 view .LVU657
 894:Src/app.c     ****     return ;
 2020              		.loc 1 894 6 is_stmt 0 view .LVU658
 2021 01e8 96B9     		cbnz	r6, .L83
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2022              		.loc 1 899 5 view .LVU659
 2023 01ea DFF84480 		ldr	r8, .L103
 2024              	.LVL148:
 2025              	.L89:
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2026              		.loc 1 899 5 is_stmt 1 view .LVU660
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2027              		.loc 1 899 64 is_stmt 0 view .LVU661
 2028 01ee 0136     		adds	r6, r6, #1
 2029              	.LVL149:
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2030              		.loc 1 899 98 view .LVU662
 2031 01f0 14AB     		add	r3, sp, #80
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2032              		.loc 1 899 69 view .LVU663
 2033 01f2 06F00302 		and	r2, r6, #3
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
ARM GAS  /tmp/ccbfgvbk.s 			page 99


 2034              		.loc 1 899 5 view .LVU664
 2035 01f6 CDF80080 		str	r8, [sp]
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2036              		.loc 1 899 98 view .LVU665
 2037 01fa 03EBC202 		add	r2, r3, r2, lsl #3
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2038              		.loc 1 899 5 view .LVU666
 2039 01fe 7968     		ldr	r1, [r7, #4]
 2040 0200 52E90823 		ldrd	r2, r3, [r2, #-32]
 2041 0204 57F8080B 		ldr	r0, [r7], #8
 2042 0208 FFF7FEFF 		bl	UTIL_LCD_DrawLine
 2043              	.LVL150:
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2044              		.loc 1 898 23 is_stmt 1 discriminator 3 view .LVU667
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2045              		.loc 1 898 17 discriminator 1 view .LVU668
 2046 020c 042E     		cmp	r6, #4
 2047 020e EED1     		bne	.L89
 2048              	.LVL151:
 2049              	.L83:
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2050              		.loc 1 898 17 is_stmt 0 discriminator 1 view .LVU669
 2051              	.LBE279:
 2052              	.LBE278:
 967:Src/app.c     ****     display_ld_hand(hand);
 2053              		.loc 1 967 3 is_stmt 1 view .LVU670
 967:Src/app.c     ****     display_ld_hand(hand);
 2054              		.loc 1 967 6 is_stmt 0 view .LVU671
 2055 0210 AB69     		ldr	r3, [r5, #24]
 2056 0212 3BB1     		cbz	r3, .L82
 968:Src/app.c     **** }
 2057              		.loc 1 968 5 is_stmt 1 view .LVU672
 2058 0214 2046     		mov	r0, r4
 969:Src/app.c     **** 
 2059              		.loc 1 969 1 is_stmt 0 view .LVU673
 2060 0216 14B0     		add	sp, sp, #80
 2061              		.cfi_remember_state
 2062              		.cfi_def_cfa_offset 48
 2063              		@ sp needed
 2064 0218 BDEC048B 		vldm	sp!, {d8-d9}
 2065              		.cfi_restore 82
 2066              		.cfi_restore 83
 2067              		.cfi_restore 80
 2068              		.cfi_restore 81
 2069              		.cfi_def_cfa_offset 32
 2070 021c BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 2071              		.cfi_restore 14
 2072              		.cfi_restore 10
 2073              		.cfi_restore 9
 2074              		.cfi_restore 8
 2075              		.cfi_restore 7
 2076              		.cfi_restore 6
 2077              		.cfi_restore 5
 2078              		.cfi_restore 4
 2079              		.cfi_def_cfa_offset 0
 2080              	.LVL152:
 968:Src/app.c     **** }
ARM GAS  /tmp/ccbfgvbk.s 			page 100


 2081              		.loc 1 968 5 view .LVU674
 2082 0220 FFF7FEBF 		b	display_ld_hand
 2083              	.LVL153:
 2084              	.L82:
 2085              		.cfi_restore_state
 969:Src/app.c     **** 
 2086              		.loc 1 969 1 view .LVU675
 2087 0224 14B0     		add	sp, sp, #80
 2088              		.cfi_def_cfa_offset 48
 2089              		@ sp needed
 2090 0226 BDEC048B 		vldm	sp!, {d8-d9}
 2091              		.cfi_restore 82
 2092              		.cfi_restore 83
 2093              		.cfi_restore 80
 2094              		.cfi_restore 81
 2095              		.cfi_def_cfa_offset 32
 2096 022a BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2097              	.LVL154:
 2098              	.L104:
 969:Src/app.c     **** 
 2099              		.loc 1 969 1 view .LVU676
 2100 022e 00BF     		.align	2
 2101              	.L103:
 2102 0230 0000FFFF 		.word	-65536
 2103 0234 FF0000FF 		.word	-16776961
 2104              		.cfi_endproc
 2105              	.LFE7389:
 2107              		.section	.rodata.dp_thread_fct.str1.1,"aMS",%progbits,1
 2108              	.LC8:
 2109 0000 72657420 		.ascii	"ret == HAL_OK\000"
 2109      3D3D2048 
 2109      414C5F4F 
 2109      4B00
 2110              		.global	__aeabi_ul2d
 2111              	.LC9:
 2112 000e 43707520 		.ascii	"Cpu load\000"
 2112      6C6F6164 
 2112      00
 2113              	.LC10:
 2114 0017 20202025 		.ascii	"   %.1f%%\000"
 2114      2E316625 
 2114      2500
 2115              	.LC11:
 2116 0021 496E6665 		.ascii	"Inferences\000"
 2116      72656E63 
 2116      657300
 2117              	.LC12:
 2118 002c 20706420 		.ascii	" pd %2ums\000"
 2118      2532756D 
 2118      7300
 2119              	.LC13:
 2120 0036 20686C20 		.ascii	" hl %2ums\000"
 2120      2532756D 
 2120      7300
 2121              	.LC14:
 2122 0040 2020252E 		.ascii	"  %.1f FPS\000"
 2122      31662046 
ARM GAS  /tmp/ccbfgvbk.s 			page 101


 2122      505300
 2123              		.section	.text.dp_thread_fct,"ax",%progbits
 2124              		.align	1
 2125              		.syntax unified
 2126              		.thumb
 2127              		.thumb_func
 2129              	dp_thread_fct:
 2130              	.LVL155:
 2131              	.LFB7410:
1746:Src/app.c     ****   button_t ld_toggle_button;
 2132              		.loc 1 1746 1 is_stmt 1 view -0
 2133              		.cfi_startproc
 2134              		@ args = 0, pretend = 0, frame = 4616
 2135              		@ frame_needed = 0, uses_anonymous_args = 0
1747:Src/app.c     ****   button_t hd_toggle_button;
 2136              		.loc 1 1747 3 view .LVU678
1748:Src/app.c     ****   uint32_t disp_ms = 0;
 2137              		.loc 1 1748 3 view .LVU679
1749:Src/app.c     ****   display_info_t info;
 2138              		.loc 1 1749 3 view .LVU680
1750:Src/app.c     ****   uint32_t ts;
 2139              		.loc 1 1750 3 view .LVU681
1751:Src/app.c     ****   int ret;
 2140              		.loc 1 1751 3 view .LVU682
1752:Src/app.c     **** 
 2141              		.loc 1 1752 3 view .LVU683
1755:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_TAMP, on_pd_toggle_button_click, &disp);
 2142              		.loc 1 1755 3 view .LVU684
1746:Src/app.c     ****   button_t ld_toggle_button;
 2143              		.loc 1 1746 1 is_stmt 0 view .LVU685
 2144 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2145              		.cfi_def_cfa_offset 36
 2146              		.cfi_offset 4, -36
 2147              		.cfi_offset 5, -32
 2148              		.cfi_offset 6, -28
 2149              		.cfi_offset 7, -24
 2150              		.cfi_offset 8, -20
 2151              		.cfi_offset 9, -16
 2152              		.cfi_offset 10, -12
 2153              		.cfi_offset 11, -8
 2154              		.cfi_offset 14, -4
 2155 0004 2DED048B 		vpush.64	{d8, d9}
 2156              		.cfi_def_cfa_offset 52
 2157              		.cfi_offset 80, -52
 2158              		.cfi_offset 81, -48
 2159              		.cfi_offset 82, -44
 2160              		.cfi_offset 83, -40
 2161              	.LBB330:
 2162              	.LBB331:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2163              		.loc 1 492 9 view .LVU686
 2164 0008 0021     		movs	r1, #0
 2165              	.LBE331:
 2166              	.LBE330:
1746:Src/app.c     ****   button_t ld_toggle_button;
 2167              		.loc 1 1746 1 view .LVU687
 2168 000a ADF5905D 		sub	sp, sp, #4608
ARM GAS  /tmp/ccbfgvbk.s 			page 102


 2169              		.cfi_def_cfa_offset 4660
 2170              	.LBB335:
 2171              	.LBB332:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2172              		.loc 1 492 9 view .LVU688
 2173 000e 0846     		mov	r0, r1
 2174              	.LVL156:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2175              		.loc 1 492 9 view .LVU689
 2176              	.LBE332:
 2177              	.LBE335:
1746:Src/app.c     ****   button_t ld_toggle_button;
 2178              		.loc 1 1746 1 view .LVU690
 2179 0010 85B0     		sub	sp, sp, #20
 2180              		.cfi_def_cfa_offset 4680
 2181              	.LVL157:
 2182              	.LBB336:
 2183              	.LBI330:
 488:Src/app.c     **** {
 2184              		.loc 1 488 13 is_stmt 1 view .LVU691
 2185              	.LBB333:
 490:Src/app.c     **** 
 2186              		.loc 1 490 3 view .LVU692
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2187              		.loc 1 492 3 view .LVU693
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2188              		.loc 1 492 9 is_stmt 0 view .LVU694
 2189 0012 FFF7FEFF 		bl	BSP_PB_Init
 2190              	.LVL158:
 493:Src/app.c     **** 
 2191              		.loc 1 493 3 is_stmt 1 view .LVU695
 2192 0016 0146     		mov	r1, r0
 2193 0018 08B1     		cbz	r0, .L106
 2194              	.LVL159:
 2195              	.L107:
 493:Src/app.c     **** 
 2196              		.loc 1 493 3 is_stmt 0 view .LVU696
 2197 001a FFF7FEFF 		bl	button_init.part.0
 2198              	.LVL160:
 2199              	.L106:
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2200              		.loc 1 495 3 is_stmt 1 view .LVU697
 496:Src/app.c     ****   b->prev_state = 0;
 2201              		.loc 1 496 23 is_stmt 0 view .LVU698
 2202 001e 9A4A     		ldr	r2, .L123+8
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2203              		.loc 1 495 16 view .LVU699
 2204 0020 03AB     		add	r3, sp, #12
 2205              	.LVL161:
 498:Src/app.c     **** }
 2206              		.loc 1 498 14 view .LVU700
 2207 0022 9A4F     		ldr	r7, .L123+12
 497:Src/app.c     ****   b->cb_args = cb_args;
 2208              		.loc 1 497 17 view .LVU701
 2209 0024 C3E90102 		strd	r0, r2, [r3, #4]
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2210              		.loc 1 495 16 view .LVU702
ARM GAS  /tmp/ccbfgvbk.s 			page 103


 2211 0028 1870     		strb	r0, [r3]
 496:Src/app.c     ****   b->prev_state = 0;
 2212              		.loc 1 496 3 is_stmt 1 view .LVU703
 498:Src/app.c     **** }
 2213              		.loc 1 498 3 view .LVU704
 2214              	.LBE333:
 2215              	.LBE336:
 2216              	.LBB337:
 2217              	.LBB338:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2218              		.loc 1 492 9 is_stmt 0 view .LVU705
 2219 002a 0120     		movs	r0, #1
 2220              	.LVL162:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2221              		.loc 1 492 9 view .LVU706
 2222              	.LBE338:
 2223              	.LBE337:
 2224              	.LBB342:
 2225              	.LBB334:
 498:Src/app.c     **** }
 2226              		.loc 1 498 14 view .LVU707
 2227 002c DF60     		str	r7, [r3, #12]
 2228              	.LVL163:
 498:Src/app.c     **** }
 2229              		.loc 1 498 14 view .LVU708
 2230              	.LBE334:
 2231              	.LBE342:
1756:Src/app.c     **** #else
 2232              		.loc 1 1756 3 is_stmt 1 view .LVU709
 2233              	.LBB343:
 2234              	.LBI337:
 488:Src/app.c     **** {
 2235              		.loc 1 488 13 view .LVU710
 2236              	.LBB339:
 490:Src/app.c     **** 
 2237              		.loc 1 490 3 view .LVU711
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2238              		.loc 1 492 3 view .LVU712
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2239              		.loc 1 492 9 is_stmt 0 view .LVU713
 2240 002e FFF7FEFF 		bl	BSP_PB_Init
 2241              	.LVL164:
 493:Src/app.c     **** 
 2242              		.loc 1 493 3 is_stmt 1 view .LVU714
 2243 0032 0028     		cmp	r0, #0
 2244 0034 F1D1     		bne	.L107
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2245              		.loc 1 495 3 view .LVU715
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2246              		.loc 1 495 16 is_stmt 0 view .LVU716
 2247 0036 0122     		movs	r2, #1
 2248              	.LBE339:
 2249              	.LBE343:
1749:Src/app.c     ****   display_info_t info;
 2250              		.loc 1 1749 12 view .LVU717
 2251 0038 0446     		mov	r4, r0
 2252              	.LBB344:
ARM GAS  /tmp/ccbfgvbk.s 			page 104


 2253              	.LBB345:
 2254              	.LBB346:
 2255              	.LBB347:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2256              		.loc 1 553 35 view .LVU718
 2257 003a 9FED919B 		vldr.64	d9, .L123
 2258              	.LBE347:
 2259              	.LBE346:
 2260              	.LBE345:
 2261              	.LBE344:
 2262              	.LBB359:
 2263              	.LBB340:
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2264              		.loc 1 495 16 view .LVU719
 2265 003e 8DF81C20 		strb	r2, [sp, #28]
 496:Src/app.c     ****   b->prev_state = 0;
 2266              		.loc 1 496 3 is_stmt 1 view .LVU720
 496:Src/app.c     ****   b->prev_state = 0;
 2267              		.loc 1 496 23 is_stmt 0 view .LVU721
 2268 0042 934A     		ldr	r2, .L123+16
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2269              		.loc 1 495 16 view .LVU722
 2270 0044 07AB     		add	r3, sp, #28
 2271              	.LVL165:
 497:Src/app.c     ****   b->cb_args = cb_args;
 2272              		.loc 1 497 17 view .LVU723
 2273 0046 C3E90102 		strd	r0, r2, [r3, #4]
 498:Src/app.c     **** }
 2274              		.loc 1 498 3 is_stmt 1 view .LVU724
 2275              	.LBE340:
 2276              	.LBE359:
 2277              	.LBB360:
 2278              	.LBB361:
1690:Src/app.c     ****   assert(ret == HAL_OK);
 2279              		.loc 1 1690 47 is_stmt 0 view .LVU725
 2280 004a DFF88C92 		ldr	r9, .L123+88
 2281              	.LBE361:
 2282              	.LBE360:
 2283              	.LBB367:
 2284              	.LBB341:
 498:Src/app.c     **** }
 2285              		.loc 1 498 14 view .LVU726
 2286 004e DF60     		str	r7, [r3, #12]
 2287              	.LVL166:
 2288              	.L117:
 498:Src/app.c     **** }
 2289              		.loc 1 498 14 view .LVU727
 2290              	.LBE341:
 2291              	.LBE367:
1761:Src/app.c     ****   {
 2292              		.loc 1 1761 3 is_stmt 1 view .LVU728
1763:Src/app.c     ****     assert(ret == pdTRUE);
 2293              		.loc 1 1763 5 view .LVU729
1763:Src/app.c     ****     assert(ret == pdTRUE);
 2294              		.loc 1 1763 11 is_stmt 0 view .LVU730
 2295 0050 4FF0FF31 		mov	r1, #-1
 2296 0054 3868     		ldr	r0, [r7]
ARM GAS  /tmp/ccbfgvbk.s 			page 105


 2297 0056 FFF7FEFF 		bl	xQueueSemaphoreTake
 2298              	.LVL167:
1764:Src/app.c     **** 
 2299              		.loc 1 1764 5 is_stmt 1 view .LVU731
 2300 005a 0128     		cmp	r0, #1
 2301 005c 06D0     		beq	.L108
1764:Src/app.c     **** 
 2302              		.loc 1 1764 5 is_stmt 0 discriminator 1 view .LVU732
 2303 005e 40F2E461 		movw	r1, #1764
 2304 0062 8C4B     		ldr	r3, .L123+20
 2305 0064 8C4A     		ldr	r2, .L123+24
 2306              	.LVL168:
 2307              	.L122:
1770:Src/app.c     ****     info = disp.info;
 2308              		.loc 1 1770 5 discriminator 1 view .LVU733
 2309 0066 8D48     		ldr	r0, .L123+28
 2310 0068 FFF7FEFF 		bl	__assert_func
 2311              	.LVL169:
 2312              	.L108:
1766:Src/app.c     ****     button_process(&hd_toggle_button);
 2313              		.loc 1 1766 5 is_stmt 1 view .LVU734
 2314 006c 03A8     		add	r0, sp, #12
 2315              	.LVL170:
1766:Src/app.c     ****     button_process(&hd_toggle_button);
 2316              		.loc 1 1766 5 is_stmt 0 view .LVU735
 2317 006e FFF7FEFF 		bl	button_process
 2318              	.LVL171:
1767:Src/app.c     **** 
 2319              		.loc 1 1767 5 is_stmt 1 view .LVU736
 2320 0072 07A8     		add	r0, sp, #28
 2321 0074 FFF7FEFF 		bl	button_process
 2322              	.LVL172:
1769:Src/app.c     ****     assert(ret == pdTRUE);
 2323              		.loc 1 1769 5 view .LVU737
1769:Src/app.c     ****     assert(ret == pdTRUE);
 2324              		.loc 1 1769 11 is_stmt 0 view .LVU738
 2325 0078 4FF0FF31 		mov	r1, #-1
 2326 007c 786D     		ldr	r0, [r7, #84]
 2327 007e FFF7FEFF 		bl	xQueueSemaphoreTake
 2328              	.LVL173:
1770:Src/app.c     ****     info = disp.info;
 2329              		.loc 1 1770 5 is_stmt 1 view .LVU739
 2330 0082 0128     		cmp	r0, #1
 2331 0084 04D0     		beq	.L109
1770:Src/app.c     ****     info = disp.info;
 2332              		.loc 1 1770 5 is_stmt 0 discriminator 1 view .LVU740
 2333 0086 40F2EA61 		movw	r1, #1770
 2334 008a 824B     		ldr	r3, .L123+20
 2335 008c 824A     		ldr	r2, .L123+24
 2336 008e EAE7     		b	.L122
 2337              	.L109:
1771:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2338              		.loc 1 1771 5 is_stmt 1 view .LVU741
1771:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2339              		.loc 1 1771 10 is_stmt 0 view .LVU742
 2340 0090 0BAE     		add	r6, sp, #44
 2341 0092 41F2E412 		movw	r2, #4580
ARM GAS  /tmp/ccbfgvbk.s 			page 106


 2342 0096 8249     		ldr	r1, .L123+32
 2343 0098 3046     		mov	r0, r6
 2344              	.LVL174:
1771:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2345              		.loc 1 1771 10 view .LVU743
 2346 009a FFF7FEFF 		bl	memcpy
 2347              	.LVL175:
1772:Src/app.c     ****     assert(ret == pdTRUE);
 2348              		.loc 1 1772 5 is_stmt 1 view .LVU744
1772:Src/app.c     ****     assert(ret == pdTRUE);
 2349              		.loc 1 1772 11 is_stmt 0 view .LVU745
 2350 009e 0023     		movs	r3, #0
 2351 00a0 786D     		ldr	r0, [r7, #84]
 2352 00a2 1A46     		mov	r2, r3
 2353 00a4 1946     		mov	r1, r3
 2354 00a6 FFF7FEFF 		bl	xQueueGenericSend
 2355              	.LVL176:
1773:Src/app.c     ****     info.disp_ms = disp_ms;
 2356              		.loc 1 1773 5 view .LVU746
 2357 00aa 0128     		cmp	r0, #1
1772:Src/app.c     ****     assert(ret == pdTRUE);
 2358              		.loc 1 1772 11 view .LVU747
 2359 00ac 0546     		mov	r5, r0
 2360              	.LVL177:
1773:Src/app.c     ****     info.disp_ms = disp_ms;
 2361              		.loc 1 1773 5 is_stmt 1 view .LVU748
 2362 00ae 04D0     		beq	.L110
1773:Src/app.c     ****     info.disp_ms = disp_ms;
 2363              		.loc 1 1773 5 is_stmt 0 discriminator 1 view .LVU749
 2364 00b0 40F2ED61 		movw	r1, #1773
 2365 00b4 774B     		ldr	r3, .L123+20
 2366 00b6 784A     		ldr	r2, .L123+24
 2367 00b8 D5E7     		b	.L122
 2368              	.L110:
1774:Src/app.c     **** 
 2369              		.loc 1 1774 5 is_stmt 1 view .LVU750
1774:Src/app.c     **** 
 2370              		.loc 1 1774 18 is_stmt 0 view .LVU751
 2371 00ba 7461     		str	r4, [r6, #20]
1776:Src/app.c     ****     dp_update_drawing_area();
 2372              		.loc 1 1776 5 is_stmt 1 view .LVU752
1776:Src/app.c     ****     dp_update_drawing_area();
 2373              		.loc 1 1776 10 is_stmt 0 view .LVU753
 2374 00bc FFF7FEFF 		bl	HAL_GetTick
 2375              	.LVL178:
1776:Src/app.c     ****     dp_update_drawing_area();
 2376              		.loc 1 1776 10 view .LVU754
 2377 00c0 8246     		mov	r10, r0
 2378              	.LVL179:
1777:Src/app.c     ****     Display_NetworkOutput(&info);
 2379              		.loc 1 1777 5 is_stmt 1 view .LVU755
 2380              	.LBB368:
 2381              	.LBI360:
1685:Src/app.c     **** {
 2382              		.loc 1 1685 13 view .LVU756
 2383              	.LBB366:
1687:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 107


 2384              		.loc 1 1687 3 view .LVU757
1689:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_fg_buffer[lcd_fg_buffer_rd_idx], SCRL_LAYER_1);
 2385              		.loc 1 1689 3 view .LVU758
 2386              	.LBB362:
 2387              	.LBI362:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 273:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 274:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 275:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 276:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 277:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 278:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 279:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 280:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 281:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 282:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 283:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 284:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 285:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 286:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 287:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 288:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 289:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 290:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 291:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 292:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 293:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 294:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 295:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 296:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 297:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 298:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 299:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 300:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 301:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 302:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 305:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 306:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 307:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 308:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 309:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 310:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 311:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 312:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 313:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 314:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 315:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 316:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 317:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 318:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 321:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 322:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 323:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
ARM GAS  /tmp/ccbfgvbk.s 			page 108


 324:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 325:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 326:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 327:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 328:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 329:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 330:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 331:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 332:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 333:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 334:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 335:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 336:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 337:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 338:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 339:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 340:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 341:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 342:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 343:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 344:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 345:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 346:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 347:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 348:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 349:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 350:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 351:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
 352:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 353:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 354:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 355:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 356:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 357:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 358:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 359:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 360:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 361:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 362:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 363:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 364:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 365:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 366:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 371:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 372:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 374:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 376:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 378:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 379:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 380:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
ARM GAS  /tmp/ccbfgvbk.s 			page 109


 381:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 382:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 383:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 384:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 385:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 386:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 387:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 388:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 389:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 390:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 391:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
 392:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 393:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 394:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 395:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 396:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 398:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Count leading zeros
 399:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Counts the number of leading zeros of a data value.
 400:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to count the leading zeros
 401:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             number of leading zeros in value
 402:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 403:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)
 404:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 405:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
 406:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      __builtin_clz(0) is undefined behaviour, so handle this case specially.
 407:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      This guarantees ARM-compatible results if happening to compile on a non-ARM
 408:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      target, and ensures the compiler doesn't decide to activate any
 409:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      optimisations using the logic "value was passed to __builtin_clz, so it
 410:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      is non-zero".
 411:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
 412:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      single CLZ instruction.
 413:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    */
 414:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (value == 0U)
 415:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 416:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     return 32U;
 417:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_clz(value);
 419:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 420:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 424:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 426:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (8 bit)
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 8 bit value.
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 432:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 434:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 435:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 436:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 437:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
ARM GAS  /tmp/ccbfgvbk.s 			page 110


 438:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 439:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 440:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 441:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 442:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 443:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 444:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);    /* Add explicit type cast here */
 445:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 446:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 447:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 448:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 449:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (16 bit)
 450:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 16 bit values.
 451:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 452:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 453:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 454:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
 455:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 456:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 457:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 458:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 459:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
 460:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 461:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 462:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 463:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 464:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 465:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 466:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);    /* Add explicit type cast here */
 467:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 471:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (32 bit)
 472:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 32 bit values.
 473:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 474:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 475:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 476:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
 477:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 479:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 481:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 482:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 484:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 486:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (8 bit)
 487:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 8 bit values.
 488:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 489:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 490:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 491:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 492:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 493:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
 494:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 111


 495:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 496:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 498:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 499:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 500:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 501:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 502:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 503:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (16 bit)
 504:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 16 bit values.
 505:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 506:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 507:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 508:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 509:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 510:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
 511:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 512:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 513:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 514:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 515:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 516:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 517:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 518:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 519:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 520:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (32 bit)
 521:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 32 bit values.
 522:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 523:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 524:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 525:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 526:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
 528:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 530:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 532:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 533:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 537:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Remove the exclusive lock
 538:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Removes the exclusive lock which is created by LDREX.
 539:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 540:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __CLREX(void)
 541:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 542:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("clrex" ::: "memory");
 543:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 544:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 545:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 546:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 547:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 548:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 549:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 550:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
ARM GAS  /tmp/ccbfgvbk.s 			page 112


 552:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 553:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 554:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 555:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Signed Saturate
 556:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates a signed value.
 557:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG1  Value to be saturated
 558:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG2  Bit position to saturate to (1..32)
 559:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 560:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 561:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SSAT(ARG1, ARG2) \
 562:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __extension__ \
 563:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** ({                          \
 564:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   int32_t __RES, __ARG1 = (ARG1); \
 565:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) : "cc" ); \
 566:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __RES; \
 567:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  })
 568:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 569:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 570:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 571:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Unsigned Saturate
 572:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates an unsigned value.
 573:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG1  Value to be saturated
 574:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG2  Bit position to saturate to (0..31)
 575:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 576:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 577:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __USAT(ARG1, ARG2) \
 578:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __extension__ \
 579:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** ({                          \
 580:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 581:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) : "cc" ); \
 582:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __RES; \
 583:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  })
 584:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 585:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 586:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 587:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right with Extend (32 bit)
 588:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Moves each bit of a bitstring right by one bit.
 589:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            The carry input is shifted in at the left end of the bitstring.
 590:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to rotate
 591:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 592:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 593:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)
 594:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 595:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 596:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 597:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 598:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 599:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 600:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 601:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 602:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 603:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (8 bit)
 604:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 8 bit value.
 605:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 606:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 607:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 608:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)
ARM GAS  /tmp/ccbfgvbk.s 			page 113


 609:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 610:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 611:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 612:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 613:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*ptr) );
 614:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 615:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 616:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 617:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 618:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
 619:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 620:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);    /* Add explicit type cast here */
 621:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 622:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 623:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 624:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 625:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (16 bit)
 626:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 16 bit values.
 627:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 628:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 629:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 630:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)
 631:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 632:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 633:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 634:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 635:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*ptr) );
 636:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 637:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 638:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 639:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 640:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
 641:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 642:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);    /* Add explicit type cast here */
 643:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 644:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 645:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 646:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 647:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (32 bit)
 648:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 32 bit values.
 649:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 650:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 651:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 652:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)
 653:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 654:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 655:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 656:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*ptr) );
 657:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 658:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 659:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 660:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 661:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 662:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (8 bit)
 663:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 8 bit values.
 664:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 665:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
ARM GAS  /tmp/ccbfgvbk.s 			page 114


 666:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 667:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)
 668:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 669:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strbt %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
 670:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 671:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 672:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 673:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 674:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (16 bit)
 675:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 16 bit values.
 676:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 677:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 678:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)
 680:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strht %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
 682:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 683:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 684:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 685:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 686:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (32 bit)
 687:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 32 bit values.
 688:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 689:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 690:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 691:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)
 692:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 693:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strt %1, %0" : "=Q" (*ptr) : "r" (value) );
 694:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 695:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 696:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 697:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 698:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 699:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 700:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 701:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Signed Saturate
 702:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates a signed value.
 703:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to be saturated
 704:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    sat  Bit position to saturate to (1..32)
 705:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 706:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 707:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)
 708:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 709:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if ((sat >= 1U) && (sat <= 32U))
 710:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 711:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
 712:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const int32_t min = -1 - max ;
 713:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     if (val > max)
 714:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 715:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return max;
 716:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 717:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     else if (val < min)
 718:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 719:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return min;
 720:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 721:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 722:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return val;
ARM GAS  /tmp/ccbfgvbk.s 			page 115


 723:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 724:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 725:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 726:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Unsigned Saturate
 727:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates an unsigned value.
 728:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to be saturated
 729:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    sat  Bit position to saturate to (0..31)
 730:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 731:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 732:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)
 733:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 734:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (sat <= 31U)
 735:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 736:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const uint32_t max = ((1U << sat) - 1U);
 737:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     if (val > (int32_t)max)
 738:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 739:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return max;
 740:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 741:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     else if (val < 0)
 742:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 743:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return 0U;
 744:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 745:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 746:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (uint32_t)val;
 747:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 748:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 749:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 750:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 751:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 752:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 753:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 754:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 755:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 756:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 757:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (8 bit)
 758:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAB instruction for 8 bit value.
 759:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 760:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 761:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 762:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)
 763:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 764:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 765:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 766:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldab %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 767:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);
 768:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 769:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 770:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 771:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 772:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (16 bit)
 773:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAH instruction for 16 bit values.
 774:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 775:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 776:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 777:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)
 778:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 779:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
ARM GAS  /tmp/ccbfgvbk.s 			page 116


 780:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 781:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldah %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 782:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);
 783:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 784:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 785:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 787:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (32 bit)
 788:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDA instruction for 32 bit values.
 789:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 790:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 791:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)
 793:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 795:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 796:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("lda %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 797:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 798:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 799:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 800:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 801:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 802:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (8 bit)
 803:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLB instruction for 8 bit values.
 804:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 805:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 806:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 807:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)
 808:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 809:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlb %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 810:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 811:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 814:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (16 bit)
 815:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLH instruction for 16 bit values.
 816:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 817:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 818:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 819:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)
 820:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 821:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlh %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 822:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 823:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 824:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 825:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 826:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (32 bit)
 827:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STL instruction for 32 bit values.
 828:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 829:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 830:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 831:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)
 832:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 833:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stl %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 834:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 835:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 836:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 117


 837:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 838:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (8 bit)
 839:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAB exclusive instruction for 8 bit value.
 840:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 841:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 842:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 843:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDAEXB(volatile uint8_t *ptr)
 844:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 845:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 846:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 847:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaexb %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 848:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);
 849:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 850:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 851:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 853:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (16 bit)
 854:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAH exclusive instruction for 16 bit values.
 855:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 856:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 857:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 858:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDAEXH(volatile uint16_t *ptr)
 859:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 860:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 861:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 862:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaexh %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 863:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);
 864:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 865:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 866:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 867:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 868:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (32 bit)
 869:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDA exclusive instruction for 32 bit values.
 870:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 871:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 872:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 873:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDAEX(volatile uint32_t *ptr)
 874:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 875:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 876:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 877:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaex %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 878:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 879:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 880:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 881:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 883:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (8 bit)
 884:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLB exclusive instruction for 8 bit values.
 885:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 886:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 887:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 888:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 889:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 890:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)
 891:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 892:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 893:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 118


 894:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlexb %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "mem
 895:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 896:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 897:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 898:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 899:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 900:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (16 bit)
 901:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLH exclusive instruction for 16 bit values.
 902:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 903:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 904:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 905:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 906:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 907:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)
 908:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 909:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 910:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 911:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlexh %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "mem
 912:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 913:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 914:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 915:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 916:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 917:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (32 bit)
 918:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STL exclusive instruction for 32 bit values.
 919:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 920:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 921:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 922:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 923:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 924:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)
 925:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 926:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 927:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlex %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "memo
 929:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 930:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 931:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 932:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 933:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 934:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 935:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /*@}*/ /* end of group CMSIS_Core_InstructionInterface */
 936:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 937:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 938:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 939:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 940:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 941:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 942:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 943:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 944:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 945:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 946:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
 947:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 948:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 950:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccbfgvbk.s 			page 119


 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 952:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 953:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 954:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 955:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 956:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 957:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
 958:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 959:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 960:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 2388              		.loc 4 960 27 view .LVU759
 2389              	.LBB363:
 961:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 962:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 2390              		.loc 4 962 3 view .LVU760
 2391              		.syntax unified
 2392              	@ 962 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2393 00c2 72B6     		cpsid i
 2394              	@ 0 "" 2
 2395              		.thumb
 2396              		.syntax unified
 2397              	.LBE363:
 2398              	.LBE362:
1690:Src/app.c     ****   assert(ret == HAL_OK);
 2399              		.loc 1 1690 3 view .LVU761
1690:Src/app.c     ****   assert(ret == HAL_OK);
 2400              		.loc 1 1690 47 is_stmt 0 view .LVU762
 2401 00c4 DFF81482 		ldr	r8, .L123+92
 2402 00c8 D9F80030 		ldr	r3, [r9]
1690:Src/app.c     ****   assert(ret == HAL_OK);
 2403              		.loc 1 1690 9 view .LVU763
 2404 00cc 7548     		ldr	r0, .L123+36
 2405              	.LVL180:
1690:Src/app.c     ****   assert(ret == HAL_OK);
 2406              		.loc 1 1690 9 view .LVU764
 2407 00ce 2946     		mov	r1, r5
 2408 00d0 00FB0380 		mla	r0, r0, r3, r8
 2409 00d4 FFF7FEFF 		bl	SCRL_SetAddress_NoReload
 2410              	.LVL181:
1691:Src/app.c     ****   __enable_irq();
 2411              		.loc 1 1691 3 is_stmt 1 view .LVU765
 2412 00d8 8346     		mov	fp, r0
 2413 00da 20B1     		cbz	r0, .L111
1691:Src/app.c     ****   __enable_irq();
 2414              		.loc 1 1691 3 is_stmt 0 discriminator 1 view .LVU766
 2415 00dc 40F29B61 		movw	r1, #1691
 2416 00e0 714B     		ldr	r3, .L123+40
 2417 00e2 724A     		ldr	r2, .L123+44
 2418 00e4 BFE7     		b	.L122
 2419              	.L111:
1692:Src/app.c     **** }
 2420              		.loc 1 1692 3 is_stmt 1 view .LVU767
 2421              	.LBB364:
 2422              	.LBI364:
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2423              		.loc 4 949 27 view .LVU768
 2424              	.LBB365:
ARM GAS  /tmp/ccbfgvbk.s 			page 120


 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2425              		.loc 4 951 3 view .LVU769
 2426              		.syntax unified
 2427              	@ 951 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2428 00e6 62B6     		cpsie i
 2429              	@ 0 "" 2
 2430              	.LVL182:
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2431              		.loc 4 951 3 is_stmt 0 view .LVU770
 2432              		.thumb
 2433              		.syntax unified
 2434              	.LBE365:
 2435              	.LBE364:
 2436              	.LBE366:
 2437              	.LBE368:
1778:Src/app.c     ****     SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_WIDTH * LCD_FG_HEIGHT* 2);
 2438              		.loc 1 1778 5 is_stmt 1 view .LVU771
 2439              	.LBB369:
 2440              	.LBI344:
 977:Src/app.c     **** {
 2441              		.loc 1 977 13 view .LVU772
 2442              	.LBB358:
 979:Src/app.c     ****   int line_nb = 0;
 2443              		.loc 1 979 3 view .LVU773
 980:Src/app.c     ****   float nn_fps;
 2444              		.loc 1 980 3 view .LVU774
 981:Src/app.c     ****   int i;
 2445              		.loc 1 981 3 view .LVU775
 982:Src/app.c     **** 
 2446              		.loc 1 982 3 view .LVU776
 985:Src/app.c     **** 
 2447              		.loc 1 985 3 view .LVU777
 2448              	.LBB350:
 2449              	.LBB351:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2450              		.loc 1 531 24 is_stmt 0 view .LVU778
 2451 00e8 714C     		ldr	r4, .L123+48
 2452              	.LVL183:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2453              		.loc 1 531 24 view .LVU779
 2454              	.LBE351:
 2455              	.LBE350:
 985:Src/app.c     **** 
 2456              		.loc 1 985 3 view .LVU780
 2457 00ea 4FF4F073 		mov	r3, #480
 2458 00ee 4FF44872 		mov	r2, #800
 2459 00f2 0146     		mov	r1, r0
 2460 00f4 0090     		str	r0, [sp]
 2461              	.LBB354:
 2462              	.LBB352:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2463              		.loc 1 531 24 view .LVU781
 2464 00f6 04F13805 		add	r5, r4, #56
 2465              	.LVL184:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2466              		.loc 1 531 24 view .LVU782
 2467 00fa 04F12006 		add	r6, r4, #32
ARM GAS  /tmp/ccbfgvbk.s 			page 121


 2468              	.LVL185:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2469              		.loc 1 531 24 view .LVU783
 2470              	.LBE352:
 2471              	.LBE354:
 985:Src/app.c     **** 
 2472              		.loc 1 985 3 view .LVU784
 2473 00fe FFF7FEFF 		bl	UTIL_LCD_FillRect
 2474              	.LVL186:
 988:Src/app.c     ****   cpuload_get_info(&cpu_load, NULL, &cpu_load_one_second, NULL);
 2475              		.loc 1 988 3 is_stmt 1 view .LVU785
 2476              	.LBB355:
 2477              	.LBI350:
 527:Src/app.c     **** {
 2478              		.loc 1 527 13 view .LVU786
 2479              	.LBB353:
 529:Src/app.c     **** 
 2480              		.loc 1 529 3 view .LVU787
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2481              		.loc 1 531 3 view .LVU788
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2482              		.loc 1 531 24 is_stmt 0 view .LVU789
 2483 0102 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 2484 0104 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 2485 0106 96E80300 		ldm	r6, {r0, r1}
 2486 010a 85E80300 		stm	r5, {r0, r1}
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2487              		.loc 1 532 3 is_stmt 1 view .LVU790
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2488              		.loc 1 532 32 is_stmt 0 view .LVU791
 2489 010e FFF7FEFF 		bl	TIM4_Get_Value
 2490              	.LVL187:
 2491 0112 0546     		mov	r5, r0
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2492              		.loc 1 532 30 discriminator 1 view .LVU792
 2493 0114 C4E9080B 		strd	r0, fp, [r4, #32]
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2494              		.loc 1 533 3 is_stmt 1 view .LVU793
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2495              		.loc 1 533 62 is_stmt 0 view .LVU794
 2496 0118 FFF7FEFF 		bl	ulTaskGetIdleRunTimeCounter
 2497              	.LVL188:
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2498              		.loc 1 533 60 discriminator 1 view .LVU795
 2499 011c 2D1A     		subs	r5, r5, r0
 2500 011e 63EB0303 		sbc	r3, r3, r3
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2501              		.loc 1 533 31 discriminator 1 view .LVU796
 2502 0122 C4E90A53 		strd	r5, r3, [r4, #40]
 534:Src/app.c     **** 
 2503              		.loc 1 534 3 is_stmt 1 view .LVU797
 534:Src/app.c     **** 
 2504              		.loc 1 534 31 is_stmt 0 view .LVU798
 2505 0126 FFF7FEFF 		bl	HAL_GetTick
 2506              	.LVL189:
 536:Src/app.c     ****     return ;
 2507              		.loc 1 536 33 view .LVU799
ARM GAS  /tmp/ccbfgvbk.s 			page 122


 2508 012a A36C     		ldr	r3, [r4, #72]
 2509 012c 226E     		ldr	r2, [r4, #96]
 534:Src/app.c     **** 
 2510              		.loc 1 534 29 discriminator 1 view .LVU800
 2511 012e 2063     		str	r0, [r4, #48]
 536:Src/app.c     ****     return ;
 2512              		.loc 1 536 3 is_stmt 1 view .LVU801
 536:Src/app.c     ****     return ;
 2513              		.loc 1 536 33 is_stmt 0 view .LVU802
 2514 0130 9B1A     		subs	r3, r3, r2
 536:Src/app.c     ****     return ;
 2515              		.loc 1 536 6 view .LVU803
 2516 0132 B3F57A7F 		cmp	r3, #1000
 2517 0136 06D3     		bcc	.L112
 540:Src/app.c     **** }
 2518              		.loc 1 540 55 view .LVU804
 2519 0138 9022     		movs	r2, #144
 2520 013a 04F13801 		add	r1, r4, #56
 2521 013e 04F15000 		add	r0, r4, #80
 2522 0142 FFF7FEFF 		bl	memmove
 2523              	.LVL190:
 2524              	.L112:
 540:Src/app.c     **** }
 2525              		.loc 1 540 55 view .LVU805
 2526              	.LBE353:
 2527              	.LBE355:
 989:Src/app.c     **** 
 2528              		.loc 1 989 3 is_stmt 1 view .LVU806
 2529              	.LBB356:
 2530              	.LBI346:
 546:Src/app.c     ****                              float *cpu_load_last_five_seconds)
 2531              		.loc 1 546 13 view .LVU807
 2532              	.LBB348:
 549:Src/app.c     ****     *cpu_load_last = 100.0 * (cpu_load->history[0].thread - cpu_load->history[1].thread) /
 2533              		.loc 1 549 3 view .LVU808
 552:Src/app.c     ****     *cpu_load_last_second = 100.0 * (cpu_load->history[2].thread - cpu_load->history[3].thread) /
 2534              		.loc 1 552 3 view .LVU809
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2535              		.loc 1 553 5 view .LVU810
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2536              		.loc 1 553 66 is_stmt 0 view .LVU811
 2537 0146 D4E91C23 		ldrd	r2, r3, [r4, #112]
 2538 014a D4E91601 		ldrd	r0, r1, [r4, #88]
 2539 014e 801A     		subs	r0, r0, r2
 2540 0150 61EB0301 		sbc	r1, r1, r3
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2541              		.loc 1 553 35 view .LVU812
 2542 0154 FFF7FEFF 		bl	__aeabi_ul2d
 2543              	.LVL191:
 554:Src/app.c     ****   if (cpu_load_last_five_seconds)
 2544              		.loc 1 554 50 view .LVU813
 2545 0158 D4E91A32 		ldrd	r3, r2, [r4, #104]
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2546              		.loc 1 553 35 view .LVU814
 2547 015c 41EC180B 		vmov	d8, r0, r1
 554:Src/app.c     ****   if (cpu_load_last_five_seconds)
 2548              		.loc 1 554 50 view .LVU815
ARM GAS  /tmp/ccbfgvbk.s 			page 123


 2549 0160 D4E91401 		ldrd	r0, r1, [r4, #80]
 2550 0164 C01A     		subs	r0, r0, r3
 2551 0166 61EB0201 		sbc	r1, r1, r2
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2552              		.loc 1 553 97 view .LVU816
 2553 016a FFF7FEFF 		bl	__aeabi_ul2d
 2554              	.LVL192:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2555              		.loc 1 553 35 view .LVU817
 2556 016e 28EE098B 		vmul.f64	d8, d8, d9
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2557              		.loc 1 553 97 view .LVU818
 2558 0172 41EC160B 		vmov	d6, r0, r1
 2559 0176 88EE067B 		vdiv.f64	d7, d8, d6
 2560              	.LBE348:
 2561              	.LBE356:
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2562              		.loc 1 992 25 view .LVU819
 2563 017a 0BAC     		add	r4, sp, #44
 2564              	.LBB357:
 2565              	.LBB349:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2566              		.loc 1 553 97 view .LVU820
 2567 017c B7EEC78B 		vcvt.f32.f64	s16, d7
 2568              	.LVL193:
 555:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 2569              		.loc 1 555 3 is_stmt 1 view .LVU821
 555:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 2570              		.loc 1 555 3 is_stmt 0 view .LVU822
 2571              	.LBE349:
 2572              	.LBE357:
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2573              		.loc 1 992 3 is_stmt 1 view .LVU823
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2574              		.loc 1 992 10 is_stmt 0 view .LVU824
 2575 0180 D4ED007A 		vldr.32	s15, [r4]
 2576 0184 9FED4B7A 		vldr.32	s14, .L123+52
 2577 0188 C7EE278A 		vdiv.f32	s17, s14, s15
 2578              	.LVL194:
 993:Src/app.c     ****   line_nb += 1;
 2579              		.loc 1 993 3 is_stmt 1 view .LVU825
 993:Src/app.c     ****   line_nb += 1;
 2580              		.loc 1 993 26 is_stmt 0 view .LVU826
 2581 018c FFF7FEFF 		bl	UTIL_LCD_GetFont
 2582              	.LVL195:
 993:Src/app.c     ****   line_nb += 1;
 2583              		.loc 1 993 3 discriminator 1 view .LVU827
 2584 0190 0021     		movs	r1, #0
 2585 0192 0222     		movs	r2, #2
 2586 0194 0846     		mov	r0, r1
 2587 0196 484B     		ldr	r3, .L123+56
 2588 0198 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2589              	.LVL196:
 994:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "   %.1f%%", cpu_load_one_second);
 2590              		.loc 1 994 3 is_stmt 1 view .LVU828
 995:Src/app.c     ****   line_nb += 2;
 2591              		.loc 1 995 3 view .LVU829
ARM GAS  /tmp/ccbfgvbk.s 			page 124


 995:Src/app.c     ****   line_nb += 2;
 2592              		.loc 1 995 26 is_stmt 0 view .LVU830
 2593 019c FFF7FEFF 		bl	UTIL_LCD_GetFont
 2594              	.LVL197:
 995:Src/app.c     ****   line_nb += 2;
 2595              		.loc 1 995 3 discriminator 1 view .LVU831
 2596 01a0 B7EEC87A 		vcvt.f64.f32	d7, s16
 2597 01a4 C188     		ldrh	r1, [r0, #6]
 2598 01a6 0222     		movs	r2, #2
 2599 01a8 8DED007B 		vstr.64	d7, [sp]
 2600 01ac 434B     		ldr	r3, .L123+60
 2601 01ae 0020     		movs	r0, #0
 2602 01b0 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2603              	.LVL198:
 996:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Inferences");
 2604              		.loc 1 996 3 is_stmt 1 view .LVU832
 997:Src/app.c     ****   line_nb += 1;
 2605              		.loc 1 997 3 view .LVU833
 997:Src/app.c     ****   line_nb += 1;
 2606              		.loc 1 997 26 is_stmt 0 view .LVU834
 2607 01b4 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2608              	.LVL199:
 997:Src/app.c     ****   line_nb += 1;
 2609              		.loc 1 997 26 discriminator 1 view .LVU835
 2610 01b8 C188     		ldrh	r1, [r0, #6]
 997:Src/app.c     ****   line_nb += 1;
 2611              		.loc 1 997 3 discriminator 1 view .LVU836
 2612 01ba 0222     		movs	r2, #2
 2613 01bc 404B     		ldr	r3, .L123+64
 2614 01be 01EB4101 		add	r1, r1, r1, lsl #1
 2615 01c2 0020     		movs	r0, #0
 2616 01c4 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2617              	.LVL200:
 998:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " pd %2ums", info->pd_ms);
 2618              		.loc 1 998 3 is_stmt 1 view .LVU837
 999:Src/app.c     ****   line_nb += 1;
 2619              		.loc 1 999 3 view .LVU838
 999:Src/app.c     ****   line_nb += 1;
 2620              		.loc 1 999 26 is_stmt 0 view .LVU839
 2621 01c8 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2622              	.LVL201:
 999:Src/app.c     ****   line_nb += 1;
 2623              		.loc 1 999 3 discriminator 1 view .LVU840
 2624 01cc 0222     		movs	r2, #2
 999:Src/app.c     ****   line_nb += 1;
 2625              		.loc 1 999 26 discriminator 1 view .LVU841
 2626 01ce C188     		ldrh	r1, [r0, #6]
 999:Src/app.c     ****   line_nb += 1;
 2627              		.loc 1 999 3 discriminator 1 view .LVU842
 2628 01d0 6368     		ldr	r3, [r4, #4]
 2629 01d2 9140     		lsls	r1, r1, r2
 2630 01d4 0020     		movs	r0, #0
 2631 01d6 0093     		str	r3, [sp]
 2632 01d8 3A4B     		ldr	r3, .L123+68
 2633 01da FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2634              	.LVL202:
1000:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " hl %2ums", info->hl_ms);
ARM GAS  /tmp/ccbfgvbk.s 			page 125


 2635              		.loc 1 1000 3 is_stmt 1 view .LVU843
1001:Src/app.c     ****   line_nb += 2;
 2636              		.loc 1 1001 3 view .LVU844
1001:Src/app.c     ****   line_nb += 2;
 2637              		.loc 1 1001 26 is_stmt 0 view .LVU845
 2638 01de FFF7FEFF 		bl	UTIL_LCD_GetFont
 2639              	.LVL203:
1001:Src/app.c     ****   line_nb += 2;
 2640              		.loc 1 1001 3 discriminator 1 view .LVU846
 2641 01e2 E368     		ldr	r3, [r4, #12]
1001:Src/app.c     ****   line_nb += 2;
 2642              		.loc 1 1001 26 discriminator 1 view .LVU847
 2643 01e4 C188     		ldrh	r1, [r0, #6]
1001:Src/app.c     ****   line_nb += 2;
 2644              		.loc 1 1001 3 discriminator 1 view .LVU848
 2645 01e6 0222     		movs	r2, #2
 2646 01e8 01EB8101 		add	r1, r1, r1, lsl #2
 2647 01ec 0020     		movs	r0, #0
 2648 01ee 0093     		str	r3, [sp]
 2649 01f0 354B     		ldr	r3, .L123+72
 2650 01f2 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2651              	.LVL204:
1002:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "  %.1f FPS", nn_fps);
 2652              		.loc 1 1002 3 is_stmt 1 view .LVU849
1003:Src/app.c     ****   line_nb += 2;
 2653              		.loc 1 1003 3 view .LVU850
1003:Src/app.c     ****   line_nb += 2;
 2654              		.loc 1 1003 26 is_stmt 0 view .LVU851
 2655 01f6 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2656              	.LVL205:
1003:Src/app.c     ****   line_nb += 2;
 2657              		.loc 1 1003 3 discriminator 1 view .LVU852
 2658 01fa B7EEE87A 		vcvt.f64.f32	d7, s17
1003:Src/app.c     ****   line_nb += 2;
 2659              		.loc 1 1003 26 discriminator 1 view .LVU853
 2660 01fe C188     		ldrh	r1, [r0, #6]
1003:Src/app.c     ****   line_nb += 2;
 2661              		.loc 1 1003 3 discriminator 1 view .LVU854
 2662 0200 324B     		ldr	r3, .L123+76
 2663 0202 8DED007B 		vstr.64	d7, [sp]
 2664 0206 0222     		movs	r2, #2
 2665 0208 0020     		movs	r0, #0
 2666 020a C1EBC101 		rsb	r1, r1, r1, lsl #3
 2667 020e FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2668              	.LVL206:
1004:Src/app.c     ****   if (DBG_INFO) {
 2669              		.loc 1 1004 3 is_stmt 1 view .LVU855
1005:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Display");
 2670              		.loc 1 1005 3 view .LVU856
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2671              		.loc 1 1013 3 view .LVU857
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2672              		.loc 1 1013 17 discriminator 1 view .LVU858
 2673 0212 236A     		ldr	r3, [r4, #32]
 2674 0214 002B     		cmp	r3, #0
 2675 0216 05DD     		ble	.L113
1014:Src/app.c     ****       display_hand(info, &info->hands[i]);
ARM GAS  /tmp/ccbfgvbk.s 			page 126


 2676              		.loc 1 1014 5 view .LVU859
1014:Src/app.c     ****       display_hand(info, &info->hands[i]);
 2677              		.loc 1 1014 8 is_stmt 0 view .LVU860
 2678 0218 E36A     		ldr	r3, [r4, #44]
 2679 021a 1BB1     		cbz	r3, .L113
1015:Src/app.c     ****   }
 2680              		.loc 1 1015 7 is_stmt 1 view .LVU861
 2681 021c 2046     		mov	r0, r4
 2682 021e 16A9     		add	r1, sp, #88
 2683 0220 FFF7FEFF 		bl	display_hand
 2684              	.LVL207:
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2685              		.loc 1 1013 38 discriminator 2 view .LVU862
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2686              		.loc 1 1013 17 discriminator 1 view .LVU863
 2687              	.L113:
1018:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
 2688              		.loc 1 1018 3 view .LVU864
1018:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
 2689              		.loc 1 1018 3 is_stmt 0 view .LVU865
 2690              	.LBE358:
 2691              	.LBE369:
1779:Src/app.c     ****     dp_commit_drawing_area();
 2692              		.loc 1 1779 5 is_stmt 1 view .LVU866
 2693              	.LBB370:
 2694              	.LBI370:
 375:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 376:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 377:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 378:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 379:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 380:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 381:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Clean by address
 382:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans D-Cache for the given address
 383:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is cleaned starting from a 32 byte aligned address in 32 byte granularity.
 384:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are cleaned.
 385:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 386:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
 387:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 388:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (volatile void *addr, int32_t dsize)
 2695              		.loc 3 388 27 view .LVU867
 389:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 390:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 391:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 2696              		.loc 3 391 5 view .LVU868
 2697              	.LBB371:
 392:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 2698              		.loc 3 392 8 view .LVU869
 2699              	.LBE371:
 2700              	.LBE370:
1779:Src/app.c     ****     dp_commit_drawing_area();
 2701              		.loc 1 1779 42 is_stmt 0 view .LVU870
 2702 0224 D9F80030 		ldr	r3, [r9]
 2703 0228 1E4A     		ldr	r2, .L123+36
 2704 022a 02FB0383 		mla	r3, r2, r3, r8
 2705              	.LVL208:
 2706              	.LBB379:
ARM GAS  /tmp/ccbfgvbk.s 			page 127


 2707              	.LBB378:
 393:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 2708              		.loc 3 393 7 is_stmt 1 view .LVU871
 394:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 395:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2709              		.loc 3 395 7 view .LVU872
 2710              	.LBB372:
 2711              	.LBI372:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2712              		.loc 4 269 27 view .LVU873
 2713              	.LBB373:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2714              		.loc 4 271 3 view .LVU874
 2715              		.syntax unified
 2716              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2717 022e BFF34F8F 		dsb 0xF
 2718              	@ 0 "" 2
 2719              		.thumb
 2720              		.syntax unified
 2721              	.LBE373:
 2722              	.LBE372:
 396:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 398:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 2723              		.loc 3 398 22 is_stmt 0 view .LVU875
 2724 0232 45F6C05E 		movw	lr, #24000
 2725 0236 4EF001E0 		dls	lr, lr
 2726 023a 254A     		ldr	r2, .L123+80
 2727              	.LVL209:
 2728              	.L115:
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 2729              		.loc 3 397 7 is_stmt 1 view .LVU876
 2730              		.loc 3 398 9 view .LVU877
 2731              		.loc 3 398 22 is_stmt 0 view .LVU878
 2732 023c C2F86832 		str	r3, [r2, #616]
 399:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 2733              		.loc 3 399 9 is_stmt 1 view .LVU879
 2734              		.loc 3 399 17 is_stmt 0 view .LVU880
 2735 0240 2033     		adds	r3, r3, #32
 2736              	.LVL210:
 400:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 2737              		.loc 3 400 9 is_stmt 1 view .LVU881
 401:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 2738              		.loc 3 401 25 discriminator 1 view .LVU882
 2739 0242 0FF005C8 		le	lr, .L115
 402:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 403:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2740              		.loc 3 403 7 view .LVU883
 2741              	.LBB374:
 2742              	.LBI374:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2743              		.loc 4 269 27 view .LVU884
 2744              	.LBB375:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2745              		.loc 4 271 3 view .LVU885
 2746              		.syntax unified
 2747              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
ARM GAS  /tmp/ccbfgvbk.s 			page 128


 2748 0246 BFF34F8F 		dsb 0xF
 2749              	@ 0 "" 2
 2750              		.thumb
 2751              		.syntax unified
 2752              	.LBE375:
 2753              	.LBE374:
 404:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 2754              		.loc 3 404 7 view .LVU886
 2755              	.LBB376:
 2756              	.LBI376:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2757              		.loc 4 258 27 view .LVU887
 2758              	.LBB377:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2759              		.loc 4 260 3 view .LVU888
 2760              		.syntax unified
 2761              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2762 024a BFF36F8F 		isb 0xF
 2763              	@ 0 "" 2
 2764              	.LVL211:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2765              		.loc 4 260 3 is_stmt 0 view .LVU889
 2766              		.thumb
 2767              		.syntax unified
 2768              	.LBE377:
 2769              	.LBE376:
 2770              	.LBE378:
 2771              	.LBE379:
1780:Src/app.c     ****     disp_ms = HAL_GetTick() - ts;
 2772              		.loc 1 1780 5 is_stmt 1 view .LVU890
 2773              	.LBB380:
 2774              	.LBI380:
1699:Src/app.c     **** {
 2775              		.loc 1 1699 13 view .LVU891
 2776              	.LBB381:
1701:Src/app.c     **** 
 2777              		.loc 1 1701 3 view .LVU892
1703:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_1);
 2778              		.loc 1 1703 3 view .LVU893
 2779              	.LBB382:
 2780              	.LBI382:
 960:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2781              		.loc 4 960 27 view .LVU894
 2782              	.LBB383:
 2783              		.loc 4 962 3 view .LVU895
 2784              		.syntax unified
 2785              	@ 962 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2786 024e 72B6     		cpsid i
 2787              	@ 0 "" 2
 2788              		.thumb
 2789              		.syntax unified
 2790              	.LBE383:
 2791              	.LBE382:
1704:Src/app.c     ****   assert(ret == HAL_OK);
 2792              		.loc 1 1704 3 view .LVU896
1704:Src/app.c     ****   assert(ret == HAL_OK);
 2793              		.loc 1 1704 9 is_stmt 0 view .LVU897
ARM GAS  /tmp/ccbfgvbk.s 			page 129


 2794 0250 0120     		movs	r0, #1
 2795 0252 FFF7FEFF 		bl	SCRL_ReloadLayer
 2796              	.LVL212:
1705:Src/app.c     ****   __enable_irq();
 2797              		.loc 1 1705 3 is_stmt 1 view .LVU898
 2798 0256 20B1     		cbz	r0, .L116
1705:Src/app.c     ****   __enable_irq();
 2799              		.loc 1 1705 3 is_stmt 0 discriminator 1 view .LVU899
 2800 0258 40F2A961 		movw	r1, #1705
 2801 025c 124B     		ldr	r3, .L123+40
 2802 025e 1D4A     		ldr	r2, .L123+84
 2803 0260 01E7     		b	.L122
 2804              	.L116:
1706:Src/app.c     ****   lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
 2805              		.loc 1 1706 3 is_stmt 1 view .LVU900
 2806              	.LBB384:
 2807              	.LBI384:
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2808              		.loc 4 949 27 view .LVU901
 2809              	.LBB385:
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2810              		.loc 4 951 3 view .LVU902
 2811              		.syntax unified
 2812              	@ 951 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2813 0262 62B6     		cpsie i
 2814              	@ 0 "" 2
 2815              		.thumb
 2816              		.syntax unified
 2817              	.LBE385:
 2818              	.LBE384:
1707:Src/app.c     **** }
 2819              		.loc 1 1707 3 view .LVU903
1707:Src/app.c     **** }
 2820              		.loc 1 1707 28 is_stmt 0 view .LVU904
 2821 0264 D9F80030 		ldr	r3, [r9]
 2822 0268 C3F10103 		rsb	r3, r3, #1
1707:Src/app.c     **** }
 2823              		.loc 1 1707 24 view .LVU905
 2824 026c C9F80030 		str	r3, [r9]
 2825              	.LVL213:
1707:Src/app.c     **** }
 2826              		.loc 1 1707 24 view .LVU906
 2827              	.LBE381:
 2828              	.LBE380:
1781:Src/app.c     ****   }
 2829              		.loc 1 1781 5 is_stmt 1 view .LVU907
1781:Src/app.c     ****   }
 2830              		.loc 1 1781 15 is_stmt 0 view .LVU908
 2831 0270 FFF7FEFF 		bl	HAL_GetTick
 2832              	.LVL214:
1781:Src/app.c     ****   }
 2833              		.loc 1 1781 13 discriminator 1 view .LVU909
 2834 0274 A0EB0A04 		sub	r4, r0, r10
 2835              	.LVL215:
1761:Src/app.c     ****   {
 2836              		.loc 1 1761 9 is_stmt 1 view .LVU910
1763:Src/app.c     ****     assert(ret == pdTRUE);
ARM GAS  /tmp/ccbfgvbk.s 			page 130


 2837              		.loc 1 1763 9 is_stmt 0 view .LVU911
 2838 0278 EAE6     		b	.L117
 2839              	.L124:
 2840 027a 00BFAFF3 		.align	3
 2840      0080
 2841              	.L123:
 2842 0280 00000000 		.word	0
 2843 0284 00005940 		.word	1079574528
 2844 0288 00000000 		.word	on_ld_toggle_button_click
 2845 028c 00000000 		.word	disp
 2846 0290 00000000 		.word	on_pd_toggle_button_click
 2847 0294 00000000 		.word	.LC1
 2848 0298 00000000 		.word	__func__.15
 2849 029c 0E000000 		.word	.LC2
 2850 02a0 A8000000 		.word	disp+168
 2851 02a4 00B80B00 		.word	768000
 2852 02a8 00000000 		.word	.LC8
 2853 02ac 00000000 		.word	__func__.11
 2854 02b0 00000000 		.word	cpu_load
 2855 02b4 00007A44 		.word	1148846080
 2856 02b8 0E000000 		.word	.LC9
 2857 02bc 17000000 		.word	.LC10
 2858 02c0 21000000 		.word	.LC11
 2859 02c4 2C000000 		.word	.LC12
 2860 02c8 36000000 		.word	.LC13
 2861 02cc 40000000 		.word	.LC14
 2862 02d0 00ED00E0 		.word	-536810240
 2863 02d4 00000000 		.word	__func__.10
 2864 02d8 00000000 		.word	lcd_fg_buffer_rd_idx
 2865 02dc 00181500 		.word	lcd_fg_buffer
 2866              		.cfi_endproc
 2867              	.LFE7410:
 2869              		.section	.rodata.app_run.str1.1,"aMS",%progbits,1
 2870              	.LC15:
 2871 0000 496E6974 		.ascii	"Init application\000"
 2871      20617070 
 2871      6C696361 
 2871      74696F6E 
 2871      00
 2872              	.LC16:
 2873 0011 72657420 		.ascii	"ret == 0\000"
 2873      3D3D2030 
 2873      00
 2874              	.LC17:
 2875 001a 6973705F 		.ascii	"isp_sem\000"
 2875      73656D00 
 2876              	.LC18:
 2877 0022 64697370 		.ascii	"disp.update\000"
 2877      2E757064 
 2877      61746500 
 2878              	.LC19:
 2879 002e 64697370 		.ascii	"disp.lock\000"
 2879      2E6C6F63 
 2879      6B00
 2880              	.LC20:
 2881 0038 6E6E00   		.ascii	"nn\000"
 2882              	.LC21:
ARM GAS  /tmp/ccbfgvbk.s 			page 131


 2883 003b 68646C20 		.ascii	"hdl != NULL\000"
 2883      213D204E 
 2883      554C4C00 
 2884              	.LC22:
 2885 0047 647000   		.ascii	"dp\000"
 2886              	.LC23:
 2887 004a 69737000 		.ascii	"isp\000"
 2888              		.section	.text.app_run,"ax",%progbits
 2889              		.align	1
 2890              		.global	app_run
 2891              		.syntax unified
 2892              		.thumb
 2893              		.thumb_func
 2895              	app_run:
 2896              	.LFB7413:
1799:Src/app.c     ****   }
1800:Src/app.c     **** }
1801:Src/app.c     **** 
1802:Src/app.c     **** /**
1803:Src/app.c     ****  * @brief Initializes the display controller (SCRL) and graphics library (UTIL_LCD).
1804:Src/app.c     ****  * @details Configures the two screen layers: Layer 0 for the background video and
1805:Src/app.c     ****  * Layer 1 for the transparent UI overlay.
1806:Src/app.c     ****  */
1807:Src/app.c     **** static void Display_init()
1808:Src/app.c     **** {
1809:Src/app.c     ****   SCRL_LayerConfig layers_config[2] = {
1810:Src/app.c     ****     {
1811:Src/app.c     ****       .origin = {lcd_bg_area.X0, lcd_bg_area.Y0},
1812:Src/app.c     ****       .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
1813:Src/app.c     ****       .format = SCRL_ARGB8888,
1814:Src/app.c     ****       .address = lcd_bg_buffer[lcd_bg_buffer_disp_idx],
1815:Src/app.c     ****     },
1816:Src/app.c     ****     {
1817:Src/app.c     ****       .origin = {lcd_fg_area.X0, lcd_fg_area.Y0},
1818:Src/app.c     ****       .size = {lcd_fg_area.XSize, lcd_fg_area.YSize},
1819:Src/app.c     ****       .format = SCRL_ARGB4444,
1820:Src/app.c     ****       .address = lcd_fg_buffer[1],
1821:Src/app.c     ****     },
1822:Src/app.c     ****   };
1823:Src/app.c     ****   SCRL_ScreenConfig screen_config = {
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
1825:Src/app.c     **** #ifdef SCR_LIB_USE_SPI
1826:Src/app.c     ****     .format = SCRL_RGB565,
1827:Src/app.c     **** #else
1828:Src/app.c     ****      .format = SCRL_YUV422, /* Use SCRL_RGB565 if host support this format to reduce cpu load */
1829:Src/app.c     **** #endif
1830:Src/app.c     ****     .address = screen_buffer,
1831:Src/app.c     ****     .fps = CAMERA_FPS,
1832:Src/app.c     ****   };
1833:Src/app.c     ****   int ret;
1834:Src/app.c     **** 
1835:Src/app.c     ****   ret = SCRL_Init((SCRL_LayerConfig *[2]){&layers_config[0], &layers_config[1]}, &screen_config);
1836:Src/app.c     ****   assert(ret == 0);
1837:Src/app.c     **** 
1838:Src/app.c     ****   UTIL_LCD_SetLayer(SCRL_LAYER_1);
1839:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
1840:Src/app.c     ****   UTIL_LCD_SetFont(&LCD_FONT);
ARM GAS  /tmp/ccbfgvbk.s 			page 132


1841:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
1842:Src/app.c     **** }
1843:Src/app.c     **** 
1844:Src/app.c     **** /**
1845:Src/app.c     ****  * @brief Main application entry point.
1846:Src/app.c     ****  * @details Initializes all hardware, software modules, and RTOS components,
1847:Src/app.c     ****  * then creates the three main application threads.
1848:Src/app.c     ****  */
1849:Src/app.c     **** void app_run()
1850:Src/app.c     **** {
 2897              		.loc 1 1850 1 is_stmt 1 view -0
 2898              		.cfi_startproc
 2899              		@ args = 0, pretend = 0, frame = 56
 2900              		@ frame_needed = 0, uses_anonymous_args = 0
1851:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 2901              		.loc 1 1851 3 view .LVU913
 2902              	.LVL216:
1852:Src/app.c     ****   UBaseType_t dp_priority = FREERTOS_PRIORITY(-2);
 2903              		.loc 1 1852 3 view .LVU914
1853:Src/app.c     ****   UBaseType_t nn_priority = FREERTOS_PRIORITY(1);
 2904              		.loc 1 1853 3 view .LVU915
1854:Src/app.c     ****   TaskHandle_t hdl;
 2905              		.loc 1 1854 3 view .LVU916
1855:Src/app.c     ****   int ret;
 2906              		.loc 1 1855 3 view .LVU917
1856:Src/app.c     **** 
1857:Src/app.c     ****   printf("Init application\n");
 2907              		.loc 1 1857 3 view .LVU918
1850:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 2908              		.loc 1 1850 1 is_stmt 0 view .LVU919
 2909 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 2910              		.cfi_def_cfa_offset 28
 2911              		.cfi_offset 4, -28
 2912              		.cfi_offset 5, -24
 2913              		.cfi_offset 6, -20
 2914              		.cfi_offset 7, -16
 2915              		.cfi_offset 8, -12
 2916              		.cfi_offset 9, -8
 2917              		.cfi_offset 14, -4
1858:Src/app.c     ****   /* Enable DWT so DWT_CYCCNT works when debugger not attached */
1859:Src/app.c     ****   CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 2918              		.loc 1 1859 12 view .LVU920
 2919 0004 854D     		ldr	r5, .L145
1850:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 2920              		.loc 1 1850 1 view .LVU921
 2921 0006 93B0     		sub	sp, sp, #76
 2922              		.cfi_def_cfa_offset 104
1857:Src/app.c     ****   /* Enable DWT so DWT_CYCCNT works when debugger not attached */
 2923              		.loc 1 1857 3 view .LVU922
 2924 0008 8548     		ldr	r0, .L145+4
 2925 000a FFF7FEFF 		bl	puts
 2926              	.LVL217:
 2927              		.loc 1 1859 3 is_stmt 1 view .LVU923
 2928              		.loc 1 1859 12 is_stmt 0 view .LVU924
 2929 000e D5F8FC30 		ldr	r3, [r5, #252]
1860:Src/app.c     **** 
1861:Src/app.c     ****   /* screen init */
ARM GAS  /tmp/ccbfgvbk.s 			page 133


1862:Src/app.c     ****   memset(lcd_bg_buffer, 0, sizeof(lcd_bg_buffer));
 2930              		.loc 1 1862 3 view .LVU925
 2931 0012 844C     		ldr	r4, .L145+8
1859:Src/app.c     **** 
 2932              		.loc 1 1859 20 view .LVU926
 2933 0014 43F08073 		orr	r3, r3, #16777216
 2934              		.loc 1 1862 3 view .LVU927
 2935 0018 0021     		movs	r1, #0
 2936 001a 2046     		mov	r0, r4
 2937 001c 824A     		ldr	r2, .L145+12
1859:Src/app.c     **** 
 2938              		.loc 1 1859 20 view .LVU928
 2939 001e C5F8FC30 		str	r3, [r5, #252]
 2940              		.loc 1 1862 3 is_stmt 1 view .LVU929
 2941 0022 FFF7FEFF 		bl	memset
 2942              	.LVL218:
1863:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(lcd_bg_buffer, sizeof(lcd_bg_buffer)));
 2943              		.loc 1 1863 3 view .LVU930
 2944              		.loc 1 1863 3 view .LVU931
 2945              		.loc 1 1863 3 discriminator 1 view .LVU932
 2946              	.LBB408:
 2947              	.LBI408:
 405:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 406:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 407:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 408:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 409:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 410:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 411:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Clean and Invalidate by address
 412:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans and invalidates D_Cache for the given address
 413:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is cleaned and invalidated starting from a 32 byte aligned address in 32 byte gr
 414:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are cleaned and inval
 415:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address (aligned to 32-byte boundary)
 416:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
 417:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
 2948              		.loc 3 418 27 view .LVU933
 419:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 420:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 2949              		.loc 3 421 5 view .LVU934
 2950              	.LBB409:
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 2951              		.loc 3 422 8 view .LVU935
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 2952              		.loc 3 423 7 view .LVU936
 424:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2953              		.loc 3 425 7 view .LVU937
 2954              	.LBB410:
 2955              	.LBI410:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2956              		.loc 4 269 27 view .LVU938
 2957              	.LBB411:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2958              		.loc 4 271 3 view .LVU939
 2959              		.syntax unified
ARM GAS  /tmp/ccbfgvbk.s 			page 134


 2960              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2961 0026 BFF34F8F 		dsb 0xF
 2962              	@ 0 "" 2
 2963              		.thumb
 2964              		.syntax unified
 2965              	.LBE411:
 2966              	.LBE410:
 426:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 2967              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU940
 2968 002a DFF880E2 		ldr	lr, .L145+144
 2969              	.LBB413:
 2970              	.LBB412:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 2971              		.loc 4 272 1 view .LVU941
 2972 002e 0023     		movs	r3, #0
 2973              	.LBE412:
 2974              	.LBE413:
 2975              		.loc 3 431 25 discriminator 1 view .LVU942
 2976 0030 4EF001E0 		dls	lr, lr
 2977              	.LVL219:
 2978              	.L126:
 2979              		.loc 3 431 25 discriminator 1 view .LVU943
 2980 0034 E218     		adds	r2, r4, r3
 2981              	.LVL220:
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 2982              		.loc 3 427 7 is_stmt 1 view .LVU944
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 2983              		.loc 3 428 9 view .LVU945
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 2984              		.loc 3 428 23 is_stmt 0 view .LVU946
 2985 0036 C5F87022 		str	r2, [r5, #624]
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 2986              		.loc 3 429 9 is_stmt 1 view .LVU947
 2987              	.LVL221:
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 2988              		.loc 3 430 9 view .LVU948
 2989              		.loc 3 431 25 discriminator 1 view .LVU949
 2990 003a 2033     		adds	r3, r3, #32
 2991              	.LVL222:
 2992              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU950
 2993 003c 0FF007C0 		le	lr, .L126
 432:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2994              		.loc 3 433 7 is_stmt 1 view .LVU951
 2995              	.LBB414:
 2996              	.LBI414:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2997              		.loc 4 269 27 view .LVU952
 2998              	.LBB415:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2999              		.loc 4 271 3 view .LVU953
 3000              		.syntax unified
ARM GAS  /tmp/ccbfgvbk.s 			page 135


 3001              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3002 0040 BFF34F8F 		dsb 0xF
 3003              	@ 0 "" 2
 3004              		.thumb
 3005              		.syntax unified
 3006              	.LBE415:
 3007              	.LBE414:
 434:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 3008              		.loc 3 434 7 view .LVU954
 3009              	.LBB416:
 3010              	.LBI416:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3011              		.loc 4 258 27 view .LVU955
 3012              	.LBB417:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3013              		.loc 4 260 3 view .LVU956
 3014              		.syntax unified
 3015              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3016 0044 BFF36F8F 		isb 0xF
 3017              	@ 0 "" 2
 3018              	.LVL223:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3019              		.loc 4 260 3 is_stmt 0 view .LVU957
 3020              		.thumb
 3021              		.syntax unified
 3022              	.LBE417:
 3023              	.LBE416:
 3024              	.LBE409:
 3025              	.LBE408:
 3026              		.loc 1 1863 3 is_stmt 1 discriminator 3 view .LVU958
1864:Src/app.c     ****   memset(lcd_fg_buffer, 0, sizeof(lcd_fg_buffer));
 3027              		.loc 1 1864 3 view .LVU959
 3028 0048 784D     		ldr	r5, .L145+16
 3029 004a 0021     		movs	r1, #0
 3030 004c 2846     		mov	r0, r5
 3031 004e 784A     		ldr	r2, .L145+20
 3032 0050 FFF7FEFF 		bl	memset
 3033              	.LVL224:
1865:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(lcd_fg_buffer, sizeof(lcd_fg_buffer)));
 3034              		.loc 1 1865 3 view .LVU960
 3035              		.loc 1 1865 3 view .LVU961
 3036              		.loc 1 1865 3 discriminator 1 view .LVU962
 3037              	.LBB418:
 3038              	.LBI418:
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 3039              		.loc 3 418 27 view .LVU963
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 3040              		.loc 3 421 5 view .LVU964
 3041              	.LBB419:
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 3042              		.loc 3 422 8 view .LVU965
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3043              		.loc 3 423 7 view .LVU966
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3044              		.loc 3 425 7 view .LVU967
 3045              	.LBB420:
 3046              	.LBI420:
ARM GAS  /tmp/ccbfgvbk.s 			page 136


 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3047              		.loc 4 269 27 view .LVU968
 3048              	.LBB421:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3049              		.loc 4 271 3 view .LVU969
 3050              		.syntax unified
 3051              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3052 0054 BFF34F8F 		dsb 0xF
 3053              	@ 0 "" 2
 3054              		.thumb
 3055              		.syntax unified
 3056              	.LBE421:
 3057              	.LBE420:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3058              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU970
 3059 0058 4BF6803E 		movw	lr, #48000
 3060              	.LBB423:
 3061              	.LBB422:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 3062              		.loc 4 272 1 view .LVU971
 3063 005c 0023     		movs	r3, #0
 3064              	.LBE422:
 3065              	.LBE423:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3066              		.loc 3 431 25 discriminator 1 view .LVU972
 3067 005e 4EF001E0 		dls	lr, lr
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3068              		.loc 3 428 23 view .LVU973
 3069 0062 6E4A     		ldr	r2, .L145
 3070              	.LVL225:
 3071              	.L127:
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3072              		.loc 3 428 23 view .LVU974
 3073 0064 E918     		adds	r1, r5, r3
 3074              	.LVL226:
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 3075              		.loc 3 427 7 is_stmt 1 view .LVU975
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3076              		.loc 3 428 9 view .LVU976
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3077              		.loc 3 428 23 is_stmt 0 view .LVU977
 3078 0066 C2F87012 		str	r1, [r2, #624]
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 3079              		.loc 3 429 9 is_stmt 1 view .LVU978
 3080              	.LVL227:
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 3081              		.loc 3 430 9 view .LVU979
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3082              		.loc 3 431 25 discriminator 1 view .LVU980
 3083 006a 2033     		adds	r3, r3, #32
 3084              	.LVL228:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3085              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU981
 3086 006c 0FF007C0 		le	lr, .L127
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 3087              		.loc 3 433 7 is_stmt 1 view .LVU982
 3088              	.LBB424:
ARM GAS  /tmp/ccbfgvbk.s 			page 137


 3089              	.LBI424:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3090              		.loc 4 269 27 view .LVU983
 3091              	.LBB425:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3092              		.loc 4 271 3 view .LVU984
 3093              		.syntax unified
 3094              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3095 0070 BFF34F8F 		dsb 0xF
 3096              	@ 0 "" 2
 3097              		.thumb
 3098              		.syntax unified
 3099              	.LBE425:
 3100              	.LBE424:
 3101              		.loc 3 434 7 view .LVU985
 3102              	.LBB426:
 3103              	.LBI426:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3104              		.loc 4 258 27 view .LVU986
 3105              	.LBB427:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3106              		.loc 4 260 3 view .LVU987
 3107              		.syntax unified
 3108              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3109 0074 BFF36F8F 		isb 0xF
 3110              	@ 0 "" 2
 3111              	.LVL229:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3112              		.loc 4 260 3 is_stmt 0 view .LVU988
 3113              		.thumb
 3114              		.syntax unified
 3115              	.LBE427:
 3116              	.LBE426:
 3117              	.LBE419:
 3118              	.LBE418:
 3119              		.loc 1 1865 3 is_stmt 1 discriminator 3 view .LVU989
1866:Src/app.c     ****   Display_init();
 3120              		.loc 1 1866 3 view .LVU990
 3121              	.LBB428:
 3122              	.LBI428:
1807:Src/app.c     **** {
 3123              		.loc 1 1807 13 view .LVU991
 3124              	.LBB429:
1809:Src/app.c     ****     {
 3125              		.loc 1 1809 3 view .LVU992
1809:Src/app.c     ****     {
 3126              		.loc 1 1809 20 is_stmt 0 view .LVU993
 3127 0078 0320     		movs	r0, #3
 3128 007a 0021     		movs	r1, #0
 3129 007c 0126     		movs	r6, #1
1823:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3130              		.loc 1 1823 21 view .LVU994
 3131 007e 0227     		movs	r7, #2
 3132 0080 4FF01E09 		mov	r9, #30
1809:Src/app.c     ****     {
 3133              		.loc 1 1809 20 view .LVU995
 3134 0084 8DF83000 		strb	r0, [sp, #48]
ARM GAS  /tmp/ccbfgvbk.s 			page 138


1814:Src/app.c     ****     },
 3135              		.loc 1 1814 31 view .LVU996
 3136 0088 6A48     		ldr	r0, .L145+24
1809:Src/app.c     ****     {
 3137              		.loc 1 1809 20 view .LVU997
 3138 008a 6B4A     		ldr	r2, .L145+28
1814:Src/app.c     ****     },
 3139              		.loc 1 1814 18 view .LVU998
 3140 008c 0068     		ldr	r0, [r0]
1809:Src/app.c     ****     {
 3141              		.loc 1 1809 20 view .LVU999
 3142 008e CDE90A12 		strd	r1, r2, [sp, #40]
1814:Src/app.c     ****     },
 3143              		.loc 1 1814 18 view .LVU1000
 3144 0092 03FB0044 		mla	r4, r3, r0, r4
1809:Src/app.c     ****     {
 3145              		.loc 1 1809 20 view .LVU1001
 3146 0096 694B     		ldr	r3, .L145+32
 3147 0098 CDE90D41 		strd	r4, r1, [sp, #52]
 3148 009c 1193     		str	r3, [sp, #68]
1823:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3149              		.loc 1 1823 3 is_stmt 1 view .LVU1002
1823:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3150              		.loc 1 1823 21 is_stmt 0 view .LVU1003
 3151 009e 684B     		ldr	r3, .L145+36
1835:Src/app.c     ****   assert(ret == 0);
 3152              		.loc 1 1835 9 view .LVU1004
 3153 00a0 06A9     		add	r1, sp, #24
1823:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3154              		.loc 1 1823 21 view .LVU1005
 3155 00a2 0893     		str	r3, [sp, #32]
1835:Src/app.c     ****   assert(ret == 0);
 3156              		.loc 1 1835 42 view .LVU1006
 3157 00a4 0AAB     		add	r3, sp, #40
 3158 00a6 0493     		str	r3, [sp, #16]
1835:Src/app.c     ****   assert(ret == 0);
 3159              		.loc 1 1835 9 view .LVU1007
 3160 00a8 04A8     		add	r0, sp, #16
1835:Src/app.c     ****   assert(ret == 0);
 3161              		.loc 1 1835 42 view .LVU1008
 3162 00aa 0EAB     		add	r3, sp, #56
1809:Src/app.c     ****     {
 3163              		.loc 1 1809 20 view .LVU1009
 3164 00ac 0F92     		str	r2, [sp, #60]
 3165 00ae 8DF84060 		strb	r6, [sp, #64]
1823:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3166              		.loc 1 1823 21 view .LVU1010
 3167 00b2 0692     		str	r2, [sp, #24]
 3168 00b4 8DF81C70 		strb	r7, [sp, #28]
 3169 00b8 ADF82490 		strh	r9, [sp, #36]	@ movhi
1833:Src/app.c     **** 
 3170              		.loc 1 1833 3 is_stmt 1 view .LVU1011
1835:Src/app.c     ****   assert(ret == 0);
 3171              		.loc 1 1835 3 view .LVU1012
1835:Src/app.c     ****   assert(ret == 0);
 3172              		.loc 1 1835 42 is_stmt 0 view .LVU1013
 3173 00bc 0593     		str	r3, [sp, #20]
ARM GAS  /tmp/ccbfgvbk.s 			page 139


1835:Src/app.c     ****   assert(ret == 0);
 3174              		.loc 1 1835 9 view .LVU1014
 3175 00be FFF7FEFF 		bl	SCRL_Init
 3176              	.LVL230:
1836:Src/app.c     **** 
 3177              		.loc 1 1836 3 is_stmt 1 view .LVU1015
 3178 00c2 0446     		mov	r4, r0
 3179 00c4 30B1     		cbz	r0, .L128
1836:Src/app.c     **** 
 3180              		.loc 1 1836 3 is_stmt 0 discriminator 1 view .LVU1016
 3181 00c6 40F22C71 		movw	r1, #1836
 3182 00ca 5E4B     		ldr	r3, .L145+40
 3183 00cc 5E4A     		ldr	r2, .L145+44
 3184              	.LVL231:
 3185              	.L144:
1836:Src/app.c     **** 
 3186              		.loc 1 1836 3 discriminator 1 view .LVU1017
 3187              	.LBE429:
 3188              	.LBE428:
1867:Src/app.c     **** 
1868:Src/app.c     ****   /* create buffer queues */
1869:Src/app.c     ****   ret = bqueue_init(&nn_input_queue, 2, (uint8_t *[2]){nn_input_buffers[0], nn_input_buffers[1]});
1870:Src/app.c     ****   assert(ret == 0);
 3189              		.loc 1 1870 3 discriminator 1 view .LVU1018
 3190 00ce 5F48     		ldr	r0, .L145+48
 3191 00d0 FFF7FEFF 		bl	__assert_func
 3192              	.LVL232:
 3193              	.L128:
 3194              	.LBB432:
 3195              	.LBB430:
1838:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
 3196              		.loc 1 1838 3 is_stmt 1 view .LVU1019
 3197 00d4 3046     		mov	r0, r6
 3198              	.LVL233:
1838:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
 3199              		.loc 1 1838 3 is_stmt 0 view .LVU1020
 3200 00d6 FFF7FEFF 		bl	UTIL_LCD_SetLayer
 3201              	.LVL234:
1839:Src/app.c     ****   UTIL_LCD_SetFont(&LCD_FONT);
 3202              		.loc 1 1839 3 is_stmt 1 view .LVU1021
 3203 00da 2046     		mov	r0, r4
 3204 00dc FFF7FEFF 		bl	UTIL_LCD_Clear
 3205              	.LVL235:
1840:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
 3206              		.loc 1 1840 3 view .LVU1022
 3207              	.LBE430:
 3208              	.LBE432:
 3209              	.LBB433:
 3210              	.LBB434:
 572:Src/app.c     ****   if (!bq->free)
 3211              		.loc 1 572 14 is_stmt 0 view .LVU1023
 3212 00e0 DFF8CC81 		ldr	r8, .L145+148
 3213              	.LBE434:
 3214              	.LBE433:
 3215              	.LBB439:
 3216              	.LBB431:
1840:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
ARM GAS  /tmp/ccbfgvbk.s 			page 140


 3217              		.loc 1 1840 3 view .LVU1024
 3218 00e4 5A48     		ldr	r0, .L145+52
 3219 00e6 FFF7FEFF 		bl	UTIL_LCD_SetFont
 3220              	.LVL236:
1841:Src/app.c     **** }
 3221              		.loc 1 1841 3 is_stmt 1 view .LVU1025
 3222 00ea 4FF0FF30 		mov	r0, #-1
 3223 00ee FFF7FEFF 		bl	UTIL_LCD_SetTextColor
 3224              	.LVL237:
1841:Src/app.c     **** }
 3225              		.loc 1 1841 3 is_stmt 0 view .LVU1026
 3226              	.LBE431:
 3227              	.LBE439:
1869:Src/app.c     ****   assert(ret == 0);
 3228              		.loc 1 1869 3 is_stmt 1 view .LVU1027
 3229              	.LBB440:
 3230              	.LBI433:
 565:Src/app.c     **** {
 3231              		.loc 1 565 12 view .LVU1028
 3232              	.LBB435:
 567:Src/app.c     **** 
 3233              		.loc 1 567 3 view .LVU1029
 569:Src/app.c     ****     return -1;
 3234              		.loc 1 569 3 view .LVU1030
 572:Src/app.c     ****   if (!bq->free)
 3235              		.loc 1 572 3 view .LVU1031
 572:Src/app.c     ****   if (!bq->free)
 3236              		.loc 1 572 14 is_stmt 0 view .LVU1032
 3237 00f2 4246     		mov	r2, r8
 3238 00f4 3946     		mov	r1, r7
 3239 00f6 3846     		mov	r0, r7
 3240 00f8 FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3241              	.LVL238:
 572:Src/app.c     ****   if (!bq->free)
 3242              		.loc 1 572 12 discriminator 1 view .LVU1033
 3243 00fc A8F10405 		sub	r5, r8, #4
 3244 0100 48F8040C 		str	r0, [r8, #-4]
 573:Src/app.c     ****     goto free_sem_error;
 3245              		.loc 1 573 3 is_stmt 1 view .LVU1034
 573:Src/app.c     ****     goto free_sem_error;
 3246              		.loc 1 573 6 is_stmt 0 view .LVU1035
 3247 0104 58B1     		cbz	r0, .L129
 575:Src/app.c     ****   if (!bq->ready)
 3248              		.loc 1 575 3 is_stmt 1 view .LVU1036
 575:Src/app.c     ****   if (!bq->ready)
 3249              		.loc 1 575 15 is_stmt 0 view .LVU1037
 3250 0106 2146     		mov	r1, r4
 3251 0108 3846     		mov	r0, r7
 3252 010a 08F15402 		add	r2, r8, #84
 3253 010e FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3254              	.LVL239:
 575:Src/app.c     ****   if (!bq->ready)
 3255              		.loc 1 575 13 discriminator 1 view .LVU1038
 3256 0112 6865     		str	r0, [r5, #84]
 576:Src/app.c     ****     goto ready_sem_error;
 3257              		.loc 1 576 3 is_stmt 1 view .LVU1039
 576:Src/app.c     ****     goto ready_sem_error;
ARM GAS  /tmp/ccbfgvbk.s 			page 141


 3258              		.loc 1 576 6 is_stmt 0 view .LVU1040
 3259 0114 40B9     		cbnz	r0, .L130
 577:Src/app.c     **** 
 3260              		.loc 1 577 5 is_stmt 1 view .LVU1041
 3261              	.LDL1:
 590:Src/app.c     **** free_sem_error:
 3262              		.loc 1 590 3 view .LVU1042
 3263 0116 58F8040C 		ldr	r0, [r8, #-4]
 3264 011a FFF7FEFF 		bl	vQueueDelete
 3265              	.LVL240:
 590:Src/app.c     **** free_sem_error:
 3266              		.loc 1 590 3 is_stmt 0 view .LVU1043
 3267              	.LBE435:
 3268              	.LBE440:
 3269              		.loc 1 1870 3 is_stmt 1 view .LVU1044
 3270              	.L129:
 3271              		.loc 1 1870 3 is_stmt 0 discriminator 1 view .LVU1045
 3272 011e 40F24E71 		movw	r1, #1870
 3273 0122 484B     		ldr	r3, .L145+40
 3274 0124 4B4A     		ldr	r2, .L145+56
 3275 0126 D2E7     		b	.L144
 3276              	.LVL241:
 3277              	.L130:
 3278              	.LBB441:
 3279              	.LBB436:
 579:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 3280              		.loc 1 579 3 is_stmt 1 view .LVU1046
 582:Src/app.c     ****   }
 3281              		.loc 1 582 20 is_stmt 0 view .LVU1047
 3282 0128 4B4B     		ldr	r3, .L145+60
 3283              	.LBE436:
 3284              	.LBE441:
 3285              	.LBB442:
 3286              	.LBB443:
 520:Src/app.c     **** }
 3287              		.loc 1 520 3 view .LVU1048
 3288 012a E022     		movs	r2, #224
 3289 012c 2146     		mov	r1, r4
 3290              	.LBE443:
 3291              	.LBE442:
 3292              	.LBB446:
 3293              	.LBB437:
 582:Src/app.c     ****   }
 3294              		.loc 1 582 20 view .LVU1049
 3295 012e C5F8AC30 		str	r3, [r5, #172]
 3296              	.LBE437:
 3297              	.LBE446:
 3298              	.LBB447:
 3299              	.LBB444:
 520:Src/app.c     **** }
 3300              		.loc 1 520 3 view .LVU1050
 3301 0132 4A48     		ldr	r0, .L145+64
 3302              	.LBE444:
 3303              	.LBE447:
 3304              	.LBB448:
 3305              	.LBB438:
 582:Src/app.c     ****   }
ARM GAS  /tmp/ccbfgvbk.s 			page 142


 3306              		.loc 1 582 20 view .LVU1051
 3307 0134 03F59623 		add	r3, r3, #307200
 584:Src/app.c     ****   bq->ready_idx = 0;
 3308              		.loc 1 584 16 view .LVU1052
 3309 0138 C5E92C34 		strd	r3, r4, [r5, #176]
 579:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 3310              		.loc 1 579 17 view .LVU1053
 3311 013c C5F8A870 		str	r7, [r5, #168]
 580:Src/app.c     ****     assert(buffers[i]);
 3312              		.loc 1 580 3 is_stmt 1 view .LVU1054
 3313              	.LVL242:
 580:Src/app.c     ****     assert(buffers[i]);
 3314              		.loc 1 580 17 discriminator 1 view .LVU1055
 581:Src/app.c     ****     bq->buffers[i] = buffers[i];
 3315              		.loc 1 581 5 view .LVU1056
 582:Src/app.c     ****   }
 3316              		.loc 1 582 5 view .LVU1057
 580:Src/app.c     ****     assert(buffers[i]);
 3317              		.loc 1 580 31 discriminator 2 view .LVU1058
 580:Src/app.c     ****     assert(buffers[i]);
 3318              		.loc 1 580 17 discriminator 1 view .LVU1059
 581:Src/app.c     ****     bq->buffers[i] = buffers[i];
 3319              		.loc 1 581 5 view .LVU1060
 582:Src/app.c     ****   }
 3320              		.loc 1 582 5 view .LVU1061
 585:Src/app.c     **** 
 3321              		.loc 1 585 3 view .LVU1062
 585:Src/app.c     **** 
 3322              		.loc 1 585 17 is_stmt 0 view .LVU1063
 3323 0140 C5F8B840 		str	r4, [r5, #184]
 587:Src/app.c     **** 
 3324              		.loc 1 587 3 is_stmt 1 view .LVU1064
 3325              	.LVL243:
 587:Src/app.c     **** 
 3326              		.loc 1 587 3 is_stmt 0 view .LVU1065
 3327              	.LBE438:
 3328              	.LBE448:
 3329              		.loc 1 1870 3 is_stmt 1 view .LVU1066
1871:Src/app.c     **** 
1872:Src/app.c     ****   cpuload_init(&cpu_load);
 3330              		.loc 1 1872 3 view .LVU1067
 3331              	.LBB449:
 3332              	.LBI442:
 518:Src/app.c     **** {
 3333              		.loc 1 518 13 view .LVU1068
 3334              	.LBB445:
 520:Src/app.c     **** }
 3335              		.loc 1 520 3 view .LVU1069
 3336 0144 FFF7FEFF 		bl	memset
 3337              	.LVL244:
 520:Src/app.c     **** }
 3338              		.loc 1 520 3 is_stmt 0 view .LVU1070
 3339              	.LBE445:
 3340              	.LBE449:
1873:Src/app.c     **** 
1874:Src/app.c     ****   /*** Camera Init ************************************************************/  
1875:Src/app.c     ****   CAM_Init();
ARM GAS  /tmp/ccbfgvbk.s 			page 143


 3341              		.loc 1 1875 3 is_stmt 1 view .LVU1071
 3342 0148 FFF7FEFF 		bl	CAM_Init
 3343              	.LVL245:
1876:Src/app.c     **** 
1877:Src/app.c     ****   /* sems + mutex init */
1878:Src/app.c     ****   isp_sem = xSemaphoreCreateCountingStatic(1, 0, &isp_sem_buffer);
 3344              		.loc 1 1878 3 view .LVU1072
 3345              		.loc 1 1878 13 is_stmt 0 view .LVU1073
 3346 014c 2146     		mov	r1, r4
 3347 014e 3046     		mov	r0, r6
 3348 0150 434A     		ldr	r2, .L145+68
 3349 0152 FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3350              	.LVL246:
 3351              		.loc 1 1878 11 discriminator 1 view .LVU1074
 3352 0156 434B     		ldr	r3, .L145+72
 3353 0158 1860     		str	r0, [r3]
1879:Src/app.c     ****   assert(isp_sem);
 3354              		.loc 1 1879 3 is_stmt 1 view .LVU1075
 3355 015a 20B9     		cbnz	r0, .L143
 3356              		.loc 1 1879 3 is_stmt 0 discriminator 1 view .LVU1076
 3357 015c 40F25771 		movw	r1, #1879
 3358 0160 414B     		ldr	r3, .L145+76
 3359 0162 3C4A     		ldr	r2, .L145+56
 3360 0164 B3E7     		b	.L144
 3361              	.L143:
1880:Src/app.c     ****   disp.update = xSemaphoreCreateCountingStatic(1, 0, &disp.update_buffer);
 3362              		.loc 1 1880 3 is_stmt 1 view .LVU1077
 3363              		.loc 1 1880 17 is_stmt 0 view .LVU1078
 3364 0166 414D     		ldr	r5, .L145+80
 3365 0168 2146     		mov	r1, r4
 3366 016a 2A46     		mov	r2, r5
 3367 016c 3046     		mov	r0, r6
 3368 016e FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3369              	.LVL247:
 3370              		.loc 1 1880 15 discriminator 1 view .LVU1079
 3371 0172 2F1F     		subs	r7, r5, #4
 3372 0174 45F8040C 		str	r0, [r5, #-4]
1881:Src/app.c     ****   assert(disp.update);
 3373              		.loc 1 1881 3 is_stmt 1 view .LVU1080
 3374 0178 20B9     		cbnz	r0, .L133
 3375              		.loc 1 1881 3 is_stmt 0 discriminator 1 view .LVU1081
 3376 017a 40F25971 		movw	r1, #1881
 3377 017e 3C4B     		ldr	r3, .L145+84
 3378 0180 344A     		ldr	r2, .L145+56
 3379 0182 A4E7     		b	.L144
 3380              	.L133:
1882:Src/app.c     ****   disp.lock = xSemaphoreCreateMutexStatic(&disp.lock_buffer);
 3381              		.loc 1 1882 3 is_stmt 1 view .LVU1082
 3382              		.loc 1 1882 15 is_stmt 0 view .LVU1083
 3383 0184 3046     		mov	r0, r6
 3384 0186 05F15401 		add	r1, r5, #84
 3385 018a FFF7FEFF 		bl	xQueueCreateMutexStatic
 3386              	.LVL248:
 3387              		.loc 1 1882 13 discriminator 1 view .LVU1084
 3388 018e 7865     		str	r0, [r7, #84]
1883:Src/app.c     ****   assert(disp.lock);
 3389              		.loc 1 1883 3 is_stmt 1 view .LVU1085
ARM GAS  /tmp/ccbfgvbk.s 			page 144


 3390 0190 20B9     		cbnz	r0, .L134
 3391              		.loc 1 1883 3 is_stmt 0 discriminator 1 view .LVU1086
 3392 0192 40F25B71 		movw	r1, #1883
 3393 0196 374B     		ldr	r3, .L145+88
 3394 0198 2E4A     		ldr	r2, .L145+56
 3395 019a 98E7     		b	.L144
 3396              	.L134:
1884:Src/app.c     **** 
1885:Src/app.c     ****   /* Start LCD Display camera pipe stream */
1886:Src/app.c     ****   CAM_DisplayPipe_Start(lcd_bg_buffer[0], CMW_MODE_CONTINUOUS);
 3397              		.loc 1 1886 3 is_stmt 1 view .LVU1087
 3398 019c 2146     		mov	r1, r4
 3399 019e 2148     		ldr	r0, .L145+8
 3400 01a0 FFF7FEFF 		bl	CAM_DisplayPipe_Start
 3401              	.LVL249:
1887:Src/app.c     **** 
1888:Src/app.c     ****   /* threads init */
1889:Src/app.c     ****   hdl = xTaskCreateStatic(nn_thread_fct, "nn", configMINIMAL_STACK_SIZE * 2, NULL, nn_priority, nn_
 3402              		.loc 1 1889 3 view .LVU1088
 3403              		.loc 1 1889 9 is_stmt 0 view .LVU1089
 3404 01a4 344B     		ldr	r3, .L145+92
 3405 01a6 4FF40062 		mov	r2, #2048
 3406 01aa 0293     		str	r3, [sp, #8]
 3407 01ac 334B     		ldr	r3, .L145+96
 3408 01ae 3449     		ldr	r1, .L145+100
 3409 01b0 0193     		str	r3, [sp, #4]
 3410 01b2 1D23     		movs	r3, #29
 3411 01b4 3348     		ldr	r0, .L145+104
 3412 01b6 0093     		str	r3, [sp]
 3413 01b8 2346     		mov	r3, r4
 3414 01ba FFF7FEFF 		bl	xTaskCreateStatic
 3415              	.LVL250:
1890:Src/app.c     ****                           &nn_thread);
1891:Src/app.c     ****   assert(hdl != NULL);
 3416              		.loc 1 1891 3 is_stmt 1 view .LVU1090
 3417 01be 20B9     		cbnz	r0, .L135
 3418              		.loc 1 1891 3 is_stmt 0 discriminator 1 view .LVU1091
 3419 01c0 40F26371 		movw	r1, #1891
 3420 01c4 304B     		ldr	r3, .L145+108
 3421 01c6 234A     		ldr	r2, .L145+56
 3422 01c8 81E7     		b	.L144
 3423              	.L135:
1892:Src/app.c     ****   hdl = xTaskCreateStatic(dp_thread_fct, "dp", configMINIMAL_STACK_SIZE * 2, NULL, dp_priority, dp_
 3424              		.loc 1 1892 3 is_stmt 1 view .LVU1092
 3425              		.loc 1 1892 9 is_stmt 0 view .LVU1093
 3426 01ca 304B     		ldr	r3, .L145+112
 3427 01cc 4FF40062 		mov	r2, #2048
 3428 01d0 0293     		str	r3, [sp, #8]
 3429 01d2 2F4B     		ldr	r3, .L145+116
 3430 01d4 2F49     		ldr	r1, .L145+120
 3431 01d6 0193     		str	r3, [sp, #4]
 3432 01d8 1A23     		movs	r3, #26
 3433 01da 2F48     		ldr	r0, .L145+124
 3434              	.LVL251:
 3435              		.loc 1 1892 9 view .LVU1094
 3436 01dc 0093     		str	r3, [sp]
 3437 01de 2346     		mov	r3, r4
ARM GAS  /tmp/ccbfgvbk.s 			page 145


 3438 01e0 FFF7FEFF 		bl	xTaskCreateStatic
 3439              	.LVL252:
1893:Src/app.c     ****                           &dp_thread);
1894:Src/app.c     ****   assert(hdl != NULL);
 3440              		.loc 1 1894 3 is_stmt 1 view .LVU1095
 3441 01e4 20B9     		cbnz	r0, .L136
 3442              		.loc 1 1894 3 is_stmt 0 discriminator 1 view .LVU1096
 3443 01e6 40F26671 		movw	r1, #1894
 3444 01ea 274B     		ldr	r3, .L145+108
 3445 01ec 194A     		ldr	r2, .L145+56
 3446 01ee 6EE7     		b	.L144
 3447              	.L136:
1895:Src/app.c     ****   hdl = xTaskCreateStatic(isp_thread_fct, "isp", configMINIMAL_STACK_SIZE * 2, NULL, isp_priority, 
 3448              		.loc 1 1895 3 is_stmt 1 view .LVU1097
 3449              		.loc 1 1895 9 is_stmt 0 view .LVU1098
 3450 01f0 2A4B     		ldr	r3, .L145+128
 3451 01f2 4FF40062 		mov	r2, #2048
 3452 01f6 0293     		str	r3, [sp, #8]
 3453 01f8 294B     		ldr	r3, .L145+132
 3454 01fa 2A49     		ldr	r1, .L145+136
 3455 01fc CDE90093 		strd	r9, r3, [sp]
 3456 0200 2948     		ldr	r0, .L145+140
 3457              	.LVL253:
 3458              		.loc 1 1895 9 view .LVU1099
 3459 0202 2346     		mov	r3, r4
 3460 0204 FFF7FEFF 		bl	xTaskCreateStatic
 3461              	.LVL254:
1896:Src/app.c     ****                           &isp_thread);
1897:Src/app.c     ****   assert(hdl != NULL);
 3462              		.loc 1 1897 3 is_stmt 1 view .LVU1100
 3463 0208 20B9     		cbnz	r0, .L125
 3464              		.loc 1 1897 3 is_stmt 0 discriminator 1 view .LVU1101
 3465 020a 40F26971 		movw	r1, #1897
 3466 020e 1E4B     		ldr	r3, .L145+108
 3467 0210 104A     		ldr	r2, .L145+56
 3468 0212 5CE7     		b	.L144
 3469              	.L125:
1898:Src/app.c     **** }
 3470              		.loc 1 1898 1 view .LVU1102
 3471 0214 13B0     		add	sp, sp, #76
 3472              		.cfi_def_cfa_offset 28
 3473              		@ sp needed
 3474 0216 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3475              	.L146:
 3476 021a 00BF     		.align	2
 3477              	.L145:
 3478 021c 00ED00E0 		.word	-536810240
 3479 0220 00000000 		.word	.LC15
 3480 0224 00882C00 		.word	lcd_bg_buffer
 3481 0228 00C05D00 		.word	6144000
 3482 022c 00181500 		.word	lcd_fg_buffer
 3483 0230 00701700 		.word	1536000
 3484 0234 00000000 		.word	lcd_bg_buffer_disp_idx
 3485 0238 2003E001 		.word	31458080
 3486 023c 00D02000 		.word	lcd_fg_buffer+768000
 3487 0240 00600900 		.word	screen_buffer
 3488 0244 11000000 		.word	.LC16
ARM GAS  /tmp/ccbfgvbk.s 			page 146


 3489 0248 00000000 		.word	__func__.5
 3490 024c 0E000000 		.word	.LC2
 3491 0250 00000000 		.word	Font20
 3492 0254 00000000 		.word	__func__.17
 3493 0258 00000000 		.word	nn_input_buffers
 3494 025c 00000000 		.word	cpu_load
 3495 0260 00000000 		.word	isp_sem_buffer
 3496 0264 00000000 		.word	isp_sem
 3497 0268 1A000000 		.word	.LC17
 3498 026c 04000000 		.word	disp+4
 3499 0270 22000000 		.word	.LC18
 3500 0274 2E000000 		.word	.LC19
 3501 0278 00000000 		.word	nn_thread
 3502 027c 00000000 		.word	nn_thread_stack
 3503 0280 38000000 		.word	.LC20
 3504 0284 00000000 		.word	nn_thread_fct
 3505 0288 3B000000 		.word	.LC21
 3506 028c 00000000 		.word	dp_thread
 3507 0290 00000000 		.word	dp_thread_stack
 3508 0294 47000000 		.word	.LC22
 3509 0298 00000000 		.word	dp_thread_fct
 3510 029c 00000000 		.word	isp_thread
 3511 02a0 00000000 		.word	isp_thread_stack
 3512 02a4 4A000000 		.word	.LC23
 3513 02a8 00000000 		.word	isp_thread_fct
 3514 02ac 00EE0200 		.word	192000
 3515 02b0 04000000 		.word	nn_input_queue+4
 3516              		.cfi_endproc
 3517              	.LFE7413:
 3519              		.section	.text.CMW_CAMERA_PIPE_FrameEventCallback,"ax",%progbits
 3520              		.align	1
 3521              		.global	CMW_CAMERA_PIPE_FrameEventCallback
 3522              		.syntax unified
 3523              		.thumb
 3524              		.thumb_func
 3526              	CMW_CAMERA_PIPE_FrameEventCallback:
 3527              	.LVL255:
 3528              	.LFB7414:
1899:Src/app.c     **** 
1900:Src/app.c     **** /**
1901:Src/app.c     ****  * @brief System-level callback registered with the camera driver for frame events.
1902:Src/app.c     ****  * @details This function is called from an Interrupt Service Routine (ISR) and
1903:Src/app.c     ****  * routes the event to the appropriate application-level handler.
1904:Src/app.c     ****  */
1905:Src/app.c     **** int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
1906:Src/app.c     **** {
 3529              		.loc 1 1906 1 is_stmt 1 view -0
 3530              		.cfi_startproc
 3531              		@ args = 0, pretend = 0, frame = 8
 3532              		@ frame_needed = 0, uses_anonymous_args = 0
1907:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3533              		.loc 1 1907 3 view .LVU1104
 3534              		.loc 1 1907 6 is_stmt 0 view .LVU1105
 3535 0000 0128     		cmp	r0, #1
1906:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3536              		.loc 1 1906 1 view .LVU1106
 3537 0002 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, r10, lr}
ARM GAS  /tmp/ccbfgvbk.s 			page 147


 3538              		.cfi_def_cfa_offset 40
 3539              		.cfi_offset 4, -32
 3540              		.cfi_offset 5, -28
 3541              		.cfi_offset 6, -24
 3542              		.cfi_offset 7, -20
 3543              		.cfi_offset 8, -16
 3544              		.cfi_offset 9, -12
 3545              		.cfi_offset 10, -8
 3546              		.cfi_offset 14, -4
1906:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3547              		.loc 1 1906 1 view .LVU1107
 3548 0006 0646     		mov	r6, r0
 3549              		.loc 1 1907 6 view .LVU1108
 3550 0008 50D1     		bne	.L148
1908:Src/app.c     ****     app_main_pipe_frame_event();
 3551              		.loc 1 1908 5 is_stmt 1 view .LVU1109
 3552              	.LBB460:
 3553              	.LBI460:
 689:Src/app.c     **** {
 3554              		.loc 1 689 13 view .LVU1110
 3555              	.LBB461:
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3556              		.loc 1 692 3 view .LVU1111
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3557              		.loc 1 692 47 is_stmt 0 view .LVU1112
 3558 000a 514F     		ldr	r7, .L174
 693:Src/app.c     ****   int ret;
 3559              		.loc 1 693 47 view .LVU1113
 3560 000c DFF87081 		ldr	r8, .L174+48
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3561              		.loc 1 692 47 view .LVU1114
 3562 0010 3D68     		ldr	r5, [r7]
 693:Src/app.c     ****   int ret;
 3563              		.loc 1 693 47 view .LVU1115
 3564 0012 D8F80040 		ldr	r4, [r8]
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3565              		.loc 1 692 47 view .LVU1116
 3566 0016 0135     		adds	r5, r5, #1
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3567              		.loc 1 692 7 view .LVU1117
 3568 0018 6B42     		rsbs	r3, r5, #0
 3569 001a 03F00303 		and	r3, r3, #3
 693:Src/app.c     ****   int ret;
 3570              		.loc 1 693 47 view .LVU1118
 3571 001e 04F10104 		add	r4, r4, #1
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3572              		.loc 1 692 7 view .LVU1119
 3573 0022 05F00305 		and	r5, r5, #3
 3574 0026 55EA43B5 		csneg	r5, r5, r3, mi
 3575              	.LVL256:
 693:Src/app.c     ****   int ret;
 3576              		.loc 1 693 3 is_stmt 1 view .LVU1120
 693:Src/app.c     ****   int ret;
 3577              		.loc 1 693 7 is_stmt 0 view .LVU1121
 3578 002a 6342     		rsbs	r3, r4, #0
 3579 002c 03F00303 		and	r3, r3, #3
 698:Src/app.c     ****   assert(ret == HAL_OK);
ARM GAS  /tmp/ccbfgvbk.s 			page 148


 3580              		.loc 1 698 78 view .LVU1122
 3581 0030 DFF850A1 		ldr	r10, .L174+52
 3582 0034 DFF85091 		ldr	r9, .L174+56
 693:Src/app.c     ****   int ret;
 3583              		.loc 1 693 7 view .LVU1123
 3584 0038 04F00304 		and	r4, r4, #3
 3585 003c 54EA43B4 		csneg	r4, r4, r3, mi
 3586              	.LVL257:
 694:Src/app.c     **** 
 3587              		.loc 1 694 3 is_stmt 1 view .LVU1124
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3588              		.loc 1 697 3 view .LVU1125
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3589              		.loc 1 697 9 is_stmt 0 view .LVU1126
 3590 0040 FFF7FEFF 		bl	CMW_CAMERA_GetDCMIPPHandle
 3591              	.LVL258:
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3592              		.loc 1 697 9 view .LVU1127
 3593 0044 3146     		mov	r1, r6
 3594 0046 0022     		movs	r2, #0
 3595 0048 0AFB0493 		mla	r3, r10, r4, r9
 3596 004c FFF7FEFF 		bl	HAL_DCMIPP_PIPE_SetMemoryAddress
 3597              	.LVL259:
 699:Src/app.c     **** 
 3598              		.loc 1 699 3 is_stmt 1 view .LVU1128
 3599 0050 0146     		mov	r1, r0
 3600 0052 30B1     		cbz	r0, .L149
 699:Src/app.c     **** 
 3601              		.loc 1 699 3 is_stmt 0 discriminator 1 view .LVU1129
 3602 0054 40F2BB21 		movw	r1, #699
 3603 0058 3E4B     		ldr	r3, .L174+4
 3604 005a 3F4A     		ldr	r2, .L174+8
 3605              	.LVL260:
 3606              	.L173:
 3607              	.LBB462:
 3608              	.LBB463:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3609              		.loc 1 675 3 discriminator 1 view .LVU1130
 3610 005c 3F48     		ldr	r0, .L174+12
 3611 005e FFF7FEFF 		bl	__assert_func
 3612              	.LVL261:
 3613              	.L149:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3614              		.loc 1 675 3 discriminator 1 view .LVU1131
 3615              	.LBE463:
 3616              	.LBE462:
 702:Src/app.c     ****   lcd_bg_buffer_disp_idx = next_disp_idx;
 3617              		.loc 1 702 3 is_stmt 1 view .LVU1132
 3618              	.LBB465:
 3619              	.LBI462:
 670:Src/app.c     **** {
 3620              		.loc 1 670 13 view .LVU1133
 3621              	.LBB464:
 672:Src/app.c     **** 
 3622              		.loc 1 672 3 view .LVU1134
 674:Src/app.c     ****   assert(ret == 0);
 3623              		.loc 1 674 3 view .LVU1135
ARM GAS  /tmp/ccbfgvbk.s 			page 149


 674:Src/app.c     ****   assert(ret == 0);
 3624              		.loc 1 674 9 is_stmt 0 view .LVU1136
 3625 0062 0AFB0590 		mla	r0, r10, r5, r9
 3626              	.LVL262:
 674:Src/app.c     ****   assert(ret == 0);
 3627              		.loc 1 674 9 view .LVU1137
 3628 0066 FFF7FEFF 		bl	SCRL_SetAddress_NoReload
 3629              	.LVL263:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3630              		.loc 1 675 3 is_stmt 1 view .LVU1138
 3631 006a 20B1     		cbz	r0, .L150
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3632              		.loc 1 675 3 is_stmt 0 discriminator 1 view .LVU1139
 3633 006c 40F2A321 		movw	r1, #675
 3634 0070 3B4B     		ldr	r3, .L174+16
 3635 0072 3C4A     		ldr	r2, .L174+20
 3636 0074 F2E7     		b	.L173
 3637              	.L150:
 676:Src/app.c     ****   assert(ret == 0);
 3638              		.loc 1 676 3 is_stmt 1 view .LVU1140
 676:Src/app.c     ****   assert(ret == 0);
 3639              		.loc 1 676 9 is_stmt 0 view .LVU1141
 3640 0076 FFF7FEFF 		bl	SCRL_ReloadLayer
 3641              	.LVL264:
 677:Src/app.c     **** 
 3642              		.loc 1 677 3 is_stmt 1 view .LVU1142
 3643 007a 20B1     		cbz	r0, .L151
 677:Src/app.c     **** 
 3644              		.loc 1 677 3 is_stmt 0 discriminator 1 view .LVU1143
 3645 007c 40F2A521 		movw	r1, #677
 3646 0080 374B     		ldr	r3, .L174+16
 3647 0082 384A     		ldr	r2, .L174+20
 3648 0084 EAE7     		b	.L173
 3649              	.L151:
 679:Src/app.c     ****   assert(ret == 0);
 3650              		.loc 1 679 3 is_stmt 1 view .LVU1144
 679:Src/app.c     ****   assert(ret == 0);
 3651              		.loc 1 679 9 is_stmt 0 view .LVU1145
 3652 0086 FFF7FEFF 		bl	SRCL_Update
 3653              	.LVL265:
 680:Src/app.c     **** }
 3654              		.loc 1 680 3 is_stmt 1 view .LVU1146
 3655 008a 20B1     		cbz	r0, .L152
 680:Src/app.c     **** }
 3656              		.loc 1 680 3 is_stmt 0 discriminator 1 view .LVU1147
 3657 008c 4FF42A71 		mov	r1, #680
 3658 0090 334B     		ldr	r3, .L174+16
 3659 0092 344A     		ldr	r2, .L174+20
 3660 0094 E2E7     		b	.L173
 3661              	.L152:
 3662              	.LVL266:
 680:Src/app.c     **** }
 3663              		.loc 1 680 3 discriminator 1 view .LVU1148
 3664              	.LBE464:
 3665              	.LBE465:
 703:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 3666              		.loc 1 703 3 is_stmt 1 view .LVU1149
ARM GAS  /tmp/ccbfgvbk.s 			page 150


 706:Src/app.c     **** }
 3667              		.loc 1 706 17 is_stmt 0 view .LVU1150
 3668 0096 344A     		ldr	r2, .L174+24
 703:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 3669              		.loc 1 703 26 view .LVU1151
 3670 0098 3D60     		str	r5, [r7]
 704:Src/app.c     **** 
 3671              		.loc 1 704 3 is_stmt 1 view .LVU1152
 706:Src/app.c     **** }
 3672              		.loc 1 706 17 is_stmt 0 view .LVU1153
 3673 009a 1368     		ldr	r3, [r2]
 704:Src/app.c     **** 
 3674              		.loc 1 704 26 view .LVU1154
 3675 009c C8F80040 		str	r4, [r8]
 706:Src/app.c     **** }
 3676              		.loc 1 706 3 is_stmt 1 view .LVU1155
 706:Src/app.c     **** }
 3677              		.loc 1 706 17 is_stmt 0 view .LVU1156
 3678 00a0 0133     		adds	r3, r3, #1
 3679 00a2 1360     		str	r3, [r2]
 3680              	.LVL267:
 3681              	.L153:
 706:Src/app.c     **** }
 3682              		.loc 1 706 17 view .LVU1157
 3683              	.LBE461:
 3684              	.LBE460:
1909:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
1910:Src/app.c     ****     app_ancillary_pipe_frame_event();
1911:Src/app.c     **** 
1912:Src/app.c     ****   return HAL_OK;
 3685              		.loc 1 1912 3 is_stmt 1 view .LVU1158
1913:Src/app.c     **** }
 3686              		.loc 1 1913 1 is_stmt 0 view .LVU1159
 3687 00a4 0020     		movs	r0, #0
 3688 00a6 02B0     		add	sp, sp, #8
 3689              		.cfi_remember_state
 3690              		.cfi_def_cfa_offset 32
 3691              		@ sp needed
 3692 00a8 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3693              	.LVL268:
 3694              	.L148:
 3695              		.cfi_restore_state
1909:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
 3696              		.loc 1 1909 8 is_stmt 1 view .LVU1160
1909:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
 3697              		.loc 1 1909 11 is_stmt 0 view .LVU1161
 3698 00ac 0228     		cmp	r0, #2
 3699 00ae F9D1     		bne	.L153
1910:Src/app.c     **** 
 3700              		.loc 1 1910 5 is_stmt 1 view .LVU1162
 3701              	.LBB466:
 3702              	.LBI466:
 714:Src/app.c     **** {
 3703              		.loc 1 714 13 view .LVU1163
 3704              	.LBB467:
 716:Src/app.c     ****   int ret;
 3705              		.loc 1 716 3 view .LVU1164
ARM GAS  /tmp/ccbfgvbk.s 			page 151


 717:Src/app.c     **** 
 3706              		.loc 1 717 3 view .LVU1165
 719:Src/app.c     ****   if (next_buffer) {
 3707              		.loc 1 719 3 view .LVU1166
 3708              	.LBB468:
 3709              	.LBI468:
 600:Src/app.c     **** {
 3710              		.loc 1 600 17 view .LVU1167
 3711              	.LVL269:
 3712              	.LBB469:
 602:Src/app.c     ****   int ret;
 3713              		.loc 1 602 3 view .LVU1168
 603:Src/app.c     **** 
 3714              		.loc 1 603 3 view .LVU1169
 605:Src/app.c     ****   if (ret == pdFALSE)
 3715              		.loc 1 605 3 view .LVU1170
 605:Src/app.c     ****   if (ret == pdFALSE)
 3716              		.loc 1 605 9 is_stmt 0 view .LVU1171
 3717 00b0 2E4C     		ldr	r4, .L174+28
 605:Src/app.c     ****   if (ret == pdFALSE)
 3718              		.loc 1 605 9 discriminator 4 view .LVU1172
 3719 00b2 0021     		movs	r1, #0
 3720 00b4 2068     		ldr	r0, [r4]
 3721              	.LVL270:
 605:Src/app.c     ****   if (ret == pdFALSE)
 3722              		.loc 1 605 9 discriminator 4 view .LVU1173
 3723 00b6 FFF7FEFF 		bl	xQueueSemaphoreTake
 3724              	.LVL271:
 606:Src/app.c     ****     return NULL;
 3725              		.loc 1 606 3 is_stmt 1 view .LVU1174
 606:Src/app.c     ****     return NULL;
 3726              		.loc 1 606 6 is_stmt 0 view .LVU1175
 3727 00ba 0028     		cmp	r0, #0
 3728 00bc F2D0     		beq	.L153
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3729              		.loc 1 609 3 is_stmt 1 view .LVU1176
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3730              		.loc 1 609 23 is_stmt 0 view .LVU1177
 3731 00be D4F8B420 		ldr	r2, [r4, #180]
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3732              		.loc 1 609 7 view .LVU1178
 3733 00c2 04EB8203 		add	r3, r4, r2, lsl #2
 3734 00c6 D3F8AC50 		ldr	r5, [r3, #172]
 3735              	.LVL272:
 610:Src/app.c     **** 
 3736              		.loc 1 610 3 is_stmt 1 view .LVU1179
 610:Src/app.c     **** 
 3737              		.loc 1 610 37 is_stmt 0 view .LVU1180
 3738 00ca D4F8A830 		ldr	r3, [r4, #168]
 610:Src/app.c     **** 
 3739              		.loc 1 610 32 view .LVU1181
 3740 00ce 0132     		adds	r2, r2, #1
 610:Src/app.c     **** 
 3741              		.loc 1 610 37 view .LVU1182
 3742 00d0 92FBF3F1 		sdiv	r1, r2, r3
 3743 00d4 03FB1122 		mls	r2, r3, r1, r2
 610:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 152


 3744              		.loc 1 610 16 view .LVU1183
 3745 00d8 C4F8B420 		str	r2, [r4, #180]
 612:Src/app.c     **** }
 3746              		.loc 1 612 3 is_stmt 1 view .LVU1184
 3747              	.LVL273:
 612:Src/app.c     **** }
 3748              		.loc 1 612 3 is_stmt 0 view .LVU1185
 3749              	.LBE469:
 3750              	.LBE468:
 720:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 3751              		.loc 1 720 3 is_stmt 1 view .LVU1186
 720:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 3752              		.loc 1 720 6 is_stmt 0 view .LVU1187
 3753 00dc 002D     		cmp	r5, #0
 3754 00de E1D0     		beq	.L153
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3755              		.loc 1 721 5 is_stmt 1 view .LVU1188
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3756              		.loc 1 721 11 is_stmt 0 view .LVU1189
 3757 00e0 FFF7FEFF 		bl	CMW_CAMERA_GetDCMIPPHandle
 3758              	.LVL274:
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3759              		.loc 1 721 11 discriminator 1 view .LVU1190
 3760 00e4 2B46     		mov	r3, r5
 3761 00e6 0022     		movs	r2, #0
 3762 00e8 3146     		mov	r1, r6
 3763 00ea FFF7FEFF 		bl	HAL_DCMIPP_PIPE_SetMemoryAddress
 3764              	.LVL275:
 723:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 3765              		.loc 1 723 5 is_stmt 1 view .LVU1191
 3766 00ee 20B1     		cbz	r0, .L156
 723:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 3767              		.loc 1 723 5 is_stmt 0 discriminator 1 view .LVU1192
 3768 00f0 40F2D321 		movw	r1, #723
 3769 00f4 174B     		ldr	r3, .L174+4
 3770 00f6 1E4A     		ldr	r2, .L174+32
 3771 00f8 B0E7     		b	.L173
 3772              	.L156:
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3773              		.loc 1 725 5 is_stmt 1 view .LVU1193
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3774              		.loc 1 725 48 is_stmt 0 view .LVU1194
 3775 00fa 1B4B     		ldr	r3, .L174+24
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3776              		.loc 1 725 31 view .LVU1195
 3777 00fc 1D4A     		ldr	r2, .L174+36
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3778              		.loc 1 725 48 view .LVU1196
 3779 00fe 1B68     		ldr	r3, [r3]
 3780              	.LBB470:
 3781              	.LBB471:
 651:Src/app.c     ****   int ret;
 3782              		.loc 1 651 14 view .LVU1197
 3783 0100 0190     		str	r0, [sp, #4]
 3784              	.LBE471:
 3785              	.LBE470:
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
ARM GAS  /tmp/ccbfgvbk.s 			page 153


 3786              		.loc 1 725 48 view .LVU1198
 3787 0102 013B     		subs	r3, r3, #1
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3788              		.loc 1 725 31 view .LVU1199
 3789 0104 1360     		str	r3, [r2]
 726:Src/app.c     ****   }
 3790              		.loc 1 726 5 is_stmt 1 view .LVU1200
 3791              	.LBB473:
 3792              	.LBI470:
 649:Src/app.c     **** {
 3793              		.loc 1 649 13 view .LVU1201
 3794              	.LVL276:
 3795              	.LBB472:
 651:Src/app.c     ****   int ret;
 3796              		.loc 1 651 3 view .LVU1202
 652:Src/app.c     **** 
 3797              		.loc 1 652 3 view .LVU1203
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3798              		.loc 1 654 3 view .LVU1204
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3799              		.loc 1 654 7 is_stmt 0 view .LVU1205
 3800 0106 FFF7FEFF 		bl	xPortIsInsideInterrupt
 3801              	.LVL277:
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3802              		.loc 1 654 6 discriminator 1 view .LVU1206
 3803 010a 0346     		mov	r3, r0
 3804 010c A0B1     		cbz	r0, .L157
 655:Src/app.c     ****     assert(ret == pdTRUE);
 3805              		.loc 1 655 5 is_stmt 1 view .LVU1207
 655:Src/app.c     ****     assert(ret == pdTRUE);
 3806              		.loc 1 655 11 is_stmt 0 view .LVU1208
 3807 010e 606D     		ldr	r0, [r4, #84]
 3808 0110 01A9     		add	r1, sp, #4
 3809 0112 FFF7FEFF 		bl	xQueueGiveFromISR
 3810              	.LVL278:
 656:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3811              		.loc 1 656 5 is_stmt 1 view .LVU1209
 3812 0116 0128     		cmp	r0, #1
 3813 0118 04D0     		beq	.L158
 656:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3814              		.loc 1 656 5 is_stmt 0 discriminator 1 view .LVU1210
 3815 011a 4FF42471 		mov	r1, #656
 3816 011e 164B     		ldr	r3, .L174+40
 3817 0120 164A     		ldr	r2, .L174+44
 3818 0122 9BE7     		b	.L173
 3819              	.L158:
 657:Src/app.c     ****   } else {
 3820              		.loc 1 657 5 is_stmt 1 view .LVU1211
 657:Src/app.c     ****   } else {
 3821              		.loc 1 657 5 view .LVU1212
 3822 0124 019B     		ldr	r3, [sp, #4]
 3823 0126 002B     		cmp	r3, #0
 3824 0128 BCD0     		beq	.L153
 657:Src/app.c     ****   } else {
 3825              		.loc 1 657 5 discriminator 1 view .LVU1213
 3826 012a 4FF0E023 		mov	r3, #-536813568
 3827 012e 4FF08052 		mov	r2, #268435456
ARM GAS  /tmp/ccbfgvbk.s 			page 154


 3828 0132 C3F8042D 		str	r2, [r3, #3332]
 3829 0136 B5E7     		b	.L153
 3830              	.LVL279:
 3831              	.L157:
 659:Src/app.c     ****     assert(ret == pdTRUE);
 3832              		.loc 1 659 5 view .LVU1214
 659:Src/app.c     ****     assert(ret == pdTRUE);
 3833              		.loc 1 659 11 is_stmt 0 view .LVU1215
 3834 0138 0246     		mov	r2, r0
 3835 013a 0146     		mov	r1, r0
 3836 013c 606D     		ldr	r0, [r4, #84]
 3837 013e FFF7FEFF 		bl	xQueueGenericSend
 3838              	.LVL280:
 660:Src/app.c     ****   }
 3839              		.loc 1 660 5 is_stmt 1 view .LVU1216
 3840 0142 0128     		cmp	r0, #1
 3841 0144 AED0     		beq	.L153
 660:Src/app.c     ****   }
 3842              		.loc 1 660 5 is_stmt 0 discriminator 1 view .LVU1217
 3843 0146 4FF42571 		mov	r1, #660
 3844 014a 0B4B     		ldr	r3, .L174+40
 3845 014c 0B4A     		ldr	r2, .L174+44
 3846 014e 85E7     		b	.L173
 3847              	.L175:
 3848              		.align	2
 3849              	.L174:
 3850 0150 00000000 		.word	lcd_bg_buffer_disp_idx
 3851 0154 00000000 		.word	.LC8
 3852 0158 00000000 		.word	__func__.3
 3853 015c 0E000000 		.word	.LC2
 3854 0160 11000000 		.word	.LC16
 3855 0164 00000000 		.word	__func__.2
 3856 0168 00000000 		.word	frame_event_nb
 3857 016c 00000000 		.word	nn_input_queue
 3858 0170 00000000 		.word	__func__.1
 3859 0174 00000000 		.word	frame_event_nb_for_resize
 3860 0178 00000000 		.word	.LC1
 3861 017c 00000000 		.word	__func__.0
 3862 0180 00000000 		.word	lcd_bg_buffer_capt_idx
 3863 0184 00701700 		.word	1536000
 3864 0188 00882C00 		.word	lcd_bg_buffer
 3865              	.LBE472:
 3866              	.LBE473:
 3867              	.LBE467:
 3868              	.LBE466:
 3869              		.cfi_endproc
 3870              	.LFE7414:
 3872              		.section	.text.CMW_CAMERA_PIPE_VsyncEventCallback,"ax",%progbits
 3873              		.align	1
 3874              		.global	CMW_CAMERA_PIPE_VsyncEventCallback
 3875              		.syntax unified
 3876              		.thumb
 3877              		.thumb_func
 3879              	CMW_CAMERA_PIPE_VsyncEventCallback:
 3880              	.LVL281:
 3881              	.LFB7415:
1914:Src/app.c     **** 
ARM GAS  /tmp/ccbfgvbk.s 			page 155


1915:Src/app.c     **** /**
1916:Src/app.c     ****  * @brief System-level callback for VSYNC events.
1917:Src/app.c     ****  */
1918:Src/app.c     **** int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
1919:Src/app.c     **** {
 3882              		.loc 1 1919 1 is_stmt 1 view -0
 3883              		.cfi_startproc
 3884              		@ args = 0, pretend = 0, frame = 8
 3885              		@ frame_needed = 0, uses_anonymous_args = 0
1920:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3886              		.loc 1 1920 3 view .LVU1219
 3887              		.loc 1 1920 6 is_stmt 0 view .LVU1220
 3888 0000 0128     		cmp	r0, #1
1919:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3889              		.loc 1 1919 1 view .LVU1221
 3890 0002 07B5     		push	{r0, r1, r2, lr}
 3891              		.cfi_def_cfa_offset 16
 3892              		.cfi_offset 14, -4
 3893              		.loc 1 1920 6 view .LVU1222
 3894 0004 10D1     		bne	.L177
1921:Src/app.c     ****     app_main_pipe_vsync_event();
 3895              		.loc 1 1921 5 is_stmt 1 view .LVU1223
 3896              	.LBB476:
 3897              	.LBI476:
 736:Src/app.c     **** {
 3898              		.loc 1 736 13 view .LVU1224
 3899              	.LBB477:
 738:Src/app.c     ****   int ret;
 3900              		.loc 1 738 3 view .LVU1225
 738:Src/app.c     ****   int ret;
 3901              		.loc 1 738 14 is_stmt 0 view .LVU1226
 3902 0006 0023     		movs	r3, #0
 3903 0008 0193     		str	r3, [sp, #4]
 739:Src/app.c     **** 
 3904              		.loc 1 739 3 is_stmt 1 view .LVU1227
 741:Src/app.c     ****   if (ret == pdTRUE)
 3905              		.loc 1 741 3 view .LVU1228
 741:Src/app.c     ****   if (ret == pdTRUE)
 3906              		.loc 1 741 9 is_stmt 0 view .LVU1229
 3907 000a 094B     		ldr	r3, .L182
 3908 000c 01A9     		add	r1, sp, #4
 3909 000e 1868     		ldr	r0, [r3]
 3910              	.LVL282:
 741:Src/app.c     ****   if (ret == pdTRUE)
 3911              		.loc 1 741 9 view .LVU1230
 3912 0010 FFF7FEFF 		bl	xQueueGiveFromISR
 3913              	.LVL283:
 742:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3914              		.loc 1 742 3 is_stmt 1 view .LVU1231
 742:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3915              		.loc 1 742 6 is_stmt 0 view .LVU1232
 3916 0014 0128     		cmp	r0, #1
 3917 0016 07D1     		bne	.L177
 743:Src/app.c     **** }
 3918              		.loc 1 743 5 is_stmt 1 view .LVU1233
 743:Src/app.c     **** }
 3919              		.loc 1 743 5 view .LVU1234
ARM GAS  /tmp/ccbfgvbk.s 			page 156


 3920 0018 019B     		ldr	r3, [sp, #4]
 3921 001a 2BB1     		cbz	r3, .L177
 743:Src/app.c     **** }
 3922              		.loc 1 743 5 discriminator 1 view .LVU1235
 3923 001c 4FF0E023 		mov	r3, #-536813568
 3924 0020 4FF08052 		mov	r2, #268435456
 3925 0024 C3F8042D 		str	r2, [r3, #3332]
 743:Src/app.c     **** }
 3926              		.loc 1 743 5 discriminator 3 view .LVU1236
 3927              	.LVL284:
 3928              	.L177:
 743:Src/app.c     **** }
 3929              		.loc 1 743 5 is_stmt 0 discriminator 3 view .LVU1237
 3930              	.LBE477:
 3931              	.LBE476:
1922:Src/app.c     **** 
1923:Src/app.c     ****   return HAL_OK;
 3932              		.loc 1 1923 3 is_stmt 1 view .LVU1238
1924:Src/app.c     **** }
 3933              		.loc 1 1924 1 is_stmt 0 view .LVU1239
 3934 0028 0020     		movs	r0, #0
 3935 002a 03B0     		add	sp, sp, #12
 3936              		.cfi_def_cfa_offset 4
 3937              		@ sp needed
 3938 002c 5DF804FB 		ldr	pc, [sp], #4
 3939              	.L183:
 3940              		.align	2
 3941              	.L182:
 3942 0030 00000000 		.word	isp_sem
 3943              		.cfi_endproc
 3944              	.LFE7415:
 3946              		.section	.rodata.__func__.0,"a"
 3949              	__func__.0:
 3950 0000 62717565 		.ascii	"bqueue_put_ready\000"
 3950      75655F70 
 3950      75745F72 
 3950      65616479 
 3950      00
 3951              		.section	.rodata.__func__.1,"a"
 3954              	__func__.1:
 3955 0000 6170705F 		.ascii	"app_ancillary_pipe_frame_event\000"
 3955      616E6369 
 3955      6C6C6172 
 3955      795F7069 
 3955      70655F66 
 3956              		.section	.rodata.__func__.2,"a"
 3959              	__func__.2:
 3960 0000 72656C6F 		.ascii	"reload_bg_layer\000"
 3960      61645F62 
 3960      675F6C61 
 3960      79657200 
 3961              		.section	.rodata.__func__.3,"a"
 3964              	__func__.3:
 3965 0000 6170705F 		.ascii	"app_main_pipe_frame_event\000"
 3965      6D61696E 
 3965      5F706970 
 3965      655F6672 
ARM GAS  /tmp/ccbfgvbk.s 			page 157


 3965      616D655F 
 3966              		.section	.rodata.__func__.5,"a"
 3969              	__func__.5:
 3970 0000 44697370 		.ascii	"Display_init\000"
 3970      6C61795F 
 3970      696E6974 
 3970      00
 3971              		.section	.rodata.__func__.6,"a"
 3974              	__func__.6:
 3975 0000 62717565 		.ascii	"bqueue_put_free\000"
 3975      75655F70 
 3975      75745F66 
 3975      72656500 
 3976              		.section	.rodata.__func__.7,"a"
 3979              	__func__.7:
 3980 0000 796F6C6F 		.ascii	"yolo_detector_run\000"
 3980      5F646574 
 3980      6563746F 
 3980      725F7275 
 3980      6E00
 3981              		.section	.rodata.__func__.8,"a"
 3984              	__func__.8:
 3985 0000 62717565 		.ascii	"bqueue_get_ready\000"
 3985      75655F67 
 3985      65745F72 
 3985      65616479 
 3985      00
 3986              		.section	.rodata.__func__.9,"a"
 3989              	__func__.9:
 3990 0000 6E6E5F74 		.ascii	"nn_thread_fct\000"
 3990      68726561 
 3990      645F6663 
 3990      7400
 3991              		.section	.rodata.__func__.10,"a"
 3994              	__func__.10:
 3995 0000 64705F63 		.ascii	"dp_commit_drawing_area\000"
 3995      6F6D6D69 
 3995      745F6472 
 3995      6177696E 
 3995      675F6172 
 3996              		.section	.rodata.__func__.11,"a"
 3999              	__func__.11:
 4000 0000 64705F75 		.ascii	"dp_update_drawing_area\000"
 4000      70646174 
 4000      655F6472 
 4000      6177696E 
 4000      675F6172 
 4001              		.section	.rodata.__func__.12,"a"
 4004              	__func__.12:
 4005 0000 62757474 		.ascii	"button_init\000"
 4005      6F6E5F69 
 4005      6E697400 
 4006              		.section	.rodata.__func__.13,"a"
 4009              	__func__.13:
 4010 0000 6F6E5F6C 		.ascii	"on_ld_toggle_button_click\000"
 4010      645F746F 
 4010      67676C65 
ARM GAS  /tmp/ccbfgvbk.s 			page 158


 4010      5F627574 
 4010      746F6E5F 
 4011              		.section	.rodata.__func__.14,"a"
 4014              	__func__.14:
 4015 0000 6F6E5F70 		.ascii	"on_pd_toggle_button_click\000"
 4015      645F746F 
 4015      67676C65 
 4015      5F627574 
 4015      746F6E5F 
 4016              		.section	.rodata.__func__.15,"a"
 4019              	__func__.15:
 4020 0000 64705F74 		.ascii	"dp_thread_fct\000"
 4020      68726561 
 4020      645F6663 
 4020      7400
 4021              		.section	.rodata.__func__.16,"a"
 4024              	__func__.16:
 4025 0000 6973705F 		.ascii	"isp_thread_fct\000"
 4025      74687265 
 4025      61645F66 
 4025      637400
 4026              		.section	.rodata.__func__.17,"a"
 4029              	__func__.17:
 4030 0000 6170705F 		.ascii	"app_run\000"
 4030      72756E00 
 4031              		.section	.bss.isp_sem_buffer,"aw",%nobits
 4032              		.align	2
 4035              	isp_sem_buffer:
 4036 0000 00000000 		.space	80
 4036      00000000 
 4036      00000000 
 4036      00000000 
 4036      00000000 
 4037              		.section	.bss.isp_sem,"aw",%nobits
 4038              		.align	2
 4041              	isp_sem:
 4042 0000 00000000 		.space	4
 4043              		.section	.bss.isp_thread_stack,"aw",%nobits
 4044              		.align	2
 4047              	isp_thread_stack:
 4048 0000 00000000 		.space	8192
 4048      00000000 
 4048      00000000 
 4048      00000000 
 4048      00000000 
 4049              		.section	.bss.isp_thread,"aw",%nobits
 4050              		.align	2
 4053              	isp_thread:
 4054 0000 00000000 		.space	96
 4054      00000000 
 4054      00000000 
 4054      00000000 
 4054      00000000 
 4055              		.section	.bss.dp_thread_stack,"aw",%nobits
 4056              		.align	2
 4059              	dp_thread_stack:
 4060 0000 00000000 		.space	8192
ARM GAS  /tmp/ccbfgvbk.s 			page 159


 4060      00000000 
 4060      00000000 
 4060      00000000 
 4060      00000000 
 4061              		.section	.bss.dp_thread,"aw",%nobits
 4062              		.align	2
 4065              	dp_thread:
 4066 0000 00000000 		.space	96
 4066      00000000 
 4066      00000000 
 4066      00000000 
 4066      00000000 
 4067              		.section	.bss.nn_thread_stack,"aw",%nobits
 4068              		.align	2
 4071              	nn_thread_stack:
 4072 0000 00000000 		.space	8192
 4072      00000000 
 4072      00000000 
 4072      00000000 
 4072      00000000 
 4073              		.section	.bss.nn_thread,"aw",%nobits
 4074              		.align	2
 4077              	nn_thread:
 4078 0000 00000000 		.space	96
 4078      00000000 
 4078      00000000 
 4078      00000000 
 4078      00000000 
 4079              		.section	.bss.nn_input_queue,"aw",%nobits
 4080              		.align	2
 4083              	nn_input_queue:
 4084 0000 00000000 		.space	188
 4084      00000000 
 4084      00000000 
 4084      00000000 
 4084      00000000 
 4085              		.section	.psram_bss,"aw"
 4086              		.align	5
 4089              	nn_input_buffers:
 4090 0000 00000000 		.space	614400
 4090      00000000 
 4090      00000000 
 4090      00000000 
 4090      00000000 
 4091              		.section	.bss.frame_event_nb_for_resize,"aw",%nobits
 4092              		.align	2
 4095              	frame_event_nb_for_resize:
 4096 0000 00000000 		.space	4
 4097              		.section	.bss.frame_event_nb,"aw",%nobits
 4098              		.align	2
 4101              	frame_event_nb:
 4102 0000 00000000 		.space	4
 4103              		.section	.data.NN_Instance_face_landmark,"aw"
 4104              		.align	2
 4107              	NN_Instance_face_landmark:
 4108 0000 00000000 		.word	NN_Interface_face_landmark
 4109 0004 00000000 		.word	0
ARM GAS  /tmp/ccbfgvbk.s 			page 160


 4110 0008 00000000 		.space	40
 4110      00000000 
 4110      00000000 
 4110      00000000 
 4110      00000000 
 4111              		.section	.rodata.str1.1,"aMS",%progbits,1
 4112              	.LC24:
 4113 0000 66616365 		.ascii	"face_landmark\000"
 4113      5F6C616E 
 4113      646D6172 
 4113      6B00
 4114              		.section	.rodata.NN_Interface_face_landmark,"a"
 4115              		.align	2
 4118              	NN_Interface_face_landmark:
 4119 0000 00000000 		.word	.LC24
 4120 0004 00000000 		.word	LL_ATON_EC_Network_Init_face_landmark
 4121 0008 00000000 		.word	LL_ATON_EC_Inference_Init_face_landmark
 4122 000c 00000000 		.word	LL_ATON_Set_User_Input_Buffer_face_landmark
 4123 0010 00000000 		.word	LL_ATON_Get_User_Input_Buffer_face_landmark
 4124 0014 00000000 		.word	LL_ATON_Set_User_Output_Buffer_face_landmark
 4125 0018 00000000 		.word	LL_ATON_Get_User_Output_Buffer_face_landmark
 4126 001c 00000000 		.word	LL_ATON_EpochBlockItems_face_landmark
 4127 0020 00000000 		.word	LL_ATON_Output_Buffers_Info_face_landmark
 4128 0024 00000000 		.word	LL_ATON_Input_Buffers_Info_face_landmark
 4129 0028 00000000 		.word	LL_ATON_Internal_Buffers_Info_face_landmark
 4130              		.section	.data.NN_Instance_yolo_detector,"aw"
 4131              		.align	2
 4134              	NN_Instance_yolo_detector:
 4135 0000 00000000 		.word	NN_Interface_yolo_detector
 4136 0004 00000000 		.word	0
 4137 0008 00000000 		.space	40
 4137      00000000 
 4137      00000000 
 4137      00000000 
 4137      00000000 
 4138              		.section	.rodata.str1.1
 4139              	.LC25:
 4140 000e 796F6C6F 		.ascii	"yolo_detector\000"
 4140      5F646574 
 4140      6563746F 
 4140      7200
 4141              		.section	.rodata.NN_Interface_yolo_detector,"a"
 4142              		.align	2
 4145              	NN_Interface_yolo_detector:
 4146 0000 0E000000 		.word	.LC25
 4147 0004 00000000 		.word	LL_ATON_EC_Network_Init_yolo_detector
 4148 0008 00000000 		.word	LL_ATON_EC_Inference_Init_yolo_detector
 4149 000c 00000000 		.word	LL_ATON_Set_User_Input_Buffer_yolo_detector
 4150 0010 00000000 		.word	LL_ATON_Get_User_Input_Buffer_yolo_detector
 4151 0014 00000000 		.word	LL_ATON_Set_User_Output_Buffer_yolo_detector
 4152 0018 00000000 		.word	LL_ATON_Get_User_Output_Buffer_yolo_detector
 4153 001c 00000000 		.word	LL_ATON_EpochBlockItems_yolo_detector
 4154 0020 00000000 		.word	LL_ATON_Output_Buffers_Info_yolo_detector
 4155 0024 00000000 		.word	LL_ATON_Input_Buffers_Info_yolo_detector
 4156 0028 00000000 		.word	LL_ATON_Internal_Buffers_Info_yolo_detector
 4157              		.section	.psram_bss
 4158              		.align	5
ARM GAS  /tmp/ccbfgvbk.s 			page 161


 4161              	screen_buffer:
 4162 96000 00000000 		.space	768000
 4162      00000000 
 4162      00000000 
 4162      00000000 
 4162      00000000 
 4163              		.section	.bss.cpu_load,"aw",%nobits
 4164              		.align	3
 4167              	cpu_load:
 4168 0000 00000000 		.space	224
 4168      00000000 
 4168      00000000 
 4168      00000000 
 4168      00000000 
 4169              		.section	.data.disp,"aw"
 4170              		.align	2
 4173              	disp:
 4174 0000 00000000 		.space	168
 4174      00000000 
 4174      00000000 
 4174      00000000 
 4174      00000000 
 4175 00a8 00000000 		.space	24
 4175      00000000 
 4175      00000000 
 4175      00000000 
 4175      00000000 
 4176 00c0 01000000 		.word	1
 4177 00c4 00000000 		.word	0
 4178 00c8 00000000 		.space	4548
 4178      00000000 
 4178      00000000 
 4178      00000000 
 4178      00000000 
 4179              		.section	.bss.lcd_fg_buffer_rd_idx,"aw",%nobits
 4180              		.align	2
 4183              	lcd_fg_buffer_rd_idx:
 4184 0000 00000000 		.space	4
 4185              		.section	.psram_bss
 4186              		.align	5
 4189              	lcd_fg_buffer:
 4190 151800 00000000 		.space	1536000
 4190      00000000 
 4190      00000000 
 4190      00000000 
 4190      00000000 
 4191              		.section	.bss.lcd_bg_buffer_capt_idx,"aw",%nobits
 4192              		.align	2
 4195              	lcd_bg_buffer_capt_idx:
 4196 0000 00000000 		.space	4
 4197              		.section	.data.lcd_bg_buffer_disp_idx,"aw"
 4198              		.align	2
 4201              	lcd_bg_buffer_disp_idx:
 4202 0000 01000000 		.word	1
 4203              		.section	.psram_bss
 4204              		.align	5
 4207              	lcd_bg_buffer:
ARM GAS  /tmp/ccbfgvbk.s 			page 162


 4208 2c8800 00000000 		.space	6144000
 4208      00000000 
 4208      00000000 
 4208      00000000 
 4208      00000000 
 4209              		.text
 4210              	.Letext0:
 4211              		.file 5 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4212              		.file 6 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4213              		.file 7 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4214              		.file 8 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4215              		.file 9 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/od_pp_output_if.h"
 4216              		.file 10 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/od_yolov8_pp_if.h"
 4217              		.file 11 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/pd_pp_output_if.h"
 4218              		.file 12 "STM32Cube_FW_N6/Drivers/CMSIS/Include/core_cm55.h"
 4219              		.file 13 "STM32Cube_FW_N6/Drivers/CMSIS/Device/ST/STM32N6xx/Include/stm32n657xx.h"
 4220              		.file 14 "STM32Cube_FW_N6/Drivers/CMSIS/Device/ST/STM32N6xx/Include/stm32n6xx.h"
 4221              		.file 15 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_def.h"
 4222              		.file 16 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_gpio.h"
 4223              		.file 17 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_dcmipp.h"
 4224              		.file 18 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_gfxmmu.h"
 4225              		.file 19 "Inc/ld.h"
 4226              		.file 20 "Lib/FreeRTOS/Source/include/projdefs.h"
 4227              		.file 21 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 4228              		.file 22 "Lib/FreeRTOS/Source/include/FreeRTOS.h"
 4229              		.file 23 "Lib/FreeRTOS/Source/include/task.h"
 4230              		.file 24 "Lib/FreeRTOS/Source/include/queue.h"
 4231              		.file 25 "Lib/FreeRTOS/Source/include/semphr.h"
 4232              		.file 26 "Lib/screenl/Inc/scrl.h"
 4233              		.file 27 "STM32Cube_FW_N6/Drivers/BSP/STM32N6570-DK/stm32n6570_discovery.h"
 4234              		.file 28 "STM32Cube_FW_N6/Utilities/lcd/../Fonts/fonts.h"
 4235              		.file 29 "STM32Cube_FW_N6/Utilities/lcd/stm32_lcd.h"
 4236              		.file 30 "Lib/NemaGFX/include/nema_hal.h"
 4237              		.file 31 "Lib/NemaGFX/include/nema_cmdlist.h"
 4238              		.file 32 "Lib/Camera_Middleware/cmw_camera.h"
 4239              		.file 33 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4240              		.file 34 "Lib/ai-postprocessing-wrapper/app_postprocess.h"
 4241              		.file 35 "Lib/AI_Runtime/Npu/ll_aton/ll_aton_runtime.h"
 4242              		.file 36 "Inc/app_cam.h"
 4243              		.file 37 "Inc/FreeRTOSConfig.h"
 4244              		.file 38 "Inc/stm32_lcd_ex.h"
 4245              		.file 39 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal.h"
 4246              		.file 40 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4247              		.file 41 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4248              		.file 42 "<built-in>"
ARM GAS  /tmp/ccbfgvbk.s 			page 163


DEFINED SYMBOLS
                            *ABS*:00000000 app.c
     /tmp/ccbfgvbk.s:26     .text.LL_Buffer_addr_start:00000000 $t
     /tmp/ccbfgvbk.s:31     .text.LL_Buffer_addr_start:00000000 LL_Buffer_addr_start
     /tmp/ccbfgvbk.s:76     .text.clamp_point:00000000 $t
     /tmp/ccbfgvbk.s:81     .text.clamp_point:00000000 clamp_point
     /tmp/ccbfgvbk.s:167    .text.isp_thread_fct:00000000 $t
     /tmp/ccbfgvbk.s:172    .text.isp_thread_fct:00000000 isp_thread_fct
     /tmp/ccbfgvbk.s:218    .text.isp_thread_fct:00000028 $d
     /tmp/ccbfgvbk.s:4041   .bss.isp_sem:00000000 isp_sem
     /tmp/ccbfgvbk.s:4024   .rodata.__func__.16:00000000 __func__.16
     /tmp/ccbfgvbk.s:226    .text.on_pd_toggle_button_click:00000000 $t
     /tmp/ccbfgvbk.s:231    .text.on_pd_toggle_button_click:00000000 on_pd_toggle_button_click
     /tmp/ccbfgvbk.s:305    .text.on_pd_toggle_button_click:0000004c $d
     /tmp/ccbfgvbk.s:4014   .rodata.__func__.14:00000000 __func__.14
     /tmp/ccbfgvbk.s:312    .text.on_ld_toggle_button_click:00000000 $t
     /tmp/ccbfgvbk.s:317    .text.on_ld_toggle_button_click:00000000 on_ld_toggle_button_click
     /tmp/ccbfgvbk.s:391    .text.on_ld_toggle_button_click:0000004c $d
     /tmp/ccbfgvbk.s:4009   .rodata.__func__.13:00000000 __func__.13
     /tmp/ccbfgvbk.s:398    .text.button_process:00000000 $t
     /tmp/ccbfgvbk.s:403    .text.button_process:00000000 button_process
     /tmp/ccbfgvbk.s:461    .text.button_init.part.0:00000000 $t
     /tmp/ccbfgvbk.s:466    .text.button_init.part.0:00000000 button_init.part.0
     /tmp/ccbfgvbk.s:489    .text.button_init.part.0:00000010 $d
     /tmp/ccbfgvbk.s:4004   .rodata.__func__.12:00000000 __func__.12
     /tmp/ccbfgvbk.s:496    .text.display_ld_hand:00000000 $t
     /tmp/ccbfgvbk.s:501    .text.display_ld_hand:00000000 display_ld_hand
     /tmp/ccbfgvbk.s:818    .text.display_ld_hand:00000164 $d
     /tmp/ccbfgvbk.s:832    .text.nn_thread_fct:00000000 $t
     /tmp/ccbfgvbk.s:837    .text.nn_thread_fct:00000000 nn_thread_fct
     /tmp/ccbfgvbk.s:1579   .text.nn_thread_fct:00000260 $d
     /tmp/ccbfgvbk.s:4083   .bss.nn_input_queue:00000000 nn_input_queue
     /tmp/ccbfgvbk.s:3989   .rodata.__func__.9:00000000 __func__.9
     /tmp/ccbfgvbk.s:3984   .rodata.__func__.8:00000000 __func__.8
     /tmp/ccbfgvbk.s:3979   .rodata.__func__.7:00000000 __func__.7
     /tmp/ccbfgvbk.s:4107   .data.NN_Instance_face_landmark:00000000 NN_Instance_face_landmark
     /tmp/ccbfgvbk.s:3974   .rodata.__func__.6:00000000 __func__.6
     /tmp/ccbfgvbk.s:4173   .data.disp:00000000 disp
     /tmp/ccbfgvbk.s:4095   .bss.frame_event_nb_for_resize:00000000 frame_event_nb_for_resize
     /tmp/ccbfgvbk.s:4134   .data.NN_Instance_yolo_detector:00000000 NN_Instance_yolo_detector
     /tmp/ccbfgvbk.s:1602   .text.display_hand:00000000 $t
     /tmp/ccbfgvbk.s:1608   .text.display_hand:00000000 display_hand
     /tmp/ccbfgvbk.s:2102   .text.display_hand:00000230 $d
     /tmp/ccbfgvbk.s:2124   .text.dp_thread_fct:00000000 $t
     /tmp/ccbfgvbk.s:2129   .text.dp_thread_fct:00000000 dp_thread_fct
     /tmp/ccbfgvbk.s:2842   .text.dp_thread_fct:00000280 $d
     /tmp/ccbfgvbk.s:4019   .rodata.__func__.15:00000000 __func__.15
     /tmp/ccbfgvbk.s:3999   .rodata.__func__.11:00000000 __func__.11
     /tmp/ccbfgvbk.s:4167   .bss.cpu_load:00000000 cpu_load
     /tmp/ccbfgvbk.s:3994   .rodata.__func__.10:00000000 __func__.10
     /tmp/ccbfgvbk.s:4183   .bss.lcd_fg_buffer_rd_idx:00000000 lcd_fg_buffer_rd_idx
     /tmp/ccbfgvbk.s:4189   .psram_bss:00151800 lcd_fg_buffer
     /tmp/ccbfgvbk.s:2889   .text.app_run:00000000 $t
     /tmp/ccbfgvbk.s:2895   .text.app_run:00000000 app_run
     /tmp/ccbfgvbk.s:3478   .text.app_run:0000021c $d
     /tmp/ccbfgvbk.s:4207   .psram_bss:002c8800 lcd_bg_buffer
     /tmp/ccbfgvbk.s:4201   .data.lcd_bg_buffer_disp_idx:00000000 lcd_bg_buffer_disp_idx
ARM GAS  /tmp/ccbfgvbk.s 			page 164


     /tmp/ccbfgvbk.s:4161   .psram_bss:00096000 screen_buffer
     /tmp/ccbfgvbk.s:3969   .rodata.__func__.5:00000000 __func__.5
     /tmp/ccbfgvbk.s:4029   .rodata.__func__.17:00000000 __func__.17
     /tmp/ccbfgvbk.s:4089   .psram_bss:00000000 nn_input_buffers
     /tmp/ccbfgvbk.s:4035   .bss.isp_sem_buffer:00000000 isp_sem_buffer
     /tmp/ccbfgvbk.s:4077   .bss.nn_thread:00000000 nn_thread
     /tmp/ccbfgvbk.s:4071   .bss.nn_thread_stack:00000000 nn_thread_stack
     /tmp/ccbfgvbk.s:4065   .bss.dp_thread:00000000 dp_thread
     /tmp/ccbfgvbk.s:4059   .bss.dp_thread_stack:00000000 dp_thread_stack
     /tmp/ccbfgvbk.s:4053   .bss.isp_thread:00000000 isp_thread
     /tmp/ccbfgvbk.s:4047   .bss.isp_thread_stack:00000000 isp_thread_stack
     /tmp/ccbfgvbk.s:3520   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000000 $t
     /tmp/ccbfgvbk.s:3526   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000000 CMW_CAMERA_PIPE_FrameEventCallback
     /tmp/ccbfgvbk.s:3850   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000150 $d
     /tmp/ccbfgvbk.s:3964   .rodata.__func__.3:00000000 __func__.3
     /tmp/ccbfgvbk.s:3959   .rodata.__func__.2:00000000 __func__.2
     /tmp/ccbfgvbk.s:4101   .bss.frame_event_nb:00000000 frame_event_nb
     /tmp/ccbfgvbk.s:3954   .rodata.__func__.1:00000000 __func__.1
     /tmp/ccbfgvbk.s:3949   .rodata.__func__.0:00000000 __func__.0
     /tmp/ccbfgvbk.s:4195   .bss.lcd_bg_buffer_capt_idx:00000000 lcd_bg_buffer_capt_idx
     /tmp/ccbfgvbk.s:3873   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000000 $t
     /tmp/ccbfgvbk.s:3879   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000000 CMW_CAMERA_PIPE_VsyncEventCallback
     /tmp/ccbfgvbk.s:3942   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000030 $d
     /tmp/ccbfgvbk.s:4032   .bss.isp_sem_buffer:00000000 $d
     /tmp/ccbfgvbk.s:4038   .bss.isp_sem:00000000 $d
     /tmp/ccbfgvbk.s:4044   .bss.isp_thread_stack:00000000 $d
     /tmp/ccbfgvbk.s:4050   .bss.isp_thread:00000000 $d
     /tmp/ccbfgvbk.s:4056   .bss.dp_thread_stack:00000000 $d
     /tmp/ccbfgvbk.s:4062   .bss.dp_thread:00000000 $d
     /tmp/ccbfgvbk.s:4068   .bss.nn_thread_stack:00000000 $d
     /tmp/ccbfgvbk.s:4074   .bss.nn_thread:00000000 $d
     /tmp/ccbfgvbk.s:4080   .bss.nn_input_queue:00000000 $d
     /tmp/ccbfgvbk.s:4086   .psram_bss:00000000 $d
     /tmp/ccbfgvbk.s:4092   .bss.frame_event_nb_for_resize:00000000 $d
     /tmp/ccbfgvbk.s:4098   .bss.frame_event_nb:00000000 $d
     /tmp/ccbfgvbk.s:4104   .data.NN_Instance_face_landmark:00000000 $d
     /tmp/ccbfgvbk.s:4118   .rodata.NN_Interface_face_landmark:00000000 NN_Interface_face_landmark
     /tmp/ccbfgvbk.s:4115   .rodata.NN_Interface_face_landmark:00000000 $d
     /tmp/ccbfgvbk.s:4131   .data.NN_Instance_yolo_detector:00000000 $d
     /tmp/ccbfgvbk.s:4145   .rodata.NN_Interface_yolo_detector:00000000 NN_Interface_yolo_detector
     /tmp/ccbfgvbk.s:4142   .rodata.NN_Interface_yolo_detector:00000000 $d
     /tmp/ccbfgvbk.s:4164   .bss.cpu_load:00000000 $d
     /tmp/ccbfgvbk.s:4170   .data.disp:00000000 $d
     /tmp/ccbfgvbk.s:4180   .bss.lcd_fg_buffer_rd_idx:00000000 $d
     /tmp/ccbfgvbk.s:4192   .bss.lcd_bg_buffer_capt_idx:00000000 $d
     /tmp/ccbfgvbk.s:4198   .data.lcd_bg_buffer_disp_idx:00000000 $d
                           .group:00000000 wm4.0.c552ae9005b0f2cca11872fae5d4b7f2
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.features.h.33.e0c9f337c65cb9f22ed5f23d082bc78b
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.cmsis_gcc.h.26.7a5fd1a99dbedde687044a4433ab3e15
                           .group:00000000 wm4.newlib.h.7.591ac1bd65c1f5b34864757667a05252
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
ARM GAS  /tmp/ccbfgvbk.s 			page 165


                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stddef.h.39.0dc9006b34572d4d9cae4c8b422c4971
                           .group:00000000 wm4.cdefs.h.49.70fc7af612f78ddcace70fdd90b5623b
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4.math.h.13.47cfc34cae8a1153323939c4d32cf7c2
                           .group:00000000 wm4.float.h.29.0e9d9baf95ec39f9555dc80c6e28186b
                           .group:00000000 wm4.syslimits.h.34.de5cbd310098bc5895998b6bde577ed2
                           .group:00000000 wm4.limits.h.9.70fb0ada6f71b16202a66baaa6d8ea70
                           .group:00000000 wm4.limits.h.60.56a1ae353e2028a24298ec6463b8b593
                           .group:00000000 wm4.arm_math_types.h.94.a6c8422e2657ad4cd95bd8be69ba02aa
                           .group:00000000 wm4.stdbool.h.29.c08aa3eec75cf5b9b5003883f43253f0
                           .group:00000000 wm4.arm_mve.h.38.47b22bbd301ce82bc6dafd1a387f65a3
                           .group:00000000 wm4.arm_math_types.h.559.cab78f278b684a3ea2271947c7aea680
                           .group:00000000 wm4.arm_math_memory.h.28.fe8a81c6a9ac13061a5f748732089249
                           .group:00000000 wm4.none.h.185.db055cca83e83f96d8d0bb450fbdf4bb
                           .group:00000000 wm4.utils.h.27.57524573fe37b04009eecf3582a4c591
                           .group:00000000 wm4.fast_math_functions.h.28.8eb7477260c1d6b62047c49a01c4cbaa
                           .group:00000000 wm4.controller_functions.h.28.7bed7d7a726df2f65b8a3d89cff01247
                           .group:00000000 wm4.filtering_functions.h.46.6cf1424fb1f86d5f9958d208b83340a1
                           .group:00000000 wm4.postprocess_conf.h.22.0bc4dded16386cef3ff1f911e754ba56
                           .group:00000000 wm4.app.h.24.7f6e7e8163dd6f9007a01e8730a64482
                           .group:00000000 wm4.stdio.h.27.3fc80220048df77954e38daec3bb9670
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.stdio.h.47.dc31ec4674d7bcb103c9f08809549f45
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.87.a1e20d2651f9bfb66e51bfbe849db00a
                           .group:00000000 wm4.app_cam.h.19.2495a46447d71a1025370e29864418f5
                           .group:00000000 wm4.app_config.h.19.88dee04c97f3e42d3acfeeca22b174e5
                           .group:00000000 wm4.od_pp_output_if.h.11.62a3da738caf687aa42d96759c237b2c
                           .group:00000000 wm4.mpe_pp_output_if.h.11.db0dd5ceb87072354c56b51e8f9b2a0d
                           .group:00000000 wm4.pd_pp_output_if.h.19.b7de9bd1876930668a82409743b6dbf4
                           .group:00000000 wm4.spe_pp_output_if.h.11.7212d2990e83c8afeadfa97fa05d17c4
                           .group:00000000 wm4.iseg_pp_output_if.h.11.94ad86e1bcba0c03902fb099324716f2
                           .group:00000000 wm4.sseg_pp_output_if.h.11.caf00fb1ae24f8dc9c80bee7827b96f2
                           .group:00000000 wm4.app_postprocess.h.46.5719832142b7cbde626021bdb2b1e6d5
                           .group:00000000 wm4.isp_conf.h.21.bfb1d020517608810095aa56acf25d1e
                           .group:00000000 wm4.stm32n6xx_hal_conf.h.21.004a06df6e15ac197e03f723792da58a
                           .group:00000000 wm4.arm_cmse.h.103.a0d15a79c4c9a67da8d5831704d7248e
                           .group:00000000 wm4.stm32n6xx.h.34.80585dd08aa426c932f6311fdb7386da
                           .group:00000000 wm4.stm32n657xx.h.26.acd272cb67318cc1a4791ce2f0720ca6
                           .group:00000000 wm4.cmsis_version.h.32.0ac195c83bb4537824e6ad1c47474b79
                           .group:00000000 wm4.core_cm55.h.68.832d5cf835639cc0d28219c3d2867330
                           .group:00000000 wm4.core_cm55.h.196.52e437a270752da561676e507b35baeb
                           .group:00000000 wm4.mpu_armv8.h.32.9d72426c8e2b47753456dcb84802c5b3
                           .group:00000000 wm4.pmu_armv8.h.32.eaa95f88a71b29390b135fd81c071b6b
                           .group:00000000 wm4.core_cm55.h.4411.860dad8650880893dd57b815844f7186
                           .group:00000000 wm4.cachel1_armv7.h.32.abd77761a989e008b0c60891114a33c7
                           .group:00000000 wm4.stm32n657xx.h.575.1c2a5e6bedffc6f9083dcc857bc6d09d
                           .group:00000000 wm4.stm32n6xx.h.114.5cf793d8af485e14f110e3e24bde1aa5
                           .group:00000000 wm4.stm32_hal_legacy.h.22.87fb12bf5a1a1e00fc134f22bc9aa8c4
ARM GAS  /tmp/ccbfgvbk.s 			page 166


                           .group:00000000 wm4.stm32n6xx_hal_def.h.63.3a8f01490e8852464e9fcb69092e9c75
                           .group:00000000 wm4.stm32n6xx_ll_bus.h.38.2366a295ee4cdb04833997d3787fcd2d
                           .group:00000000 wm4.stm32n6xx_ll_rcc.h.21.002e22a16fd7f67dde6dce41e8ba9620
                           .group:00000000 wm4.stm32n6xx_hal_rcc.h.194.1cb1283e40f9bebcd3fba2a9a961838e
                           .group:00000000 wm4.stm32n6xx_hal_rcc_ex.h.21.79aa32178dfef625fbd20d362449acfa
                           .group:00000000 wm4.stm32n6xx_hal_rcc.h.4359.3f0b7ad33826d95438602c9aebc08af9
                           .group:00000000 wm4.stm32n6xx_hal_gpio.h.21.89d54af663b98eb8fc098192053f7eeb
                           .group:00000000 wm4.stm32n6xx_hal_gpio_ex.h.22.4acb2e3511a98bb48b81cfc8e09fd59e
                           .group:00000000 wm4.stm32n6xx_hal_rif.h.21.424d0bafb874a777dee3742a22e13037
                           .group:00000000 wm4.stm32n6xx_hal_dma.h.21.61e48c5c2e8d25d22177834b232fe45c
                           .group:00000000 wm4.stm32n6xx_hal_dma_ex.h.21.66e597beb090a165329d6ccf665e41bc
                           .group:00000000 wm4.stm32n6xx_hal_dma.h.1020.87e2180c009560b617c1f8208140c950
                           .group:00000000 wm4.stm32n6xx_hal_cortex.h.21.f493623cc58f9454ab4eae41e395c5cc
                           .group:00000000 wm4.stm32n6xx_hal_bsec.h.21.61b309e67dd810e28897a01b1b21a97f
                           .group:00000000 wm4.stm32n6xx_hal_dcmipp.h.21.f538bfd785c6469670251ac9bc7af55d
                           .group:00000000 wm4.stm32n6xx_hal_dma2d.h.21.75c8d46cdbb72970123b3f34ae2043d7
                           .group:00000000 wm4.stm32n6xx_hal_exti.h.21.fda87e715ea6b98239ec30171d1df594
                           .group:00000000 wm4.stm32n6xx_hal_gfxmmu.h.21.9784a9103143d48bd3c37389d0e0b8e6
                           .group:00000000 wm4.stm32n6xx_hal_i2c.h.21.3f483626ff64c5bf027265bb2e1d1331
                           .group:00000000 wm4.stm32n6xx_hal_i2c_ex.h.21.79e9196c22282cdaf6b4047893638c45
                           .group:00000000 wm4.stm32n6xx_hal_i2c.h.741.1084702632703acc669e4282b3043372
                           .group:00000000 wm4.stm32n6xx_hal_icache.h.21.194b4ec6e76f32b14f65c85616854850
                           .group:00000000 wm4.stm32n6xx_hal_ltdc.h.21.ae1eb09930e7e550e48e418ac5849e4d
                           .group:00000000 wm4.stm32n6xx_hal_ltdc.h.1002.b13ede7fc94ed5ad1c6768a157d2149a
                           .group:00000000 wm4.stm32n6xx_ll_usb.h.21.d518a5d97876c2ff49040c20a2c4a120
                           .group:00000000 wm4.stm32n6xx_hal_pcd.h.155.27040aac6844effe2af8c180caf1dd2e
                           .group:00000000 wm4.stm32n6xx_hal_pwr.h.21.cdb73e4869c3fed3fc84f901ec0e5f0a
                           .group:00000000 wm4.stm32n6xx_hal_pwr_ex.h.21.1a673224a58b0c1e5fad8eeda6514208
                           .group:00000000 wm4.stm32n6xx_hal_ramcfg.h.21.a62dfbb4d2c14e9a8c634a215e37bd3d
                           .group:00000000 wm4.stm32n6xx_hal_spi.h.21.9f810303326e2d91749800e9911f8e4d
                           .group:00000000 wm4.stm32n6xx_hal_spi.h.906.93ec0695066db4253cdbcb7d84358a0b
                           .group:00000000 wm4.stm32n6xx_hal_tim.h.21.839dd2b2a70382fb2c44f8f293a84d5f
                           .group:00000000 wm4.stm32n6xx_hal_tim_ex.h.21.e372d5ac63c13441211ea4ecbd353150
                           .group:00000000 wm4.stm32n6xx_hal_uart.h.21.230f549bfa0d5ebfd77bfb311b2aca15
                           .group:00000000 wm4.stm32n6xx_hal_uart_ex.h.21.a0d5511e1d0703b7b5278c8f5472b96d
                           .group:00000000 wm4.stm32n6xx_hal_xspi.h.21.e17898be2073b6b6b19faf30b4e304e9
                           .group:00000000 wm4.stm32n6xx_hal_cacheaxi.h.21.7c3375b7903ec42376e4883320997f74
                           .group:00000000 wm4.stm32n6xx_hal_gpu2d.h.21.48d0249122abad294a630c39cc4ebaed
                           .group:00000000 wm4.stm32n6xx_hal.h.81.5e59143eba07faca3e9aeaa5470826c8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.isp_core.h.109.be5387f515355b6edcb70af2607f9a68
                           .group:00000000 wm4.ld.h.19.0265bc80a0b44244ca0b5cbb3eb7cf16
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.assert.h.11.d99a111e320bc5106fc4046225782672
                           .group:00000000 wm4.ll_aton_config.h.20.79eb8be0291ee9086e6be08969d61846
                           .group:00000000 wm4.ll_aton_attributes.h.20.d1fce4a2519a8c4442db76dcb52b420f
                           .group:00000000 wm4.errno.h.2.ba016d646105af6cad23be83630b6a3f
                           .group:00000000 wm4.errno.h.9.ae5ea2b0ff9ea6e39e585807e35200d3
                           .group:00000000 wm4.ll_aton_util.h.34.9098eaa90d3d72b819973556e3e5fe44
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.FreeRTOSConfig.h.59.0e97f89e6eb1b28c12ea610dd500bb25
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
ARM GAS  /tmp/ccbfgvbk.s 			page 167


                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.queue.h.68.219f47fba8b59640449b84d04c5bd6d8
                           .group:00000000 wm4.semphr.h.40.c1a9c6f5bf0feb4da0b6a45d234a79d0
                           .group:00000000 wm4.ll_aton_platform.h.20.06ded592ee586a6abb6019a90ebd54df
                           .group:00000000 wm4.ll_aton_platform.h.288.664a74b8c5792a861b3d52bd39f4a693
                           .group:00000000 wm4.ATON.h.19.cf7dff4c0f1bfe90e42066f604751dc7
                           .group:00000000 wm4.ll_aton_rcompat.h.22.b2bd0d777466a5ac720f3b2429c5fea7
                           .group:00000000 wm4.ll_aton_platform.h.383.f09ccd502bb682b863f991d963ee7462
                           .group:00000000 wm4.ll_aton_osal_freertos.h.62.85a065f77def7f6fef26149f92fe1378
                           .group:00000000 wm4.ll_aton_osal.h.116.bc018513feb9b28713cf2afc78ec679b
                           .group:00000000 wm4.ll_aton_rt_user_api.h.71.e6b7f8d03b2c998f838260ad3cb6cd40
                           .group:00000000 wm4.cmw_errno.h.21.91021ac9b2627a1ce6b8517d105715d1
                           .group:00000000 wm4.stm32n6570_discovery_conf.h.21.f52c8202689527a3dc0d9c6cba9c0416
                           .group:00000000 wm4.stm32n6570_discovery_errno.h.22.80e523b09444a11ebe4b6e24ae914f0e
                           .group:00000000 wm4.stm32n6570_discovery_bus.h.62.3b5b2c6837f7adeb489604fa214cd371
                           .group:00000000 wm4.cmw_camera.h.33.b34cbb506ffb5bbc0bae0cee9fc48966
                           .group:00000000 wm4.stm32n6570_discovery.h.25.5fc3699797f7c334a2e25a2a6a563b07
                           .group:00000000 wm4.lcd.h.21.98701c105e66fef2e089854e5bc0fe32
                           .group:00000000 wm4.stm32_lcd.h.55.1a04e503950bf34ef3721d2ebb9542fc
                           .group:00000000 wm4.stm32_lcd_ex.h.21.eaf9c9c1000e162e58259e027110f2f5
                           .group:00000000 wm4.utils.h.19.2f7e4a8a839d9215c56961f5a9914d6d
                           .group:00000000 wm4.nema_sys_defs.h.24.0b35b5138cb9b4a3130f5d424bc2bcc0
                           .group:00000000 wm4.nema_hal.h.193.74a3b292db2bcbda0132dae40ae0f4e5
                           .group:00000000 wm4.nema_cmdlist.h.30.a652eb980f08f0ed22ad00119d504926
                           .group:00000000 wm4.nema_graphics.h.61.b3907f86eccb4e55a4b69e8aebdd3657
                           .group:00000000 wm4.nema_blender.h.30.fb13cc9231bd108bca212984b3a891e0
                           .group:00000000 wm4.nema_math.h.30.ef7265c89982f7dae18e3ec2d7f3d003
                           .group:00000000 wm4.nema_version.h.35.6aae27202c190348dff84b89d4c12df7
                           .group:00000000 wm4.nema_error.h.29.50848ed81d21ff4ae4b870fae3681118

UNDEFINED SYMBOLS
xQueueSemaphoreTake
__assert_func
CAM_IspUpdate
xQueueGenericSend
BSP_PB_GetState
cos
sin
UTIL_LCD_FillCircle
UTIL_LCD_DrawLine
ld_bindings_idx
LL_ATON_Output_Buffers_Info_yolo_detector
LL_ATON_Input_Buffers_Info_yolo_detector
app_postprocess_init
LL_ATON_Output_Buffers_Info_face_landmark
LL_ATON_Input_Buffers_Info_face_landmark
HAL_GetTick
CAM_NNPipe_Start
LL_ATON_Set_User_Input_Buffer_yolo_detector
LL_ATON_RT_Main
app_postprocess_run
ARM GAS  /tmp/ccbfgvbk.s 			page 168


UTIL_LCD_DrawRect
__aeabi_ul2d
BSP_PB_Init
memcpy
SCRL_SetAddress_NoReload
UTIL_LCD_FillRect
TIM4_Get_Value
ulTaskGetIdleRunTimeCounter
memmove
UTIL_LCD_GetFont
UTIL_LCDEx_PrintfAt
SCRL_ReloadLayer
puts
memset
SCRL_Init
UTIL_LCD_SetLayer
UTIL_LCD_Clear
UTIL_LCD_SetFont
UTIL_LCD_SetTextColor
xQueueCreateCountingSemaphoreStatic
vQueueDelete
CAM_Init
xQueueCreateMutexStatic
CAM_DisplayPipe_Start
xTaskCreateStatic
Font20
CMW_CAMERA_GetDCMIPPHandle
HAL_DCMIPP_PIPE_SetMemoryAddress
SRCL_Update
xPortIsInsideInterrupt
xQueueGiveFromISR
LL_ATON_EC_Network_Init_face_landmark
LL_ATON_EC_Inference_Init_face_landmark
LL_ATON_Set_User_Input_Buffer_face_landmark
LL_ATON_Get_User_Input_Buffer_face_landmark
LL_ATON_Set_User_Output_Buffer_face_landmark
LL_ATON_Get_User_Output_Buffer_face_landmark
LL_ATON_EpochBlockItems_face_landmark
LL_ATON_Internal_Buffers_Info_face_landmark
LL_ATON_EC_Network_Init_yolo_detector
LL_ATON_EC_Inference_Init_yolo_detector
LL_ATON_Get_User_Input_Buffer_yolo_detector
LL_ATON_Set_User_Output_Buffer_yolo_detector
LL_ATON_Get_User_Output_Buffer_yolo_detector
LL_ATON_EpochBlockItems_yolo_detector
LL_ATON_Internal_Buffers_Info_yolo_detector
