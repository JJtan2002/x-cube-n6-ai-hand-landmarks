ARM GAS  /tmp/ccfH4MMM.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 4
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"app.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Src/app.c"
  25              		.section	.text.clamp_point,"ax",%progbits
  26              		.align	1
  27              		.syntax unified
  28              		.thumb
  29              		.thumb_func
  31              	clamp_point:
  32              	.LVL0:
  33              	.LFB7380:
   1:Src/app.c     **** /**
   2:Src/app.c     ****   ******************************************************************************
   3:Src/app.c     ****   * @file    app.c
   4:Src/app.c     ****   * @author  MDG Application Team
   5:Src/app.c     ****   ******************************************************************************
   6:Src/app.c     ****   * @attention
   7:Src/app.c     ****   *
   8:Src/app.c     ****   * Copyright (c) 2024 STMicroelectronics.
   9:Src/app.c     ****   * All rights reserved.
  10:Src/app.c     ****   *
  11:Src/app.c     ****   * This software is licensed under terms that can be found in the LICENSE file
  12:Src/app.c     ****   * in the root directory of this software component.
  13:Src/app.c     ****   * If no LICENSE file comes with this software, it is provided AS-IS.
  14:Src/app.c     ****   *
  15:Src/app.c     ****   ******************************************************************************
  16:Src/app.c     ****   */
  17:Src/app.c     **** 
  18:Src/app.c     **** /*TODO: DECLARE MODELS 
  19:Src/app.c     **** //LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(yolo_detector);
  20:Src/app.c     **** //static roi_t rois[YOLO_MAX_NB];
  21:Src/app.c     **** //LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(face_landmark);
  22:Src/app.c     **** //static ld_point_t fl_landmarks[1[FL_LANDMARK_NB]; // Use new constants
  23:Src/app.c     **** */
  24:Src/app.c     **** /*TODO: REMOVE ROTATION LOGICS AS DMS WILL NOT USE IT
  25:Src/app.c     ****  * NOTE THAT ROTATION LOGIC IS USED FOR N6 BOARD 
ARM GAS  /tmp/ccfH4MMM.s 			page 2


  26:Src/app.c     **** */
  27:Src/app.c     **** #include "app.h"
  28:Src/app.c     **** 
  29:Src/app.c     **** #include <stdint.h>
  30:Src/app.c     **** #include <stdio.h>
  31:Src/app.c     **** 
  32:Src/app.c     **** #include "app_cam.h"
  33:Src/app.c     **** #include "app_config.h"
  34:Src/app.c     **** #include "IPL_resize.h"
  35:Src/app.c     **** #include "app_postprocess.h"
  36:Src/app.c     **** #include "isp_api.h"
  37:Src/app.c     **** #include "ld.h"
  38:Src/app.c     **** #include "ll_aton_runtime.h"
  39:Src/app.c     **** #include "cmw_camera.h"
  40:Src/app.c     **** #include "scrl.h"
  41:Src/app.c     **** #ifdef STM32N6570_DK_REV
  42:Src/app.c     **** #include "stm32n6570_discovery.h"
  43:Src/app.c     **** #else
  44:Src/app.c     **** #include "stm32n6xx_nucleo.h"
  45:Src/app.c     **** #endif
  46:Src/app.c     **** #include "stm32_lcd.h"
  47:Src/app.c     **** #include "stm32_lcd_ex.h"
  48:Src/app.c     **** #include "stm32n6xx_hal.h"
  49:Src/app.c     **** #include "FreeRTOS.h"
  50:Src/app.c     **** #include "task.h"
  51:Src/app.c     **** #include "semphr.h"
  52:Src/app.c     **** #include "utils.h"
  53:Src/app.c     **** 
  54:Src/app.c     **** #define FREERTOS_PRIORITY(p) ((UBaseType_t)((int)tskIDLE_PRIORITY + configMAX_PRIORITIES / 2 + (p))
  55:Src/app.c     **** 
  56:Src/app.c     **** #ifndef M_PI
  57:Src/app.c     **** #define M_PI 3.14159265358979323846
  58:Src/app.c     **** #endif
  59:Src/app.c     **** 
  60:Src/app.c     **** #include "nema_core.h"
  61:Src/app.c     **** #include "nema_error.h"
  62:Src/app.c     **** void nema_enable_tiling(int);
  63:Src/app.c     **** 
  64:Src/app.c     **** #define LCD_FG_WIDTH LCD_BG_WIDTH
  65:Src/app.c     **** #define LCD_FG_HEIGHT LCD_BG_HEIGHT
  66:Src/app.c     **** 
  67:Src/app.c     **** #define CACHE_OP(__op__) do { \
  68:Src/app.c     ****   if (is_cache_enable()) { \
  69:Src/app.c     ****     __op__; \
  70:Src/app.c     ****   } \
  71:Src/app.c     **** } while (0)
  72:Src/app.c     **** 
  73:Src/app.c     **** #define DBG_INFO 0
  74:Src/app.c     **** #define USE_FILTERED_TS 1
  75:Src/app.c     **** 
  76:Src/app.c     **** #define BQUEUE_MAX_BUFFERS 2
  77:Src/app.c     **** #define CPU_LOAD_HISTORY_DEPTH 8
  78:Src/app.c     **** 
  79:Src/app.c     **** #define DISPLAY_BUFFER_NB (DISPLAY_DELAY + 2)
  80:Src/app.c     **** 
  81:Src/app.c     **** /* palm detector */
  82:Src/app.c     **** #define PD_MAX_HAND_NB 1
ARM GAS  /tmp/ccfH4MMM.s 			page 3


  83:Src/app.c     **** #define YOLO_MAX_NB 20
  84:Src/app.c     **** 
  85:Src/app.c     **** typedef float app_v3_t[3];
  86:Src/app.c     **** 
  87:Src/app.c     **** /**
  88:Src/app.c     ****  * @brief Defines a Region Of Interest (ROI).
  89:Src/app.c     ****  * @details This is a key structure used to pass the location of a detected object
  90:Src/app.c     ****  * (like a hand or face) to the next stage of the pipeline.
  91:Src/app.c     ****  */
  92:Src/app.c     **** typedef struct {
  93:Src/app.c     ****   float cx;
  94:Src/app.c     ****   float cy;
  95:Src/app.c     ****   float w;
  96:Src/app.c     ****   float h;
  97:Src/app.c     ****   float rotation;
  98:Src/app.c     **** } roi_t;
  99:Src/app.c     **** 
 100:Src/app.c     **** #define UTIL_LCD_COLOR_TRANSPARENT 0
 101:Src/app.c     **** 
 102:Src/app.c     **** #ifdef STM32N6570_DK_REV
 103:Src/app.c     **** #define LCD_FONT Font20
 104:Src/app.c     **** #define DISK_RADIUS 2
 105:Src/app.c     **** #else
 106:Src/app.c     **** #define LCD_FONT Font12
 107:Src/app.c     **** #define DISK_RADIUS 1
 108:Src/app.c     **** #endif
 109:Src/app.c     **** 
 110:Src/app.c     **** /**
 111:Src/app.c     ****  * @brief A simple rectangle definition using top-left corner and size.
 112:Src/app.c     ****  */
 113:Src/app.c     **** typedef struct
 114:Src/app.c     **** {
 115:Src/app.c     ****   uint32_t X0;
 116:Src/app.c     ****   uint32_t Y0;
 117:Src/app.c     ****   uint32_t XSize;
 118:Src/app.c     ****   uint32_t YSize;
 119:Src/app.c     **** } Rectangle_TypeDef;
 120:Src/app.c     **** 
 121:Src/app.c     **** /**
 122:Src/app.c     ****  * @brief A thread-safe buffer queue for passing data between tasks (e.g., camera and NN).
 123:Src/app.c     ****  * @details Implements a classic producer-consumer model using semaphores.
 124:Src/app.c     ****  */
 125:Src/app.c     **** typedef struct {
 126:Src/app.c     ****   SemaphoreHandle_t free;         /* Signals that a buffer is free for writing. */
 127:Src/app.c     ****   StaticSemaphore_t free_buffer;
 128:Src/app.c     ****   SemaphoreHandle_t ready;        /* Signals that a buffer is ready for reading. */
 129:Src/app.c     ****   StaticSemaphore_t ready_buffer; 
 130:Src/app.c     ****   int buffer_nb;                  /* Total number of buffers in the queue. */
 131:Src/app.c     ****   uint8_t *buffers[BQUEUE_MAX_BUFFERS];
 132:Src/app.c     ****   int free_idx;          /* Index of the next free buffer. */ 
 133:Src/app.c     ****   int ready_idx;        /* Index of the next ready buffer. */
 134:Src/app.c     **** } bqueue_t;
 135:Src/app.c     **** 
 136:Src/app.c     **** /**
 137:Src/app.c     ****  * @brief Holds data for calculating CPU load.
 138:Src/app.c     ****  */
 139:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 4


 140:Src/app.c     **** typedef struct {
 141:Src/app.c     ****   uint64_t current_total;
 142:Src/app.c     ****   uint64_t current_thread_total;
 143:Src/app.c     ****   uint64_t prev_total;
 144:Src/app.c     ****   uint64_t prev_thread_total;
 145:Src/app.c     ****   struct {
 146:Src/app.c     ****     uint64_t total;
 147:Src/app.c     ****     uint64_t thread;
 148:Src/app.c     ****     uint32_t tick;
 149:Src/app.c     ****   } history[CPU_LOAD_HISTORY_DEPTH];
 150:Src/app.c     **** } cpuload_info_t;
 151:Src/app.c     **** 
 152:Src/app.c     **** /**
 153:Src/app.c     ****  * @brief Holds all information for a single detected hand/face instance.
 154:Src/app.c     ****  * @details This is the main data structure linking the output of the first model
 155:Src/app.c     ****  * to the input of the second, and finally to the display.
 156:Src/app.c     ****  */
 157:Src/app.c     **** typedef struct {
 158:Src/app.c     ****   int is_valid;             /* Flag to check if the detection in this struct is current. */
 159:Src/app.c     ****   pd_pp_box_t pd_hands;     /* Palm Detector raw output. */
 160:Src/app.c     ****   roi_t roi;            /* Region of Interest for the detected hand. */
 161:Src/app.c     ****   ld_point_t ld_landmarks[LD_LANDMARK_NB];        /* Final output from the landmark model */
 162:Src/app.c     **** } hand_info_t;
 163:Src/app.c     **** 
 164:Src/app.c     **** /**
 165:Src/app.c     ****  * @brief Holds all information for a single detected hand/face instance.
 166:Src/app.c     ****  * @details This is the main data structure linking the output of the first model
 167:Src/app.c     ****  * to the input of the second, and finally to the display.
 168:Src/app.c     ****  */
 169:Src/app.c     **** typedef struct {
 170:Src/app.c     ****   int is_valid;             /* Flag to check if the detection in this struct is current. */
 171:Src/app.c     ****   pd_pp_box_t pd_hands;     /* Palm Detector raw output. */
 172:Src/app.c     ****   roi_t roi;            /* Region of Interest for the detected hand. */
 173:Src/app.c     ****   ld_point_t ld_landmarks[LD_LANDMARK_NB];        /* Final output from the landmark model */
 174:Src/app.c     **** } face_info_t;
 175:Src/app.c     **** 
 176:Src/app.c     **** 
 177:Src/app.c     **** /**
 178:Src/app.c     ****  * @brief Aggregates all information needed by the display thread to render one frame.
 179:Src/app.c     ****  */
 180:Src/app.c     **** typedef struct {
 181:Src/app.c     ****   float nn_period_ms;
 182:Src/app.c     ****   uint32_t pd_ms;
 183:Src/app.c     ****   uint32_t yolo_ms;
 184:Src/app.c     ****   uint32_t hl_ms;
 185:Src/app.c     ****   uint32_t pp_ms;
 186:Src/app.c     ****   uint32_t disp_ms;
 187:Src/app.c     ****   int is_ld_displayed;    /* Toggle for showing landmarks. */
 188:Src/app.c     ****   int is_pd_displayed;    /* Toggle for showing palm detector boxes. */
 189:Src/app.c     ****   int pd_hand_nb;       /* Number of valid hands detected by the palm detector. */
 190:Src/app.c     ****   int nb_faces;
 191:Src/app.c     ****   float pd_max_prob;      /* Maximum confidence score of the detected hands. */
 192:Src/app.c     ****   hand_info_t hands[PD_MAX_HAND_NB];  /* Array of detected hands. */
 193:Src/app.c     ****   face_info_t faces[YOLO_MAX_NB];
 194:Src/app.c     **** } display_info_t;
 195:Src/app.c     **** 
 196:Src/app.c     **** /**
ARM GAS  /tmp/ccfH4MMM.s 			page 5


 197:Src/app.c     ****  * @brief A wrapper for the display_info_t struct to make it thread-safe.
 198:Src/app.c     ****  */
 199:Src/app.c     **** typedef struct {
 200:Src/app.c     ****   SemaphoreHandle_t update;         /* Semaphore to signal that new info is ready. */
 201:Src/app.c     ****   StaticSemaphore_t update_buffer;  
 202:Src/app.c     ****   SemaphoreHandle_t lock;           /* Mutex to protect access to the 'info' struct. */
 203:Src/app.c     ****   StaticSemaphore_t lock_buffer;
 204:Src/app.c     ****   display_info_t info;
 205:Src/app.c     **** } display_t;
 206:Src/app.c     **** 
 207:Src/app.c     **** /**
 208:Src/app.c     ****  * @brief Encapsulates all data related to the Palm Detector (PD) model.
 209:Src/app.c     ****  * @details This will be adapted for our Face Detector (FD) model.
 210:Src/app.c     ****  */
 211:Src/app.c     **** typedef struct {
 212:Src/app.c     ****   uint32_t nn_in_len;       /* Size of the model's input tensor. */
 213:Src/app.c     ****   float *prob_out;          /* Output probabilities for each detected hand. */
 214:Src/app.c     ****   uint32_t prob_out_len;
 215:Src/app.c     ****   float *boxes_out;         /* Pointer to the bounding box output tensor. */
 216:Src/app.c     ****   uint32_t boxes_out_len;
 217:Src/app.c     ****   pd_model_pp_static_param_t static_param;    /* Parameters for post-processing. */
 218:Src/app.c     ****   pd_postprocess_out_t pd_out;    /* Struct to hold post-processing results. */
 219:Src/app.c     **** } pd_model_info_t;
 220:Src/app.c     **** 
 221:Src/app.c     **** /**
 222:Src/app.c     ****  * @brief Encapsulates all data related to the YOLO model.
 223:Src/app.c     ****  * @details This struct holds pointers to the model's raw output and contains the
 224:Src/app.c     ****  * necessary parameters and buffers for the YOLOv8 post-processing library.
 225:Src/app.c     ****  */
 226:Src/app.c     **** typedef struct {
 227:Src/app.c     ****   void* nn_in;                  // Pointer to the input tensor buffer (the image)
 228:Src/app.c     ****   size_t nn_in_len;             // Length of the input tensor buffer in bytes
 229:Src/app.c     **** 
 230:Src/app.c     ****   int8_t* raw_output_tensor;    // Pointer to the raw output from the NPU
 231:Src/app.c     ****   size_t raw_output_len;        // Length of the raw output buffer in bytes
 232:Src/app.c     **** 
 233:Src/app.c     ****   od_pp_out_t pp_output;        // Struct to hold the final, processed output (bounding boxes)
 234:Src/app.c     ****   yolov8_pp_static_param_t pp_params; // Static parameters for the YOLOv8 post-processing
 235:Src/app.c     **** 
 236:Src/app.c     **** } yolo_model_info_t;
 237:Src/app.c     **** 
 238:Src/app.c     **** 
 239:Src/app.c     **** /**
 240:Src/app.c     ****  * @brief Encapsulates all data related to the Hand Landmark (HL) model.
 241:Src/app.c     ****  * @details This will be adapted for our Face Landmark model.
 242:Src/app.c     ****  */
 243:Src/app.c     **** typedef struct {
 244:Src/app.c     ****   uint8_t *nn_in;       /* Pointer to the model's input tensor. */
 245:Src/app.c     ****   uint32_t nn_in_len;
 246:Src/app.c     ****   float *prob_out;      /* Pointer to the landmark presence probability output. */
 247:Src/app.c     ****   uint32_t prob_out_len;
 248:Src/app.c     ****   float *landmarks_out; /* Pointer to the landmark coordinates output tensor. */
 249:Src/app.c     ****   uint32_t landmarks_out_len;
 250:Src/app.c     **** } hl_model_info_t;
 251:Src/app.c     **** 
 252:Src/app.c     **** /**
 253:Src/app.c     ****  * @brief Encapsulates all data related to the Face Landmark model.
ARM GAS  /tmp/ccfH4MMM.s 			page 6


 254:Src/app.c     ****  */
 255:Src/app.c     **** typedef struct {
 256:Src/app.c     ****   uint8_t *nn_in;       /* Pointer to the model's input tensor. */
 257:Src/app.c     ****   uint32_t nn_in_len;
 258:Src/app.c     ****   float *prob_out;      /* Pointer to the landmark presence probability output. */
 259:Src/app.c     ****   uint32_t prob_out_len;
 260:Src/app.c     ****   float *landmarks_out; /* Pointer to the landmark coordinates output tensor. */
 261:Src/app.c     ****   uint32_t landmarks_out_len;
 262:Src/app.c     **** } fl_model_info_t;
 263:Src/app.c     **** 
 264:Src/app.c     **** 
 265:Src/app.c     **** /**
 266:Src/app.c     ****  * @brief A simple structure to manage a UI button's state and callback.
 267:Src/app.c     ****  */
 268:Src/app.c     **** typedef struct {
 269:Src/app.c     ****   Button_TypeDef button_id;
 270:Src/app.c     ****   int prev_state;
 271:Src/app.c     ****   void (*on_click_handler)(void *cb_args);
 272:Src/app.c     ****   void *cb_args;
 273:Src/app.c     **** } button_t;
 274:Src/app.c     **** 
 275:Src/app.c     **** /* Globals */
 276:Src/app.c     **** 
 277:Src/app.c     **** /* Rectangle definitions for the full background and foreground layers. */
 278:Src/app.c     **** static Rectangle_TypeDef lcd_bg_area = {
 279:Src/app.c     ****   .X0 = 0,
 280:Src/app.c     ****   .Y0 = 0,
 281:Src/app.c     ****   .XSize = LCD_BG_WIDTH,
 282:Src/app.c     ****   .YSize = LCD_BG_HEIGHT,
 283:Src/app.c     **** };
 284:Src/app.c     **** 
 285:Src/app.c     **** static Rectangle_TypeDef lcd_fg_area = {
 286:Src/app.c     ****   .X0 = 0,
 287:Src/app.c     ****   .Y0 = 0,
 288:Src/app.c     ****   .XSize = LCD_FG_WIDTH,
 289:Src/app.c     ****   .YSize = LCD_FG_HEIGHT,
 290:Src/app.c     **** };
 291:Src/app.c     **** 
 292:Src/app.c     **** /* The main display buffers. This is a set of 3+ full-frame buffers for smooth video.
 293:Src/app.c     ****    ALIGN_32 ensures 32-byte alignment for performance (DMA/cache).
 294:Src/app.c     ****    IN_PSRAM places this large buffer in external PSRAM. */
 295:Src/app.c     **** /* Lcd Background Buffer */
 296:Src/app.c     **** static uint8_t lcd_bg_buffer[DISPLAY_BUFFER_NB][LCD_BG_WIDTH * LCD_BG_HEIGHT * DISPLAY_BPP] ALIGN_3
 297:Src/app.c     **** static int lcd_bg_buffer_disp_idx = 1;
 298:Src/app.c     **** static int lcd_bg_buffer_capt_idx = 0;
 299:Src/app.c     **** /* Lcd Foreground Buffer */
 300:Src/app.c     **** static uint8_t lcd_fg_buffer[2][LCD_FG_WIDTH * LCD_FG_HEIGHT* 2] ALIGN_32 IN_PSRAM;
 301:Src/app.c     **** static int lcd_fg_buffer_rd_idx;
 302:Src/app.c     **** static display_t disp = {
 303:Src/app.c     ****   .info.is_ld_displayed = 1,
 304:Src/app.c     ****   .info.is_pd_displayed = 0,
 305:Src/app.c     **** };
 306:Src/app.c     **** static cpuload_info_t cpu_load;
 307:Src/app.c     **** /* screen buffer */
 308:Src/app.c     **** static uint8_t screen_buffer[LCD_BG_WIDTH * LCD_BG_HEIGHT * 2] ALIGN_32 IN_PSRAM;
 309:Src/app.c     **** 
 310:Src/app.c     **** /* model */
ARM GAS  /tmp/ccfH4MMM.s 			page 7


 311:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(palm_detector);
 312:Src/app.c     ****  /* Declare the necessary runtime instances and global buffers to hold outputs */
 313:Src/app.c     ****  /* palm detector */
 314:Src/app.c     **** static roi_t rois[PD_MAX_HAND_NB];
 315:Src/app.c     ****  /* hand landmark */
 316:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(hand_landmark);
 317:Src/app.c     **** static ld_point_t ld_landmarks[PD_MAX_HAND_NB][LD_LANDMARK_NB];
 318:Src/app.c     **** LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(yolo_detector);
 319:Src/app.c     **** static roi_t rois_yolo[YOLO_MAX_NB];
 320:Src/app.c     **** //LL_ATON_DECLARE_NAMED_NN_INSTANCE_AND_INTERFACE(face_landmark);
 321:Src/app.c     **** static ld_point_t fl_landmarks[1][FL_LANDMARK_NB]; // Use new constants
 322:Src/app.c     **** /* Counters for frame synchronization. */
 323:Src/app.c     **** static uint32_t frame_event_nb;
 324:Src/app.c     **** static volatile uint32_t frame_event_nb_for_resize;
 325:Src/app.c     **** 
 326:Src/app.c     **** /*TODO: UPDATE THE DEFINED MACROS UNDER app.h
 327:Src/app.c     **** * OR postprocess_conf.h which defines the postprocessing type, we should be able to define it to YO
 328:Src/app.c     **** */
 329:Src/app.c     ****  /* nn input buffers */
 330:Src/app.c     **** static uint8_t nn_input_buffers[2][NN_WIDTH * NN_HEIGHT * NN_BPP] ALIGN_32 IN_PSRAM;
 331:Src/app.c     **** static bqueue_t nn_input_queue;
 332:Src/app.c     **** 
 333:Src/app.c     **** /* --- RTOS Task (Thread) Declarations --- */
 334:Src/app.c     **** /* Statically allocates the memory for the three main application tasks and their stacks. */static 
 335:Src/app.c     **** static StackType_t nn_thread_stack[2 * configMINIMAL_STACK_SIZE];
 336:Src/app.c     **** static StaticTask_t dp_thread;
 337:Src/app.c     **** static StackType_t dp_thread_stack[2 *configMINIMAL_STACK_SIZE];
 338:Src/app.c     **** static StaticTask_t isp_thread;
 339:Src/app.c     **** static StackType_t isp_thread_stack[2 *configMINIMAL_STACK_SIZE];
 340:Src/app.c     **** static SemaphoreHandle_t isp_sem;
 341:Src/app.c     **** static StaticSemaphore_t isp_sem_buffer;
 342:Src/app.c     **** 
 343:Src/app.c     **** static GFXMMU_HandleTypeDef hgfxmmu;
 344:Src/app.c     **** static nema_cmdlist_t cl;
 345:Src/app.c     **** 
 346:Src/app.c     **** static int is_cache_enable()
 347:Src/app.c     **** {
 348:Src/app.c     **** #if defined(USE_DCACHE)
 349:Src/app.c     ****   return 1;
 350:Src/app.c     **** #else
 351:Src/app.c     ****   return 0;
 352:Src/app.c     **** #endif
 353:Src/app.c     **** }
 354:Src/app.c     **** 
 355:Src/app.c     **** /* THESE FUNCTIONS ARE TO BE DEPRECIATED*/
 356:Src/app.c     **** 
 357:Src/app.c     **** /** HELPER FUNCTIONS
 358:Src/app.c     ****  * @brief Normalizes an angle to the range [-PI, PI].
 359:Src/app.c     ****  * @param angle The input angle in radians.
 360:Src/app.c     ****  * @return The equivalent angle within the range [-PI, PI].
 361:Src/app.c     ****  */
 362:Src/app.c     **** static float pd_normalize_angle(float angle)
 363:Src/app.c     **** {
 364:Src/app.c     ****   return angle - 2 * M_PI * floorf((angle - (-M_PI)) / (2 * M_PI));
 365:Src/app.c     **** }
 366:Src/app.c     **** 
 367:Src/app.c     **** static float pd_cook_rotation(float angle)
ARM GAS  /tmp/ccfH4MMM.s 			page 8


 368:Src/app.c     **** {
 369:Src/app.c     ****   return angle;
 370:Src/app.c     **** }
 371:Src/app.c     **** 
 372:Src/app.c     **** static float pd_compute_rotation(pd_pp_box_t *box)
 373:Src/app.c     **** {
 374:Src/app.c     ****   float x0, y0, x1, y1;
 375:Src/app.c     ****   float rotation;
 376:Src/app.c     **** 
 377:Src/app.c     ****   x0 = box->pKps[0].x;
 378:Src/app.c     ****   y0 = box->pKps[0].y;
 379:Src/app.c     ****   x1 = box->pKps[2].x;
 380:Src/app.c     ****   y1 = box->pKps[2].y;
 381:Src/app.c     **** 
 382:Src/app.c     ****   rotation = M_PI * 0.5 - atan2f(-(y1 - y0), x1 - x0);
 383:Src/app.c     **** 
 384:Src/app.c     ****   return pd_cook_rotation(pd_normalize_angle(rotation));
 385:Src/app.c     **** }
 386:Src/app.c     **** /* END OF DEPRECIATED FUNCTIONS */
 387:Src/app.c     **** 
 388:Src/app.c     **** /* TO WRITE EQUIVALENT FOR YOLO FACE DETECTOR*/
 389:Src/app.c     **** 
 390:Src/app.c     **** /**
 391:Src/app.c     ****  * @brief Converts normalized AI model coordinates (0.0 to 1.0) to screen pixel coordinates.
 392:Src/app.c     ****  * @details The AI model outputs coordinates relative to its square input buffer. This
 393:Src/app.c     ****  * function scales them to match the final display resolution.
 394:Src/app.c     ****  * @param box Pointer to the detection box with normalized coordinates.
 395:Src/app.c     ****  */
 396:Src/app.c     **** static void cvt_pd_coord_to_screen_coord(pd_pp_box_t *box)
 397:Src/app.c     **** {
 398:Src/app.c     ****   int i;
 399:Src/app.c     **** 
 400:Src/app.c     ****   /* This is not a typo. Since screen aspect ratio was conserved. We really want to use LCD_BG_WIDT
 401:Src/app.c     ****    * y positions.
 402:Src/app.c     ****    */
 403:Src/app.c     **** 
 404:Src/app.c     ****   box->x_center *= LCD_BG_WIDTH;
 405:Src/app.c     ****   box->y_center *= LCD_BG_WIDTH;
 406:Src/app.c     ****   box->width *= LCD_BG_WIDTH;
 407:Src/app.c     ****   box->height *= LCD_BG_WIDTH;
 408:Src/app.c     ****   for (i = 0; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++) {
 409:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 410:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 411:Src/app.c     ****   }
 412:Src/app.c     **** }
 413:Src/app.c     **** 
 414:Src/app.c     **** /**
 415:Src/app.c     ****  * @brief Adjusts a Region of Interest (ROI) by shifting its center and scaling its size.
 416:Src/app.c     ****  * @details This is used to create the final input for the second model. It takes the
 417:Src/app.c     ****  * initial detection, shifts it, and scales it up to ensure the full object (e.g.,
 418:Src/app.c     ****  * the whole hand, not just the palm) is included. It also makes the ROI a square.
 419:Src/app.c     ****  */
 420:Src/app.c     **** static void roi_shift_and_scale(roi_t *roi, float shift_x, float shift_y, float scale_x, float scal
 421:Src/app.c     **** {
 422:Src/app.c     ****   float long_side;
 423:Src/app.c     ****   float sx, sy;
 424:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 9


 425:Src/app.c     ****   sx = (roi->w * shift_x * cos(roi->rotation) - roi->h * shift_y * sin(roi->rotation));
 426:Src/app.c     ****   sy = (roi->w * shift_x * sin(roi->rotation) + roi->h * shift_y * cos(roi->rotation));
 427:Src/app.c     **** 
 428:Src/app.c     ****   roi->cx += sx;
 429:Src/app.c     ****   roi->cy += sy;
 430:Src/app.c     **** 
 431:Src/app.c     ****   long_side = MAX(roi->w, roi->h);
 432:Src/app.c     ****   roi->w = long_side;
 433:Src/app.c     ****   roi->h = long_side;
 434:Src/app.c     **** 
 435:Src/app.c     ****   roi->w *= scale_x;
 436:Src/app.c     ****   roi->h *= scale_y;
 437:Src/app.c     **** }
 438:Src/app.c     **** 
 439:Src/app.c     **** /* TO WRITE EQUIVALENT FUNCTION FOR YOLO FACE DETECTOR
 440:Src/app.c     ****  * WHICH HANDLES THE MULTI-CLASS OUTPUT OF THE YOLO DETECTOR
 441:Src/app.c     ****  * AND CONVERTS IT INTO A PROPER FACE ROI FOR THE LANDMARK MODEL.
 442:Src/app.c     **** */
 443:Src/app.c     **** /**
 444:Src/app.c     ****  * @brief Converts the output of the first model (detector) into an ROI for the second model.
 445:Src/app.c     ****  * @details This is the core "glue" function between the two AI models. It takes the raw
 446:Src/app.c     ****  * palm/face detection and transforms it into a properly scaled, rotated, and positioned
 447:Src/app.c     ****  * ROI that the second (landmark) model can use.
 448:Src/app.c     ****  * @param box The raw output from the palm/face detector.
 449:Src/app.c     ****  * @param roi The ROI structure to be filled for the landmark model.
 450:Src/app.c     ****  */
 451:Src/app.c     **** static void pd_box_to_roi(pd_pp_box_t *box,  roi_t *roi)
 452:Src/app.c     **** {
 453:Src/app.c     ****   const float shift_x = 0;
 454:Src/app.c     ****   const float shift_y = -0.5;
 455:Src/app.c     ****   const float scale = 2.6;
 456:Src/app.c     **** 
 457:Src/app.c     ****   roi->cx = box->x_center;
 458:Src/app.c     ****   roi->cy = box->y_center;
 459:Src/app.c     ****   roi->w = box->width;
 460:Src/app.c     ****   roi->h = box->height;
 461:Src/app.c     ****   roi->rotation = pd_compute_rotation(box);
 462:Src/app.c     **** 
 463:Src/app.c     ****   roi_shift_and_scale(roi, shift_x, shift_y, scale, scale);
 464:Src/app.c     **** 
 465:Src/app.c     **** }
 466:Src/app.c     **** 
 467:Src/app.c     **** /**
 468:Src/app.c     ****  * @brief A utility function to copy data from one detection box struct to another.
 469:Src/app.c     ****  * TODO: ADAPT INTO COPYING FD BOXES
 470:Src/app.c     ****  */
 471:Src/app.c     **** static void copy_pd_box(pd_pp_box_t *dst, pd_pp_box_t *src)
 472:Src/app.c     **** {
 473:Src/app.c     ****   int i;
 474:Src/app.c     **** 
 475:Src/app.c     ****   dst->prob = src->prob;
 476:Src/app.c     ****   dst->x_center = src->x_center;
 477:Src/app.c     ****   dst->y_center = src->y_center;
 478:Src/app.c     ****   dst->width = src->width;
 479:Src/app.c     ****   dst->height = src->height;
 480:Src/app.c     ****   for (i = 0 ; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++)
 481:Src/app.c     ****     dst->pKps[i] = src->pKps[i];
ARM GAS  /tmp/ccfH4MMM.s 			page 10


 482:Src/app.c     **** }
 483:Src/app.c     **** 
 484:Src/app.c     **** /**
 485:Src/app.c     ****  * @brief Initializes a hardware button using the Board Support Package (BSP).
 486:Src/app.c     ****  * @param on_click_handler Function pointer to call when the button is pressed.
 487:Src/app.c     ****  */
 488:Src/app.c     **** static void button_init(button_t *b, Button_TypeDef id, void (*on_click_handler)(void *), void *cb_
 489:Src/app.c     **** {
 490:Src/app.c     ****   int ret;
 491:Src/app.c     **** 
 492:Src/app.c     ****   ret = BSP_PB_Init(id, BUTTON_MODE_GPIO);
 493:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 494:Src/app.c     **** 
 495:Src/app.c     ****   b->button_id = id;
 496:Src/app.c     ****   b->on_click_handler = on_click_handler;
 497:Src/app.c     ****   b->prev_state = 0;
 498:Src/app.c     ****   b->cb_args = cb_args;
 499:Src/app.c     **** }
 500:Src/app.c     **** 
 501:Src/app.c     **** /**
 502:Src/app.c     ****  * @brief Polls a button's state and triggers its callback on a press event.
 503:Src/app.c     ****  * @details This should be called periodically in a UI or main task.
 504:Src/app.c     ****  */
 505:Src/app.c     **** static void button_process(button_t *b)
 506:Src/app.c     **** {
 507:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 508:Src/app.c     **** 
 509:Src/app.c     ****   if (state != b->prev_state && state && b->on_click_handler)
 510:Src/app.c     ****     b->on_click_handler(b->cb_args);
 511:Src/app.c     **** 
 512:Src/app.c     ****   b->prev_state = state;
 513:Src/app.c     **** }
 514:Src/app.c     **** 
 515:Src/app.c     **** /**
 516:Src/app.c     ****  * @brief Initializes the CPU load tracking structure.
 517:Src/app.c     ****  */
 518:Src/app.c     **** static void cpuload_init(cpuload_info_t *cpu_load)
 519:Src/app.c     **** {
 520:Src/app.c     ****   memset(cpu_load, 0, sizeof(cpuload_info_t));
 521:Src/app.c     **** }
 522:Src/app.c     **** 
 523:Src/app.c     **** /**
 524:Src/app.c     ****  * @brief Updates the CPU load history with a new data point.
 525:Src/app.c     ****  * @details Uses FreeRTOS's runtime counters to get total time and idle time.
 526:Src/app.c     ****  */
 527:Src/app.c     **** static void cpuload_update(cpuload_info_t *cpu_load)
 528:Src/app.c     **** {
 529:Src/app.c     ****   int i;
 530:Src/app.c     **** 
 531:Src/app.c     ****   cpu_load->history[1] = cpu_load->history[0];
 532:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 533:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 534:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 535:Src/app.c     **** 
 536:Src/app.c     ****   if (cpu_load->history[1].tick - cpu_load->history[2].tick < 1000)
 537:Src/app.c     ****     return ;
 538:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 11


 539:Src/app.c     ****   for (i = 0; i < CPU_LOAD_HISTORY_DEPTH - 2; i++)
 540:Src/app.c     ****     cpu_load->history[CPU_LOAD_HISTORY_DEPTH - 1 - i] = cpu_load->history[CPU_LOAD_HISTORY_DEPTH - 
 541:Src/app.c     **** }
 542:Src/app.c     **** 
 543:Src/app.c     **** /**
 544:Src/app.c     ****  * @brief Calculates CPU load percentages over different time windows.
 545:Src/app.c     ****  */
 546:Src/app.c     **** static void cpuload_get_info(cpuload_info_t *cpu_load, float *cpu_load_last, float *cpu_load_last_s
 547:Src/app.c     ****                              float *cpu_load_last_five_seconds)
 548:Src/app.c     **** {
 549:Src/app.c     ****   if (cpu_load_last)
 550:Src/app.c     ****     *cpu_load_last = 100.0 * (cpu_load->history[0].thread - cpu_load->history[1].thread) /
 551:Src/app.c     ****                      (cpu_load->history[0].total - cpu_load->history[1].total);
 552:Src/app.c     ****   if (cpu_load_last_second)
 553:Src/app.c     ****     *cpu_load_last_second = 100.0 * (cpu_load->history[2].thread - cpu_load->history[3].thread) /
 554:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 555:Src/app.c     ****   if (cpu_load_last_five_seconds)
 556:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 557:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[7].total);
 558:Src/app.c     **** }
 559:Src/app.c     **** 
 560:Src/app.c     **** /**
 561:Src/app.c     ****  * @brief Initializes a thread-safe buffer queue (bqueue).
 562:Src/app.c     ****  * @details Creates the FreeRTOS semaphores needed for producer-consumer synchronization.
 563:Src/app.c     ****  * @return 0 on success, -1 on failure.
 564:Src/app.c     ****  */
 565:Src/app.c     **** static int bqueue_init(bqueue_t *bq, int buffer_nb, uint8_t **buffers)
 566:Src/app.c     **** {
 567:Src/app.c     ****   int i;
 568:Src/app.c     **** 
 569:Src/app.c     ****   if (buffer_nb > BQUEUE_MAX_BUFFERS)
 570:Src/app.c     ****     return -1;
 571:Src/app.c     **** 
 572:Src/app.c     ****   bq->free = xSemaphoreCreateCountingStatic(buffer_nb, buffer_nb, &bq->free_buffer);
 573:Src/app.c     ****   if (!bq->free)
 574:Src/app.c     ****     goto free_sem_error;
 575:Src/app.c     ****   bq->ready = xSemaphoreCreateCountingStatic(buffer_nb, 0, &bq->ready_buffer);
 576:Src/app.c     ****   if (!bq->ready)
 577:Src/app.c     ****     goto ready_sem_error;
 578:Src/app.c     **** 
 579:Src/app.c     ****   bq->buffer_nb = buffer_nb;
 580:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 581:Src/app.c     ****     assert(buffers[i]);
 582:Src/app.c     ****     bq->buffers[i] = buffers[i];
 583:Src/app.c     ****   }
 584:Src/app.c     ****   bq->free_idx = 0;
 585:Src/app.c     ****   bq->ready_idx = 0;
 586:Src/app.c     **** 
 587:Src/app.c     ****   return 0;
 588:Src/app.c     **** 
 589:Src/app.c     **** ready_sem_error:
 590:Src/app.c     ****   vSemaphoreDelete(bq->free);
 591:Src/app.c     **** free_sem_error:
 592:Src/app.c     ****   return -1;
 593:Src/app.c     **** }
 594:Src/app.c     **** 
 595:Src/app.c     **** /**
ARM GAS  /tmp/ccfH4MMM.s 			page 12


 596:Src/app.c     ****  * @brief Gets a free buffer from the queue for a producer to write to.
 597:Src/app.c     ****  * @param is_blocking If true, will wait indefinitely for a free buffer.
 598:Src/app.c     ****  * @return Pointer to a free buffer, or NULL if non-blocking and none are available.
 599:Src/app.c     ****  */
 600:Src/app.c     **** static uint8_t *bqueue_get_free(bqueue_t *bq, int is_blocking)
 601:Src/app.c     **** {
 602:Src/app.c     ****   uint8_t *res;
 603:Src/app.c     ****   int ret;
 604:Src/app.c     **** 
 605:Src/app.c     ****   ret = xSemaphoreTake(bq->free, is_blocking ? portMAX_DELAY : 0);
 606:Src/app.c     ****   if (ret == pdFALSE)
 607:Src/app.c     ****     return NULL;
 608:Src/app.c     **** 
 609:Src/app.c     ****   res = bq->buffers[bq->free_idx];
 610:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 611:Src/app.c     **** 
 612:Src/app.c     ****   return res;
 613:Src/app.c     **** }
 614:Src/app.c     **** 
 615:Src/app.c     **** /**
 616:Src/app.c     ****  * @brief Returns a buffer to the free pool (used by a consumer).
 617:Src/app.c     ****  */
 618:Src/app.c     **** static void bqueue_put_free(bqueue_t *bq)
 619:Src/app.c     **** {
 620:Src/app.c     ****   int ret;
 621:Src/app.c     **** 
 622:Src/app.c     ****   ret = xSemaphoreGive(bq->free);
 623:Src/app.c     ****   assert(ret == pdTRUE);
 624:Src/app.c     **** }
 625:Src/app.c     **** 
 626:Src/app.c     **** /**
 627:Src/app.c     ****  * @brief Gets a ready buffer from the queue for a consumer to read from.
 628:Src/app.c     ****  * @details This function will block until a buffer is ready.
 629:Src/app.c     ****  * @return Pointer to a ready buffer.
 630:Src/app.c     ****  */
 631:Src/app.c     **** static uint8_t *bqueue_get_ready(bqueue_t *bq)
 632:Src/app.c     **** {
 633:Src/app.c     ****   uint8_t *res;
 634:Src/app.c     ****   int ret;
 635:Src/app.c     **** 
 636:Src/app.c     ****   ret = xSemaphoreTake(bq->ready, portMAX_DELAY);
 637:Src/app.c     ****   assert(ret == pdTRUE);
 638:Src/app.c     **** 
 639:Src/app.c     ****   res = bq->buffers[bq->ready_idx];
 640:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 641:Src/app.c     **** 
 642:Src/app.c     ****   return res;
 643:Src/app.c     **** }
 644:Src/app.c     **** 
 645:Src/app.c     **** /**
 646:Src/app.c     ****  * @brief Puts a buffer into the ready pool (used by a producer).
 647:Src/app.c     ****  * @details Handles being called from an Interrupt Service Routine (ISR).
 648:Src/app.c     ****  */
 649:Src/app.c     **** static void bqueue_put_ready(bqueue_t *bq)
 650:Src/app.c     **** {
 651:Src/app.c     ****   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 652:Src/app.c     ****   int ret;
ARM GAS  /tmp/ccfH4MMM.s 			page 13


 653:Src/app.c     **** 
 654:Src/app.c     ****   if (xPortIsInsideInterrupt()) {
 655:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 656:Src/app.c     ****     assert(ret == pdTRUE);
 657:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 658:Src/app.c     ****   } else {
 659:Src/app.c     ****     ret = xSemaphoreGive(bq->ready);
 660:Src/app.c     ****     assert(ret == pdTRUE);
 661:Src/app.c     ****   }
 662:Src/app.c     **** }
 663:Src/app.c     **** 
 664:Src/app.c     **** /**
 665:Src/app.c     ****  * @brief Updates the display controller to show a new background buffer.
 666:Src/app.c     ****  * @details This function directly interacts with the screen layer driver to perform
 667:Src/app.c     ****  * a "flip," making the newly rendered frame visible.
 668:Src/app.c     ****  * @param next_disp_idx The index of the buffer in lcd_bg_buffer to display.
 669:Src/app.c     ****  */
 670:Src/app.c     **** static void reload_bg_layer(int next_disp_idx)
 671:Src/app.c     **** {
 672:Src/app.c     ****   int ret;
 673:Src/app.c     **** 
 674:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_bg_buffer[next_disp_idx], SCRL_LAYER_0);
 675:Src/app.c     ****   assert(ret == 0);
 676:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 677:Src/app.c     ****   assert(ret == 0);
 678:Src/app.c     **** 
 679:Src/app.c     ****   ret = SRCL_Update();
 680:Src/app.c     ****   assert(ret == 0);
 681:Src/app.c     **** }
 682:Src/app.c     **** 
 683:Src/app.c     **** /**
 684:Src/app.c     ****  * @brief Frame event callback for the main display pipe (Pipe 1).
 685:Src/app.c     ****  * @details This function is triggered by a hardware interrupt every time the DCMIPP
 686:Src/app.c     ****  * has finished writing a new video frame for the display. It implements
 687:Src/app.c     ****  * a triple-buffering scheme for smooth, tear-free video.
 688:Src/app.c     ****  */
 689:Src/app.c     **** static void app_main_pipe_frame_event()
 690:Src/app.c     **** {
 691:Src/app.c     ****   /* Calculate the indices for the next display buffer and next capture buffer in a circular manner
 692:Src/app.c     ****   int next_disp_idx = (lcd_bg_buffer_disp_idx + 1) % DISPLAY_BUFFER_NB;
 693:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 694:Src/app.c     ****   int ret;
 695:Src/app.c     **** 
 696:Src/app.c     ****   /* Tell the DCMIPP hardware where to write the *next* frame it captures. */
 697:Src/app.c     ****   ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE1,
 698:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 699:Src/app.c     ****   assert(ret == HAL_OK);
 700:Src/app.c     **** 
 701:Src/app.c     ****   /* Update the global indices to track the buffers. */
 702:Src/app.c     ****   reload_bg_layer(next_disp_idx);
 703:Src/app.c     ****   lcd_bg_buffer_disp_idx = next_disp_idx;
 704:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 705:Src/app.c     **** 
 706:Src/app.c     ****   frame_event_nb++;
 707:Src/app.c     **** }
 708:Src/app.c     **** 
 709:Src/app.c     **** /**
ARM GAS  /tmp/ccfH4MMM.s 			page 14


 710:Src/app.c     ****  * @brief Frame event callback for the ancillary NN pipe (Pipe 2).
 711:Src/app.c     ****  * @details This function is triggered by a hardware interrupt every time the DCMIPP
 712:Src/app.c     ****  * has finished writing a new, smaller frame for the AI model.
 713:Src/app.c     ****  */
 714:Src/app.c     **** static void app_ancillary_pipe_frame_event()
 715:Src/app.c     **** {
 716:Src/app.c     ****   uint8_t *next_buffer;
 717:Src/app.c     ****   int ret;
 718:Src/app.c     **** 
 719:Src/app.c     ****   next_buffer = bqueue_get_free(&nn_input_queue, 0);
 720:Src/app.c     ****   if (next_buffer) {
 721:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 722:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 723:Src/app.c     ****     assert(ret == HAL_OK);
 724:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 725:Src/app.c     ****     frame_event_nb_for_resize = frame_event_nb - 1;
 726:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 727:Src/app.c     ****   }
 728:Src/app.c     **** }
 729:Src/app.c     **** 
 730:Src/app.c     **** /**
 731:Src/app.c     ****  * @brief VSYNC event callback for the display.
 732:Src/app.c     ****  * @details This is triggered by a hardware interrupt at the start of each vertical
 733:Src/app.c     ****  * blanking interval of the display. It's used to synchronize the camera's
 734:Src/app.c     ****  * Image Signal Processing (ISP) task with the display refresh rate.
 735:Src/app.c     ****  */
 736:Src/app.c     **** static void app_main_pipe_vsync_event()
 737:Src/app.c     **** {
 738:Src/app.c     ****   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 739:Src/app.c     ****   int ret;
 740:Src/app.c     **** 
 741:Src/app.c     ****   ret = xSemaphoreGiveFromISR(isp_sem, &xHigherPriorityTaskWoken);
 742:Src/app.c     ****   if (ret == pdTRUE)
 743:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 744:Src/app.c     **** }
 745:Src/app.c     **** 
 746:Src/app.c     **** /**
 747:Src/app.c     ****  * @brief Clamps a 2D point to ensure it's within the screen boundaries.
 748:Src/app.c     ****  * @return 1 if the point was moved, 0 otherwise.
 749:Src/app.c     ****  */
 750:Src/app.c     **** static int clamp_point(int *x, int *y)
 751:Src/app.c     **** {
  34              		.loc 1 751 1 view -0
  35              		.cfi_startproc
  36              		@ args = 0, pretend = 0, frame = 0
  37              		@ frame_needed = 0, uses_anonymous_args = 0
 752:Src/app.c     ****   int xi = *x;
  38              		.loc 1 752 3 view .LVU1
  39              		.loc 1 752 7 is_stmt 0 view .LVU2
  40 0000 0368     		ldr	r3, [r0]
  41              	.LVL1:
 753:Src/app.c     ****   int yi = *y;
  42              		.loc 1 753 3 is_stmt 1 view .LVU3
 751:Src/app.c     ****   int xi = *x;
  43              		.loc 1 751 1 is_stmt 0 view .LVU4
  44 0002 10B5     		push	{r4, lr}
  45              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccfH4MMM.s 			page 15


  46              		.cfi_offset 4, -8
  47              		.cfi_offset 14, -4
 754:Src/app.c     **** 
 755:Src/app.c     ****   if (*x < 0)
  48              		.loc 1 755 6 view .LVU5
  49 0004 002B     		cmp	r3, #0
 756:Src/app.c     ****     *x = 0;
  50              		.loc 1 756 8 view .LVU6
  51 0006 B8BF     		it	lt
  52 0008 0024     		movlt	r4, #0
 753:Src/app.c     **** 
  53              		.loc 1 753 7 view .LVU7
  54 000a 0A68     		ldr	r2, [r1]
  55              	.LVL2:
 755:Src/app.c     ****     *x = 0;
  56              		.loc 1 755 3 is_stmt 1 view .LVU8
  57              		.loc 1 756 5 view .LVU9
  58              		.loc 1 756 8 is_stmt 0 view .LVU10
  59 000c B8BF     		it	lt
  60 000e 0460     		strlt	r4, [r0]
 757:Src/app.c     ****   if (*y < 0)
  61              		.loc 1 757 3 is_stmt 1 view .LVU11
  62              		.loc 1 757 6 is_stmt 0 view .LVU12
  63 0010 0C68     		ldr	r4, [r1]
  64 0012 002C     		cmp	r4, #0
 758:Src/app.c     ****     *y = 0;
  65              		.loc 1 758 5 is_stmt 1 view .LVU13
  66              		.loc 1 758 8 is_stmt 0 view .LVU14
  67 0014 BCBF     		itt	lt
  68 0016 0024     		movlt	r4, #0
  69 0018 0C60     		strlt	r4, [r1]
 759:Src/app.c     ****   if (*x >= lcd_bg_area.XSize)
  70              		.loc 1 759 3 is_stmt 1 view .LVU15
  71              		.loc 1 759 6 is_stmt 0 view .LVU16
  72 001a 0468     		ldr	r4, [r0]
  73 001c B4F5487F 		cmp	r4, #800
 760:Src/app.c     ****     *x = lcd_bg_area.XSize - 1;
  74              		.loc 1 760 5 is_stmt 1 view .LVU17
  75              		.loc 1 760 8 is_stmt 0 view .LVU18
  76 0020 24BF     		itt	cs
  77 0022 40F21F34 		movwcs	r4, #799
  78 0026 0460     		strcs	r4, [r0]
 761:Src/app.c     ****   if (*y >= lcd_bg_area.YSize)
  79              		.loc 1 761 3 is_stmt 1 view .LVU19
  80              		.loc 1 761 6 is_stmt 0 view .LVU20
  81 0028 0C68     		ldr	r4, [r1]
  82 002a B4F5F07F 		cmp	r4, #480
 762:Src/app.c     ****     *y = lcd_bg_area.YSize - 1;
  83              		.loc 1 762 5 is_stmt 1 view .LVU21
  84              		.loc 1 762 8 is_stmt 0 view .LVU22
  85 002e 24BF     		itt	cs
  86 0030 40F2DF14 		movwcs	r4, #479
  87 0034 0C60     		strcs	r4, [r1]
 763:Src/app.c     **** 
 764:Src/app.c     ****   return (xi != *x) || (yi != *y);
  88              		.loc 1 764 3 is_stmt 1 view .LVU23
  89              		.loc 1 764 21 is_stmt 0 view .LVU24
ARM GAS  /tmp/ccfH4MMM.s 			page 16


  90 0036 0068     		ldr	r0, [r0]
  91              	.LVL3:
  92              		.loc 1 764 21 view .LVU25
  93 0038 9842     		cmp	r0, r3
  94 003a 04D1     		bne	.L7
  95              		.loc 1 764 21 discriminator 2 view .LVU26
  96 003c 0868     		ldr	r0, [r1]
  97 003e 801A     		subs	r0, r0, r2
  98 0040 18BF     		it	ne
  99 0042 0120     		movne	r0, #1
 100              	.L1:
 765:Src/app.c     **** }
 101              		.loc 1 765 1 view .LVU27
 102 0044 10BD     		pop	{r4, pc}
 103              	.L7:
 764:Src/app.c     **** }
 104              		.loc 1 764 21 discriminator 3 view .LVU28
 105 0046 0120     		movs	r0, #1
 764:Src/app.c     **** }
 106              		.loc 1 764 21 view .LVU29
 107 0048 FCE7     		b	.L1
 108              		.cfi_endproc
 109              	.LFE7380:
 111              		.section	.rodata.isp_thread_fct.str1.1,"aMS",%progbits,1
 112              	.LC1:
 113 0000 72657420 		.ascii	"ret == pdTRUE\000"
 113      3D3D2070 
 113      64545255 
 113      4500
 114              	.LC2:
 115 000e 5372632F 		.ascii	"Src/app.c\000"
 115      6170702E 
 115      6300
 116              		.section	.text.isp_thread_fct,"ax",%progbits
 117              		.align	1
 118              		.syntax unified
 119              		.thumb
 120              		.thumb_func
 122              	isp_thread_fct:
 123              	.LVL4:
 124              	.LFB7411:
 766:Src/app.c     **** 
 767:Src/app.c     **** /**
 768:Src/app.c     ****  * @brief Clamps a 2D point, keeping a minimum margin from the screen edges.
 769:Src/app.c     ****  * @return 1 if the point was moved, 0 otherwise.
 770:Src/app.c     ****  */
 771:Src/app.c     **** static int clamp_point_with_margin(int *x, int *y, int margin)
 772:Src/app.c     **** {
 773:Src/app.c     ****   int xi = *x;
 774:Src/app.c     ****   int yi = *y;
 775:Src/app.c     **** 
 776:Src/app.c     ****   if (*x < margin)
 777:Src/app.c     ****     *x = margin;
 778:Src/app.c     ****   if (*y < margin)
 779:Src/app.c     ****     *y = margin;
 780:Src/app.c     ****   if (*x >= lcd_bg_area.XSize - margin)
 781:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
ARM GAS  /tmp/ccfH4MMM.s 			page 17


 782:Src/app.c     ****   if (*y >= lcd_bg_area.YSize - margin)
 783:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 784:Src/app.c     **** 
 785:Src/app.c     ****   return (xi != *x) || (yi != *y);
 786:Src/app.c     **** }
 787:Src/app.c     **** 
 788:Src/app.c     **** /**
 789:Src/app.c     ****  * @brief Draws the output of the first model (palm/face detector).
 790:Src/app.c     ****  * @param hand Pointer to the raw detection box data.
 791:Src/app.c     ****  */
 792:Src/app.c     **** static void display_pd_hand(pd_pp_box_t *hand)
 793:Src/app.c     **** {
 794:Src/app.c     ****   int xc, yc;
 795:Src/app.c     ****   int x0, y0;
 796:Src/app.c     ****   int x1, y1;
 797:Src/app.c     ****   int w, h;
 798:Src/app.c     ****   int i;
 799:Src/app.c     **** 
 800:Src/app.c     ****   /* display box around palm */
 801:Src/app.c     ****   xc = (int)hand->x_center;
 802:Src/app.c     ****   yc = (int)hand->y_center;
 803:Src/app.c     ****   w = (int)hand->width;
 804:Src/app.c     ****   h = (int)hand->height;
 805:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 806:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 807:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 808:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 809:Src/app.c     ****   clamp_point(&x0, &y0);
 810:Src/app.c     ****   clamp_point(&x1, &y1);
 811:Src/app.c     ****   UTIL_LCD_DrawRect(x0, y0, x1 - x0, y1 - y0, UTIL_LCD_COLOR_GREEN);
 812:Src/app.c     **** 
 813:Src/app.c     ****   /* display palm key points */
 814:Src/app.c     ****   for (i = 0; i < 7; i++) {
 815:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 816:Src/app.c     **** 
 817:Src/app.c     ****     x0 = (int)hand->pKps[i].x;
 818:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 819:Src/app.c     ****     clamp_point(&x0, &y0);
 820:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 821:Src/app.c     ****   }
 822:Src/app.c     **** }
 823:Src/app.c     **** 
 824:Src/app.c     **** /**
 825:Src/app.c     ****  * @brief Rotates a 2D point around the origin.
 826:Src/app.c     ****  */
 827:Src/app.c     **** static void rotate_point(float pt[2], float rotation)
 828:Src/app.c     **** {
 829:Src/app.c     ****   float x = pt[0];
 830:Src/app.c     ****   float y = pt[1];
 831:Src/app.c     **** 
 832:Src/app.c     ****   pt[0] = cos(rotation) * x - sin(rotation) * y;
 833:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 834:Src/app.c     **** }
 835:Src/app.c     **** 
 836:Src/app.c     **** /**
 837:Src/app.c     ****  * @brief Calculates the four corner coordinates of a rotated ROI rectangle.
 838:Src/app.c     ****  */
ARM GAS  /tmp/ccfH4MMM.s 			page 18


 839:Src/app.c     **** static void roi_to_corners(roi_t *roi, float corners[4][2])
 840:Src/app.c     **** {
 841:Src/app.c     ****   const float corners_init[4][2] = {
 842:Src/app.c     ****     {-roi->w / 2, -roi->h / 2},
 843:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 844:Src/app.c     ****     { roi->w / 2,  roi->h / 2},
 845:Src/app.c     ****     {-roi->w / 2,  roi->h / 2},
 846:Src/app.c     ****   };
 847:Src/app.c     ****   int i;
 848:Src/app.c     **** 
 849:Src/app.c     ****   memcpy(corners, corners_init, sizeof(corners_init));
 850:Src/app.c     ****   /* rotate */
 851:Src/app.c     ****   for (i = 0; i < 4; i++)
 852:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 853:Src/app.c     **** 
 854:Src/app.c     ****   /* shift */
 855:Src/app.c     ****   for (i = 0; i < 4; i++) {
 856:Src/app.c     ****     corners[i][0] += roi->cx;
 857:Src/app.c     ****     corners[i][1] += roi->cy;
 858:Src/app.c     ****   }
 859:Src/app.c     **** }
 860:Src/app.c     **** 
 861:Src/app.c     **** /**
 862:Src/app.c     ****  * @brief Clamps all four corners of a rectangle to the screen boundaries.
 863:Src/app.c     ****  */
 864:Src/app.c     **** static int clamp_corners(float corners_in[4][2], int corners_out[4][2])
 865:Src/app.c     **** {
 866:Src/app.c     ****   int is_clamp = 0;
 867:Src/app.c     ****   int i;
 868:Src/app.c     **** 
 869:Src/app.c     ****   for (i = 0; i < 4; i++) {
 870:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 871:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 872:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 873:Src/app.c     ****   }
 874:Src/app.c     **** 
 875:Src/app.c     ****   return is_clamp;
 876:Src/app.c     **** }
 877:Src/app.c     **** 
 878:Src/app.c     **** /**
 879:Src/app.c     ****  * @brief Draws the rotated red ROI box for debugging purposes.
 880:Src/app.c     ****  * @details This shows the exact region that was cropped and sent to the second model.
 881:Src/app.c     ****  */
 882:Src/app.c     **** static void display_roi(roi_t *roi)
 883:Src/app.c     **** {
 884:Src/app.c     ****   float corners_f[4][2];
 885:Src/app.c     ****   int corners[4][2];
 886:Src/app.c     ****   int is_clamp;
 887:Src/app.c     ****   int i;
 888:Src/app.c     **** 
 889:Src/app.c     ****   /* compute box corners */
 890:Src/app.c     ****   roi_to_corners(roi, corners_f);
 891:Src/app.c     **** 
 892:Src/app.c     ****   /* clamp */
 893:Src/app.c     ****   is_clamp = clamp_corners(corners_f, corners);
 894:Src/app.c     ****   if (is_clamp)
 895:Src/app.c     ****     return ;
ARM GAS  /tmp/ccfH4MMM.s 			page 19


 896:Src/app.c     **** 
 897:Src/app.c     ****   /* display */
 898:Src/app.c     ****   for (i = 0; i < 4; i++)
 899:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 900:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 901:Src/app.c     **** }
 902:Src/app.c     **** 
 903:Src/app.c     **** /**
 904:Src/app.c     ****  * @brief Decodes a landmark's relative coordinates into absolute screen coordinates.
 905:Src/app.c     ****  * @details The landmark model outputs coordinates relative to the ROI (0.0 to 1.0).
 906:Src/app.c     ****  * This function transforms them back into the main screen's coordinate space by
 907:Src/app.c     ****  * applying the ROI's translation, scaling, and rotation.
 908:Src/app.c     ****  * @param roi The Region of Interest that was used as input for the landmark model.
 909:Src/app.c     ****  * @param lm The landmark point with relative coordinates.
 910:Src/app.c     ****  * @param decoded The landmark point with absolute screen coordinates (output).
 911:Src/app.c     ****  */
 912:Src/app.c     **** static void decode_ld_landmark(roi_t *roi, ld_point_t *lm, ld_point_t *decoded)
 913:Src/app.c     **** {
 914:Src/app.c     ****   float rotation = roi->rotation;
 915:Src/app.c     ****   float w = roi->w;
 916:Src/app.c     ****   float h = roi->h;
 917:Src/app.c     **** 
 918:Src/app.c     ****   decoded->x = roi->cx + (lm->x - 0.5) * w * cos(rotation) - (lm->y - 0.5) * h * sin(rotation);
 919:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 920:Src/app.c     **** }
 921:Src/app.c     **** 
 922:Src/app.c     **** /**
 923:Src/app.c     ****  * @brief Draws the output of the second model (hand/face landmarks).
 924:Src/app.c     ****  */
 925:Src/app.c     **** static void display_ld_hand(hand_info_t *hand)
 926:Src/app.c     **** {
 927:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 928:Src/app.c     ****   roi_t *roi = &hand->roi;
 929:Src/app.c     ****   int x[LD_LANDMARK_NB];
 930:Src/app.c     ****   int y[LD_LANDMARK_NB];
 931:Src/app.c     ****   int is_clamped[LD_LANDMARK_NB];
 932:Src/app.c     ****   ld_point_t decoded;
 933:Src/app.c     ****   int i;
 934:Src/app.c     **** 
 935:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++) {
 936:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 937:Src/app.c     ****     x[i] = (int)decoded.x;
 938:Src/app.c     ****     y[i] = (int)decoded.y;
 939:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 940:Src/app.c     ****   }
 941:Src/app.c     **** 
 942:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++) {
 943:Src/app.c     ****     if (is_clamped[i])
 944:Src/app.c     ****       continue;
 945:Src/app.c     ****     UTIL_LCD_FillCircle(x[i], y[i], disk_radius, UTIL_LCD_COLOR_YELLOW);
 946:Src/app.c     ****   }
 947:Src/app.c     **** 
 948:Src/app.c     ****   for (i = 0; i < LD_BINDING_NB; i++) {
 949:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 950:Src/app.c     ****       continue;
 951:Src/app.c     ****     UTIL_LCD_DrawLine(x[ld_bindings_idx[i][0]], y[ld_bindings_idx[i][0]],
 952:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
ARM GAS  /tmp/ccfH4MMM.s 			page 20


 953:Src/app.c     ****                       UTIL_LCD_COLOR_BLACK);
 954:Src/app.c     ****   }
 955:Src/app.c     **** }
 956:Src/app.c     **** 
 957:Src/app.c     **** /**
 958:Src/app.c     ****  * @brief Main drawing wrapper to display all info for a single detected hand/face.
 959:Src/app.c     ****  * @details Checks UI toggles to decide whether to draw the bounding box and/or the landmarks.
 960:Src/app.c     ****  */
 961:Src/app.c     **** void display_hand(display_info_t *info, hand_info_t *hand)
 962:Src/app.c     **** {
 963:Src/app.c     ****   if (info->is_pd_displayed) {
 964:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 965:Src/app.c     ****     display_roi(&hand->roi);
 966:Src/app.c     ****   }
 967:Src/app.c     ****   if (info->is_ld_displayed)
 968:Src/app.c     ****     display_ld_hand(hand);
 969:Src/app.c     **** }
 970:Src/app.c     **** 
 971:Src/app.c     **** /**
 972:Src/app.c     ****  * @brief Renders the entire UI overlay for one frame.
 973:Src/app.c     ****  * @details This is the main function called by the display task. It clears the
 974:Src/app.c     ****  * overlay, draws performance stats, and then draws the AI model results.
 975:Src/app.c     ****  * @param info The main display structure containing all data to be rendered.
 976:Src/app.c     ****  */
 977:Src/app.c     **** static void Display_NetworkOutput(display_info_t *info)
 978:Src/app.c     **** {
 979:Src/app.c     ****   float cpu_load_one_second;
 980:Src/app.c     ****   int line_nb = 0;
 981:Src/app.c     ****   float nn_fps;
 982:Src/app.c     ****   int i;
 983:Src/app.c     **** 
 984:Src/app.c     ****   /* clear previous ui */
 985:Src/app.c     ****   UTIL_LCD_FillRect(lcd_fg_area.X0, lcd_fg_area.Y0, lcd_fg_area.XSize, lcd_fg_area.YSize, 0x0000000
 986:Src/app.c     **** 
 987:Src/app.c     ****   /* cpu load */
 988:Src/app.c     ****   cpuload_update(&cpu_load);
 989:Src/app.c     ****   cpuload_get_info(&cpu_load, NULL, &cpu_load_one_second, NULL);
 990:Src/app.c     **** 
 991:Src/app.c     ****   /* draw metrics */
 992:Src/app.c     ****   nn_fps = 1000.0 / info->nn_period_ms;
 993:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 994:Src/app.c     ****   line_nb += 1;
 995:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "   %.1f%%", cpu_load_one_second);
 996:Src/app.c     ****   line_nb += 2;
 997:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Inferences");
 998:Src/app.c     ****   line_nb += 1;
 999:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " pd %2ums", info->pd_ms);
1000:Src/app.c     ****   line_nb += 1;
1001:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " hl %2ums", info->hl_ms);
1002:Src/app.c     ****   line_nb += 2;
1003:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "  %.1f FPS", nn_fps);
1004:Src/app.c     ****   line_nb += 2;
1005:Src/app.c     ****   if (DBG_INFO) {
1006:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Display");
1007:Src/app.c     ****     line_nb += 1;
1008:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "   %ums", info->disp_ms);
1009:Src/app.c     ****     line_nb += 1;
ARM GAS  /tmp/ccfH4MMM.s 			page 21


1010:Src/app.c     ****   }
1011:Src/app.c     **** 
1012:Src/app.c     ****   /* display palm detector output */
1013:Src/app.c     ****   for (i = 0; i < info->pd_hand_nb; i++) {
1014:Src/app.c     ****     if (info->hands[i].is_valid)
1015:Src/app.c     ****       display_hand(info, &info->hands[i]);
1016:Src/app.c     ****   }
1017:Src/app.c     **** 
1018:Src/app.c     ****   if (DBG_INFO)
1019:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
1020:Src/app.c     **** }
1021:Src/app.c     **** 
1022:Src/app.c     **** /**
1023:Src/app.c     ****  * @brief Initializes the Palm Detector model and its post-processor.
1024:Src/app.c     ****  * @details This function gets memory addresses for the model's output tensors
1025:Src/app.c     ****  * (where the NPU writes its results) and prepares the software-based
1026:Src/app.c     ****  * post-processing library. This is for the FIRST model in the sequence.
1027:Src/app.c     ****  * @param info Pointer to the palm detector model info structure to be filled.
1028:Src/app.c     ****  */
1029:Src/app.c     **** static void palm_detector_init(pd_model_info_t *info)
1030:Src/app.c     **** {
1031:Src/app.c     ****   /* Get pointers to the model's output and input buffer information from the AI library. */
1032:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_palm_detector();
1033:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_palm_detector();
1034:Src/app.c     ****   int ret;
1035:Src/app.c     **** 
1036:Src/app.c     ****   /* Store pointers and sizes for the model's input and output tensors. */
1037:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1038:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[0]);
1039:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[0]);
1040:Src/app.c     ****   assert(info->prob_out_len == AI_PD_MODEL_PP_TOTAL_DETECTIONS * sizeof(float));
1041:Src/app.c     ****   info->boxes_out = (float *) LL_Buffer_addr_start(&nn_out_info[1]);
1042:Src/app.c     ****   info->boxes_out_len = LL_Buffer_len(&nn_out_info[1]);
1043:Src/app.c     ****   assert(info->boxes_out_len == AI_PD_MODEL_PP_TOTAL_DETECTIONS * sizeof(float) * 18);
1044:Src/app.c     **** 
1045:Src/app.c     ****   /* Initialize the post-processing library with model-specific parameters (e.g., anchor boxes). */
1046:Src/app.c     ****   ret = app_postprocess_init(&info->static_param);
1047:Src/app.c     ****   assert(ret == AI_PD_POSTPROCESS_ERROR_NO);
1048:Src/app.c     **** }
1049:Src/app.c     **** 
1050:Src/app.c     **** /**
1051:Src/app.c     ****  * @brief Initializes the YOLOv8 Detector model and its post-processor parameters.
1052:Src/app.c     ****  * @details This function gets the memory address for the model's single raw output
1053:Src/app.c     ****  * tensor and configures the parameters for the YOLOv8 post-processing library.
1054:Src/app.c     ****  * @param info Pointer to the yolo_detector_info_t structure to be filled.
1055:Src/app.c     ****  */
1056:Src/app.c     **** static void yolo_detector_init(yolo_model_info_t *info)
1057:Src/app.c     **** {
1058:Src/app.c     ****   /* Get pointers to the info structures for the model's I/O buffers. */
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_yolo_detector();
1060:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
1061:Src/app.c     **** 
1062:Src/app.c     ****   /* --- Get I/O Buffer Addresses --- */
1063:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1064:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1065:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
1066:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
ARM GAS  /tmp/ccfH4MMM.s 			page 22


1067:Src/app.c     **** 
1068:Src/app.c     ****   /* --- Initialize the Post-Processing Parameters --- */
1069:Src/app.c     ****   /* Call the generic init function. It will populate the pp_params struct
1070:Src/app.c     ****      with the correct default values from the pre-processor defines. */
1071:Src/app.c     ****   app_postprocess_init(&info->pp_params);
1072:Src/app.c     **** }
1073:Src/app.c     **** 
1074:Src/app.c     **** /**
1075:Src/app.c     ****  * @brief Runs one inference of the YOLOv8 Detector model.
1076:Src/app.c     ****  * @details This function runs the NPU inference, calls the YOLOv8 post-processing
1077:Src/app.c     ****  * library, filters the results for faces (class ID 2), and prepares the
1078:Src/app.c     ****  * Regions of Interest (ROIs) for the next stage.
1079:Src/app.c     ****  * @param buffer Pointer to the input image from the camera.
1080:Src/app.c     ****  * @param info Pointer to the initialized yolo_detector_info_t structure.
1081:Src/app.c     ****  * @param yolo_exec_time Pointer to store the execution time of this stage.
1082:Src/app.c     ****  * @return The number of *faces* detected.
1083:Src/app.c     ****  */
1084:Src/app.c     **** static int yolo_detector_run(uint8_t *buffer, yolo_model_info_t *info, uint32_t *yolo_exec_time)
1085:Src/app.c     **** {
1086:Src/app.c     ****   uint32_t start_ts;
1087:Src/app.c     ****   int total_detections;
1088:Src/app.c     ****   int face_nb = 0; /* This will count only the faces we find. */
1089:Src/app.c     ****   int ret;
1090:Src/app.c     **** 
1091:Src/app.c     ****   start_ts = HAL_GetTick();
1092:Src/app.c     **** 
1093:Src/app.c     ****   /* --- 1. Run Inference --- */
1094:Src/app.c     ****   ret = LL_ATON_Set_User_Input_Buffer_yolo_detector(0, buffer, info->nn_in_len);
1095:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
1096:Src/app.c     **** 
1097:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_yolo_detector);
1098:Src/app.c     **** 
1099:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->raw_output_tensor, info->raw_output_len));
1100:Src/app.c     **** 
1101:Src/app.c     ****   /* --- 2. Run Post-Processing via Wrapper --- */
1102:Src/app.c     ****   /* Call the generic post-processing wrapper. It will internally call the correct INT8 function. *
1103:Src/app.c     ****   ret = app_postprocess_run((void * []){info->raw_output_tensor}, 1, &info->pp_output, &info->pp_pa
1104:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
1105:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
1106:Src/app.c     **** 
1107:Src/app.c     ****   /* --- 3. Filter for Faces & Prepare ROIs --- */
1108:Src/app.c     ****   for (int i = 0; i < total_detections; i++)
1109:Src/app.c     ****   {
1110:Src/app.c     ****     /* Check if the detected object is a face (class ID 2). */
1111:Src/app.c     ****     if (info->pp_output.pOutBuff[i].class_index == 2)
1112:Src/app.c     ****     {
1113:Src/app.c     ****       pd_pp_box_t temp_box = {0};
1114:Src/app.c     ****       temp_box.x_center = info->pp_output.pOutBuff[i].x_center;
1115:Src/app.c     ****       temp_box.y_center = info->pp_output.pOutBuff[i].y_center;
1116:Src/app.c     ****       temp_box.width    = info->pp_output.pOutBuff[i].width;
1117:Src/app.c     ****       temp_box.height   = info->pp_output.pOutBuff[i].height;
1118:Src/app.c     ****       temp_box.prob     = info->pp_output.pOutBuff[i].conf;
1119:Src/app.c     **** 
1120:Src/app.c     ****       cvt_pd_coord_to_screen_coord(&temp_box);
1121:Src/app.c     ****       pd_box_to_roi(&temp_box, &rois[face_nb]);
1122:Src/app.c     **** 
1123:Src/app.c     ****       face_nb++; /* Increment the count of found faces. */
ARM GAS  /tmp/ccfH4MMM.s 			page 23


1124:Src/app.c     ****       if (face_nb >= YOLO_MAX_NB) { break; } /* Stop if we've reached our limit. */
1125:Src/app.c     ****     }
1126:Src/app.c     ****   }
1127:Src/app.c     **** 
1128:Src/app.c     ****   *yolo_exec_time = HAL_GetTick() - start_ts;
1129:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
1130:Src/app.c     **** }
1131:Src/app.c     ****  
1132:Src/app.c     **** /**
1133:Src/app.c     ****  * @brief Initializes the Face Landmark model.
1134:Src/app.c     ****  * @details This function gets memory addresses for the model's input and output
1135:Src/app.c     ****  * tensors. It is configured based on analysis of the Python post-processing script.
1136:Src/app.c     ****  * @param info Pointer to the face landmark model info structure to be filled.
1137:Src/app.c     ****  * @note The indices for nn_out_info have been updated to match the model's
1138:Src/app.c     ****  * actual output order: [0] for score, [1] for landmarks.
1139:Src/app.c     ****  */
1140:Src/app.c     **** static void face_landmark_init(fl_model_info_t *info)
1141:Src/app.c     **** {
1142:Src/app.c     ****   // Get pointers to the info structures for the model's input/output buffers
1143:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_face_landmark();
1144:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_face_landmark();
1145:Src/app.c     **** 
1146:Src/app.c     ****   // --- INPUT TENSOR ---
1147:Src/app.c     ****   // The input is the image buffer for the model to process.
1148:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1149:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1150:Src/app.c     **** 
1151:Src/app.c     ****   // --- OUTPUT TENSORS (Order corrected based on Python analysis) ---
1152:Src/app.c     **** 
1153:Src/app.c     ****   // Output 0: Presence Score
1154:Src/app.c     ****   // This buffer will contain a single float indicating the confidence that a face was detected.
1155:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[0]);
1156:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[0]);
1157:Src/app.c     ****   assert(info->prob_out_len == sizeof(float));
1158:Src/app.c     **** 
1159:Src/app.c     ****   // Output 1: Landmarks
1160:Src/app.c     ****   // This buffer contains the raw coordinates for all 468 facial landmarks.
1161:Src/app.c     ****   // Even if post-processing only uses x and y, we must map the full 3D output buffer.
1162:Src/app.c     ****   info->landmarks_out = (float *) LL_Buffer_addr_start(&nn_out_info[1]);
1163:Src/app.c     ****   info->landmarks_out_len = LL_Buffer_len(&nn_out_info[1]);
1164:Src/app.c     ****   assert(info->landmarks_out_len == sizeof(float) * 1404); // 468 landmarks * 3 (x,y,z)
1165:Src/app.c     **** }
1166:Src/app.c     **** 
1167:Src/app.c     **** 
1168:Src/app.c     **** /**
1169:Src/app.c     ****  * @brief Runs one inference of the Palm Detector model.
1170:Src/app.c     ****  * @param buffer Pointer to the input image from the camera.
1171:Src/app.c     ****  * @param info Pointer to the initialized model info structure.
1172:Src/app.c     ****  * @param pd_exec_time Pointer to store the execution time of this stage.
1173:Src/app.c     ****  * @return The number of hands/faces detected.
1174:Src/app.c     ****  */
1175:Src/app.c     **** static int palm_detector_run(uint8_t *buffer, pd_model_info_t *info, uint32_t *pd_exec_time)
1176:Src/app.c     **** {
1177:Src/app.c     ****   uint32_t start_ts;
1178:Src/app.c     ****   int hand_nb;
1179:Src/app.c     ****   int ret;
1180:Src/app.c     ****   int i;
ARM GAS  /tmp/ccfH4MMM.s 			page 24


1181:Src/app.c     **** 
1182:Src/app.c     ****   start_ts = HAL_GetTick();
1183:Src/app.c     ****   /* Set the input buffer for the NPU. */
1184:Src/app.c     ****   /* Note that we don't need to clean/invalidate those input buffers since they are only access in 
1185:Src/app.c     ****   ret = LL_ATON_Set_User_Input_Buffer_palm_detector(0, buffer, info->nn_in_len);
1186:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
1187:Src/app.c     **** 
1188:Src/app.c     ****   /* Trigger the NPU to run the inference. This is a blocking call. */
1189:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_palm_detector);
1190:Src/app.c     **** 
1191:Src/app.c     ****   /* Run software post-processing to decode the raw NPU output into human-readable boxes and scores
1192:Src/app.c     ****   ret = app_postprocess_run((void * []){info->prob_out, info->boxes_out}, 2, &info->pd_out, &info->
1193:Src/app.c     ****   assert(ret == AI_PD_POSTPROCESS_ERROR_NO);
1194:Src/app.c     ****   hand_nb = MIN(info->pd_out.box_nb, PD_MAX_HAND_NB);
1195:Src/app.c     **** 
1196:Src/app.c     ****   /* For each detected hand/face, convert its coordinates and generate an ROI for the next model. *
1197:Src/app.c     ****   for (i = 0; i < hand_nb; i++) {
1198:Src/app.c     ****     cvt_pd_coord_to_screen_coord(&info->pd_out.pOutData[i]);
1199:Src/app.c     ****     pd_box_to_roi(&info->pd_out.pOutData[i], &rois[i]);
1200:Src/app.c     ****   }
1201:Src/app.c     **** 
1202:Src/app.c     ****   /* Discard nn_out region (used by pp_outputs variables) to avoid Dcache evictions during nn infer
1203:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->prob_out, info->prob_out_len));
1204:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->boxes_out, info->boxes_out_len));
1205:Src/app.c     **** 
1206:Src/app.c     ****   *pd_exec_time = HAL_GetTick() - start_ts;
1207:Src/app.c     **** 
1208:Src/app.c     ****   return hand_nb;
1209:Src/app.c     **** }
1210:Src/app.c     **** 
1211:Src/app.c     **** /**
1212:Src/app.c     ****  * @brief Initializes the Hand Landmark model.
1213:Src/app.c     ****  * @details This function gets memory addresses for the SECOND model's input and output
1214:Src/app.c     ****  * tensors, allowing the application to prepare the input and read the results.
1215:Src/app.c     ****  * @param info Pointer to the hand landmark model info structure to be filled.
1216:Src/app.c     ****  */
1217:Src/app.c     **** static void hand_landmark_init(hl_model_info_t *info)
1218:Src/app.c     **** {
1219:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_out_info = LL_ATON_Output_Buffers_Info_hand_landmark();
1220:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_hand_landmark();
1221:Src/app.c     **** 
1222:Src/app.c     ****   info->nn_in = LL_Buffer_addr_start(&nn_in_info[0]);
1223:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
1224:Src/app.c     ****   info->prob_out = (float *) LL_Buffer_addr_start(&nn_out_info[2]);
1225:Src/app.c     ****   info->prob_out_len = LL_Buffer_len(&nn_out_info[2]);
1226:Src/app.c     ****   assert(info->prob_out_len == sizeof(float));
1227:Src/app.c     ****   info->landmarks_out = (float *) LL_Buffer_addr_start(&nn_out_info[3]);
1228:Src/app.c     ****   info->landmarks_out_len = LL_Buffer_len(&nn_out_info[3]);
1229:Src/app.c     ****   assert(info->landmarks_out_len == sizeof(float) * 63);
1230:Src/app.c     **** }
1231:Src/app.c     **** 
1232:Src/app.c     **** 
1233:Src/app.c     **** static void app_transform(nema_matrix3x3_t t, app_v3_t v)
1234:Src/app.c     **** {
1235:Src/app.c     ****   app_v3_t r;
1236:Src/app.c     ****   int i;
1237:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 25


1238:Src/app.c     ****   for (i = 0; i < 3; i++)
1239:Src/app.c     ****     r[i] = t[i][0] * v[0] + t[i][1] * v[1] + t[i][2] * v[2];
1240:Src/app.c     **** 
1241:Src/app.c     ****   for (i = 0; i < 3; i++)
1242:Src/app.c     ****     v[i] = r[i];
1243:Src/app.c     **** }
1244:Src/app.c     **** /**
1245:Src/app.c     ****  * @brief Prepares the landmark model's input using the NEMA GPU.
1246:Src/app.c     ****  * @details This function offloads the entire crop, rotate, and resize operation to
1247:Src/app.c     ****  * the hardware accelerator. It builds a transformation matrix and submits it
1248:Src/app.c     ****  * to the GPU, which is much faster than the CPU-based version.
1249:Src/app.c     ****  * @return 0 on success.
1250:Src/app.c     ****  */
1251:Src/app.c     **** static int hand_landmark_prepare_input(uint8_t *buffer, roi_t *roi, hl_model_info_t *info)
1252:Src/app.c     **** {
1253:Src/app.c     ****   app_v3_t vertex[] = {
1254:Src/app.c     ****     {           0,             0, 1},
1255:Src/app.c     ****     {LCD_BG_WIDTH,             0, 1},
1256:Src/app.c     ****     {LCD_BG_WIDTH, LCD_BG_HEIGHT, 1},
1257:Src/app.c     ****     {           0, LCD_BG_HEIGHT, 1},
1258:Src/app.c     ****   };
1259:Src/app.c     ****   GFXMMU_BuffersTypeDef buffers = { 0 };
1260:Src/app.c     ****   nema_matrix3x3_t t;
1261:Src/app.c     ****   int ret;
1262:Src/app.c     ****   int i;
1263:Src/app.c     **** 
1264:Src/app.c     ****   buffers.Buf0Address = (uint32_t) info->nn_in;
1265:Src/app.c     ****   ret = HAL_GFXMMU_ModifyBuffers(&hgfxmmu, &buffers);
1266:Src/app.c     ****   assert(ret == HAL_OK);
1267:Src/app.c     **** 
1268:Src/app.c     ****   /* bind destination texture */
1269:Src/app.c     ****   nema_bind_dst_tex(GFXMMU_VIRTUAL_BUFFER0_BASE, LD_WIDTH, LD_HEIGHT, NEMA_RGBA8888, -1);
1270:Src/app.c     ****   nema_set_clip(0, 0, LD_WIDTH, LD_HEIGHT);
1271:Src/app.c     ****   nema_clear(0);
1272:Src/app.c     ****   /* bind source texture */
1273:Src/app.c     ****   nema_bind_src_tex((uintptr_t) buffer, LCD_BG_WIDTH, LCD_BG_HEIGHT, NEMA_RGBA8888, -1, NEMA_FILTER
1274:Src/app.c     ****   nema_enable_tiling(1);
1275:Src/app.c     ****   nema_set_blend_blit(NEMA_BL_SRC);
1276:Src/app.c     **** 
1277:Src/app.c     ****   /* let's go */
1278:Src/app.c     ****   nema_mat3x3_load_identity(t);
1279:Src/app.c     ****   nema_mat3x3_translate(t, -roi->cx, -roi->cy);
1280:Src/app.c     ****   nema_mat3x3_rotate(t, nema_rad_to_deg(-roi->rotation));
1281:Src/app.c     ****   nema_mat3x3_scale(t, LD_WIDTH / roi->w, LD_HEIGHT / roi->h);
1282:Src/app.c     ****   nema_mat3x3_translate(t, LD_WIDTH / 2, LD_HEIGHT / 2);
1283:Src/app.c     ****   for (i = 0 ; i < 4; i++)
1284:Src/app.c     ****     app_transform(t, vertex[i]);
1285:Src/app.c     ****   nema_blit_quad_fit(vertex[0][0], vertex[0][1], vertex[1][0], vertex[1][1],
1286:Src/app.c     ****                      vertex[2][0], vertex[2][1], vertex[3][0], vertex[3][1]);
1287:Src/app.c     **** 
1288:Src/app.c     ****   nema_cl_submit(&cl);
1289:Src/app.c     ****   nema_cl_wait(&cl);
1290:Src/app.c     ****   HAL_ICACHE_Invalidate();
1291:Src/app.c     **** 
1292:Src/app.c     ****   assert(!nema_get_error());
1293:Src/app.c     **** 
1294:Src/app.c     ****   return 0;
ARM GAS  /tmp/ccfH4MMM.s 			page 26


1295:Src/app.c     **** }
1296:Src/app.c     **** 
1297:Src/app.c     **** /**
1298:Src/app.c     ****  * @brief Runs one inference of the Hand Landmark model.
1299:Src/app.c     ****  * @param buffer Pointer to the source display buffer (for cropping).
1300:Src/app.c     ****  * @param info Pointer to the initialized landmark model info.
1301:Src/app.c     ****  * @param roi The Region of Interest to process.
1302:Src/app.c     ****  * @param ld_landmarks Output array to store the final landmark coordinates.
1303:Src/app.c     ****  * @return 1 if a hand was found and landmarks are valid, 0 otherwise.
1304:Src/app.c     ****  */
1305:Src/app.c     **** static int hand_landmark_run(uint8_t *buffer, hl_model_info_t *info, roi_t *roi,
1306:Src/app.c     ****                              ld_point_t ld_landmarks[LD_LANDMARK_NB])
1307:Src/app.c     **** {
1308:Src/app.c     ****   int is_clamped;
1309:Src/app.c     ****   int is_valid;
1310:Src/app.c     **** 
1311:Src/app.c     ****   is_clamped = hand_landmark_prepare_input(buffer, roi, info);
1312:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(info->nn_in, info->nn_in_len));
1313:Src/app.c     ****   if (is_clamped)
1314:Src/app.c     ****     return 0;
1315:Src/app.c     **** 
1316:Src/app.c     ****   LL_ATON_RT_Main(&NN_Instance_hand_landmark);
1317:Src/app.c     **** 
1318:Src/app.c     ****   is_valid = ld_post_process(info->prob_out, info->landmarks_out, ld_landmarks);
1319:Src/app.c     **** 
1320:Src/app.c     ****   /* Discard nn_out region (used by pp_input and pp_outputs variables) to avoid Dcache evictions du
1321:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->prob_out, info->prob_out_len));
1322:Src/app.c     ****   CACHE_OP(SCB_InvalidateDCache_by_Addr(info->landmarks_out, info->landmarks_out_len));
1323:Src/app.c     **** 
1324:Src/app.c     ****   return is_valid;
1325:Src/app.c     **** }
1326:Src/app.c     **** 
1327:Src/app.c     **** 
1328:Src/app.c     **** /**
1329:Src/app.c     ****  * @brief Initializes the NEMA GPU and its associated drivers.
1330:Src/app.c     ****  */
1331:Src/app.c     **** static void app_rot_init(hl_model_info_t *info)
1332:Src/app.c     **** {
1333:Src/app.c     ****   GFXMMU_PackingTypeDef packing = { 0 };
1334:Src/app.c     ****   int ret;
1335:Src/app.c     **** 
1336:Src/app.c     ****   printf("init nema\n");
1337:Src/app.c     ****   nema_init();
1338:Src/app.c     ****   assert(!nema_get_error());
1339:Src/app.c     ****   nema_ext_hold_enable(2);
1340:Src/app.c     ****   nema_ext_hold_irq_enable(2);
1341:Src/app.c     ****   nema_ext_hold_enable(3);
1342:Src/app.c     ****   nema_ext_hold_irq_enable(3);
1343:Src/app.c     ****   printf("init nema DONE %s\n", nema_get_sw_device_name());
1344:Src/app.c     **** 
1345:Src/app.c     ****   hgfxmmu.Instance = GFXMMU;
1346:Src/app.c     ****   hgfxmmu.Init.BlockSize = GFXMMU_12BYTE_BLOCKS;
1347:Src/app.c     ****   hgfxmmu.Init.AddressTranslation = DISABLE;
1348:Src/app.c     ****   ret = HAL_GFXMMU_Init(&hgfxmmu);
1349:Src/app.c     ****   assert(ret == HAL_OK);
1350:Src/app.c     **** 
1351:Src/app.c     ****   packing.Buffer0Activation = ENABLE;
ARM GAS  /tmp/ccfH4MMM.s 			page 27


1352:Src/app.c     ****   packing.Buffer0Mode       = GFXMMU_PACKING_MSB_REMOVE;
1353:Src/app.c     ****   packing.DefaultAlpha      = 0xff;
1354:Src/app.c     ****   ret = HAL_GFXMMU_ConfigPacking(&hgfxmmu, &packing);
1355:Src/app.c     ****   assert(ret == HAL_OK);
1356:Src/app.c     **** 
1357:Src/app.c     ****   cl = nema_cl_create_sized(8192);
1358:Src/app.c     ****   nema_cl_bind_circular(&cl);
1359:Src/app.c     **** }
1360:Src/app.c     **** 
1361:Src/app.c     **** /**
1362:Src/app.c     ****  * @brief Computes the rotation based on the final landmark points.
1363:Src/app.c     ****  * @details Uses landmark points 0 and 9 (e.g., wrist and middle finger base)
1364:Src/app.c     ****  * for a potentially more stable rotation estimate than the first model.
1365:Src/app.c     ****  */
1366:Src/app.c     **** static float ld_compute_rotation(ld_point_t lm[LD_LANDMARK_NB])
1367:Src/app.c     **** {
1368:Src/app.c     ****   float x0, y0, x1, y1;
1369:Src/app.c     ****   float rotation;
1370:Src/app.c     **** 
1371:Src/app.c     ****   x0 = lm[0].x;
1372:Src/app.c     ****   y0 = lm[0].y;
1373:Src/app.c     ****   x1 = lm[9].x;
1374:Src/app.c     ****   y1 = lm[9].y;
1375:Src/app.c     **** 
1376:Src/app.c     ****   rotation = M_PI * 0.5 - atan2f(-(y1 - y0), x1 - x0);
1377:Src/app.c     **** 
1378:Src/app.c     ****   return pd_cook_rotation(pd_normalize_angle(rotation));
1379:Src/app.c     **** }
1380:Src/app.c     **** 
1381:Src/app.c     **** /**
1382:Src/app.c     ****  * @brief Creates a new, tighter ROI based on the detected landmarks.
1383:Src/app.c     ****  * @details This is used to update the ROI for tracking in the next frame.
1384:Src/app.c     ****  */
1385:Src/app.c     **** static void ld_to_roi(ld_point_t lm[LD_LANDMARK_NB], roi_t *roi, pd_pp_box_t *next_pd)
1386:Src/app.c     **** {
1387:Src/app.c     ****   const int pd_to_ld_idx[AI_PD_MODEL_PP_NB_KEYPOINTS] = {0, 5, 9, 13, 17, 1, 2};
1388:Src/app.c     ****   const int indices[] = {0, 1, 2, 3, 5, 6, 9, 10, 13, 14, 17, 18};
1389:Src/app.c     ****   float max_x, max_y, min_x, min_y;
1390:Src/app.c     ****   int i;
1391:Src/app.c     **** 
1392:Src/app.c     ****   max_x = max_y = -10000;
1393:Src/app.c     ****   min_x = min_y =  10000;
1394:Src/app.c     **** 
1395:Src/app.c     ****   roi->rotation = ld_compute_rotation(lm);
1396:Src/app.c     **** 
1397:Src/app.c     ****   for (i = 0; i < ARRAY_NB(indices); i++) {
1398:Src/app.c     ****     max_x = MAX(max_x, lm[indices[i]].x);
1399:Src/app.c     ****     max_y = MAX(max_y, lm[indices[i]].y);
1400:Src/app.c     ****     min_x = MIN(min_x, lm[indices[i]].x);
1401:Src/app.c     ****     min_y = MIN(min_y, lm[indices[i]].y);
1402:Src/app.c     ****   }
1403:Src/app.c     **** 
1404:Src/app.c     ****   roi->cx = (max_x + min_x) / 2;
1405:Src/app.c     ****   roi->cy = (max_y + min_y) / 2;
1406:Src/app.c     ****   roi->w = (max_x - min_x);
1407:Src/app.c     ****   roi->h = (max_y - min_y);
1408:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 28


1409:Src/app.c     ****   next_pd->x_center = roi->cx;
1410:Src/app.c     ****   next_pd->y_center = roi->cy;
1411:Src/app.c     ****   next_pd->width = roi->w;
1412:Src/app.c     ****   next_pd->height = roi->h;
1413:Src/app.c     ****   for (i = 0; i < AI_PD_MODEL_PP_NB_KEYPOINTS; i++) {
1414:Src/app.c     ****     next_pd->pKps[i].x = lm[pd_to_ld_idx[i]].x;
1415:Src/app.c     ****     next_pd->pKps[i].y = lm[pd_to_ld_idx[i]].y;
1416:Src/app.c     ****   }
1417:Src/app.c     **** }
1418:Src/app.c     **** 
1419:Src/app.c     **** /**
1420:Src/app.c     ****  * @brief Computes the predicted ROI for the next frame to enable tracking.
1421:Src/app.c     ****  * @details This is the core of the tracking logic. Instead of running the slow
1422:Src/app.c     ****  * detector on every frame, we use the landmarks from the current frame to predict
1423:Src/app.c     ****  * where the hand/face will be in the next frame. We then only need to run the
1424:Src/app.c     ****  * fast landmark model on that small predicted ROI.
1425:Src/app.c     ****  */
1426:Src/app.c     **** static void compute_next_roi(roi_t *src, ld_point_t lm_in[LD_LANDMARK_NB], roi_t *next, pd_pp_box_t
1427:Src/app.c     **** {
1428:Src/app.c     ****   const float shift_x = 0;
1429:Src/app.c     ****   const float shift_y = -0.1;
1430:Src/app.c     ****   const float scale = 2.0;
1431:Src/app.c     ****   ld_point_t lm[LD_LANDMARK_NB];
1432:Src/app.c     ****   roi_t roi;
1433:Src/app.c     ****   int i;
1434:Src/app.c     **** 
1435:Src/app.c     ****   for (i = 0; i < LD_LANDMARK_NB; i++)
1436:Src/app.c     ****     decode_ld_landmark(src, &lm_in[i], &lm[i]);
1437:Src/app.c     **** 
1438:Src/app.c     ****   ld_to_roi(lm, &roi, next_pd);
1439:Src/app.c     ****   roi_shift_and_scale(&roi, shift_x, shift_y, scale, scale);
1440:Src/app.c     **** 
1441:Src/app.c     ****   *next = roi;
1442:Src/app.c     **** }
1443:Src/app.c     **** 
1444:Src/app.c     **** /**
1445:Src/app.c     ****  * @brief The main function for the Neural Network processing thread.
1446:Src/app.c     ****  * @details This is the entry point for the FreeRTOS task that handles all AI inference.
1447:Src/app.c     ****  * It will contain a `while(1)` loop to process frames as they become available.
1448:Src/app.c     ****  */
1449:Src/app.c     **** static void nn_thread_fct_backup(void *arg)
1450:Src/app.c     **** {
1451:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
1452:Src/app.c     ****   float nn_period_filtered_ms = 0;
1453:Src/app.c     ****   float pd_filtered_ms = 0;
1454:Src/app.c     ****   float ld_filtered_ms = 0;
1455:Src/app.c     **** 
1456:Src/app.c     ****   /* Model-specific info structures. */
1457:Src/app.c     ****   hl_model_info_t hl_info;
1458:Src/app.c     ****   pd_model_info_t pd_info;
1459:Src/app.c     ****   yolo_model_info_t yolo_info;
1460:Src/app.c     **** 
1461:Src/app.c     ****   /* Timing variables. */
1462:Src/app.c     ****   uint32_t nn_period_ms;
1463:Src/app.c     ****   uint32_t nn_period[2];
1464:Src/app.c     ****   uint8_t *nn_pipe_dst;
1465:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 29


1466:Src/app.c     ****   /* Structs for holding tracking information between frames. */
1467:Src/app.c     ****   pd_pp_point_t box_next_keypoints[AI_PD_MODEL_PP_NB_KEYPOINTS];
1468:Src/app.c     ****   pd_pp_box_t box_next;
1469:Src/app.c     ****   od_pp_out_t boxes_next[YOLO_MAX_NB];
1470:Src/app.c     **** 
1471:Src/app.c     **** 
1472:Src/app.c     ****   int is_tracking = 0;
1473:Src/app.c     ****   roi_t roi_next;
1474:Src/app.c     ****   uint32_t pd_ms;
1475:Src/app.c     ****   uint32_t hl_ms;
1476:Src/app.c     ****   uint32_t yolo_ms;
1477:Src/app.c     ****   uint32_t fl_ms;
1478:Src/app.c     ****   int ret;
1479:Src/app.c     ****   int j;
1480:Src/app.c     ****   int temp = 0;
1481:Src/app.c     **** 
1482:Src/app.c     ****   /* Current tracking algo only support single hand */
1483:Src/app.c     ****   assert(PD_MAX_HAND_NB == 1);
1484:Src/app.c     **** 
1485:Src/app.c     ****   /* setup models buffer info */
1486:Src/app.c     ****   palm_detector_init(&pd_info);
1487:Src/app.c     ****   box_next.pKps = box_next_keypoints;
1488:Src/app.c     ****   hand_landmark_init(&hl_info);
1489:Src/app.c     ****   app_rot_init(&hl_info);
1490:Src/app.c     ****   yolo_detector_init(&yolo_info);
1491:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
1492:Src/app.c     ****   nn_period[1] = HAL_GetTick();
1493:Src/app.c     **** 
1494:Src/app.c     ****   /* Get an initial free buffer and start the camera's NN pipe. */
1495:Src/app.c     ****   nn_pipe_dst = bqueue_get_free(&nn_input_queue, 0);
1496:Src/app.c     ****   assert(nn_pipe_dst);
1497:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
1498:Src/app.c     ****   while (1)
1499:Src/app.c     ****   {
1500:Src/app.c     ****     uint8_t *capture_buffer;
1501:Src/app.c     ****     int idx_for_resize;
1502:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
1503:Src/app.c     ****     nn_period[0] = nn_period[1];
1504:Src/app.c     ****     nn_period[1] = HAL_GetTick();
1505:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
1506:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
1507:Src/app.c     ****     
1508:Src/app.c     ****     /* Block and wait for a new NN frame to be ready from the camera. */
1509:Src/app.c     ****     capture_buffer = bqueue_get_ready(&nn_input_queue);
1510:Src/app.c     ****     assert(capture_buffer);
1511:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
1512:Src/app.c     **** 
1513:Src/app.c     ****     /* --- Core Tracking Logic --- */
1514:Src/app.c     ****     /* If we are NOT currently tracking an object, run the full-frame detector. */
1515:Src/app.c     ****     if (!is_tracking) {
1516:Src/app.c     ****       is_tracking = palm_detector_run(capture_buffer, &pd_info, &pd_ms);
1517:Src/app.c     ****       box_next.prob = pd_info.pd_out.pOutData[0].prob;
1518:Src/app.c     ****     } else {
1519:Src/app.c     ****       rois[0] = roi_next;
1520:Src/app.c     ****       copy_pd_box(&pd_info.pd_out.pOutData[0], &box_next);
1521:Src/app.c     ****       pd_ms = 0;
1522:Src/app.c     ****     }
ARM GAS  /tmp/ccfH4MMM.s 			page 30


1523:Src/app.c     ****     pd_filtered_ms = USE_FILTERED_TS ? (7 * pd_filtered_ms + pd_ms) / 8 : pd_ms;
1524:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
1525:Src/app.c     **** 
1526:Src/app.c     ****     /* then run hand landmark detector if needed */
1527:Src/app.c     ****     if (is_tracking) {
1528:Src/app.c     ****       hl_ms = HAL_GetTick();
1529:Src/app.c     ****       /* Run the landmark model. Note it uses the main display buffer for cropping. */
1530:Src/app.c     ****       is_tracking = hand_landmark_run(lcd_bg_buffer[idx_for_resize], &hl_info, &rois[0], ld_landmar
1531:Src/app.c     ****       /* Invalidate this buffer region as the CPU/GPU may have read from it. */
1532:Src/app.c     ****       CACHE_OP(SCB_InvalidateDCache_by_Addr(lcd_bg_buffer[idx_for_resize], sizeof(lcd_bg_buffer[idx
1533:Src/app.c     **** 
1534:Src/app.c     ****       /* If landmarks were successfully found, predict the ROI for the NEXT frame. */
1535:Src/app.c     ****       if (is_tracking)
1536:Src/app.c     ****         compute_next_roi(&rois[0], ld_landmarks[0], &roi_next, &box_next);
1537:Src/app.c     ****       hl_ms = HAL_GetTick() - hl_ms;
1538:Src/app.c     ****     } else {
1539:Src/app.c     ****       /* If no object is being tracked, skip landmarking. */
1540:Src/app.c     ****       hl_ms = 0;
1541:Src/app.c     ****     }
1542:Src/app.c     ****     ld_filtered_ms = USE_FILTERED_TS ? (7 * ld_filtered_ms + hl_ms) / 8 : hl_ms;
1543:Src/app.c     **** 
1544:Src/app.c     ****     /* update display stats */
1545:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
1546:Src/app.c     ****     assert(ret == pdTRUE);
1547:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms;
1548:Src/app.c     ****     disp.info.hl_ms = is_tracking ? (int)ld_filtered_ms : 0;
1549:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
1550:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking;
1551:Src/app.c     ****     disp.info.pd_max_prob = pd_info.pd_out.pOutData[0].prob;
1552:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
1553:Src/app.c     ****     copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]);
1554:Src/app.c     ****     disp.info.hands[0].roi = rois[0];
1555:Src/app.c     ****     for (j = 0; j < LD_LANDMARK_NB; j++)
1556:Src/app.c     ****       disp.info.hands[0].ld_landmarks[j] = ld_landmarks[0][j];
1557:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1558:Src/app.c     ****     assert(ret == pdTRUE);
1559:Src/app.c     **** 
1560:Src/app.c     ****     /* It's possible xqueue is empty if display is slow. So don't check error code that may by pdFA
1561:Src/app.c     ****     xSemaphoreGive(disp.update);
1562:Src/app.c     ****   }
1563:Src/app.c     **** }
1564:Src/app.c     **** 
1565:Src/app.c     **** static void nn_thread_fct(void *arg)
1566:Src/app.c     **** {
1567:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
1568:Src/app.c     ****   float nn_period_filtered_ms = 0;
1569:Src/app.c     ****   float pd_filtered_ms = 0;
1570:Src/app.c     ****   float ld_filtered_ms = 0;
1571:Src/app.c     **** 
1572:Src/app.c     ****   /* Model-specific info structures. */
1573:Src/app.c     ****   hl_model_info_t hl_info; // Disabled
1574:Src/app.c     ****   // pd_model_info_t pd_info; // Disabled
1575:Src/app.c     ****   yolo_model_info_t yolo_info; // Disabled
1576:Src/app.c     **** 
1577:Src/app.c     ****   /* Timing variables. */
1578:Src/app.c     ****   uint32_t nn_period_ms;
1579:Src/app.c     ****   uint32_t nn_period[2];
ARM GAS  /tmp/ccfH4MMM.s 			page 31


1580:Src/app.c     ****   uint8_t *nn_pipe_dst;
1581:Src/app.c     **** 
1582:Src/app.c     ****   /* Structs for holding tracking information between frames. */
1583:Src/app.c     ****   pd_pp_point_t box_next_keypoints[AI_PD_MODEL_PP_NB_KEYPOINTS];
1584:Src/app.c     ****   pd_pp_box_t box_next;
1585:Src/app.c     ****   // od_pp_out_t boxes_next[YOLO_MAX_NB]; // Unused for now
1586:Src/app.c     **** 
1587:Src/app.c     **** 
1588:Src/app.c     ****   int is_tracking = 0;
1589:Src/app.c     ****   roi_t roi_next;
1590:Src/app.c     ****   uint32_t pd_ms;
1591:Src/app.c     ****   uint32_t hl_ms;
1592:Src/app.c     ****   uint32_t yolo_ms;
1593:Src/app.c     ****   // uint32_t fl_ms; // Unused for now
1594:Src/app.c     ****   int ret;
1595:Src/app.c     ****   int j;
1596:Src/app.c     ****   // int temp = 0; // Unused for now
1597:Src/app.c     **** 
1598:Src/app.c     ****   /* Current tracking algo only support single hand */
1599:Src/app.c     ****   assert(PD_MAX_HAND_NB == 1);
1600:Src/app.c     **** 
1601:Src/app.c     ****   /* setup models buffer info */
1602:Src/app.c     ****   // palm_detector_init(&pd_info); // Disabled
1603:Src/app.c     ****   box_next.pKps = box_next_keypoints;
1604:Src/app.c     ****   // hand_landmark_init(&hl_info); // Disabled
1605:Src/app.c     ****   app_rot_init(&hl_info);       // Disabled
1606:Src/app.c     ****   yolo_detector_init(&yolo_info); // Disabled
1607:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
1608:Src/app.c     ****   nn_period[1] = HAL_GetTick();
1609:Src/app.c     **** 
1610:Src/app.c     ****   /* Get an initial free buffer and start the camera's NN pipe. */
1611:Src/app.c     ****   nn_pipe_dst = bqueue_get_free(&nn_input_queue, 0);
1612:Src/app.c     ****   assert(nn_pipe_dst);
1613:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
1614:Src/app.c     ****   while (1)
1615:Src/app.c     ****   {
1616:Src/app.c     ****     uint8_t *capture_buffer;
1617:Src/app.c     ****     int idx_for_resize;
1618:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
1619:Src/app.c     ****     nn_period[0] = nn_period[1];
1620:Src/app.c     ****     nn_period[1] = HAL_GetTick();
1621:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
1622:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
1623:Src/app.c     ****     
1624:Src/app.c     ****     /* Block and wait for a new NN frame to be ready from the camera. */
1625:Src/app.c     ****     capture_buffer = bqueue_get_ready(&nn_input_queue);
1626:Src/app.c     ****     assert(capture_buffer);
1627:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
1628:Src/app.c     **** 
1629:Src/app.c     ****     /* --- Core Tracking Logic --- */
1630:Src/app.c     ****     /* If we are NOT currently tracking an object, run the full-frame detector. */
1631:Src/app.c     ****     if (!is_tracking) {
1632:Src/app.c     ****       /* --- ALL MODEL CALLS ARE REMOVED FOR THIS TEST --- */
1633:Src/app.c     ****       int nb_faces = yolo_detector_run(capture_buffer, &yolo_info, &yolo_ms);
1634:Src/app.c     ****       
1635:Src/app.c     ****       /* --- Force tracking to be ON and create a dummy box --- */
1636:Src/app.c     ****       is_tracking = 0;
ARM GAS  /tmp/ccfH4MMM.s 			page 32


1637:Src/app.c     ****       pd_ms = 0; // Set dummy timing
1638:Src/app.c     ****     } else {
1639:Src/app.c     ****       rois[0] = roi_next;
1640:Src/app.c     ****       // copy_pd_box(&pd_info.pd_out.pOutData[0], &box_next); // Disabled
1641:Src/app.c     ****       pd_ms = 0;
1642:Src/app.c     ****     }
1643:Src/app.c     ****     pd_filtered_ms = USE_FILTERED_TS ? (7 * pd_filtered_ms + pd_ms) / 8 : pd_ms;
1644:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
1645:Src/app.c     **** 
1646:Src/app.c     ****     /* then run hand landmark detector if needed */
1647:Src/app.c     ****     if (is_tracking) {
1648:Src/app.c     ****       /* --- Hand landmarking is disabled for this test --- */
1649:Src/app.c     ****       hl_ms = 0; // Set to 0 since it's disabled
1650:Src/app.c     ****     } else {
1651:Src/app.c     ****       /* If no object is being tracked, skip landmarking. */
1652:Src/app.c     ****       hl_ms = 0;
1653:Src/app.c     ****     }
1654:Src/app.c     ****     ld_filtered_ms = USE_FILTERED_TS ? (7 * ld_filtered_ms + hl_ms) / 8 : hl_ms;
1655:Src/app.c     **** 
1656:Src/app.c     ****     /* update display stats */
1657:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
1658:Src/app.c     ****     assert(ret == pdTRUE);
1659:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
1660:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
1661:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
1662:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
1663:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
1664:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
1665:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
1666:Src/app.c     ****     if (is_tracking)
1667:Src/app.c     ****     {
1668:Src/app.c     ****       disp.info.hands[0].roi = rois[0]; /* Show the dummy ROI */
1669:Src/app.c     ****     }
1670:Src/app.c     ****     /* Landmark drawing is disabled */
1671:Src/app.c     ****     // for (j = 0; j < LD_LANDMARK_NB; j++)
1672:Src/app.c     ****     //   disp.info.hands[0].ld_landmarks[j] = ld_landmarks[0][j];
1673:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1674:Src/app.c     ****     assert(ret == pdTRUE);
1675:Src/app.c     **** 
1676:Src/app.c     ****     /* It's possible xqueue is empty if display is slow. So don't check error code that may by pdFA
1677:Src/app.c     ****     xSemaphoreGive(disp.update);
1678:Src/app.c     ****   }
1679:Src/app.c     **** }
1680:Src/app.c     **** 
1681:Src/app.c     **** /**
1682:Src/app.c     ****  * @brief Sets the memory address for the foreground layer for the next draw operation.
1683:Src/app.c     ****  * @details Part of a double-buffering scheme for the UI overlay. This function prepares
1684:Src/app.c     ****  * the off-screen buffer for drawing.
1685:Src/app.c     ****  */
1686:Src/app.c     **** static void dp_update_drawing_area()
1687:Src/app.c     **** {
1688:Src/app.c     ****   int ret;
1689:Src/app.c     **** 
1690:Src/app.c     ****   __disable_irq();
1691:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_fg_buffer[lcd_fg_buffer_rd_idx], SCRL_LAYER_1);
1692:Src/app.c     ****   assert(ret == HAL_OK);
1693:Src/app.c     ****   __enable_irq();
ARM GAS  /tmp/ccfH4MMM.s 			page 33


1694:Src/app.c     **** }
1695:Src/app.c     **** 
1696:Src/app.c     **** /**
1697:Src/app.c     ****  * @brief Commits the newly drawn foreground buffer to the display.
1698:Src/app.c     ****  * @details This "flips" the foreground buffers, making the newly drawn UI visible.
1699:Src/app.c     ****  */
1700:Src/app.c     **** static void dp_commit_drawing_area()
1701:Src/app.c     **** {
1702:Src/app.c     ****   int ret;
1703:Src/app.c     **** 
1704:Src/app.c     ****   __disable_irq();
1705:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_1);
1706:Src/app.c     ****   assert(ret == HAL_OK);
1707:Src/app.c     ****   __enable_irq();
1708:Src/app.c     ****   lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
1709:Src/app.c     **** }
1710:Src/app.c     **** 
1711:Src/app.c     **** /**
1712:Src/app.c     ****  * @brief Callback function to toggle the landmark display.
1713:Src/app.c     ****  */
1714:Src/app.c     **** static void on_ld_toggle_button_click(void *args)
1715:Src/app.c     **** {
1716:Src/app.c     ****   display_t *disp = (display_t *) args;
1717:Src/app.c     ****   int ret;
1718:Src/app.c     **** 
1719:Src/app.c     ****   ret = xSemaphoreTake(disp->lock, portMAX_DELAY);
1720:Src/app.c     ****   assert(ret == pdTRUE);
1721:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
1722:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
1723:Src/app.c     ****   assert(ret == pdTRUE);
1724:Src/app.c     **** }
1725:Src/app.c     **** 
1726:Src/app.c     **** /**
1727:Src/app.c     ****  * @brief Callback function to toggle the bounding box display.
1728:Src/app.c     ****  */
1729:Src/app.c     **** static void on_pd_toggle_button_click(void *args)
1730:Src/app.c     **** {
1731:Src/app.c     ****   display_t *disp = (display_t *) args;
1732:Src/app.c     ****   int ret;
1733:Src/app.c     **** 
1734:Src/app.c     ****   ret = xSemaphoreTake(disp->lock, portMAX_DELAY);
1735:Src/app.c     ****   assert(ret == pdTRUE);
1736:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
1737:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
1738:Src/app.c     ****   assert(ret == pdTRUE);
1739:Src/app.c     **** }
1740:Src/app.c     **** 
1741:Src/app.c     **** /**
1742:Src/app.c     ****  * @brief The main function for the Display Processor (DP) thread.
1743:Src/app.c     ****  * @details This task waits for a signal from the NN thread, then wakes up to
1744:Src/app.c     ****  * draw the entire UI overlay for one frame.
1745:Src/app.c     ****  */
1746:Src/app.c     **** static void dp_thread_fct(void *arg)
1747:Src/app.c     **** {
1748:Src/app.c     ****   button_t ld_toggle_button;
1749:Src/app.c     ****   button_t hd_toggle_button;
1750:Src/app.c     ****   uint32_t disp_ms = 0;
ARM GAS  /tmp/ccfH4MMM.s 			page 34


1751:Src/app.c     ****   display_info_t info;
1752:Src/app.c     ****   uint32_t ts;
1753:Src/app.c     ****   int ret;
1754:Src/app.c     **** 
1755:Src/app.c     **** #ifdef STM32N6570_DK_REV
1756:Src/app.c     ****   button_init(&ld_toggle_button, BUTTON_USER1, on_ld_toggle_button_click, &disp);
1757:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_TAMP, on_pd_toggle_button_click, &disp);
1758:Src/app.c     **** #else
1759:Src/app.c     ****   button_init(&ld_toggle_button, BUTTON_USER, on_ld_toggle_button_click, &disp);
1760:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_USER, on_pd_toggle_button_click, &disp);
1761:Src/app.c     **** #endif
1762:Src/app.c     ****   while (1)
1763:Src/app.c     ****   {
1764:Src/app.c     ****     ret = xSemaphoreTake(disp.update, portMAX_DELAY);
1765:Src/app.c     ****     assert(ret == pdTRUE);
1766:Src/app.c     **** 
1767:Src/app.c     ****     button_process(&ld_toggle_button);
1768:Src/app.c     ****     button_process(&hd_toggle_button);
1769:Src/app.c     **** 
1770:Src/app.c     ****     ret = xSemaphoreTake(disp.lock, portMAX_DELAY);
1771:Src/app.c     ****     assert(ret == pdTRUE);
1772:Src/app.c     ****     info = disp.info;
1773:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
1774:Src/app.c     ****     assert(ret == pdTRUE);
1775:Src/app.c     ****     info.disp_ms = disp_ms;
1776:Src/app.c     **** 
1777:Src/app.c     ****     ts = HAL_GetTick();
1778:Src/app.c     ****     dp_update_drawing_area();
1779:Src/app.c     ****     Display_NetworkOutput(&info);
1780:Src/app.c     ****     SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_WIDTH * LCD_FG_HEIGHT* 2);
1781:Src/app.c     ****     dp_commit_drawing_area();
1782:Src/app.c     ****     disp_ms = HAL_GetTick() - ts;
1783:Src/app.c     ****   }
1784:Src/app.c     **** }
1785:Src/app.c     **** 
1786:Src/app.c     **** /**
1787:Src/app.c     ****  * @brief The main function for the Image Signal Processor (ISP) thread.
1788:Src/app.c     ****  * @details This task waits for the VSYNC signal and then runs the camera's
1789:Src/app.c     ****  * periodic processing functions (e.g., auto-exposure, auto-white-balance).
1790:Src/app.c     ****  */
1791:Src/app.c     **** static void isp_thread_fct(void *arg)
1792:Src/app.c     **** {
 125              		.loc 1 1792 1 is_stmt 1 view -0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              		.loc 1 1792 1 is_stmt 0 view .LVU31
 130 0000 10B5     		push	{r4, lr}
 131              		.cfi_def_cfa_offset 8
 132              		.cfi_offset 4, -8
 133              		.cfi_offset 14, -4
1793:Src/app.c     ****   int ret;
1794:Src/app.c     **** 
1795:Src/app.c     ****   while (1) {
1796:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 134              		.loc 1 1796 11 view .LVU32
 135 0002 094C     		ldr	r4, .L11
ARM GAS  /tmp/ccfH4MMM.s 			page 35


 136              	.LVL5:
 137              	.L10:
1793:Src/app.c     ****   int ret;
 138              		.loc 1 1793 3 is_stmt 1 view .LVU33
1795:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 139              		.loc 1 1795 3 view .LVU34
 140              		.loc 1 1796 5 view .LVU35
 141              		.loc 1 1796 11 is_stmt 0 view .LVU36
 142 0004 4FF0FF31 		mov	r1, #-1
 143 0008 2068     		ldr	r0, [r4]
 144 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 145              	.LVL6:
1797:Src/app.c     ****     assert(ret == pdTRUE);
 146              		.loc 1 1797 5 is_stmt 1 view .LVU37
 147 000e 0128     		cmp	r0, #1
 148 0010 06D0     		beq	.L9
 149              		.loc 1 1797 5 is_stmt 0 discriminator 1 view .LVU38
 150 0012 40F20571 		movw	r1, #1797
 151 0016 054B     		ldr	r3, .L11+4
 152 0018 054A     		ldr	r2, .L11+8
 153 001a 0648     		ldr	r0, .L11+12
 154              	.LVL7:
 155              		.loc 1 1797 5 discriminator 1 view .LVU39
 156 001c FFF7FEFF 		bl	__assert_func
 157              	.LVL8:
 158              	.L9:
1798:Src/app.c     **** 
1799:Src/app.c     ****     CAM_IspUpdate();
 159              		.loc 1 1799 5 is_stmt 1 view .LVU40
 160 0020 FFF7FEFF 		bl	CAM_IspUpdate
 161              	.LVL9:
1795:Src/app.c     ****     ret = xSemaphoreTake(isp_sem, portMAX_DELAY);
 162              		.loc 1 1795 9 view .LVU41
1796:Src/app.c     ****     assert(ret == pdTRUE);
 163              		.loc 1 1796 9 is_stmt 0 view .LVU42
 164 0024 EEE7     		b	.L10
 165              	.L12:
 166 0026 00BF     		.align	2
 167              	.L11:
 168 0028 00000000 		.word	isp_sem
 169 002c 00000000 		.word	.LC1
 170 0030 00000000 		.word	__func__.17
 171 0034 0E000000 		.word	.LC2
 172              		.cfi_endproc
 173              	.LFE7411:
 175              		.section	.text.on_pd_toggle_button_click,"ax",%progbits
 176              		.align	1
 177              		.syntax unified
 178              		.thumb
 179              		.thumb_func
 181              	on_pd_toggle_button_click:
 182              	.LVL10:
 183              	.LFB7409:
1730:Src/app.c     ****   display_t *disp = (display_t *) args;
 184              		.loc 1 1730 1 is_stmt 1 view -0
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccfH4MMM.s 			page 36


 187              		@ frame_needed = 0, uses_anonymous_args = 0
1731:Src/app.c     ****   int ret;
 188              		.loc 1 1731 3 view .LVU44
1732:Src/app.c     **** 
 189              		.loc 1 1732 3 view .LVU45
1734:Src/app.c     ****   assert(ret == pdTRUE);
 190              		.loc 1 1734 3 view .LVU46
1730:Src/app.c     ****   display_t *disp = (display_t *) args;
 191              		.loc 1 1730 1 is_stmt 0 view .LVU47
 192 0000 10B5     		push	{r4, lr}
 193              		.cfi_def_cfa_offset 8
 194              		.cfi_offset 4, -8
 195              		.cfi_offset 14, -4
1734:Src/app.c     ****   assert(ret == pdTRUE);
 196              		.loc 1 1734 9 view .LVU48
 197 0002 4FF0FF31 		mov	r1, #-1
1730:Src/app.c     ****   display_t *disp = (display_t *) args;
 198              		.loc 1 1730 1 view .LVU49
 199 0006 0446     		mov	r4, r0
1734:Src/app.c     ****   assert(ret == pdTRUE);
 200              		.loc 1 1734 9 view .LVU50
 201 0008 406D     		ldr	r0, [r0, #84]
 202              	.LVL11:
1734:Src/app.c     ****   assert(ret == pdTRUE);
 203              		.loc 1 1734 9 view .LVU51
 204 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 205              	.LVL12:
1735:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
 206              		.loc 1 1735 3 is_stmt 1 view .LVU52
 207 000e 0128     		cmp	r0, #1
 208 0010 06D0     		beq	.L14
1735:Src/app.c     ****   disp->info.is_pd_displayed = !disp->info.is_pd_displayed;
 209              		.loc 1 1735 3 is_stmt 0 discriminator 1 view .LVU53
 210 0012 40F2C761 		movw	r1, #1735
 211 0016 0D4B     		ldr	r3, .L17
 212 0018 0D4A     		ldr	r2, .L17+4
 213              	.L16:
1738:Src/app.c     **** }
 214              		.loc 1 1738 3 discriminator 1 view .LVU54
 215 001a 0E48     		ldr	r0, .L17+8
 216              	.LVL13:
1738:Src/app.c     **** }
 217              		.loc 1 1738 3 discriminator 1 view .LVU55
 218 001c FFF7FEFF 		bl	__assert_func
 219              	.LVL14:
 220              	.L14:
1736:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 221              		.loc 1 1736 3 is_stmt 1 view .LVU56
1736:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 222              		.loc 1 1736 32 is_stmt 0 view .LVU57
 223 0020 D4F8C430 		ldr	r3, [r4, #196]
1737:Src/app.c     ****   assert(ret == pdTRUE);
 224              		.loc 1 1737 9 view .LVU58
 225 0024 606D     		ldr	r0, [r4, #84]
 226              	.LVL15:
1736:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 227              		.loc 1 1736 32 view .LVU59
ARM GAS  /tmp/ccfH4MMM.s 			page 37


 228 0026 B3FA83F3 		clz	r3, r3
 229 002a 5B09     		lsrs	r3, r3, #5
1736:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 230              		.loc 1 1736 30 view .LVU60
 231 002c C4F8C430 		str	r3, [r4, #196]
1737:Src/app.c     ****   assert(ret == pdTRUE);
 232              		.loc 1 1737 3 is_stmt 1 view .LVU61
1737:Src/app.c     ****   assert(ret == pdTRUE);
 233              		.loc 1 1737 9 is_stmt 0 view .LVU62
 234 0030 0023     		movs	r3, #0
 235 0032 1A46     		mov	r2, r3
 236 0034 1946     		mov	r1, r3
 237 0036 FFF7FEFF 		bl	xQueueGenericSend
 238              	.LVL16:
1738:Src/app.c     **** }
 239              		.loc 1 1738 3 is_stmt 1 view .LVU63
 240 003a 0128     		cmp	r0, #1
 241 003c 04D0     		beq	.L13
1738:Src/app.c     **** }
 242              		.loc 1 1738 3 is_stmt 0 discriminator 1 view .LVU64
 243 003e 40F2CA61 		movw	r1, #1738
 244 0042 024B     		ldr	r3, .L17
 245 0044 024A     		ldr	r2, .L17+4
 246 0046 E8E7     		b	.L16
 247              	.L13:
1739:Src/app.c     **** 
 248              		.loc 1 1739 1 view .LVU65
 249 0048 10BD     		pop	{r4, pc}
 250              	.LVL17:
 251              	.L18:
1739:Src/app.c     **** 
 252              		.loc 1 1739 1 view .LVU66
 253 004a 00BF     		.align	2
 254              	.L17:
 255 004c 00000000 		.word	.LC1
 256 0050 00000000 		.word	__func__.15
 257 0054 0E000000 		.word	.LC2
 258              		.cfi_endproc
 259              	.LFE7409:
 261              		.section	.text.on_ld_toggle_button_click,"ax",%progbits
 262              		.align	1
 263              		.syntax unified
 264              		.thumb
 265              		.thumb_func
 267              	on_ld_toggle_button_click:
 268              	.LVL18:
 269              	.LFB7408:
1715:Src/app.c     ****   display_t *disp = (display_t *) args;
 270              		.loc 1 1715 1 is_stmt 1 view -0
 271              		.cfi_startproc
 272              		@ args = 0, pretend = 0, frame = 0
 273              		@ frame_needed = 0, uses_anonymous_args = 0
1716:Src/app.c     ****   int ret;
 274              		.loc 1 1716 3 view .LVU68
1717:Src/app.c     **** 
 275              		.loc 1 1717 3 view .LVU69
1719:Src/app.c     ****   assert(ret == pdTRUE);
ARM GAS  /tmp/ccfH4MMM.s 			page 38


 276              		.loc 1 1719 3 view .LVU70
1715:Src/app.c     ****   display_t *disp = (display_t *) args;
 277              		.loc 1 1715 1 is_stmt 0 view .LVU71
 278 0000 10B5     		push	{r4, lr}
 279              		.cfi_def_cfa_offset 8
 280              		.cfi_offset 4, -8
 281              		.cfi_offset 14, -4
1719:Src/app.c     ****   assert(ret == pdTRUE);
 282              		.loc 1 1719 9 view .LVU72
 283 0002 4FF0FF31 		mov	r1, #-1
1715:Src/app.c     ****   display_t *disp = (display_t *) args;
 284              		.loc 1 1715 1 view .LVU73
 285 0006 0446     		mov	r4, r0
1719:Src/app.c     ****   assert(ret == pdTRUE);
 286              		.loc 1 1719 9 view .LVU74
 287 0008 406D     		ldr	r0, [r0, #84]
 288              	.LVL19:
1719:Src/app.c     ****   assert(ret == pdTRUE);
 289              		.loc 1 1719 9 view .LVU75
 290 000a FFF7FEFF 		bl	xQueueSemaphoreTake
 291              	.LVL20:
1720:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
 292              		.loc 1 1720 3 is_stmt 1 view .LVU76
 293 000e 0128     		cmp	r0, #1
 294 0010 06D0     		beq	.L20
1720:Src/app.c     ****   disp->info.is_ld_displayed = !disp->info.is_ld_displayed;
 295              		.loc 1 1720 3 is_stmt 0 discriminator 1 view .LVU77
 296 0012 4FF4D761 		mov	r1, #1720
 297 0016 0D4B     		ldr	r3, .L23
 298 0018 0D4A     		ldr	r2, .L23+4
 299              	.L22:
1723:Src/app.c     **** }
 300              		.loc 1 1723 3 discriminator 1 view .LVU78
 301 001a 0E48     		ldr	r0, .L23+8
 302              	.LVL21:
1723:Src/app.c     **** }
 303              		.loc 1 1723 3 discriminator 1 view .LVU79
 304 001c FFF7FEFF 		bl	__assert_func
 305              	.LVL22:
 306              	.L20:
1721:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 307              		.loc 1 1721 3 is_stmt 1 view .LVU80
1721:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 308              		.loc 1 1721 32 is_stmt 0 view .LVU81
 309 0020 D4F8C030 		ldr	r3, [r4, #192]
1722:Src/app.c     ****   assert(ret == pdTRUE);
 310              		.loc 1 1722 9 view .LVU82
 311 0024 606D     		ldr	r0, [r4, #84]
 312              	.LVL23:
1721:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 313              		.loc 1 1721 32 view .LVU83
 314 0026 B3FA83F3 		clz	r3, r3
 315 002a 5B09     		lsrs	r3, r3, #5
1721:Src/app.c     ****   ret = xSemaphoreGive(disp->lock);
 316              		.loc 1 1721 30 view .LVU84
 317 002c C4F8C030 		str	r3, [r4, #192]
1722:Src/app.c     ****   assert(ret == pdTRUE);
ARM GAS  /tmp/ccfH4MMM.s 			page 39


 318              		.loc 1 1722 3 is_stmt 1 view .LVU85
1722:Src/app.c     ****   assert(ret == pdTRUE);
 319              		.loc 1 1722 9 is_stmt 0 view .LVU86
 320 0030 0023     		movs	r3, #0
 321 0032 1A46     		mov	r2, r3
 322 0034 1946     		mov	r1, r3
 323 0036 FFF7FEFF 		bl	xQueueGenericSend
 324              	.LVL24:
1723:Src/app.c     **** }
 325              		.loc 1 1723 3 is_stmt 1 view .LVU87
 326 003a 0128     		cmp	r0, #1
 327 003c 04D0     		beq	.L19
1723:Src/app.c     **** }
 328              		.loc 1 1723 3 is_stmt 0 discriminator 1 view .LVU88
 329 003e 40F2BB61 		movw	r1, #1723
 330 0042 024B     		ldr	r3, .L23
 331 0044 024A     		ldr	r2, .L23+4
 332 0046 E8E7     		b	.L22
 333              	.L19:
1724:Src/app.c     **** 
 334              		.loc 1 1724 1 view .LVU89
 335 0048 10BD     		pop	{r4, pc}
 336              	.LVL25:
 337              	.L24:
1724:Src/app.c     **** 
 338              		.loc 1 1724 1 view .LVU90
 339 004a 00BF     		.align	2
 340              	.L23:
 341 004c 00000000 		.word	.LC1
 342 0050 00000000 		.word	__func__.14
 343 0054 0E000000 		.word	.LC2
 344              		.cfi_endproc
 345              	.LFE7408:
 347              		.section	.text.button_process,"ax",%progbits
 348              		.align	1
 349              		.syntax unified
 350              		.thumb
 351              		.thumb_func
 353              	button_process:
 354              	.LVL26:
 355              	.LFB7367:
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 356              		.loc 1 506 1 is_stmt 1 view -0
 357              		.cfi_startproc
 358              		@ args = 0, pretend = 0, frame = 0
 359              		@ frame_needed = 0, uses_anonymous_args = 0
 507:Src/app.c     **** 
 360              		.loc 1 507 3 view .LVU92
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
 361              		.loc 1 506 1 is_stmt 0 view .LVU93
 362 0000 38B5     		push	{r3, r4, r5, lr}
 363              		.cfi_def_cfa_offset 16
 364              		.cfi_offset 3, -16
 365              		.cfi_offset 4, -12
 366              		.cfi_offset 5, -8
 367              		.cfi_offset 14, -4
 506:Src/app.c     ****   int state = BSP_PB_GetState(b->button_id);
ARM GAS  /tmp/ccfH4MMM.s 			page 40


 368              		.loc 1 506 1 view .LVU94
 369 0002 0446     		mov	r4, r0
 507:Src/app.c     **** 
 370              		.loc 1 507 15 view .LVU95
 371 0004 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 372              	.LVL27:
 507:Src/app.c     **** 
 373              		.loc 1 507 15 view .LVU96
 374 0006 FFF7FEFF 		bl	BSP_PB_GetState
 375              	.LVL28:
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 376              		.loc 1 509 6 view .LVU97
 377 000a 6368     		ldr	r3, [r4, #4]
 507:Src/app.c     **** 
 378              		.loc 1 507 15 view .LVU98
 379 000c 0546     		mov	r5, r0
 380              	.LVL29:
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 381              		.loc 1 509 3 is_stmt 1 view .LVU99
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 382              		.loc 1 509 6 is_stmt 0 view .LVU100
 383 000e 8342     		cmp	r3, r0
 384 0010 04D0     		beq	.L26
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 385              		.loc 1 509 30 discriminator 1 view .LVU101
 386 0012 18B1     		cbz	r0, .L26
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 387              		.loc 1 509 43 discriminator 2 view .LVU102
 388 0014 A368     		ldr	r3, [r4, #8]
 509:Src/app.c     ****     b->on_click_handler(b->cb_args);
 389              		.loc 1 509 39 discriminator 2 view .LVU103
 390 0016 0BB1     		cbz	r3, .L26
 510:Src/app.c     **** 
 391              		.loc 1 510 5 is_stmt 1 view .LVU104
 392 0018 E068     		ldr	r0, [r4, #12]
 393              	.LVL30:
 510:Src/app.c     **** 
 394              		.loc 1 510 5 is_stmt 0 view .LVU105
 395 001a 9847     		blx	r3
 396              	.LVL31:
 397              	.L26:
 512:Src/app.c     **** }
 398              		.loc 1 512 3 is_stmt 1 view .LVU106
 512:Src/app.c     **** }
 399              		.loc 1 512 17 is_stmt 0 view .LVU107
 400 001c 6560     		str	r5, [r4, #4]
 513:Src/app.c     **** 
 401              		.loc 1 513 1 view .LVU108
 402 001e 38BD     		pop	{r3, r4, r5, pc}
 513:Src/app.c     **** 
 403              		.loc 1 513 1 view .LVU109
 404              		.cfi_endproc
 405              	.LFE7367:
 407              		.section	.rodata.button_init.part.0.str1.1,"aMS",%progbits,1
 408              	.LC3:
 409 0000 72657420 		.ascii	"ret == BSP_ERROR_NONE\000"
 409      3D3D2042 
ARM GAS  /tmp/ccfH4MMM.s 			page 41


 409      53505F45 
 409      52524F52 
 409      5F4E4F4E 
 410              		.section	.text.button_init.part.0,"ax",%progbits
 411              		.align	1
 412              		.syntax unified
 413              		.thumb
 414              		.thumb_func
 416              	button_init.part.0:
 417              	.LFB7416:
 488:Src/app.c     **** {
 418              		.loc 1 488 13 is_stmt 1 view -0
 419              		.cfi_startproc
 420              		@ Volatile: function does not return.
 421              		@ args = 0, pretend = 0, frame = 0
 422              		@ frame_needed = 0, uses_anonymous_args = 0
 423              	.LVL32:
 488:Src/app.c     **** {
 424              		.loc 1 488 13 is_stmt 0 view .LVU111
 425 0000 08B5     		push	{r3, lr}
 426              		.cfi_def_cfa_offset 8
 427              		.cfi_offset 3, -8
 428              		.cfi_offset 14, -4
 493:Src/app.c     **** 
 429              		.loc 1 493 3 discriminator 1 view .LVU112
 430 0002 40F2ED11 		movw	r1, #493
 431 0006 024B     		ldr	r3, .L34
 432 0008 024A     		ldr	r2, .L34+4
 433 000a 0348     		ldr	r0, .L34+8
 434 000c FFF7FEFF 		bl	__assert_func
 435              	.LVL33:
 436              	.L35:
 437              		.align	2
 438              	.L34:
 439 0010 00000000 		.word	.LC3
 440 0014 00000000 		.word	__func__.13
 441 0018 0E000000 		.word	.LC2
 442              		.cfi_endproc
 443              	.LFE7416:
 445              		.section	.text.display_ld_hand,"ax",%progbits
 446              		.align	1
 447              		.syntax unified
 448              		.thumb
 449              		.thumb_func
 451              	display_ld_hand:
 452              	.LVL34:
 453              	.LFB7388:
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 454              		.loc 1 926 1 is_stmt 1 view -0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 256
 457              		@ frame_needed = 0, uses_anonymous_args = 0
 927:Src/app.c     ****   roi_t *roi = &hand->roi;
 458              		.loc 1 927 3 view .LVU114
 928:Src/app.c     ****   int x[LD_LANDMARK_NB];
 459              		.loc 1 928 3 view .LVU115
 929:Src/app.c     ****   int y[LD_LANDMARK_NB];
ARM GAS  /tmp/ccfH4MMM.s 			page 42


 460              		.loc 1 929 3 view .LVU116
 930:Src/app.c     ****   int is_clamped[LD_LANDMARK_NB];
 461              		.loc 1 930 3 view .LVU117
 931:Src/app.c     ****   ld_point_t decoded;
 462              		.loc 1 931 3 view .LVU118
 932:Src/app.c     ****   int i;
 463              		.loc 1 932 3 view .LVU119
 933:Src/app.c     **** 
 464              		.loc 1 933 3 view .LVU120
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 465              		.loc 1 935 3 view .LVU121
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 466              		.loc 1 935 17 discriminator 1 view .LVU122
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 467              		.loc 1 926 1 is_stmt 0 view .LVU123
 468 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 469              		.cfi_def_cfa_offset 36
 470              		.cfi_offset 4, -36
 471              		.cfi_offset 5, -32
 472              		.cfi_offset 6, -28
 473              		.cfi_offset 7, -24
 474              		.cfi_offset 8, -20
 475              		.cfi_offset 9, -16
 476              		.cfi_offset 10, -12
 477              		.cfi_offset 11, -8
 478              		.cfi_offset 14, -4
 479 0004 2DED0A8B 		vpush.64	{d8, d9, d10, d11, d12}
 480              		.cfi_def_cfa_offset 76
 481              		.cfi_offset 80, -76
 482              		.cfi_offset 81, -72
 483              		.cfi_offset 82, -68
 484              		.cfi_offset 83, -64
 485              		.cfi_offset 84, -60
 486              		.cfi_offset 85, -56
 487              		.cfi_offset 86, -52
 488              		.cfi_offset 87, -48
 489              		.cfi_offset 88, -44
 490              		.cfi_offset 89, -40
 491              	.LBB114:
 492              	.LBB115:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 493              		.loc 1 918 46 view .LVU124
 494 0008 90ED0BCA 		vldr.32	s24, [r0, #44]
 495 000c B7EECCCA 		vcvt.f64.f32	d12, s24
 496              	.LBE115:
 497              	.LBE114:
 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 498              		.loc 1 926 1 view .LVU125
 499 0010 C3B0     		sub	sp, sp, #268
 500              		.cfi_def_cfa_offset 344
 501              	.LBB120:
 502              	.LBB116:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 503              		.loc 1 918 46 view .LVU126
 504 0012 B0EE4C0B 		vmov.f64	d0, d12
 505              	.LBE116:
 506              	.LBE120:
ARM GAS  /tmp/ccfH4MMM.s 			page 43


 926:Src/app.c     ****   const int disk_radius = DISK_RADIUS;
 507              		.loc 1 926 1 view .LVU127
 508 0016 0446     		mov	r4, r0
 509              	.LBB121:
 510              	.LBB117:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 511              		.loc 1 918 19 view .LVU128
 512 0018 90ED07AA 		vldr.32	s20, [r0, #28]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 513              		.loc 1 918 40 view .LVU129
 514 001c 90ED09BA 		vldr.32	s22, [r0, #36]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 515              		.loc 1 918 46 view .LVU130
 516 0020 FFF7FEFF 		bl	cos
 517              	.LVL35:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 518              		.loc 1 918 46 view .LVU131
 519 0024 B0EE408B 		vmov.f64	d8, d0
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 520              		.loc 1 918 82 discriminator 1 view .LVU132
 521 0028 B0EE4C0B 		vmov.f64	d0, d12
 522 002c FFF7FEFF 		bl	sin
 523              	.LVL36:
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 524              		.loc 1 918 76 discriminator 1 view .LVU133
 525 0030 94ED0A9A 		vldr.32	s18, [r4, #40]
 919:Src/app.c     **** }
 526              		.loc 1 919 19 view .LVU134
 527 0034 94ED086A 		vldr.32	s12, [r4, #32]
 528 0038 2DAD     		add	r5, sp, #180
 529 003a 18A8     		add	r0, sp, #96
 530 003c 0DF10C0C 		add	ip, sp, #12
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 531              		.loc 1 918 19 view .LVU135
 532 0040 B7EECAAA 		vcvt.f64.f32	d10, s20
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 533              		.loc 1 918 40 view .LVU136
 534 0044 B7EECBBA 		vcvt.f64.f32	d11, s22
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 535              		.loc 1 918 76 discriminator 1 view .LVU137
 536 0048 B7EEC99A 		vcvt.f64.f32	d9, s18
 919:Src/app.c     **** }
 537              		.loc 1 919 19 view .LVU138
 538 004c B7EEC66A 		vcvt.f64.f32	d6, s12
 539 0050 AE46     		mov	lr, r5
 540 0052 0646     		mov	r6, r0
 541 0054 6746     		mov	r7, ip
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 542              		.loc 1 918 33 view .LVU139
 543 0056 B6EE005B 		vmov.f64	d5, #5.0e-1
 544              	.LBE117:
 545              	.LBE121:
 546              	.LBB122:
 547              	.LBB123:
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 548              		.loc 1 780 6 view .LVU140
 549 005a 40F21D39 		movw	r9, #797
ARM GAS  /tmp/ccfH4MMM.s 			page 44


 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 550              		.loc 1 782 6 view .LVU141
 551 005e 40F2DD18 		movw	r8, #477
 785:Src/app.c     **** }
 552              		.loc 1 785 21 discriminator 3 view .LVU142
 553 0062 1521     		movs	r1, #21
 554              	.LVL37:
 555              	.L38:
 785:Src/app.c     **** }
 556              		.loc 1 785 21 discriminator 3 view .LVU143
 557              	.LBE123:
 558              	.LBE122:
 936:Src/app.c     ****     x[i] = (int)decoded.x;
 559              		.loc 1 936 5 is_stmt 1 view .LVU144
 560              	.LBB128:
 561              	.LBI114:
 912:Src/app.c     **** {
 562              		.loc 1 912 13 view .LVU145
 563              	.LBB118:
 914:Src/app.c     ****   float w = roi->w;
 564              		.loc 1 914 3 view .LVU146
 915:Src/app.c     ****   float h = roi->h;
 565              		.loc 1 915 3 view .LVU147
 916:Src/app.c     **** 
 566              		.loc 1 916 3 view .LVU148
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 567              		.loc 1 918 3 view .LVU149
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 568              		.loc 1 918 29 is_stmt 0 view .LVU150
 569 0064 94ED0C3A 		vldr.32	s6, [r4, #48]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 570              		.loc 1 918 65 discriminator 1 view .LVU151
 571 0068 94ED0D4A 		vldr.32	s8, [r4, #52]
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 572              		.loc 1 918 29 view .LVU152
 573 006c B7EEC33A 		vcvt.f64.f32	d3, s6
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 574              		.loc 1 918 65 discriminator 1 view .LVU153
 575 0070 B7EEC44A 		vcvt.f64.f32	d4, s8
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 576              		.loc 1 918 33 view .LVU154
 577 0074 33EE453B 		vsub.f64	d3, d3, d5
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 578              		.loc 1 918 24 discriminator 1 view .LVU155
 579 0078 B0EE4A7B 		vmov.f64	d7, d10
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 580              		.loc 1 918 40 view .LVU156
 581 007c 23EE0B3B 		vmul.f64	d3, d3, d11
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 582              		.loc 1 918 69 discriminator 1 view .LVU157
 583 0080 34EE454B 		vsub.f64	d4, d4, d5
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 584              		.loc 1 918 24 discriminator 1 view .LVU158
 585 0084 A3EE087B 		vfma.f64	d7, d3, d8
 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 586              		.loc 1 918 76 discriminator 1 view .LVU159
 587 0088 24EE094B 		vmul.f64	d4, d4, d9
ARM GAS  /tmp/ccfH4MMM.s 			page 45


 918:Src/app.c     ****   decoded->y = roi->cy + (lm->x - 0.5) * w * sin(rotation) + (lm->y - 0.5) * h * cos(rotation);
 588              		.loc 1 918 60 discriminator 2 view .LVU160
 589 008c A4EE407B 		vfms.f64	d7, d4, d0
 590 0090 F7EEC72B 		vcvt.f32.f64	s5, d7
 919:Src/app.c     **** }
 591              		.loc 1 919 3 is_stmt 1 view .LVU161
 919:Src/app.c     **** }
 592              		.loc 1 919 24 is_stmt 0 discriminator 1 view .LVU162
 593 0094 B0EE467B 		vmov.f64	d7, d6
 594 0098 A3EE007B 		vfma.f64	d7, d3, d0
 919:Src/app.c     **** }
 595              		.loc 1 919 60 discriminator 2 view .LVU163
 596 009c A8EE047B 		vfma.f64	d7, d8, d4
 597              	.LVL38:
 919:Src/app.c     **** }
 598              		.loc 1 919 60 discriminator 2 view .LVU164
 599              	.LBE118:
 600              	.LBE128:
 937:Src/app.c     ****     y[i] = (int)decoded.y;
 601              		.loc 1 937 5 is_stmt 1 view .LVU165
 937:Src/app.c     ****     y[i] = (int)decoded.y;
 602              		.loc 1 937 12 is_stmt 0 view .LVU166
 603 00a0 FDEEE24A 		vcvt.s32.f32	s9, s5
 604 00a4 14EE90AA 		vmov	r10, s9	@ int
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 605              		.loc 1 938 5 is_stmt 1 view .LVU167
 606              	.LBB129:
 607              	.LBB119:
 919:Src/app.c     **** }
 608              		.loc 1 919 60 is_stmt 0 discriminator 2 view .LVU168
 609 00a8 B7EEC77B 		vcvt.f32.f64	s14, d7
 610              	.LBE119:
 611              	.LBE129:
 612              	.LBB130:
 613              	.LBB124:
 776:Src/app.c     ****     *x = margin;
 614              		.loc 1 776 6 view .LVU169
 615 00ac 5246     		mov	r2, r10
 616              	.LBE124:
 617              	.LBE130:
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 618              		.loc 1 938 12 view .LVU170
 619 00ae FDEEC77A 		vcvt.s32.f32	s15, s14
 620              	.LBB131:
 621              	.LBB125:
 776:Src/app.c     ****     *x = margin;
 622              		.loc 1 776 6 view .LVU171
 623 00b2 022A     		cmp	r2, #2
 624 00b4 B8BF     		it	lt
 625 00b6 0222     		movlt	r2, #2
 626              	.LBE125:
 627              	.LBE131:
 938:Src/app.c     ****     is_clamped[i] = clamp_point_with_margin(&x[i], &y[i], disk_radius);
 628              		.loc 1 938 12 view .LVU172
 629 00b8 17EE903A 		vmov	r3, s15	@ int
 939:Src/app.c     ****   }
 630              		.loc 1 939 5 is_stmt 1 view .LVU173
ARM GAS  /tmp/ccfH4MMM.s 			page 46


 631              	.LVL39:
 632              	.LBB132:
 633              	.LBI122:
 771:Src/app.c     **** {
 634              		.loc 1 771 12 view .LVU174
 635              	.LBB126:
 773:Src/app.c     ****   int yi = *y;
 636              		.loc 1 773 3 view .LVU175
 774:Src/app.c     **** 
 637              		.loc 1 774 3 view .LVU176
 776:Src/app.c     ****     *x = margin;
 638              		.loc 1 776 3 view .LVU177
 778:Src/app.c     ****     *y = margin;
 639              		.loc 1 778 3 view .LVU178
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 640              		.loc 1 780 3 view .LVU179
 780:Src/app.c     ****     *x = lcd_bg_area.XSize - margin - 1;
 641              		.loc 1 780 6 is_stmt 0 view .LVU180
 642 00bc 4A45     		cmp	r2, r9
 643 00be A8BF     		it	ge
 644 00c0 4A46     		movge	r2, r9
 778:Src/app.c     ****     *y = margin;
 645              		.loc 1 778 6 view .LVU181
 646 00c2 022B     		cmp	r3, #2
 647 00c4 9B46     		mov	fp, r3
 648 00c6 B8BF     		it	lt
 649 00c8 4FF0020B 		movlt	fp, #2
 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 650              		.loc 1 782 6 view .LVU182
 651 00cc C345     		cmp	fp, r8
 652 00ce A8BF     		it	ge
 653 00d0 C346     		movge	fp, r8
 785:Src/app.c     **** }
 654              		.loc 1 785 21 discriminator 2 view .LVU183
 655 00d2 B3EB0B03 		subs	r3, r3, fp
 656              	.LVL40:
 785:Src/app.c     **** }
 657              		.loc 1 785 21 discriminator 2 view .LVU184
 658 00d6 18BF     		it	ne
 659 00d8 0123     		movne	r3, #1
 660 00da 9245     		cmp	r10, r2
 661 00dc 18BF     		it	ne
 662 00de 0123     		movne	r3, #1
 663              	.LBE126:
 664              	.LBE132:
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 665              		.loc 1 935 17 discriminator 1 view .LVU185
 666 00e0 0139     		subs	r1, r1, #1
 667 00e2 4CF8042B 		str	r2, [ip], #4
 668              	.LBB133:
 669              	.LBB127:
 782:Src/app.c     ****     *y = lcd_bg_area.YSize - margin - 1;
 670              		.loc 1 782 3 is_stmt 1 view .LVU186
 671 00e6 40F804BB 		str	fp, [r0], #4
 785:Src/app.c     **** }
 672              		.loc 1 785 3 view .LVU187
 673              	.LVL41:
ARM GAS  /tmp/ccfH4MMM.s 			page 47


 785:Src/app.c     **** }
 674              		.loc 1 785 3 is_stmt 0 view .LVU188
 675              	.LBE127:
 676              	.LBE133:
 939:Src/app.c     ****   }
 677              		.loc 1 939 19 discriminator 1 view .LVU189
 678 00ea 4EF8043B 		str	r3, [lr], #4
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 679              		.loc 1 935 36 is_stmt 1 discriminator 3 view .LVU190
 935:Src/app.c     ****     decode_ld_landmark(roi, &hand->ld_landmarks[i], &decoded);
 680              		.loc 1 935 17 discriminator 1 view .LVU191
 681 00ee 04F10804 		add	r4, r4, #8
 682 00f2 B7D1     		bne	.L38
 942:Src/app.c     ****     if (is_clamped[i])
 683              		.loc 1 942 10 is_stmt 0 view .LVU192
 684 00f4 0024     		movs	r4, #0
 685              	.L40:
 686              	.LVL42:
 943:Src/app.c     ****       continue;
 687              		.loc 1 943 5 is_stmt 1 view .LVU193
 943:Src/app.c     ****       continue;
 688              		.loc 1 943 19 is_stmt 0 view .LVU194
 689 00f6 55F8043B 		ldr	r3, [r5], #4
 943:Src/app.c     ****       continue;
 690              		.loc 1 943 8 view .LVU195
 691 00fa 43B9     		cbnz	r3, .L39
 945:Src/app.c     ****   }
 692              		.loc 1 945 5 is_stmt 1 view .LVU196
 693 00fc 6FF0FF03 		mvn	r3, #255
 694 0100 0222     		movs	r2, #2
 695 0102 56F82410 		ldr	r1, [r6, r4, lsl #2]
 696 0106 57F82400 		ldr	r0, [r7, r4, lsl #2]
 697 010a FFF7FEFF 		bl	UTIL_LCD_FillCircle
 698              	.LVL43:
 699              	.L39:
 942:Src/app.c     ****     if (is_clamped[i])
 700              		.loc 1 942 36 discriminator 2 view .LVU197
 701 010e 0134     		adds	r4, r4, #1
 702              	.LVL44:
 942:Src/app.c     ****     if (is_clamped[i])
 703              		.loc 1 942 17 discriminator 1 view .LVU198
 704 0110 152C     		cmp	r4, #21
 705 0112 F0D1     		bne	.L40
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 706              		.loc 1 948 10 is_stmt 0 view .LVU199
 707 0114 0025     		movs	r5, #0
 951:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
 708              		.loc 1 951 5 view .LVU200
 709 0116 4FF07F46 		mov	r6, #-16777216
 710 011a 124C     		ldr	r4, .L47
 711              	.LVL45:
 712              	.L42:
 949:Src/app.c     ****       continue;
 713              		.loc 1 949 5 is_stmt 1 view .LVU201
 949:Src/app.c     ****       continue;
 714              		.loc 1 949 38 is_stmt 0 view .LVU202
 715 011c 2068     		ldr	r0, [r4]
ARM GAS  /tmp/ccfH4MMM.s 			page 48


 949:Src/app.c     ****       continue;
 716              		.loc 1 949 19 view .LVU203
 717 011e 42AB     		add	r3, sp, #264
 718 0120 03EB8000 		add	r0, r3, r0, lsl #2
 949:Src/app.c     ****       continue;
 719              		.loc 1 949 8 view .LVU204
 720 0124 50F8543C 		ldr	r3, [r0, #-84]
 721 0128 8BB9     		cbnz	r3, .L41
 949:Src/app.c     ****       continue;
 722              		.loc 1 949 75 discriminator 2 view .LVU205
 723 012a 6268     		ldr	r2, [r4, #4]
 949:Src/app.c     ****       continue;
 724              		.loc 1 949 56 discriminator 2 view .LVU206
 725 012c 42AB     		add	r3, sp, #264
 726 012e 03EB8202 		add	r2, r3, r2, lsl #2
 949:Src/app.c     ****       continue;
 727              		.loc 1 949 43 discriminator 2 view .LVU207
 728 0132 52F8543C 		ldr	r3, [r2, #-84]
 729 0136 53B9     		cbnz	r3, .L41
 951:Src/app.c     ****                       x[ld_bindings_idx[i][1]], y[ld_bindings_idx[i][1]],
 730              		.loc 1 951 5 is_stmt 1 view .LVU208
 731 0138 0096     		str	r6, [sp]
 732 013a 52F8A83C 		ldr	r3, [r2, #-168]
 733 013e 50F8A81C 		ldr	r1, [r0, #-168]
 734 0142 52F8FC2C 		ldr	r2, [r2, #-252]
 735 0146 50F8FC0C 		ldr	r0, [r0, #-252]
 736 014a FFF7FEFF 		bl	UTIL_LCD_DrawLine
 737              	.LVL46:
 738              	.L41:
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 739              		.loc 1 948 35 discriminator 2 view .LVU209
 740 014e 0135     		adds	r5, r5, #1
 741              	.LVL47:
 948:Src/app.c     ****     if (is_clamped[ld_bindings_idx[i][0]] || is_clamped[ld_bindings_idx[i][1]])
 742              		.loc 1 948 17 discriminator 1 view .LVU210
 743 0150 152D     		cmp	r5, #21
 744 0152 04F10804 		add	r4, r4, #8
 745 0156 E1D1     		bne	.L42
 955:Src/app.c     **** 
 746              		.loc 1 955 1 is_stmt 0 view .LVU211
 747 0158 43B0     		add	sp, sp, #268
 748              		.cfi_def_cfa_offset 76
 749              		@ sp needed
 750 015a BDEC0A8B 		vldm	sp!, {d8-d12}
 751              		.cfi_restore 88
 752              		.cfi_restore 89
 753              		.cfi_restore 86
 754              		.cfi_restore 87
 755              		.cfi_restore 84
 756              		.cfi_restore 85
 757              		.cfi_restore 82
 758              		.cfi_restore 83
 759              		.cfi_restore 80
 760              		.cfi_restore 81
 761              		.cfi_def_cfa_offset 36
 762 015e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 763              	.LVL48:
ARM GAS  /tmp/ccfH4MMM.s 			page 49


 764              	.L48:
 955:Src/app.c     **** 
 765              		.loc 1 955 1 view .LVU212
 766 0162 00BF     		.align	2
 767              	.L47:
 768 0164 00000000 		.word	ld_bindings_idx
 769              		.cfi_endproc
 770              	.LFE7388:
 772              		.section	.rodata.nn_thread_fct.str1.1,"aMS",%progbits,1
 773              	.LC4:
 774 0000 696E6974 		.ascii	"init nema\000"
 774      206E656D 
 774      6100
 775              	.LC5:
 776 000a 216E656D 		.ascii	"!nema_get_error()\000"
 776      615F6765 
 776      745F6572 
 776      726F7228 
 776      2900
 777              	.LC6:
 778 001c 696E6974 		.ascii	"init nema DONE %s\012\000"
 778      206E656D 
 778      6120444F 
 778      4E452025 
 778      730A00
 779              	.LC7:
 780 002f 72657420 		.ascii	"ret == HAL_OK\000"
 780      3D3D2048 
 780      414C5F4F 
 780      4B00
 781              	.LC8:
 782 003d 6E6E5F70 		.ascii	"nn_pipe_dst\000"
 782      6970655F 
 782      64737400 
 783              	.LC9:
 784 0049 63617074 		.ascii	"capture_buffer\000"
 784      7572655F 
 784      62756666 
 784      657200
 785              	.LC10:
 786 0058 72657420 		.ascii	"ret == LL_ATON_User_IO_NOERROR\000"
 786      3D3D204C 
 786      4C5F4154 
 786      4F4E5F55 
 786      7365725F 
 787              	.LC11:
 788 0077 72657420 		.ascii	"ret == AI_OD_POSTPROCESS_ERROR_NO\000"
 788      3D3D2041 
 788      495F4F44 
 788      5F504F53 
 788      5450524F 
 789              		.section	.text.nn_thread_fct,"ax",%progbits
 790              		.align	1
 791              		.syntax unified
 792              		.thumb
 793              		.thumb_func
 795              	nn_thread_fct:
ARM GAS  /tmp/ccfH4MMM.s 			page 50


 796              	.LVL49:
 797              	.LFB7405:
1566:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
 798              		.loc 1 1566 1 is_stmt 1 view -0
 799              		.cfi_startproc
 800              		@ args = 0, pretend = 0, frame = 128
 801              		@ frame_needed = 0, uses_anonymous_args = 0
1568:Src/app.c     ****   float pd_filtered_ms = 0;
 802              		.loc 1 1568 3 view .LVU214
1569:Src/app.c     ****   float ld_filtered_ms = 0;
 803              		.loc 1 1569 3 view .LVU215
1570:Src/app.c     **** 
 804              		.loc 1 1570 3 view .LVU216
1573:Src/app.c     ****   // pd_model_info_t pd_info; // Disabled
 805              		.loc 1 1573 3 view .LVU217
1575:Src/app.c     **** 
 806              		.loc 1 1575 3 view .LVU218
1578:Src/app.c     ****   uint32_t nn_period[2];
 807              		.loc 1 1578 3 view .LVU219
1579:Src/app.c     ****   uint8_t *nn_pipe_dst;
 808              		.loc 1 1579 3 view .LVU220
1580:Src/app.c     **** 
 809              		.loc 1 1580 3 view .LVU221
1583:Src/app.c     ****   pd_pp_box_t box_next;
 810              		.loc 1 1583 3 view .LVU222
1584:Src/app.c     ****   // od_pp_out_t boxes_next[YOLO_MAX_NB]; // Unused for now
 811              		.loc 1 1584 3 view .LVU223
1588:Src/app.c     ****   roi_t roi_next;
 812              		.loc 1 1588 3 view .LVU224
1589:Src/app.c     ****   uint32_t pd_ms;
 813              		.loc 1 1589 3 view .LVU225
1590:Src/app.c     ****   uint32_t hl_ms;
 814              		.loc 1 1590 3 view .LVU226
1591:Src/app.c     ****   uint32_t yolo_ms;
 815              		.loc 1 1591 3 view .LVU227
1592:Src/app.c     ****   // uint32_t fl_ms; // Unused for now
 816              		.loc 1 1592 3 view .LVU228
1594:Src/app.c     ****   int j;
 817              		.loc 1 1594 3 view .LVU229
1595:Src/app.c     ****   // int temp = 0; // Unused for now
 818              		.loc 1 1595 3 view .LVU230
1599:Src/app.c     **** 
 819              		.loc 1 1599 3 view .LVU231
1603:Src/app.c     ****   // hand_landmark_init(&hl_info); // Disabled
 820              		.loc 1 1603 3 view .LVU232
1605:Src/app.c     ****   yolo_detector_init(&yolo_info); // Disabled
 821              		.loc 1 1605 3 view .LVU233
 822              	.LBB194:
 823              	.LBI194:
1331:Src/app.c     **** {
 824              		.loc 1 1331 13 view .LVU234
 825              	.LBB195:
1333:Src/app.c     ****   int ret;
 826              		.loc 1 1333 3 view .LVU235
 827              	.LBE195:
 828              	.LBE194:
1566:Src/app.c     ****   /* Variables for filtering/smoothing performance metrics. */
ARM GAS  /tmp/ccfH4MMM.s 			page 51


 829              		.loc 1 1566 1 is_stmt 0 view .LVU236
 830 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 831              		.cfi_def_cfa_offset 36
 832              		.cfi_offset 4, -36
 833              		.cfi_offset 5, -32
 834              		.cfi_offset 6, -28
 835              		.cfi_offset 7, -24
 836              		.cfi_offset 8, -20
 837              		.cfi_offset 9, -16
 838              		.cfi_offset 10, -12
 839              		.cfi_offset 11, -8
 840              		.cfi_offset 14, -4
 841 0004 2DED028B 		vpush.64	{d8}
 842              		.cfi_def_cfa_offset 44
 843              		.cfi_offset 80, -44
 844              		.cfi_offset 81, -40
 845 0008 A1B0     		sub	sp, sp, #132
 846              		.cfi_def_cfa_offset 176
 847              	.LBB197:
 848              	.LBB196:
1333:Src/app.c     ****   int ret;
 849              		.loc 1 1333 25 view .LVU237
 850 000a 2422     		movs	r2, #36
 851 000c 0021     		movs	r1, #0
 852 000e 12A8     		add	r0, sp, #72
 853              	.LVL50:
1333:Src/app.c     ****   int ret;
 854              		.loc 1 1333 25 view .LVU238
 855 0010 FFF7FEFF 		bl	memset
 856              	.LVL51:
1334:Src/app.c     **** 
 857              		.loc 1 1334 3 is_stmt 1 view .LVU239
1336:Src/app.c     ****   nema_init();
 858              		.loc 1 1336 3 view .LVU240
 859 0014 BB48     		ldr	r0, .L84
 860 0016 FFF7FEFF 		bl	puts
 861              	.LVL52:
1337:Src/app.c     ****   assert(!nema_get_error());
 862              		.loc 1 1337 3 view .LVU241
 863 001a FFF7FEFF 		bl	nema_init
 864              	.LVL53:
1338:Src/app.c     ****   nema_ext_hold_enable(2);
 865              		.loc 1 1338 3 view .LVU242
 866 001e FFF7FEFF 		bl	nema_get_error
 867              	.LVL54:
1338:Src/app.c     ****   nema_ext_hold_enable(2);
 868              		.loc 1 1338 3 is_stmt 0 discriminator 1 view .LVU243
 869 0022 0646     		mov	r6, r0
 870 0024 30B1     		cbz	r0, .L50
 871 0026 40F23A51 		movw	r1, #1338
 872 002a B74B     		ldr	r3, .L84+4
 873 002c B74A     		ldr	r2, .L84+8
 874              	.LVL55:
 875              	.L83:
1349:Src/app.c     **** 
 876              		.loc 1 1349 3 discriminator 1 view .LVU244
 877 002e B848     		ldr	r0, .L84+12
ARM GAS  /tmp/ccfH4MMM.s 			page 52


 878 0030 FFF7FEFF 		bl	__assert_func
 879              	.LVL56:
 880              	.L50:
1339:Src/app.c     ****   nema_ext_hold_irq_enable(2);
 881              		.loc 1 1339 3 is_stmt 1 view .LVU245
 882 0034 0220     		movs	r0, #2
 883 0036 FFF7FEFF 		bl	nema_ext_hold_enable
 884              	.LVL57:
1340:Src/app.c     ****   nema_ext_hold_enable(3);
 885              		.loc 1 1340 3 view .LVU246
 886 003a 0220     		movs	r0, #2
 887 003c FFF7FEFF 		bl	nema_ext_hold_irq_enable
 888              	.LVL58:
1341:Src/app.c     ****   nema_ext_hold_irq_enable(3);
 889              		.loc 1 1341 3 view .LVU247
 890 0040 0320     		movs	r0, #3
 891 0042 FFF7FEFF 		bl	nema_ext_hold_enable
 892              	.LVL59:
1342:Src/app.c     ****   printf("init nema DONE %s\n", nema_get_sw_device_name());
 893              		.loc 1 1342 3 view .LVU248
 894 0046 0320     		movs	r0, #3
 895 0048 FFF7FEFF 		bl	nema_ext_hold_irq_enable
 896              	.LVL60:
1343:Src/app.c     **** 
 897              		.loc 1 1343 3 view .LVU249
 898 004c FFF7FEFF 		bl	nema_get_sw_device_name
 899              	.LVL61:
 900 0050 0146     		mov	r1, r0
1343:Src/app.c     **** 
 901              		.loc 1 1343 3 is_stmt 0 discriminator 1 view .LVU250
 902 0052 B048     		ldr	r0, .L84+16
 903 0054 FFF7FEFF 		bl	printf
 904              	.LVL62:
1345:Src/app.c     ****   hgfxmmu.Init.BlockSize = GFXMMU_12BYTE_BLOCKS;
 905              		.loc 1 1345 3 is_stmt 1 view .LVU251
1346:Src/app.c     ****   hgfxmmu.Init.AddressTranslation = DISABLE;
 906              		.loc 1 1346 26 is_stmt 0 view .LVU252
 907 0058 4023     		movs	r3, #64
1345:Src/app.c     ****   hgfxmmu.Init.BlockSize = GFXMMU_12BYTE_BLOCKS;
 908              		.loc 1 1345 20 view .LVU253
 909 005a AF4C     		ldr	r4, .L84+20
1346:Src/app.c     ****   hgfxmmu.Init.AddressTranslation = DISABLE;
 910              		.loc 1 1346 26 view .LVU254
 911 005c AF4A     		ldr	r2, .L84+24
1348:Src/app.c     ****   assert(ret == HAL_OK);
 912              		.loc 1 1348 9 view .LVU255
 913 005e 2046     		mov	r0, r4
1346:Src/app.c     ****   hgfxmmu.Init.AddressTranslation = DISABLE;
 914              		.loc 1 1346 26 view .LVU256
 915 0060 C4E90023 		strd	r2, r3, [r4]
1347:Src/app.c     ****   ret = HAL_GFXMMU_Init(&hgfxmmu);
 916              		.loc 1 1347 3 is_stmt 1 view .LVU257
1347:Src/app.c     ****   ret = HAL_GFXMMU_Init(&hgfxmmu);
 917              		.loc 1 1347 35 is_stmt 0 view .LVU258
 918 0064 2673     		strb	r6, [r4, #12]
1348:Src/app.c     ****   assert(ret == HAL_OK);
 919              		.loc 1 1348 3 is_stmt 1 view .LVU259
ARM GAS  /tmp/ccfH4MMM.s 			page 53


1348:Src/app.c     ****   assert(ret == HAL_OK);
 920              		.loc 1 1348 9 is_stmt 0 view .LVU260
 921 0066 FFF7FEFF 		bl	HAL_GFXMMU_Init
 922              	.LVL63:
1349:Src/app.c     **** 
 923              		.loc 1 1349 3 is_stmt 1 view .LVU261
 924 006a 20B1     		cbz	r0, .L51
1349:Src/app.c     **** 
 925              		.loc 1 1349 3 is_stmt 0 discriminator 1 view .LVU262
 926 006c 40F24551 		movw	r1, #1349
 927 0070 AB4B     		ldr	r3, .L84+28
 928 0072 A64A     		ldr	r2, .L84+8
 929 0074 DBE7     		b	.L83
 930              	.L51:
1351:Src/app.c     ****   packing.Buffer0Mode       = GFXMMU_PACKING_MSB_REMOVE;
 931              		.loc 1 1351 3 is_stmt 1 view .LVU263
1351:Src/app.c     ****   packing.Buffer0Mode       = GFXMMU_PACKING_MSB_REMOVE;
 932              		.loc 1 1351 29 is_stmt 0 view .LVU264
 933 0076 0123     		movs	r3, #1
 934 0078 8DF84830 		strb	r3, [sp, #72]
1352:Src/app.c     ****   packing.DefaultAlpha      = 0xff;
 935              		.loc 1 1352 3 is_stmt 1 view .LVU265
1353:Src/app.c     ****   ret = HAL_GFXMMU_ConfigPacking(&hgfxmmu, &packing);
 936              		.loc 1 1353 29 is_stmt 0 view .LVU266
 937 007c FF23     		movs	r3, #255
1352:Src/app.c     ****   packing.DefaultAlpha      = 0xff;
 938              		.loc 1 1352 29 view .LVU267
 939 007e 1390     		str	r0, [sp, #76]
1353:Src/app.c     ****   ret = HAL_GFXMMU_ConfigPacking(&hgfxmmu, &packing);
 940              		.loc 1 1353 3 is_stmt 1 view .LVU268
1354:Src/app.c     ****   assert(ret == HAL_OK);
 941              		.loc 1 1354 9 is_stmt 0 view .LVU269
 942 0080 12A9     		add	r1, sp, #72
 943 0082 2046     		mov	r0, r4
 944              	.LVL64:
1353:Src/app.c     ****   ret = HAL_GFXMMU_ConfigPacking(&hgfxmmu, &packing);
 945              		.loc 1 1353 29 view .LVU270
 946 0084 1A93     		str	r3, [sp, #104]
1354:Src/app.c     ****   assert(ret == HAL_OK);
 947              		.loc 1 1354 3 is_stmt 1 view .LVU271
1354:Src/app.c     ****   assert(ret == HAL_OK);
 948              		.loc 1 1354 9 is_stmt 0 view .LVU272
 949 0086 FFF7FEFF 		bl	HAL_GFXMMU_ConfigPacking
 950              	.LVL65:
1355:Src/app.c     **** 
 951              		.loc 1 1355 3 is_stmt 1 view .LVU273
 952 008a 20B1     		cbz	r0, .L52
1355:Src/app.c     **** 
 953              		.loc 1 1355 3 is_stmt 0 discriminator 1 view .LVU274
 954 008c 40F24B51 		movw	r1, #1355
 955 0090 A34B     		ldr	r3, .L84+28
 956 0092 9E4A     		ldr	r2, .L84+8
 957 0094 CBE7     		b	.L83
 958              	.L52:
1357:Src/app.c     ****   nema_cl_bind_circular(&cl);
 959              		.loc 1 1357 3 is_stmt 1 view .LVU275
1357:Src/app.c     ****   nema_cl_bind_circular(&cl);
ARM GAS  /tmp/ccfH4MMM.s 			page 54


 960              		.loc 1 1357 8 is_stmt 0 view .LVU276
 961 0096 6C46     		mov	r4, sp
 962 0098 A24D     		ldr	r5, .L84+32
 963 009a 4FF40051 		mov	r1, #8192
 964 009e 6846     		mov	r0, sp
 965              	.LVL66:
1357:Src/app.c     ****   nema_cl_bind_circular(&cl);
 966              		.loc 1 1357 8 view .LVU277
 967 00a0 FFF7FEFF 		bl	nema_cl_create_sized
 968              	.LVL67:
 969 00a4 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 970 00a6 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 971 00a8 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 972 00aa 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 973 00ac 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 974 00ae 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 975 00b0 94E80700 		ldm	r4, {r0, r1, r2}
 976 00b4 85E80700 		stm	r5, {r0, r1, r2}
1358:Src/app.c     **** }
 977              		.loc 1 1358 3 is_stmt 1 view .LVU278
 978 00b8 A5F13000 		sub	r0, r5, #48
 979 00bc FFF7FEFF 		bl	nema_cl_bind_circular
 980              	.LVL68:
1358:Src/app.c     **** }
 981              		.loc 1 1358 3 is_stmt 0 view .LVU279
 982              	.LBE196:
 983              	.LBE197:
1606:Src/app.c     ****   /*** Application Main Loop ***************************************************************/
 984              		.loc 1 1606 3 is_stmt 1 view .LVU280
 985              	.LBB198:
 986              	.LBI198:
1056:Src/app.c     **** {
 987              		.loc 1 1056 13 view .LVU281
 988              	.LBB199:
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
 989              		.loc 1 1059 3 view .LVU282
1059:Src/app.c     ****   const LL_Buffer_InfoTypeDef *nn_in_info = LL_ATON_Input_Buffers_Info_yolo_detector();
 990              		.loc 1 1059 46 is_stmt 0 view .LVU283
 991 00c0 FFF7FEFF 		bl	LL_ATON_Output_Buffers_Info_yolo_detector
 992              	.LVL69:
 993 00c4 0446     		mov	r4, r0
 994              	.LVL70:
1060:Src/app.c     **** 
 995              		.loc 1 1060 3 is_stmt 1 view .LVU284
1060:Src/app.c     **** 
 996              		.loc 1 1060 45 is_stmt 0 view .LVU285
 997 00c6 FFF7FEFF 		bl	LL_ATON_Input_Buffers_Info_yolo_detector
 998              	.LVL71:
1063:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 999              		.loc 1 1063 3 is_stmt 1 view .LVU286
 1000              	.LBB200:
 1001              	.LBI200:
 1002              		.file 2 "Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h"
   1:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** /**
   2:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
   3:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @file    ll_aton_NN_interface.h
   4:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @author  SRA Artificial Intelligence & Embedded Architectures
ARM GAS  /tmp/ccfH4MMM.s 			page 55


   5:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @brief   Interface that defines a NN generated by the AtoNN Compiler.
   6:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
   7:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @attention
   8:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
   9:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * Copyright (c) 2024 STMicroelectronics.
  10:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * All rights reserved.
  11:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
  12:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * This software is licensed under terms that can be found in the LICENSE file
  13:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * in the root directory of this software component.
  14:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * If no LICENSE file comes with this software, it is provided AS-IS.
  15:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  *
  16:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  ******************************************************************************
  17:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  */
  18:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  19:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifndef __LL_ATON_NN_INTERFACE_H
  20:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #define __LL_ATON_NN_INTERFACE_H
  21:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  22:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifdef __cplusplus
  23:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** extern "C"
  24:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** {
  25:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif
  26:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  27:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <assert.h>
  28:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stdbool.h>
  29:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stddef.h>
  30:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include <stdint.h>
  31:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  32:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_config.h"
  33:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  34:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_attributes.h"
  35:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #include "ll_aton_util.h"
  36:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  37:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup User I/O Return Values & Callback Event Types
  38:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
  39:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  40:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  41:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum LL_ATON_User_IO_Result
  42:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  43:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_NOERROR,     /**< */
  44:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_ALIGN, /**< */
  45:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_SIZE,  /**< */
  46:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_User_IO_WRONG_INDEX, /**< */
  47:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_ATON_User_IO_Result_t;
  48:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  49:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum LL_ATON_RT_Callbacktype
  50:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  51:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_PRE_START,  /**< Callback called before start_epoch_block */
  52:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_POST_START, /**< Callback called after start_epoch_block */
  53:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_PRE_END,    /**< Callback called before end_epoch_block */
  54:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_POST_END,   /**< Callback called after end_epoch_block */
  55:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_NN_Init,    /**< Callback called after `LL_ATON_RT_Init_Network`,
  56:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                          *     NOTE: 3rd parameter passed is `NULL` */
  57:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_NN_DeInit,  /**< Callback called after `LL_ATON_RT_DeInit_Network`,
  58:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                          *     NOTE: 3rd parameter passed is `NULL` */
  59:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_RT_Init,    /**< Callback called after `LL_ATON_RT_RuntimeInit` */
  60:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_RT_Callbacktype_RT_Deinit,  /**< Callback called before `LL_ATON_RT_RuntimeDeInit` */
  61:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_ATON_RT_Callbacktype_t;
ARM GAS  /tmp/ccfH4MMM.s 			page 56


  62:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  63:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
  64:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
  65:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  66:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  67:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types for Epoch Blocks
  68:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
  69:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  70:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  71:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /* this is needed to avoid some compilers (e.g. KEIL) that observe a strict semantic about conver
  72:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * pointers to integers in cost initializers
  73:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
  74:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef union
  75:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  76:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     unsigned char *p;
  77:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uintptr_t i;
  78:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } __LL_address_t;
  79:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  80:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*EpochBlock_FuncPtr_t)(const void *epoch_block);
  81:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  82:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
  83:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  84:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_NONE = 0x0,                 /**< */
  85:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_epoch_start = (0x1 << 0),   /**< First EpochBlock of an Epoch */
  86:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_epoch_end = (0x1 << 1),     /**< Last EpochBlock of an Epoch */
  87:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_blob = (0x1 << 2),          /**< Item is an Epoch Blob */
  88:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_last_eb = (0x1 << 3),       /**< Last EpochBlock */
  89:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_pure_hw = (0x1 << 4),       /**< Pure HW EpochBlock */
  90:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_pure_sw = (0x1 << 5),       /**< Pure SW EpochBlock */
  91:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_hybrid = (0x1 << 6),        /**< Hybrid EpochBlock (i.e. mixed HW/SW) */
  92:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_internal = (0x1 << 7),      /**< ATON lib internal EpochBlock (used to impleme
  93:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_Flags_blob_encrypted = (0x1 << 8) /**< The blob is encrypted and must be decrypted o
  94:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } EpochBlock_Flags_t;
  95:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
  96:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
  97:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
  98:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_FuncPtr_t start_epoch_block; /**< Method to execute the EpochBlock */
  99:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     EpochBlock_FuncPtr_t end_epoch_block;   /**< Method to be executed when the EpochBlock ends */
 100:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uintptr_t blob_address;                 /**< Blob address (in case this EpochBlock represents a
 101:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t wait_mask;                     /**< Mask needed to check when an EpochBlock ends
 102:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                              *    - if epoch blob: number (not bitmask) of epoch co
 103:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                              *    - otherwise: bitmask with all output streaming en
 104:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t flags;                         /**< EpochBlock flags */
 105:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifdef LL_ATON_EB_DBG_INFO
 106:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int16_t epoch_num;             /**< Epoch number / First epoch number within blob */
 107:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int16_t last_epoch_num;        /**< Epoch number / Last epoch number within blob */
 108:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t in_streng_mask;       /**< Debug information about input streaming engines used in epo
 109:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t out_streng_mask;      /**< Debug information about output streaming engines used in ep
 110:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint64_t estimated_npu_cycles; /**< Debug information estimates for NPU cycles in epoch w/o mem
 111:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint64_t estimated_tot_cycles; /**< Debug information estimates for NPU cycles in epoch w/ memo
 112:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                             // LL_ATON_EB_DBG_INFO
 113:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } EpochBlock_ItemTypeDef;
 114:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef EpochBlock_ItemTypeDef LL_ATON_RT_EpochBlockItem_t;
 115:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 116:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 117:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 118:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
ARM GAS  /tmp/ccfH4MMM.s 			page 57


 119:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 120:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Declarations for User Callbacks
 121:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 122:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 123:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 124:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 125:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the last one of an array of `const EpochBlock_ItemType
 126:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 127:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 128:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb);
 129:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 130:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 131:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the first EpochBlock of an Epoch
 132:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 133:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 134:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb);
 135:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 136:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 137:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the last EpochBlock of an Epoch
 138:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 139:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 140:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochEnd(const EpochBlock_ItemTypeDef *eb);
 141:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 142:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 143:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is the an Epoch Blob
 144:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 145:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 146:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb);
 147:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 148:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 149:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if - in case this epoch is a blob (see above) - the blob is encrypted
 150:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 151:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 152:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsBlobEncrypted(const EpochBlock_ItemTypeDef *eb);
 153:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 154:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 155:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is pure SW epoch
 156:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 157:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 158:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureSW(const EpochBlock_ItemTypeDef *eb);
 159:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 160:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 161:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is a pure HW or mixed SW/HW epoch
 162:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 163:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 164:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb);
 165:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 166:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 167:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is a hybrid epoch
 168:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 169:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 170:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb);
 171:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 172:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 173:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Checks if the pointed element is an internal epoch
 174:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 175:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
ARM GAS  /tmp/ccfH4MMM.s 			page 58


 176:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb);
 177:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 178:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 179:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Returns the Epoch controller id to use
 180:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 181:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 182:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb);
 183:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 184:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 185:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief Returns the address of the configuration of the epoch controller (the blob address)
 186:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 187:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 188:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb);
 189:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 190:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 191:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer types definition
 192:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 193:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 194:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 195:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 196:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 197:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 198:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types for Input, Output, and Internal Buffers
 199:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 200:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 201:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 202:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
 203:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 204:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UNDEFINED = 0,
 205:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FLOAT = 1,
 206:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT2 = 2,
 207:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT2 = 3,
 208:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT4 = 4,
 209:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT4 = 5,
 210:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT8 = 6,
 211:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT8 = 7,
 212:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT16 = 8,
 213:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT16 = 9,
 214:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT32 = 10,
 215:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_INT64 = 11,
 216:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_STRING = 12,
 217:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_BOOL = 13,
 218:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FLOAT16 = 14,
 219:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_DOUBLE = 15,
 220:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT32 = 16,
 221:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_UINT64 = 17,
 222:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_COMPLEX64 = 18,
 223:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_COMPLEX128 = 19,
 224:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_BFLOAT16 = 20,
 225:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     DataType_FXP = 100 // AtoNN specific
 226:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } Buffer_DataType_TypeDef;
 227:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 228:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 229:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer Channel position
 230:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 231:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 232:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef enum
ARM GAS  /tmp/ccfH4MMM.s 			page 59


 233:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 234:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_UNDEFINED = 0, /**< No channel present */
 235:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_First = 1,     /**< Channel First         ( ...B C H W )*/
 236:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_Last = 2,      /**< Channel Last          ( ...B H W C ) */
 237:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     CHPos_Mixed = 3,     /**< Channel with Batch(b) ( ...B C/b H W b ) */
 238:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } Buffer_CHPos_TypeDef;
 239:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 240:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 241:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief ATON buffer definition
 242:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 243:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 244:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 245:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const char *name;             /**< Buffer name. NULL if end of list */
 246:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     __LL_address_t addr_base;     /**< Buffer base address */
 247:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_start;        /**< Offset of the buffer start address from the base address */
 248:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_end;          /**< Offset of the buffer end address from the base address
 249:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (first bytes address beyond buffer length) */
 250:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t offset_limit;        /**< Offset of the limiter address from the base address,
 251:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (needed for configuring streaming engines) */
 252:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t is_user_allocated;    /**< */
 253:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t is_param;             /**< */
 254:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t epoch;               /**< */
 255:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t batch;               /**< */
 256:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const uint32_t *mem_shape;    /**< shape as seen by the user in memory (only valid for input/ou
 257:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint16_t mem_ndims;           /**< Number of dimensions of mem_shape (Length of mem_shape) */
 258:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     Buffer_CHPos_TypeDef chpos;   /**< Position  of channels dimension in mem shape */
 259:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     Buffer_DataType_TypeDef type; /**< */
 260:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int8_t Qm;                    /**< */
 261:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     int8_t Qn;                    /**< */
 262:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t Qunsigned;            /**< */
 263:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t ndims;                /**< */
 264:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t nbits;                /**< */
 265:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint8_t per_channel;          /**< */
 266:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const uint32_t *shape;        /**< */
 267:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const float *scale;           /**< */
 268:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const int16_t *offset;        /**< This can become int8 or uint8 based on the Qunsigned field.
 269:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                    *   (This field Must have the same format of the quantized value
 270:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } LL_Buffer_InfoTypeDef;
 271:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 272:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 273:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 274:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 275:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 276:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Declarations for Buffer Analysis
 277:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 278:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 279:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 280:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 281:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the base address of the mem pool the buffer is allocated in
 282:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 283:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 284:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf);
 285:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 286:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 287:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the start address of the buffer
 288:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 289:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
ARM GAS  /tmp/ccfH4MMM.s 			page 60


 290:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf);
 291:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 292:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 293:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the end address of the buffer
 294:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 295:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 296:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_end(const LL_Buffer_InfoTypeDef *buf);
 297:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 298:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 299:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the limit address of the buffer
 300:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 301:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 302:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_limit(const LL_Buffer_InfoTypeDef *buf);
 303:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 304:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 305:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the length of the buffer
 306:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 307:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 308:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf);
 309:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 310:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 311:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief returns the buffer elements number of bits
 312:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    *
 313:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 314:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_bits(const LL_Buffer_InfoTypeDef *buf);
 315:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 316:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 317:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 318:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 319:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 320:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Handle-style Data Types and Declaration Macros for ATON Runtime Execution & User AP
 321:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 322:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 323:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 324:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   struct __nn_instance_struct; // forward declaration
 325:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct __nn_instance_struct NN_Instance_TypeDef;
 326:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 327:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** /**
 328:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @brief Declare the function prototypes for named NN interface functions generated by the AtoNN c
 329:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  * @param network_name name of the network as provided by option `--network-name`
 330:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****  */
 331:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #define LL_ATON_DECLARE_NAMED_NN_PROTOS(network_name)                                              
 332:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern bool LL_ATON_EC_Network_Init_##network_name(void);                                        
 333:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern bool LL_ATON_EC_Inference_Init_##network_name(void);                                      
 334:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern LL_ATON_User_IO_Result_t LL_ATON_Set_User_Input_Buffer_##network_name(uint32_t num, void *
 335:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                                                uint32_t size);     
 336:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern void *LL_ATON_Get_User_Input_Buffer_##network_name(uint32_t num);                         
 337:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern LL_ATON_User_IO_Result_t LL_ATON_Set_User_Output_Buffer_##network_name(uint32_t num, void 
 338:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                                                 uint32_t size);    
 339:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern void *LL_ATON_Get_User_Output_Buffer_##network_name(uint32_t num);                        
 340:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const EpochBlock_ItemTypeDef *LL_ATON_EpochBlockItems_##network_name(void);               
 341:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Output_Buffers_Info_##network_name(void);            
 342:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Input_Buffers_Info_##network_name(void);             
 343:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   extern const LL_Buffer_InfoTypeDef *LL_ATON_Internal_Buffers_Info_##network_name(void);
 344:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 345:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 346:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @brief  Type definitions for NN interface functions
ARM GAS  /tmp/ccfH4MMM.s 			page 61


 347:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 348:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef bool (*NN_EC_Hook_TypeDef)(void);
 349:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef LL_ATON_User_IO_Result_t (*NN_InputSetter_TypeDef)(uint32_t num, void *buffer, uint32_t s
 350:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void *(*NN_InputGetter_TypeDef)(uint32_t num);
 351:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef LL_ATON_User_IO_Result_t (*NN_OutputSetter_TypeDef)(uint32_t num, void *buffer, uint32_t 
 352:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void *(*NN_OutputGetter_TypeDef)(uint32_t num);
 353:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef const EpochBlock_ItemTypeDef *(*NN_EpochBlockItems_TypeDef)(void);
 354:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef const LL_Buffer_InfoTypeDef *(*NN_Buffers_Info_TypeDef)(void);
 355:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 356:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*TraceRuntime_FuncPtr_t)(LL_ATON_RT_Callbacktype_t ctype);
 357:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 358:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef void (*TraceEpochBlock_FuncPtr_t)(LL_ATON_RT_Callbacktype_t ctype, const NN_Instance_Type
 359:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                             const EpochBlock_ItemTypeDef *epoch_block);
 360:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 361:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 362:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 363:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const char *network_name;
 364:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EC_Hook_TypeDef ec_network_init;
 365:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EC_Hook_TypeDef ec_inference_init;
 366:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_InputSetter_TypeDef input_setter;
 367:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_InputGetter_TypeDef input_getter;
 368:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_OutputSetter_TypeDef output_setter;
 369:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_OutputGetter_TypeDef output_getter;
 370:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_EpochBlockItems_TypeDef epoch_block_items;
 371:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef output_buffers_info;
 372:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef input_buffers_info;
 373:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Buffers_Info_TypeDef internal_buffers_info;
 374:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } NN_Interface_TypeDef;
 375:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 376:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   typedef struct
 377:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 378:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile current_epoch_block; // pointer to current epoch block
 379:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile first_epoch_block;   // pointer to first epoch block in 
 380:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile next_epoch_block;    // pointer to epoch block to be ins
 381:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 382:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef *volatile saved_current_epoch_block; // pointer to saved current e
 383:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const EpochBlock_ItemTypeDef
 384:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****         *volatile saved_first_epoch_block; // pointer to saved first epoch block in current epoch l
 385:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 386:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     bool inference_started; // inference has been started
 387:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 388:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #if (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
 389:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t triggered_events;        // currently triggered events/IRQs in current epoch
 390:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile bool current_epoch_block_started; // has current epoch block already been started
 391:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                                         // (LL_ATON_RT_MODE == LL_ATON_RT_ASYNC)
 392:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 393:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #ifndef NDEBUG
 394:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t
 395:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****         nr_of_epoch_blocks; // number of epoch blocks in network (includes also terminating empty e
 396:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     volatile uint32_t saved_nr_of_epoch_blocks; // number of epoch blocks in saved network (include
 397:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****                                                 // empty epoch block)
 398:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif                                          // NDEBUG
 399:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 400:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     TraceEpochBlock_FuncPtr_t epoch_callback_function; // epoch callback function
 401:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 402:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #if defined(LL_ATON_RT_RELOC)
 403:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     uint32_t inst_reloc;
ARM GAS  /tmp/ccfH4MMM.s 			page 62


 404:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** #endif
 405:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 406:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   } NN_Execution_State_TypeDef;
 407:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 408:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   struct __nn_instance_struct
 409:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 410:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     const NN_Interface_TypeDef *network;
 411:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     NN_Execution_State_TypeDef exec_state;
 412:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   };
 413:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 414:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /**
 415:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @}
 416:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 417:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 418:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   /** @defgroup Helper Function Inline Implementations
 419:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    * @{
 420:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****    */
 421:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 422:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsLastEpochBlock(const EpochBlock_ItemTypeDef *eb)
 423:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 424:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_last_eb) != 0);
 425:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 426:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 427:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochStart(const EpochBlock_ItemTypeDef *eb)
 428:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 429:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_epoch_start) != 0);
 430:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 431:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 432:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochEnd(const EpochBlock_ItemTypeDef *eb)
 433:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 434:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_epoch_end) != 0);
 435:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 436:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 437:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochBlob(const EpochBlock_ItemTypeDef *eb)
 438:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 439:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_blob) != 0);
 440:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 441:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 442:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsBlobEncrypted(const EpochBlock_ItemTypeDef *eb)
 443:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 444:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_blob_encrypted) != 0);
 445:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 446:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 447:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureSW(const EpochBlock_ItemTypeDef *eb)
 448:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 449:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_pure_sw) != 0);
 450:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 451:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 452:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochPureHW(const EpochBlock_ItemTypeDef *eb)
 453:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 454:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_pure_hw) != 0);
 455:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 456:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 457:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochHybrid(const EpochBlock_ItemTypeDef *eb)
 458:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 459:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_hybrid) != 0);
 460:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
ARM GAS  /tmp/ccfH4MMM.s 			page 63


 461:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 462:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline bool EpochBlock_IsEpochInternal(const EpochBlock_ItemTypeDef *eb)
 463:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 464:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return ((eb->flags & EpochBlock_Flags_internal) != 0);
 465:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 466:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 467:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t EpochBlock_EpochControllerUnit(const EpochBlock_ItemTypeDef *eb)
 468:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 469:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
 470:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return eb->wait_mask;
 471:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 472:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 473:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uintptr_t EpochBlock_EpochBlobAddr(const EpochBlock_ItemTypeDef *eb)
 474:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 475:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     LL_ATON_ASSERT(EpochBlock_IsEpochBlob(eb));
 476:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return eb->blob_address;
 477:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 478:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 479:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_base(const LL_Buffer_InfoTypeDef *buf)
 480:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     if (buf->is_user_allocated)
 482:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       unsigned char **tmp = (unsigned char **)buf->addr_base.p;
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
 485:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 486:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return buf->addr_base.p;
 487:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 488:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 489:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_start(const LL_Buffer_InfoTypeDef *buf)
 1003              		.loc 2 489 32 view .LVU287
 1004              	.LBB201:
 490:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_start;
 1005              		.loc 2 491 5 view .LVU288
 1006              	.LBB202:
 1007              	.LBI202:
 479:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 1008              		.loc 2 479 32 view .LVU289
 1009              	.LBB203:
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1010              		.loc 2 481 5 view .LVU290
 1011 00ca 4268     		ldr	r2, [r0, #4]
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1012              		.loc 2 481 8 is_stmt 0 view .LVU291
 1013 00cc 017D     		ldrb	r1, [r0, #20]	@ zero_extendqisi2
 486:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 1014              		.loc 2 486 26 view .LVU292
 1015 00ce 1346     		mov	r3, r2
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1016              		.loc 2 481 8 view .LVU293
 1017 00d0 01B1     		cbz	r1, .L54
 1018              	.LBB204:
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
 1019              		.loc 2 483 7 is_stmt 1 view .LVU294
 1020              	.LVL72:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1021              		.loc 2 484 7 view .LVU295
ARM GAS  /tmp/ccfH4MMM.s 			page 64


 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1022              		.loc 2 484 14 is_stmt 0 view .LVU296
 1023 00d2 1368     		ldr	r3, [r2]
 1024              	.LVL73:
 1025              	.L54:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1026              		.loc 2 484 14 view .LVU297
 1027              	.LBE204:
 1028              	.LBE203:
 1029              	.LBE202:
 1030              		.loc 2 491 42 discriminator 1 view .LVU298
 1031 00d4 8268     		ldr	r2, [r0, #8]
 1032              	.LVL74:
 1033              		.loc 2 491 37 discriminator 1 view .LVU299
 1034 00d6 1344     		add	r3, r3, r2
 1035              	.LBE201:
 1036              	.LBE200:
1063:Src/app.c     ****   info->nn_in_len = LL_Buffer_len(&nn_in_info[0]);
 1037              		.loc 1 1063 15 discriminator 1 view .LVU300
 1038 00d8 1293     		str	r3, [sp, #72]
1064:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
 1039              		.loc 1 1064 3 is_stmt 1 view .LVU301
 1040              	.LVL75:
 1041              	.LBB205:
 1042              	.LBI205:
 492:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 493:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 494:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_end(const LL_Buffer_InfoTypeDef *buf)
 495:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 496:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_end;
 497:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 498:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 499:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline unsigned char *LL_Buffer_addr_limit(const LL_Buffer_InfoTypeDef *buf)
 500:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 501:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return LL_Buffer_addr_base(buf) + buf->offset_limit;
 502:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 503:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h **** 
 504:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   static inline uint32_t LL_Buffer_len(const LL_Buffer_InfoTypeDef *buf)
 1043              		.loc 2 504 26 view .LVU302
 1044              	.LBB206:
 505:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 506:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     return buf->offset_end - buf->offset_start;
 1045              		.loc 2 506 5 view .LVU303
 1046              		.loc 2 506 28 is_stmt 0 view .LVU304
 1047 00da C368     		ldr	r3, [r0, #12]
 1048 00dc 9B1A     		subs	r3, r3, r2
 1049              	.LBE206:
 1050              	.LBE205:
1064:Src/app.c     ****   info->raw_output_tensor = (int8_t *) LL_Buffer_addr_start(&nn_out_info[0]);
 1051              		.loc 1 1064 19 discriminator 1 view .LVU305
 1052 00de 1393     		str	r3, [sp, #76]
1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 1053              		.loc 1 1065 3 is_stmt 1 view .LVU306
 1054              	.LVL76:
 1055              	.LBB207:
 1056              	.LBI207:
 489:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
ARM GAS  /tmp/ccfH4MMM.s 			page 65


 1057              		.loc 2 489 32 view .LVU307
 1058              	.LBB208:
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 1059              		.loc 2 491 5 view .LVU308
 1060              	.LBB209:
 1061              	.LBI209:
 479:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 1062              		.loc 2 479 32 view .LVU309
 1063              	.LBB210:
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1064              		.loc 2 481 5 view .LVU310
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1065              		.loc 2 481 8 is_stmt 0 view .LVU311
 1066 00e0 227D     		ldrb	r2, [r4, #20]	@ zero_extendqisi2
 1067              	.LBB211:
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
 1068              		.loc 2 483 23 view .LVU312
 1069 00e2 6368     		ldr	r3, [r4, #4]
 1070              	.LBE211:
 481:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     {
 1071              		.loc 2 481 8 view .LVU313
 1072 00e4 02B1     		cbz	r2, .L55
 1073              	.LBB212:
 483:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****       return *tmp;
 1074              		.loc 2 483 7 is_stmt 1 view .LVU314
 1075              	.LVL77:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1076              		.loc 2 484 7 view .LVU315
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1077              		.loc 2 484 14 is_stmt 0 view .LVU316
 1078 00e6 1B68     		ldr	r3, [r3]
 1079              	.LVL78:
 1080              	.L55:
 484:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****     }
 1081              		.loc 2 484 14 view .LVU317
 1082              	.LBE212:
 1083              	.LBE210:
 1084              	.LBE209:
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 1085              		.loc 2 491 42 discriminator 1 view .LVU318
 1086 00e8 A268     		ldr	r2, [r4, #8]
 1087              	.LVL79:
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 1088              		.loc 2 491 42 discriminator 1 view .LVU319
 1089              	.LBE208:
 1090              	.LBE207:
1071:Src/app.c     **** }
 1091              		.loc 1 1071 3 view .LVU320
 1092 00ea 18A8     		add	r0, sp, #96
 1093              	.LVL80:
 1094              	.LBB214:
 1095              	.LBB213:
 491:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   }
 1096              		.loc 2 491 37 discriminator 1 view .LVU321
 1097 00ec 1344     		add	r3, r3, r2
 1098              	.LBE213:
 1099              	.LBE214:
ARM GAS  /tmp/ccfH4MMM.s 			page 66


1065:Src/app.c     ****   info->raw_output_len = LL_Buffer_len(&nn_out_info[0]);
 1100              		.loc 1 1065 27 discriminator 1 view .LVU322
 1101 00ee 1493     		str	r3, [sp, #80]
1066:Src/app.c     **** 
 1102              		.loc 1 1066 3 is_stmt 1 view .LVU323
 1103              	.LVL81:
 1104              	.LBB215:
 1105              	.LBI215:
 504:Lib/AI_Runtime/Npu/ll_aton/ll_aton_NN_interface.h ****   {
 1106              		.loc 2 504 26 view .LVU324
 1107              	.LBB216:
 1108              		.loc 2 506 5 view .LVU325
 1109              		.loc 2 506 28 is_stmt 0 view .LVU326
 1110 00f0 E368     		ldr	r3, [r4, #12]
 1111              	.LBE216:
 1112              	.LBE215:
 1113              	.LBE199:
 1114              	.LBE198:
 1115              	.LBB220:
 1116              	.LBB221:
 605:Src/app.c     ****   if (ret == pdFALSE)
 1117              		.loc 1 605 9 view .LVU327
 1118 00f2 8D4C     		ldr	r4, .L84+36
 1119              	.LVL82:
 605:Src/app.c     ****   if (ret == pdFALSE)
 1120              		.loc 1 605 9 view .LVU328
 1121              	.LBE221:
 1122              	.LBE220:
 1123              	.LBB225:
 1124              	.LBB219:
 1125              	.LBB218:
 1126              	.LBB217:
 1127              		.loc 2 506 28 view .LVU329
 1128 00f4 9B1A     		subs	r3, r3, r2
 1129              	.LBE217:
 1130              	.LBE218:
1066:Src/app.c     **** 
 1131              		.loc 1 1066 24 discriminator 1 view .LVU330
 1132 00f6 1593     		str	r3, [sp, #84]
1071:Src/app.c     **** }
 1133              		.loc 1 1071 3 is_stmt 1 view .LVU331
 1134 00f8 FFF7FEFF 		bl	app_postprocess_init
 1135              	.LVL83:
1071:Src/app.c     **** }
 1136              		.loc 1 1071 3 is_stmt 0 view .LVU332
 1137              	.LBE219:
 1138              	.LBE225:
1608:Src/app.c     **** 
 1139              		.loc 1 1608 3 is_stmt 1 view .LVU333
1608:Src/app.c     **** 
 1140              		.loc 1 1608 18 is_stmt 0 view .LVU334
 1141 00fc FFF7FEFF 		bl	HAL_GetTick
 1142              	.LVL84:
 1143              	.LBB226:
 1144              	.LBB222:
 605:Src/app.c     ****   if (ret == pdFALSE)
 1145              		.loc 1 605 9 discriminator 4 view .LVU335
ARM GAS  /tmp/ccfH4MMM.s 			page 67


 1146 0100 0021     		movs	r1, #0
 1147              	.LBE222:
 1148              	.LBE226:
1608:Src/app.c     **** 
 1149              		.loc 1 1608 18 view .LVU336
 1150 0102 0546     		mov	r5, r0
 1151              	.LVL85:
1611:Src/app.c     ****   assert(nn_pipe_dst);
 1152              		.loc 1 1611 3 is_stmt 1 view .LVU337
 1153              	.LBB227:
 1154              	.LBI220:
 600:Src/app.c     **** {
 1155              		.loc 1 600 17 view .LVU338
 1156              	.LBB223:
 602:Src/app.c     ****   int ret;
 1157              		.loc 1 602 3 view .LVU339
 603:Src/app.c     **** 
 1158              		.loc 1 603 3 view .LVU340
 605:Src/app.c     ****   if (ret == pdFALSE)
 1159              		.loc 1 605 3 view .LVU341
 605:Src/app.c     ****   if (ret == pdFALSE)
 1160              		.loc 1 605 9 is_stmt 0 discriminator 4 view .LVU342
 1161 0104 2068     		ldr	r0, [r4]
 1162              	.LVL86:
 605:Src/app.c     ****   if (ret == pdFALSE)
 1163              		.loc 1 605 9 discriminator 4 view .LVU343
 1164 0106 FFF7FEFF 		bl	xQueueSemaphoreTake
 1165              	.LVL87:
 606:Src/app.c     ****     return NULL;
 1166              		.loc 1 606 3 is_stmt 1 view .LVU344
 606:Src/app.c     ****     return NULL;
 1167              		.loc 1 606 6 is_stmt 0 view .LVU345
 1168 010a 20B9     		cbnz	r0, .L56
 1169              	.LVL88:
 1170              	.L57:
 606:Src/app.c     ****     return NULL;
 1171              		.loc 1 606 6 view .LVU346
 1172              	.LBE223:
 1173              	.LBE227:
1612:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
 1174              		.loc 1 1612 3 discriminator 1 view .LVU347
 1175 010c 40F24C61 		movw	r1, #1612
 1176 0110 864B     		ldr	r3, .L84+40
 1177 0112 874A     		ldr	r2, .L84+44
 1178 0114 8BE7     		b	.L83
 1179              	.LVL89:
 1180              	.L56:
 1181              	.LBB228:
 1182              	.LBB224:
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1183              		.loc 1 609 3 is_stmt 1 view .LVU348
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1184              		.loc 1 609 23 is_stmt 0 view .LVU349
 1185 0116 D4F8B430 		ldr	r3, [r4, #180]
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 1186              		.loc 1 609 7 view .LVU350
 1187 011a 04EB8302 		add	r2, r4, r3, lsl #2
ARM GAS  /tmp/ccfH4MMM.s 			page 68


 1188 011e D2F8AC00 		ldr	r0, [r2, #172]
 1189              	.LVL90:
 610:Src/app.c     **** 
 1190              		.loc 1 610 3 is_stmt 1 view .LVU351
 610:Src/app.c     **** 
 1191              		.loc 1 610 37 is_stmt 0 view .LVU352
 1192 0122 D4F8A820 		ldr	r2, [r4, #168]
 610:Src/app.c     **** 
 1193              		.loc 1 610 32 view .LVU353
 1194 0126 0133     		adds	r3, r3, #1
 610:Src/app.c     **** 
 1195              		.loc 1 610 37 view .LVU354
 1196 0128 93FBF2F1 		sdiv	r1, r3, r2
 1197 012c 02FB1133 		mls	r3, r2, r1, r3
 610:Src/app.c     **** 
 1198              		.loc 1 610 16 view .LVU355
 1199 0130 C4F8B430 		str	r3, [r4, #180]
 612:Src/app.c     **** }
 1200              		.loc 1 612 3 is_stmt 1 view .LVU356
 1201              	.LVL91:
 612:Src/app.c     **** }
 1202              		.loc 1 612 3 is_stmt 0 view .LVU357
 1203              	.LBE224:
 1204              	.LBE228:
1612:Src/app.c     ****   CAM_NNPipe_Start(nn_pipe_dst, CMW_MODE_CONTINUOUS);
 1205              		.loc 1 1612 3 is_stmt 1 view .LVU358
 1206 0134 0028     		cmp	r0, #0
 1207 0136 E9D0     		beq	.L57
1613:Src/app.c     ****   while (1)
 1208              		.loc 1 1613 3 view .LVU359
1568:Src/app.c     ****   float pd_filtered_ms = 0;
 1209              		.loc 1 1568 9 is_stmt 0 view .LVU360
 1210 0138 9FED7E8A 		vldr.32	s16, .L84+48
1613:Src/app.c     ****   while (1)
 1211              		.loc 1 1613 3 view .LVU361
 1212 013c 0021     		movs	r1, #0
 1213 013e FFF7FEFF 		bl	CAM_NNPipe_Start
 1214              	.LVL92:
1613:Src/app.c     ****   while (1)
 1215              		.loc 1 1613 3 view .LVU362
 1216 0142 18EE108A 		vmov	r8, s16
 1217              	.LBB229:
1622:Src/app.c     ****     
 1218              		.loc 1 1622 27 view .LVU363
 1219 0146 DFED7C8A 		vldr.32	s17, .L84+52
1627:Src/app.c     **** 
 1220              		.loc 1 1627 48 view .LVU364
 1221 014a DFF81892 		ldr	r9, .L84+96
 1222              	.LBB230:
 1223              	.LBB231:
 1224              	.LBB232:
1097:Src/app.c     **** 
 1225              		.loc 1 1097 3 view .LVU365
 1226 014e DFF818A2 		ldr	r10, .L84+100
 1227              	.LVL93:
 1228              	.L71:
1097:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 69


 1229              		.loc 1 1097 3 view .LVU366
 1230              	.LBE232:
 1231              	.LBE231:
 1232              	.LBE230:
 1233              	.LBE229:
1614:Src/app.c     ****   {
 1234              		.loc 1 1614 3 is_stmt 1 view .LVU367
 1235              	.LBB263:
1616:Src/app.c     ****     int idx_for_resize;
 1236              		.loc 1 1616 5 view .LVU368
1617:Src/app.c     ****     /* Measure and filter the time between loop iterations. */
 1237              		.loc 1 1617 5 view .LVU369
1619:Src/app.c     ****     nn_period[1] = HAL_GetTick();
 1238              		.loc 1 1619 5 view .LVU370
1620:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1239              		.loc 1 1620 5 view .LVU371
1620:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1240              		.loc 1 1620 20 is_stmt 0 view .LVU372
 1241 0152 FFF7FEFF 		bl	HAL_GetTick
 1242              	.LVL94:
1621:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
 1243              		.loc 1 1621 18 view .LVU373
 1244 0156 431B     		subs	r3, r0, r5
 1245 0158 07EE903A 		vmov	s15, r3	@ int
1622:Src/app.c     ****     
 1246              		.loc 1 1622 75 view .LVU374
 1247 015c B2EE0E7A 		vmov.f32	s14, #1.5e+1
 1248 0160 F8EE677A 		vcvt.f32.u32	s15, s15
 1249 0164 E8EE077A 		vfma.f32	s15, s16, s14
1620:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1250              		.loc 1 1620 20 view .LVU375
 1251 0168 0746     		mov	r7, r0
 1252              	.LVL95:
1621:Src/app.c     ****     nn_period_filtered_ms = USE_FILTERED_TS ? (15 * nn_period_filtered_ms + nn_period_ms) / 16 : nn
 1253              		.loc 1 1621 5 is_stmt 1 view .LVU376
1622:Src/app.c     ****     
 1254              		.loc 1 1622 5 view .LVU377
 1255              	.LBB255:
 1256              	.LBB256:
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1257              		.loc 1 636 9 is_stmt 0 view .LVU378
 1258 016a 4FF0FF31 		mov	r1, #-1
 1259 016e 606D     		ldr	r0, [r4, #84]
 1260              	.LVL96:
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1261              		.loc 1 636 9 view .LVU379
 1262              	.LBE256:
 1263              	.LBE255:
1622:Src/app.c     ****     
 1264              		.loc 1 1622 27 view .LVU380
 1265 0170 27EEA88A 		vmul.f32	s16, s15, s17
 1266              	.LVL97:
1625:Src/app.c     ****     assert(capture_buffer);
 1267              		.loc 1 1625 5 is_stmt 1 view .LVU381
 1268              	.LBB258:
 1269              	.LBI255:
 631:Src/app.c     **** {
ARM GAS  /tmp/ccfH4MMM.s 			page 70


 1270              		.loc 1 631 17 view .LVU382
 1271              	.LBB257:
 633:Src/app.c     ****   int ret;
 1272              		.loc 1 633 3 view .LVU383
 634:Src/app.c     **** 
 1273              		.loc 1 634 3 view .LVU384
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1274              		.loc 1 636 3 view .LVU385
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1275              		.loc 1 636 9 is_stmt 0 view .LVU386
 1276 0174 FFF7FEFF 		bl	xQueueSemaphoreTake
 1277              	.LVL98:
 637:Src/app.c     **** 
 1278              		.loc 1 637 3 view .LVU387
 1279 0178 0128     		cmp	r0, #1
 636:Src/app.c     ****   assert(ret == pdTRUE);
 1280              		.loc 1 636 9 view .LVU388
 1281 017a 0546     		mov	r5, r0
 1282              	.LVL99:
 637:Src/app.c     **** 
 1283              		.loc 1 637 3 is_stmt 1 view .LVU389
 1284 017c 04D0     		beq	.L58
 637:Src/app.c     **** 
 1285              		.loc 1 637 3 is_stmt 0 discriminator 1 view .LVU390
 1286 017e 40F27D21 		movw	r1, #637
 1287 0182 6E4B     		ldr	r3, .L84+56
 1288 0184 6E4A     		ldr	r2, .L84+60
 1289 0186 52E7     		b	.L83
 1290              	.L58:
 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1291              		.loc 1 639 3 is_stmt 1 view .LVU391
 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1292              		.loc 1 639 23 is_stmt 0 view .LVU392
 1293 0188 D4F8B830 		ldr	r3, [r4, #184]
 639:Src/app.c     ****   bq->ready_idx = (bq->ready_idx + 1) % bq->buffer_nb;
 1294              		.loc 1 639 7 view .LVU393
 1295 018c 04EB8302 		add	r2, r4, r3, lsl #2
 1296 0190 D2F8ACB0 		ldr	fp, [r2, #172]
 1297              	.LVL100:
 640:Src/app.c     **** 
 1298              		.loc 1 640 3 is_stmt 1 view .LVU394
 640:Src/app.c     **** 
 1299              		.loc 1 640 39 is_stmt 0 view .LVU395
 1300 0194 D4F8A820 		ldr	r2, [r4, #168]
 640:Src/app.c     **** 
 1301              		.loc 1 640 34 view .LVU396
 1302 0198 0133     		adds	r3, r3, #1
 640:Src/app.c     **** 
 1303              		.loc 1 640 39 view .LVU397
 1304 019a 93FBF2F1 		sdiv	r1, r3, r2
 1305 019e 02FB1133 		mls	r3, r2, r1, r3
 640:Src/app.c     **** 
 1306              		.loc 1 640 17 view .LVU398
 1307 01a2 C4F8B830 		str	r3, [r4, #184]
 642:Src/app.c     **** }
 1308              		.loc 1 642 3 is_stmt 1 view .LVU399
 1309              	.LVL101:
ARM GAS  /tmp/ccfH4MMM.s 			page 71


 642:Src/app.c     **** }
 1310              		.loc 1 642 3 is_stmt 0 view .LVU400
 1311              	.LBE257:
 1312              	.LBE258:
1626:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
 1313              		.loc 1 1626 5 is_stmt 1 view .LVU401
 1314 01a6 BBF1000F 		cmp	fp, #0
 1315 01aa 04D1     		bne	.L59
1626:Src/app.c     ****     idx_for_resize = frame_event_nb_for_resize % DISPLAY_BUFFER_NB;
 1316              		.loc 1 1626 5 is_stmt 0 discriminator 1 view .LVU402
 1317 01ac 40F25A61 		movw	r1, #1626
 1318 01b0 644B     		ldr	r3, .L84+64
 1319 01b2 5F4A     		ldr	r2, .L84+44
 1320 01b4 3BE7     		b	.L83
 1321              	.L59:
1627:Src/app.c     **** 
 1322              		.loc 1 1627 5 is_stmt 1 view .LVU403
1627:Src/app.c     **** 
 1323              		.loc 1 1627 48 is_stmt 0 view .LVU404
 1324 01b6 D9F80030 		ldr	r3, [r9]
 1325              	.LVL102:
1631:Src/app.c     ****       /* --- ALL MODEL CALLS ARE REMOVED FOR THIS TEST --- */
 1326              		.loc 1 1631 5 is_stmt 1 view .LVU405
 1327              	.LBB259:
1633:Src/app.c     ****       
 1328              		.loc 1 1633 7 view .LVU406
 1329              	.LBB253:
 1330              	.LBI231:
1084:Src/app.c     **** {
 1331              		.loc 1 1084 12 view .LVU407
 1332              	.LBB251:
1086:Src/app.c     ****   int total_detections;
 1333              		.loc 1 1086 3 view .LVU408
1087:Src/app.c     ****   int face_nb = 0; /* This will count only the faces we find. */
 1334              		.loc 1 1087 3 view .LVU409
1088:Src/app.c     ****   int ret;
 1335              		.loc 1 1088 3 view .LVU410
1089:Src/app.c     **** 
 1336              		.loc 1 1089 3 view .LVU411
1091:Src/app.c     **** 
 1337              		.loc 1 1091 3 view .LVU412
1091:Src/app.c     **** 
 1338              		.loc 1 1091 14 is_stmt 0 view .LVU413
 1339 01ba FFF7FEFF 		bl	HAL_GetTick
 1340              	.LVL103:
1094:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
 1341              		.loc 1 1094 3 is_stmt 1 view .LVU414
1094:Src/app.c     ****   assert(ret == LL_ATON_User_IO_NOERROR);
 1342              		.loc 1 1094 9 is_stmt 0 view .LVU415
 1343 01be 5946     		mov	r1, fp
 1344 01c0 0020     		movs	r0, #0
 1345 01c2 139A     		ldr	r2, [sp, #76]
 1346 01c4 FFF7FEFF 		bl	LL_ATON_Set_User_Input_Buffer_yolo_detector
 1347              	.LVL104:
1095:Src/app.c     **** 
 1348              		.loc 1 1095 3 is_stmt 1 view .LVU416
 1349 01c8 20B1     		cbz	r0, .L60
ARM GAS  /tmp/ccfH4MMM.s 			page 72


1095:Src/app.c     **** 
 1350              		.loc 1 1095 3 is_stmt 0 discriminator 1 view .LVU417
 1351 01ca 40F24741 		movw	r1, #1095
 1352 01ce 5E4B     		ldr	r3, .L84+68
 1353 01d0 5E4A     		ldr	r2, .L84+72
 1354 01d2 2CE7     		b	.L83
 1355              	.L60:
1097:Src/app.c     **** 
 1356              		.loc 1 1097 3 is_stmt 1 view .LVU418
 1357 01d4 5046     		mov	r0, r10
 1358              	.LVL105:
1097:Src/app.c     **** 
 1359              		.loc 1 1097 3 is_stmt 0 view .LVU419
 1360 01d6 FFF7FEFF 		bl	LL_ATON_RT_Main
 1361              	.LVL106:
1099:Src/app.c     **** 
 1362              		.loc 1 1099 3 is_stmt 1 view .LVU420
1099:Src/app.c     **** 
 1363              		.loc 1 1099 3 view .LVU421
1099:Src/app.c     **** 
 1364              		.loc 1 1099 3 discriminator 1 view .LVU422
 1365 01da 159A     		ldr	r2, [sp, #84]
 1366              	.LVL107:
 1367              	.LBB233:
 1368              	.LBI233:
 1369              		.file 3 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h"
   1:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /******************************************************************************
   2:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @file     cachel1_armv7.h
   3:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @brief    CMSIS Level 1 Cache API for Armv7-M and later
   4:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @version  V1.0.3
   5:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * @date     17. March 2023
   6:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  ******************************************************************************/
   7:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /*
   8:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Copyright (c) 2020-2021 Arm Limited. All rights reserved.
   9:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  10:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  12:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * not use this file except in compliance with the License.
  14:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * You may obtain a copy of the License at
  15:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  16:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  *
  18:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * See the License for the specific language governing permissions and
  22:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  * limitations under the License.
  23:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  */
  24:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  25:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #if   defined ( __ICCARM__ )
  26:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #elif defined (__clang__)
  28:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #pragma clang system_header    /* treat file as system include file */
  29:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  30:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  31:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef ARM_CACHEL1_ARMV7_H
ARM GAS  /tmp/ccfH4MMM.s 			page 73


  32:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define ARM_CACHEL1_ARMV7_H
  33:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  34:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  35:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \ingroup  CMSIS_Core_FunctionInterface
  36:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \defgroup CMSIS_Core_CacheFunctions Cache Functions
  37:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief    Functions that configure Instruction and Data cache.
  38:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   @{
  39:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****  */
  40:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  41:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /* Cache Size ID Register Macros */
  42:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define CCSIDR_WAYS(x)         (((x) & SCB_CCSIDR_ASSOCIATIVITY_Msk) >> SCB_CCSIDR_ASSOCIATIVITY_Po
  43:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define CCSIDR_SETS(x)         (((x) & SCB_CCSIDR_NUMSETS_Msk      ) >> SCB_CCSIDR_NUMSETS_Pos     
  44:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  45:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef __SCB_DCACHE_LINE_SIZE
  46:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define __SCB_DCACHE_LINE_SIZE  32U /*!< Cortex-M7 cache line size is fixed to 32 bytes (8 words). 
  47:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  48:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  49:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #ifndef __SCB_ICACHE_LINE_SIZE
  50:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #define __SCB_ICACHE_LINE_SIZE  32U /*!< Cortex-M7 cache line size is fixed to 32 bytes (8 words). 
  51:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** #endif
  52:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  53:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  54:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Enable I-Cache
  55:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns on I-Cache
  56:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  57:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_EnableICache (void)
  58:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  59:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  60:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
  61:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  62:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  63:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  64:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  65:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  66:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  67:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  68:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  69:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  70:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
  71:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
  72:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  73:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  74:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  75:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Disable I-Cache
  76:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns off I-Cache
  77:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  78:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_DisableICache (void)
  79:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  80:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  81:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  82:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  83:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
  84:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  85:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  86:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
  87:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
  88:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
ARM GAS  /tmp/ccfH4MMM.s 			page 74


  89:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  90:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
  91:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
  92:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Invalidate I-Cache
  93:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates I-Cache
  94:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
  95:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateICache (void)
  96:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
  97:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
  98:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
  99:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 100:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->ICIALLU = 0UL;
 101:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 102:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 103:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 104:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 105:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 106:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 107:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 108:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   I-Cache Invalidate by address
 109:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates I-Cache for the given address.
 110:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            I-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.
 111:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            I-Cache memory blocks which are part of given address + given size are invalidated.
 112:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 113:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   isize   size of memory block (in number of bytes)
 114:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 115:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateICache_by_Addr (volatile void *addr, int32_t isize)
 116:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 117:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
 118:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( isize > 0 ) {
 119:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = isize + (((uint32_t)addr) & (__SCB_ICACHE_LINE_SIZE - 1U));
 120:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_ICACHE_LINE_SIZE - 1U) */;
 121:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 122:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 123:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 124:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 125:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->ICIMVAU = op_addr;             /* register accepts only 32byte aligned values, only bi
 126:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_ICACHE_LINE_SIZE;
 127:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_ICACHE_LINE_SIZE;
 128:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 129:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 130:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 131:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 132:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 133:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 134:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 135:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 136:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 137:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 138:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Enable D-Cache
 139:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns on D-Cache
 140:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 141:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_EnableDCache (void)
 142:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 143:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 144:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 145:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
ARM GAS  /tmp/ccfH4MMM.s 			page 75


 146:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 147:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 148:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 149:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 150:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 151:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 152:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 153:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 154:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 155:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* invalidate D-Cache */
 156:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 157:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 158:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 159:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 160:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 161:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 162:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 163:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 164:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 165:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 166:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 167:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 168:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 169:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 170:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 171:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 172:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 173:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 174:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 175:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 176:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 177:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 178:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Disable D-Cache
 179:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Turns off D-Cache
 180:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 181:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_DisableDCache (void)
 182:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 183:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 184:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     struct {
 185:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 186:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 187:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 188:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } locals
 189:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if ((defined(__GNUC__) || defined(__clang__)) && !defined(__OPTIMIZE__))
 190:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        __ALIGNED(__SCB_DCACHE_LINE_SIZE)
 191:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 192:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ;
 193:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 194:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 195:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 196:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 197:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
 198:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 199:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 200:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if !defined(__OPTIMIZE__)
 201:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       /*
 202:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * For the endless loop issue with no optimization builds.
ARM GAS  /tmp/ccfH4MMM.s 			page 76


 203:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * More details, see https://github.com/ARM-software/CMSIS_5/issues/620
 204:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        *
 205:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * The issue only happens when local variables are in stack. If
 206:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * local variables are saved in general purpose register, then the function
 207:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * is OK.
 208:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        *
 209:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * When local variables are in stack, after disabling the cache, flush the
 210:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        * local variables cache line for data consistency.
 211:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        */
 212:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       /* Clean and invalidate the local variable cache. */
 213:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #if defined(__ICCARM__)
 214:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     /* As we can't align the stack to the cache line size, invalidate each of the variables */
 215:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.sets;
 216:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.ways;
 217:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals.ccsidr;
 218:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #else
 219:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       SCB->DCCIMVAC = (uint32_t)&locals;
 220:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 221:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 222:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 223:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     #endif
 224:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 225:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     locals.ccsidr = SCB->CCSIDR;
 226:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean & invalidate D-Cache */
 227:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     locals.sets = (uint32_t)(CCSIDR_SETS(locals.ccsidr));
 228:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 229:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       locals.ways = (uint32_t)(CCSIDR_WAYS(locals.ccsidr));
 230:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 231:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCISW = (((locals.sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 232:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                        ((locals.ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
 233:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 234:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 235:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 236:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (locals.ways-- != 0U);
 237:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(locals.sets-- != 0U);
 238:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 239:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 240:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 241:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 242:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 243:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 244:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 245:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 246:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Invalidate D-Cache
 247:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates D-Cache
 248:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 249:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateDCache (void)
 250:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 251:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 252:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 253:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 254:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 255:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 256:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 257:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 259:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
ARM GAS  /tmp/ccfH4MMM.s 			page 77


 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 261:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* invalidate D-Cache */
 262:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 263:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 264:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 265:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 266:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 267:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 268:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 270:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 273:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 274:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 275:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 276:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 277:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 278:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 279:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 280:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 281:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Clean D-Cache
 282:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans D-Cache
 283:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 284:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanDCache (void)
 285:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 286:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 287:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 288:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 289:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 290:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 291:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 292:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 293:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 294:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 295:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 296:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean D-Cache */
 297:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 298:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 299:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 300:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 301:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCSW = (((sets << SCB_DCCSW_SET_Pos) & SCB_DCCSW_SET_Msk) |
 302:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                       ((ways << SCB_DCCSW_WAY_Pos) & SCB_DCCSW_WAY_Msk)  );
 303:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 304:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 305:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 306:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 307:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 308:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 309:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 310:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 311:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 312:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 313:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 314:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 315:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 316:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   Clean & Invalidate D-Cache
ARM GAS  /tmp/ccfH4MMM.s 			page 78


 317:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans and Invalidates D-Cache
 318:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   */
 319:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache (void)
 320:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 321:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 322:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ccsidr;
 323:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t sets;
 324:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     uint32_t ways;
 325:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 326:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 327:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 328:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 329:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     ccsidr = SCB->CCSIDR;
 330:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 331:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                                             /* clean & invalidate D-Cache */
 332:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 333:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     do {
 334:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 335:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 336:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 337:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****                        ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
 338:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #if defined ( __CC_ARM )
 339:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****           __schedule_barrier();
 340:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         #endif
 341:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while (ways-- != 0U);
 342:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     } while(sets-- != 0U);
 343:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 344:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __DSB();
 345:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     __ISB();
 346:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 347:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 348:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 349:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 350:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 351:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Invalidate by address
 352:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Invalidates D-Cache for the given address.
 353:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is invalidated starting from a 32 byte aligned address in 32 byte granularity.
 354:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are invalidated.
 355:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 356:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
 357:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 358:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_InvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
 1370              		.loc 3 358 27 view .LVU423
 1371              	.LBB234:
 359:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 360:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 361:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 1372              		.loc 3 361 5 view .LVU424
 1373              		.loc 3 361 8 is_stmt 0 view .LVU425
 1374 01dc 002A     		cmp	r2, #0
 1375 01de 1CDD     		ble	.L61
 1376              	.LBB235:
 362:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 1377              		.loc 3 362 8 is_stmt 1 view .LVU426
 1378              		.loc 3 362 36 is_stmt 0 view .LVU427
 1379 01e0 149B     		ldr	r3, [sp, #80]
 1380              		.loc 3 362 52 view .LVU428
ARM GAS  /tmp/ccfH4MMM.s 			page 79


 1381 01e2 03F01F00 		and	r0, r3, #31
 1382              		.loc 3 362 32 view .LVU429
 1383 01e6 1044     		add	r0, r0, r2
 1384              	.LVL108:
 363:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 1385              		.loc 3 363 7 is_stmt 1 view .LVU430
 364:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 365:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 1386              		.loc 3 365 7 view .LVU431
 1387              	.LBB236:
 1388              	.LBI236:
 1389              		.file 4 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h"
   1:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.4.1
   5:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     27. May 2021
   6:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2021 Arm Limited. All rights reserved.
   9:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  10:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  /tmp/ccfH4MMM.s 			page 80


  46:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE
  50:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  52:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  67:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
ARM GAS  /tmp/ccfH4MMM.s 			page 81


 103:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 124:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 130:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 135:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 141:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 146:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
ARM GAS  /tmp/ccfH4MMM.s 			page 82


 160:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 163:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 166:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute__((used, section(".vectors")))
 183:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
 186:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_SEAL
 187:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_SEAL              __StackSeal
 188:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 189:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 190:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __TZ_STACK_SEAL_SIZE
 191:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __TZ_STACK_SEAL_SIZE      8U
 192:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 193:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __TZ_STACK_SEAL_VALUE
 195:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __TZ_STACK_SEAL_VALUE     0xFEF5EDA5FEF5EDA5ULL
 196:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 197:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 198:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 199:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_STACKSEAL_S (uint32_t* stackTop) {
 200:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   *((uint64_t *)stackTop) = __TZ_STACK_SEAL_VALUE;
 201:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 202:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 203:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 204:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 205:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 206:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 207:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 208:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 209:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** */
 210:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 211:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 212:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 213:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 214:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 215:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 216:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
ARM GAS  /tmp/ccfH4MMM.s 			page 83


 217:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 218:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 219:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 220:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
 221:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 222:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 223:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 224:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 225:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 226:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 227:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 228:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 229:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 230:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 231:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 232:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 233:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 234:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi":::"memory")
 235:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 236:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 237:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 238:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 239:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 240:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 241:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 242:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe":::"memory")
 243:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 244:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 245:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 246:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 247:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 248:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 249:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 250:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 251:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 253:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 254:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 255:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 256:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 257:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 259:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 261:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 262:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 263:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 264:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 265:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 266:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 267:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 268:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 1390              		.loc 4 269 27 view .LVU432
 1391              	.LBB237:
 270:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
ARM GAS  /tmp/ccfH4MMM.s 			page 84


 1392              		.loc 4 271 3 view .LVU433
 1393              		.syntax unified
 1394              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1395 01e8 BFF34F8F 		dsb 0xF
 1396              	@ 0 "" 2
 1397              		.thumb
 1398              		.syntax unified
 1399              	.LBE237:
 1400              	.LBE236:
 366:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 371:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 1401              		.loc 3 371 25 is_stmt 0 discriminator 1 view .LVU434
 1402 01ec DA43     		mvns	r2, r3
 1403              	.LVL109:
 1404              		.loc 3 371 25 discriminator 1 view .LVU435
 1405 01ee 03EB000C 		add	ip, r3, r0
 1406 01f2 6244     		add	r2, r2, ip
 1407 01f4 2038     		subs	r0, r0, #32
 1408              	.LVL110:
 1409              		.loc 3 371 25 discriminator 1 view .LVU436
 1410 01f6 5209     		lsrs	r2, r2, #5
 1411 01f8 2030     		adds	r0, r0, #32
 1412              	.LVL111:
 1413              		.loc 3 371 25 discriminator 1 view .LVU437
 1414 01fa 02F1010E 		add	lr, r2, #1
 1415 01fe D8BF     		it	le
 1416 0200 AE46     		movle	lr, r5
 1417 0202 4EF001E0 		dls	lr, lr
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1418              		.loc 3 368 22 view .LVU438
 1419 0206 5249     		ldr	r1, .L84+76
 1420              	.LVL112:
 1421              	.L62:
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 1422              		.loc 3 367 7 is_stmt 1 view .LVU439
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1423              		.loc 3 368 9 view .LVU440
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 1424              		.loc 3 368 22 is_stmt 0 view .LVU441
 1425 0208 C1F85C32 		str	r3, [r1, #604]
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 1426              		.loc 3 369 9 is_stmt 1 view .LVU442
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 1427              		.loc 3 369 17 is_stmt 0 view .LVU443
 1428 020c 2033     		adds	r3, r3, #32
 1429              	.LVL113:
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 1430              		.loc 3 370 9 is_stmt 1 view .LVU444
 1431              		.loc 3 371 25 discriminator 1 view .LVU445
 1432 020e 0FF005C8 		le	lr, .L62
 372:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 373:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 1433              		.loc 3 373 7 view .LVU446
ARM GAS  /tmp/ccfH4MMM.s 			page 85


 1434              	.LBB238:
 1435              	.LBI238:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1436              		.loc 4 269 27 view .LVU447
 1437              	.LBB239:
 1438              		.loc 4 271 3 view .LVU448
 1439              		.syntax unified
 1440              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1441 0212 BFF34F8F 		dsb 0xF
 1442              	@ 0 "" 2
 1443              		.thumb
 1444              		.syntax unified
 1445              	.LBE239:
 1446              	.LBE238:
 374:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 1447              		.loc 3 374 7 view .LVU449
 1448              	.LBB240:
 1449              	.LBI240:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 1450              		.loc 4 258 27 view .LVU450
 1451              	.LBB241:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1452              		.loc 4 260 3 view .LVU451
 1453              		.syntax unified
 1454              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1455 0216 BFF36F8F 		isb 0xF
 1456              	@ 0 "" 2
 1457              	.LVL114:
 1458              		.thumb
 1459              		.syntax unified
 1460              	.L61:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1461              		.loc 4 260 3 is_stmt 0 view .LVU452
 1462              	.LBE241:
 1463              	.LBE240:
 1464              	.LBE235:
 1465              	.LBE234:
 1466              	.LBE233:
1099:Src/app.c     **** 
 1467              		.loc 1 1099 3 is_stmt 1 discriminator 3 view .LVU453
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1468              		.loc 1 1103 3 view .LVU454
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1469              		.loc 1 1103 40 is_stmt 0 view .LVU455
 1470 021a 149B     		ldr	r3, [sp, #80]
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1471              		.loc 1 1103 9 view .LVU456
 1472 021c 0121     		movs	r1, #1
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1473              		.loc 1 1103 40 view .LVU457
 1474 021e 1193     		str	r3, [sp, #68]
1103:Src/app.c     ****   assert(ret == AI_OD_POSTPROCESS_ERROR_NO);
 1475              		.loc 1 1103 9 view .LVU458
 1476 0220 16AA     		add	r2, sp, #88
 1477 0222 18AB     		add	r3, sp, #96
 1478 0224 11A8     		add	r0, sp, #68
 1479 0226 FFF7FEFF 		bl	app_postprocess_run
ARM GAS  /tmp/ccfH4MMM.s 			page 86


 1480              	.LVL115:
1104:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
 1481              		.loc 1 1104 3 is_stmt 1 view .LVU459
 1482 022a 20B1     		cbz	r0, .L63
1104:Src/app.c     ****   total_detections = info->pp_output.nb_detect;
 1483              		.loc 1 1104 3 is_stmt 0 discriminator 1 view .LVU460
 1484 022c 4FF48A61 		mov	r1, #1104
 1485 0230 484B     		ldr	r3, .L84+80
 1486 0232 464A     		ldr	r2, .L84+72
 1487 0234 FBE6     		b	.L83
 1488              	.L63:
1105:Src/app.c     **** 
 1489              		.loc 1 1105 3 is_stmt 1 view .LVU461
 1490              	.LBB242:
1111:Src/app.c     ****     {
 1491              		.loc 1 1111 24 is_stmt 0 view .LVU462
 1492 0236 DDE91631 		ldrd	r3, r1, [sp, #88]
 1493 023a 8842     		cmp	r0, r1
1111:Src/app.c     ****     {
 1494              		.loc 1 1111 36 view .LVU463
 1495 023c 03F11402 		add	r2, r3, #20
 1496 0240 4FF01805 		mov	r5, #24
 1497 0244 01F10103 		add	r3, r1, #1
 1498 0248 02DC     		bgt	.L78
 1499 024a B1F1004F 		cmp	r1, #-2147483648
 1500 024e 00D1     		bne	.L64
 1501              	.L78:
 1502 0250 0123     		movs	r3, #1
 1503              	.LVL116:
 1504              	.L64:
1108:Src/app.c     ****   {
 1505              		.loc 1 1108 21 is_stmt 1 discriminator 1 view .LVU464
 1506 0252 013B     		subs	r3, r3, #1
 1507 0254 0ED1     		bne	.L67
 1508              	.LBE242:
1128:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
 1509              		.loc 1 1128 3 view .LVU465
1128:Src/app.c     ****   return face_nb; /* Return the count of faces, not total objects. */
 1510              		.loc 1 1128 21 is_stmt 0 view .LVU466
 1511 0256 FFF7FEFF 		bl	HAL_GetTick
 1512              	.LVL117:
1129:Src/app.c     **** }
 1513              		.loc 1 1129 3 is_stmt 1 view .LVU467
1129:Src/app.c     **** }
 1514              		.loc 1 1129 3 is_stmt 0 view .LVU468
 1515              	.LBE251:
 1516              	.LBE253:
1636:Src/app.c     ****       pd_ms = 0; // Set dummy timing
 1517              		.loc 1 1636 7 is_stmt 1 view .LVU469
1637:Src/app.c     ****     } else {
 1518              		.loc 1 1637 7 view .LVU470
1637:Src/app.c     ****     } else {
 1519              		.loc 1 1637 7 is_stmt 0 view .LVU471
 1520              	.LBE259:
1643:Src/app.c     ****     bqueue_put_free(&nn_input_queue);
 1521              		.loc 1 1643 5 is_stmt 1 view .LVU472
1644:Src/app.c     **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 87


 1522              		.loc 1 1644 5 view .LVU473
 1523              	.LBB260:
 1524              	.LBI260:
 618:Src/app.c     **** {
 1525              		.loc 1 618 13 view .LVU474
 1526              	.LBB261:
 620:Src/app.c     **** 
 1527              		.loc 1 620 3 view .LVU475
 622:Src/app.c     ****   assert(ret == pdTRUE);
 1528              		.loc 1 622 3 view .LVU476
 622:Src/app.c     ****   assert(ret == pdTRUE);
 1529              		.loc 1 622 9 is_stmt 0 view .LVU477
 1530 025a 0023     		movs	r3, #0
 1531 025c 2068     		ldr	r0, [r4]
 1532 025e 1A46     		mov	r2, r3
 1533 0260 1946     		mov	r1, r3
 1534 0262 FFF7FEFF 		bl	xQueueGenericSend
 1535              	.LVL118:
 623:Src/app.c     **** }
 1536              		.loc 1 623 3 is_stmt 1 view .LVU478
 1537 0266 0128     		cmp	r0, #1
 1538 0268 23D0     		beq	.L68
 623:Src/app.c     **** }
 1539              		.loc 1 623 3 is_stmt 0 discriminator 1 view .LVU479
 1540 026a 40F26F21 		movw	r1, #623
 1541 026e 334B     		ldr	r3, .L84+56
 1542 0270 394A     		ldr	r2, .L84+84
 1543 0272 DCE6     		b	.L83
 1544              	.LVL119:
 1545              	.L67:
 623:Src/app.c     **** }
 1546              		.loc 1 623 3 discriminator 1 view .LVU480
 1547              	.LBE261:
 1548              	.LBE260:
 1549              	.LBB262:
 1550              	.LBB254:
 1551              	.LBB252:
 1552              	.LBB250:
1111:Src/app.c     ****     {
 1553              		.loc 1 1111 5 is_stmt 1 view .LVU481
1111:Src/app.c     ****     {
 1554              		.loc 1 1111 36 is_stmt 0 view .LVU482
 1555 0274 05FB00F1 		mul	r1, r5, r0
1111:Src/app.c     ****     {
 1556              		.loc 1 1111 8 view .LVU483
 1557 0278 5158     		ldr	r1, [r2, r1]
 1558 027a 0229     		cmp	r1, #2
 1559 027c 17D1     		bne	.L65
 1560              	.LBB243:
 1561              	.LBB244:
 1562              	.LBB245:
 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1563              		.loc 1 409 20 view .LVU484
 1564 027e 4FF0070E 		mov	lr, #7
 1565 0282 9FED367A 		vldr.32	s14, .L84+88
 1566 0286 4EF001E0 		dls	lr, lr
 1567              	.L66:
ARM GAS  /tmp/ccfH4MMM.s 			page 88


 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1568              		.loc 1 409 5 is_stmt 1 view .LVU485
 409:Src/app.c     ****     box->pKps[i].y *= LCD_BG_WIDTH;
 1569              		.loc 1 409 20 is_stmt 0 view .LVU486
 1570 028a D6ED007A 		vldr.32	s15, [r6]
 1571 028e 67EE877A 		vmul.f32	s15, s15, s14
 1572 0292 C6ED007A 		vstr.32	s15, [r6]
 410:Src/app.c     ****   }
 1573              		.loc 1 410 5 is_stmt 1 view .LVU487
 410:Src/app.c     ****   }
 1574              		.loc 1 410 20 is_stmt 0 view .LVU488
 1575 0296 D6ED017A 		vldr.32	s15, [r6, #4]
 1576 029a 67EE877A 		vmul.f32	s15, s15, s14
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1577              		.loc 1 408 17 discriminator 1 view .LVU489
 1578 029e 0836     		adds	r6, r6, #8
 410:Src/app.c     ****   }
 1579              		.loc 1 410 20 view .LVU490
 1580 02a0 46ED017A 		vstr.32	s15, [r6, #-4]
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1581              		.loc 1 408 49 is_stmt 1 discriminator 3 view .LVU491
 408:Src/app.c     ****     box->pKps[i].x *= LCD_BG_WIDTH;
 1582              		.loc 1 408 17 discriminator 1 view .LVU492
 1583 02a4 0FF00FC8 		le	lr, .L66
 1584              	.LBE245:
 1585              	.LBE244:
1121:Src/app.c     **** 
 1586              		.loc 1 1121 7 view .LVU493
 1587              	.LVL120:
 1588              	.LBB246:
 1589              	.LBI246:
 451:Src/app.c     **** {
 1590              		.loc 1 451 13 view .LVU494
 1591              	.LBB247:
 453:Src/app.c     ****   const float shift_y = -0.5;
 1592              		.loc 1 453 3 view .LVU495
 454:Src/app.c     ****   const float scale = 2.6;
 1593              		.loc 1 454 3 view .LVU496
 455:Src/app.c     **** 
 1594              		.loc 1 455 3 view .LVU497
 457:Src/app.c     ****   roi->cy = box->y_center;
 1595              		.loc 1 457 3 view .LVU498
 458:Src/app.c     ****   roi->w = box->width;
 1596              		.loc 1 458 3 view .LVU499
 459:Src/app.c     ****   roi->h = box->height;
 1597              		.loc 1 459 3 view .LVU500
 460:Src/app.c     ****   roi->rotation = pd_compute_rotation(box);
 1598              		.loc 1 460 3 view .LVU501
 461:Src/app.c     **** 
 1599              		.loc 1 461 3 view .LVU502
 1600              	.LBB248:
 1601              	.LBI248:
 372:Src/app.c     **** {
 1602              		.loc 1 372 14 view .LVU503
 1603              	.LBB249:
 374:Src/app.c     ****   float rotation;
 1604              		.loc 1 374 3 view .LVU504
ARM GAS  /tmp/ccfH4MMM.s 			page 89


 375:Src/app.c     **** 
 1605              		.loc 1 375 3 view .LVU505
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1606              		.loc 1 377 3 view .LVU506
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1607              		.loc 1 377 6 is_stmt 0 view .LVU507
 1608 02a8 0023     		movs	r3, #0
 1609 02aa 1B68     		ldr	r3, [r3]	@ float
 1610 02ac FFDE     		.inst	0xdeff
 1611              	.LVL121:
 1612              	.L65:
 377:Src/app.c     ****   y0 = box->pKps[0].y;
 1613              		.loc 1 377 6 view .LVU508
 1614              	.LBE249:
 1615              	.LBE248:
 1616              	.LBE247:
 1617              	.LBE246:
 1618              	.LBE243:
1108:Src/app.c     ****   {
 1619              		.loc 1 1108 42 is_stmt 1 discriminator 2 view .LVU509
 1620 02ae 0130     		adds	r0, r0, #1
 1621              	.LVL122:
1108:Src/app.c     ****   {
 1622              		.loc 1 1108 42 is_stmt 0 discriminator 2 view .LVU510
 1623 02b0 CFE7     		b	.L64
 1624              	.LVL123:
 1625              	.L68:
1108:Src/app.c     ****   {
 1626              		.loc 1 1108 42 discriminator 2 view .LVU511
 1627              	.LBE250:
 1628              	.LBE252:
 1629              	.LBE254:
 1630              	.LBE262:
1647:Src/app.c     ****       /* --- Hand landmarking is disabled for this test --- */
 1631              		.loc 1 1647 5 is_stmt 1 view .LVU512
1652:Src/app.c     ****     }
 1632              		.loc 1 1652 7 view .LVU513
1654:Src/app.c     **** 
 1633              		.loc 1 1654 5 view .LVU514
1657:Src/app.c     ****     assert(ret == pdTRUE);
 1634              		.loc 1 1657 5 view .LVU515
1657:Src/app.c     ****     assert(ret == pdTRUE);
 1635              		.loc 1 1657 11 is_stmt 0 view .LVU516
 1636 02b2 2B4D     		ldr	r5, .L84+92
 1637 02b4 4FF0FF31 		mov	r1, #-1
 1638 02b8 686D     		ldr	r0, [r5, #84]
 1639 02ba FFF7FEFF 		bl	xQueueSemaphoreTake
 1640              	.LVL124:
1658:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
 1641              		.loc 1 1658 5 is_stmt 1 view .LVU517
 1642 02be 0128     		cmp	r0, #1
 1643 02c0 04D0     		beq	.L69
1658:Src/app.c     ****     disp.info.pd_ms = is_tracking ? 0 : (int)pd_filtered_ms; /* This will now show 0 */
 1644              		.loc 1 1658 5 is_stmt 0 discriminator 1 view .LVU518
 1645 02c2 40F27A61 		movw	r1, #1658
 1646 02c6 1D4B     		ldr	r3, .L84+56
 1647 02c8 194A     		ldr	r2, .L84+44
ARM GAS  /tmp/ccfH4MMM.s 			page 90


 1648 02ca B0E6     		b	.L83
 1649              	.L69:
1659:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1650              		.loc 1 1659 5 is_stmt 1 view .LVU519
1659:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1651              		.loc 1 1659 21 is_stmt 0 discriminator 4 view .LVU520
 1652 02cc 4FF0000B 		mov	fp, #0
 1653              	.LVL125:
1673:Src/app.c     ****     assert(ret == pdTRUE);
 1654              		.loc 1 1673 11 view .LVU521
 1655 02d0 686D     		ldr	r0, [r5, #84]
 1656              	.LVL126:
1673:Src/app.c     ****     assert(ret == pdTRUE);
 1657              		.loc 1 1673 11 view .LVU522
 1658 02d2 5B46     		mov	r3, fp
 1659 02d4 5A46     		mov	r2, fp
 1660 02d6 5946     		mov	r1, fp
1661:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
 1661              		.loc 1 1661 28 view .LVU523
 1662 02d8 85ED2A8A 		vstr.32	s16, [r5, #168]
1659:Src/app.c     ****     disp.info.hl_ms = (int)ld_filtered_ms; /* This will be 0 */
 1663              		.loc 1 1659 21 discriminator 4 view .LVU524
 1664 02dc C5F8ACB0 		str	fp, [r5, #172]
1660:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
 1665              		.loc 1 1660 5 is_stmt 1 view .LVU525
1660:Src/app.c     ****     disp.info.nn_period_ms = nn_period_filtered_ms;
 1666              		.loc 1 1660 21 is_stmt 0 view .LVU526
 1667 02e0 C5F8B4B0 		str	fp, [r5, #180]
1661:Src/app.c     ****     disp.info.pd_hand_nb = is_tracking; /* This will show 1 */
 1668              		.loc 1 1661 5 is_stmt 1 view .LVU527
1662:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
 1669              		.loc 1 1662 5 view .LVU528
1662:Src/app.c     ****     disp.info.pd_max_prob = 0.0f; /* Dummy data */
 1670              		.loc 1 1662 26 is_stmt 0 view .LVU529
 1671 02e4 C5F8C8B0 		str	fp, [r5, #200]
1663:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
 1672              		.loc 1 1663 5 is_stmt 1 view .LVU530
1663:Src/app.c     ****     disp.info.hands[0].is_valid = is_tracking;
 1673              		.loc 1 1663 27 is_stmt 0 view .LVU531
 1674 02e8 C5F8D080 		str	r8, [r5, #208]	@ float
1664:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
 1675              		.loc 1 1664 5 is_stmt 1 view .LVU532
1664:Src/app.c     ****     // copy_pd_box(&disp.info.hands[0].pd_hands, &pd_info.pd_out.pOutData[0]); // Disabled
 1676              		.loc 1 1664 33 is_stmt 0 view .LVU533
 1677 02ec C5F8D4B0 		str	fp, [r5, #212]
1666:Src/app.c     ****     {
 1678              		.loc 1 1666 5 is_stmt 1 view .LVU534
1673:Src/app.c     ****     assert(ret == pdTRUE);
 1679              		.loc 1 1673 5 view .LVU535
1673:Src/app.c     ****     assert(ret == pdTRUE);
 1680              		.loc 1 1673 11 is_stmt 0 view .LVU536
 1681 02f0 FFF7FEFF 		bl	xQueueGenericSend
 1682              	.LVL127:
1674:Src/app.c     **** 
 1683              		.loc 1 1674 5 is_stmt 1 view .LVU537
 1684 02f4 0128     		cmp	r0, #1
 1685 02f6 39D0     		beq	.L70
ARM GAS  /tmp/ccfH4MMM.s 			page 91


1674:Src/app.c     **** 
 1686              		.loc 1 1674 5 is_stmt 0 discriminator 1 view .LVU538
 1687 02f8 40F28A61 		movw	r1, #1674
 1688 02fc 0F4B     		ldr	r3, .L84+56
 1689 02fe 0C4A     		ldr	r2, .L84+44
 1690 0300 95E6     		b	.L83
 1691              	.L85:
 1692 0302 00BF     		.align	2
 1693              	.L84:
 1694 0304 00000000 		.word	.LC4
 1695 0308 0A000000 		.word	.LC5
 1696 030c 00000000 		.word	__func__.9
 1697 0310 0E000000 		.word	.LC2
 1698 0314 1C000000 		.word	.LC6
 1699 0318 00000000 		.word	hgfxmmu
 1700 031c 00000358 		.word	1476591616
 1701 0320 2F000000 		.word	.LC7
 1702 0324 00000000 		.word	cl
 1703 0328 00000000 		.word	nn_input_queue
 1704 032c 3D000000 		.word	.LC8
 1705 0330 00000000 		.word	__func__.10
 1706 0334 00000000 		.word	0
 1707 0338 0000803D 		.word	1031798784
 1708 033c 00000000 		.word	.LC1
 1709 0340 00000000 		.word	__func__.8
 1710 0344 49000000 		.word	.LC9
 1711 0348 58000000 		.word	.LC10
 1712 034c 00000000 		.word	__func__.7
 1713 0350 00ED00E0 		.word	-536810240
 1714 0354 77000000 		.word	.LC11
 1715 0358 00000000 		.word	__func__.6
 1716 035c 00004844 		.word	1145569280
 1717 0360 00000000 		.word	disp
 1718 0364 00000000 		.word	frame_event_nb_for_resize
 1719 0368 00000000 		.word	NN_Instance_yolo_detector
 1720              	.L70:
1677:Src/app.c     ****   }
 1721              		.loc 1 1677 5 is_stmt 1 view .LVU539
 1722 036c 2868     		ldr	r0, [r5]
 1723              	.LVL128:
1677:Src/app.c     ****   }
 1724              		.loc 1 1677 5 is_stmt 0 view .LVU540
 1725 036e 5B46     		mov	r3, fp
 1726 0370 5A46     		mov	r2, fp
 1727 0372 5946     		mov	r1, fp
 1728 0374 FFF7FEFF 		bl	xQueueGenericSend
 1729              	.LVL129:
 1730              	.LBE263:
1614:Src/app.c     ****   {
 1731              		.loc 1 1614 9 is_stmt 1 view .LVU541
 1732              	.LBB264:
1620:Src/app.c     ****     nn_period_ms = nn_period[1] - nn_period[0];
 1733              		.loc 1 1620 18 is_stmt 0 discriminator 1 view .LVU542
 1734 0378 3D46     		mov	r5, r7
 1735              	.LBE264:
1615:Src/app.c     ****     uint8_t *capture_buffer;
 1736              		.loc 1 1615 3 view .LVU543
ARM GAS  /tmp/ccfH4MMM.s 			page 92


 1737 037a EAE6     		b	.L71
 1738              		.cfi_endproc
 1739              	.LFE7405:
 1741              		.section	.text.display_hand,"ax",%progbits
 1742              		.align	1
 1743              		.global	display_hand
 1744              		.syntax unified
 1745              		.thumb
 1746              		.thumb_func
 1748              	display_hand:
 1749              	.LVL130:
 1750              	.LFB7389:
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1751              		.loc 1 962 1 is_stmt 1 view -0
 1752              		.cfi_startproc
 1753              		@ args = 0, pretend = 0, frame = 72
 1754              		@ frame_needed = 0, uses_anonymous_args = 0
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1755              		.loc 1 963 3 view .LVU545
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1756              		.loc 1 962 1 is_stmt 0 view .LVU546
 1757 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1758              		.cfi_def_cfa_offset 32
 1759              		.cfi_offset 4, -32
 1760              		.cfi_offset 5, -28
 1761              		.cfi_offset 6, -24
 1762              		.cfi_offset 7, -20
 1763              		.cfi_offset 8, -16
 1764              		.cfi_offset 9, -12
 1765              		.cfi_offset 10, -8
 1766              		.cfi_offset 14, -4
 1767 0004 2DED048B 		vpush.64	{d8, d9}
 1768              		.cfi_def_cfa_offset 48
 1769              		.cfi_offset 80, -48
 1770              		.cfi_offset 81, -44
 1771              		.cfi_offset 82, -40
 1772              		.cfi_offset 83, -36
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1773              		.loc 1 963 6 view .LVU547
 1774 0008 C369     		ldr	r3, [r0, #28]
 962:Src/app.c     ****   if (info->is_pd_displayed) {
 1775              		.loc 1 962 1 view .LVU548
 1776 000a 0546     		mov	r5, r0
 1777 000c 0C46     		mov	r4, r1
 1778 000e 94B0     		sub	sp, sp, #80
 1779              		.cfi_def_cfa_offset 128
 963:Src/app.c     ****     display_pd_hand(&hand->pd_hands);
 1780              		.loc 1 963 6 view .LVU549
 1781 0010 002B     		cmp	r3, #0
 1782 0012 00F0FD80 		beq	.L87
 964:Src/app.c     ****     display_roi(&hand->roi);
 1783              		.loc 1 964 5 is_stmt 1 view .LVU550
 1784              	.LVL131:
 1785              	.LBB276:
 1786              	.LBI276:
 792:Src/app.c     **** {
 1787              		.loc 1 792 13 view .LVU551
ARM GAS  /tmp/ccfH4MMM.s 			page 93


 1788              	.LBB277:
 794:Src/app.c     ****   int x0, y0;
 1789              		.loc 1 794 3 view .LVU552
 795:Src/app.c     ****   int x1, y1;
 1790              		.loc 1 795 3 view .LVU553
 796:Src/app.c     ****   int w, h;
 1791              		.loc 1 796 3 view .LVU554
 797:Src/app.c     ****   int i;
 1792              		.loc 1 797 3 view .LVU555
 798:Src/app.c     **** 
 1793              		.loc 1 798 3 view .LVU556
 801:Src/app.c     ****   yc = (int)hand->y_center;
 1794              		.loc 1 801 3 view .LVU557
 801:Src/app.c     ****   yc = (int)hand->y_center;
 1795              		.loc 1 801 6 is_stmt 0 view .LVU558
 1796 0016 D1ED027A 		vldr.32	s15, [r1, #8]
 1797 001a FDEEE77A 		vcvt.s32.f32	s15, s15
 1798 001e 17EE900A 		vmov	r0, s15	@ int
 1799              	.LVL132:
 802:Src/app.c     ****   w = (int)hand->width;
 1800              		.loc 1 802 3 is_stmt 1 view .LVU559
 802:Src/app.c     ****   w = (int)hand->width;
 1801              		.loc 1 802 6 is_stmt 0 view .LVU560
 1802 0022 D1ED037A 		vldr.32	s15, [r1, #12]
 1803 0026 FDEEE77A 		vcvt.s32.f32	s15, s15
 1804 002a 17EE901A 		vmov	r1, s15	@ int
 1805              	.LVL133:
 803:Src/app.c     ****   h = (int)hand->height;
 1806              		.loc 1 803 3 is_stmt 1 view .LVU561
 804:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 1807              		.loc 1 804 3 view .LVU562
 804:Src/app.c     ****   x0 = xc - (w + 1) / 2;
 1808              		.loc 1 804 5 is_stmt 0 view .LVU563
 1809 002e D4ED057A 		vldr.32	s15, [r4, #20]
 1810 0032 FDEEE77A 		vcvt.s32.f32	s15, s15
 1811 0036 17EE903A 		vmov	r3, s15	@ int
 1812              	.LVL134:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1813              		.loc 1 805 3 is_stmt 1 view .LVU564
 803:Src/app.c     ****   h = (int)hand->height;
 1814              		.loc 1 803 5 is_stmt 0 view .LVU565
 1815 003a D4ED047A 		vldr.32	s15, [r4, #16]
 1816 003e FDEEE77A 		vcvt.s32.f32	s15, s15
 1817 0042 17EE902A 		vmov	r2, s15	@ int
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1818              		.loc 1 805 16 view .LVU566
 1819 0046 0132     		adds	r2, r2, #1
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1820              		.loc 1 805 21 view .LVU567
 1821 0048 02EBD272 		add	r2, r2, r2, lsr #31
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1822              		.loc 1 806 16 view .LVU568
 1823 004c 0133     		adds	r3, r3, #1
 1824              	.LVL135:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1825              		.loc 1 805 21 view .LVU569
 1826 004e 5210     		asrs	r2, r2, #1
ARM GAS  /tmp/ccfH4MMM.s 			page 94


 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1827              		.loc 1 806 21 view .LVU570
 1828 0050 03EBD373 		add	r3, r3, r3, lsr #31
 1829              	.LVL136:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1830              		.loc 1 805 21 view .LVU571
 1831 0054 5242     		rsbs	r2, r2, #0
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1832              		.loc 1 806 21 view .LVU572
 1833 0056 5B10     		asrs	r3, r3, #1
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1834              		.loc 1 805 11 view .LVU573
 1835 0058 8618     		adds	r6, r0, r2
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1836              		.loc 1 806 21 view .LVU574
 1837 005a 5B42     		rsbs	r3, r3, #0
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1838              		.loc 1 807 6 view .LVU575
 1839 005c 801A     		subs	r0, r0, r2
 1840              	.LVL137:
 805:Src/app.c     ****   y0 = yc - (h + 1) / 2;
 1841              		.loc 1 805 6 view .LVU576
 1842 005e 0296     		str	r6, [sp, #8]
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1843              		.loc 1 806 3 is_stmt 1 view .LVU577
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1844              		.loc 1 806 11 is_stmt 0 view .LVU578
 1845 0060 CE18     		adds	r6, r1, r3
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1846              		.loc 1 808 6 view .LVU579
 1847 0062 C91A     		subs	r1, r1, r3
 1848              	.LVL138:
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1849              		.loc 1 807 6 view .LVU580
 1850 0064 0490     		str	r0, [sp, #16]
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1851              		.loc 1 808 6 view .LVU581
 1852 0066 0C91     		str	r1, [sp, #48]
 809:Src/app.c     ****   clamp_point(&x1, &y1);
 1853              		.loc 1 809 3 view .LVU582
 1854 0068 02A8     		add	r0, sp, #8
 1855 006a 03A9     		add	r1, sp, #12
 806:Src/app.c     ****   x1 = xc + (w + 1) / 2;
 1856              		.loc 1 806 6 view .LVU583
 1857 006c 0396     		str	r6, [sp, #12]
 807:Src/app.c     ****   y1 = yc + (h + 1) / 2;
 1858              		.loc 1 807 3 is_stmt 1 view .LVU584
 808:Src/app.c     ****   clamp_point(&x0, &y0);
 1859              		.loc 1 808 3 view .LVU585
 809:Src/app.c     ****   clamp_point(&x1, &y1);
 1860              		.loc 1 809 3 view .LVU586
 1861 006e FFF7FEFF 		bl	clamp_point
 1862              	.LVL139:
 810:Src/app.c     ****   UTIL_LCD_DrawRect(x0, y0, x1 - x0, y1 - y0, UTIL_LCD_COLOR_GREEN);
 1863              		.loc 1 810 3 view .LVU587
 1864 0072 0CA9     		add	r1, sp, #48
 1865 0074 04A8     		add	r0, sp, #16
ARM GAS  /tmp/ccfH4MMM.s 			page 95


 1866 0076 FFF7FEFF 		bl	clamp_point
 1867              	.LVL140:
 811:Src/app.c     **** 
 1868              		.loc 1 811 3 view .LVU588
 1869 007a DDE90201 		ldrd	r0, r1, [sp, #8]
 1870 007e 4FF0FF23 		mov	r3, #-16711936
 1871 0082 049A     		ldr	r2, [sp, #16]
 1872 0084 0093     		str	r3, [sp]
 1873 0086 0C9B     		ldr	r3, [sp, #48]
 1874 0088 121A     		subs	r2, r2, r0
 1875 008a 5B1A     		subs	r3, r3, r1
 1876 008c FFF7FEFF 		bl	UTIL_LCD_DrawRect
 1877              	.LVL141:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1878              		.loc 1 814 3 view .LVU589
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1879              		.loc 1 814 17 discriminator 1 view .LVU590
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1880              		.loc 1 814 10 is_stmt 0 view .LVU591
 1881 0090 0026     		movs	r6, #0
 1882              	.LBB278:
 815:Src/app.c     **** 
 1883              		.loc 1 815 62 discriminator 3 view .LVU592
 1884 0092 DFF8A081 		ldr	r8, .L107+4
 1885 0096 664F     		ldr	r7, .L107
 1886              	.LVL142:
 1887              	.L89:
 815:Src/app.c     **** 
 1888              		.loc 1 815 5 is_stmt 1 view .LVU593
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1889              		.loc 1 817 25 is_stmt 0 view .LVU594
 1890 0098 A269     		ldr	r2, [r4, #24]
 815:Src/app.c     **** 
 1891              		.loc 1 815 62 discriminator 3 view .LVU595
 1892 009a 36F00203 		bics	r3, r6, #2
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1893              		.loc 1 817 25 view .LVU596
 1894 009e 02EBC602 		add	r2, r2, r6, lsl #3
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1895              		.loc 1 817 10 view .LVU597
 1896 00a2 D2ED007A 		vldr.32	s15, [r2]
 1897 00a6 FDEEE77A 		vcvt.s32.f32	s15, s15
 1898 00aa CDED027A 		vstr.32	s15, [sp, #8]	@ int
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1899              		.loc 1 818 10 view .LVU598
 1900 00ae D2ED017A 		vldr.32	s15, [r2, #4]
 815:Src/app.c     **** 
 1901              		.loc 1 815 62 discriminator 3 view .LVU599
 1902 00b2 0CBF     		ite	eq
 1903 00b4 C146     		moveq	r9, r8
 1904 00b6 B946     		movne	r9, r7
 1905              	.LVL143:
 817:Src/app.c     ****     y0 = (int)hand->pKps[i].y;
 1906              		.loc 1 817 5 is_stmt 1 view .LVU600
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1907              		.loc 1 818 5 view .LVU601
 818:Src/app.c     ****     clamp_point(&x0, &y0);
ARM GAS  /tmp/ccfH4MMM.s 			page 96


 1908              		.loc 1 818 10 is_stmt 0 view .LVU602
 1909 00b8 FDEEE77A 		vcvt.s32.f32	s15, s15
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1910              		.loc 1 819 5 view .LVU603
 1911 00bc 03A9     		add	r1, sp, #12
 1912 00be 02A8     		add	r0, sp, #8
 818:Src/app.c     ****     clamp_point(&x0, &y0);
 1913              		.loc 1 818 10 view .LVU604
 1914 00c0 CDED037A 		vstr.32	s15, [sp, #12]	@ int
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1915              		.loc 1 819 5 is_stmt 1 view .LVU605
 1916              	.LBE278:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1917              		.loc 1 814 23 is_stmt 0 discriminator 2 view .LVU606
 1918 00c4 0136     		adds	r6, r6, #1
 1919              	.LVL144:
 1920              	.LBB279:
 819:Src/app.c     ****     UTIL_LCD_FillCircle(x0, y0, 2, color);
 1921              		.loc 1 819 5 view .LVU607
 1922 00c6 FFF7FEFF 		bl	clamp_point
 1923              	.LVL145:
 820:Src/app.c     ****   }
 1924              		.loc 1 820 5 is_stmt 1 view .LVU608
 1925 00ca DDE90201 		ldrd	r0, r1, [sp, #8]
 1926 00ce 4B46     		mov	r3, r9
 1927 00d0 0222     		movs	r2, #2
 1928 00d2 FFF7FEFF 		bl	UTIL_LCD_FillCircle
 1929              	.LVL146:
 1930              	.LBE279:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1931              		.loc 1 814 23 discriminator 2 view .LVU609
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1932              		.loc 1 814 17 discriminator 1 view .LVU610
 1933 00d6 072E     		cmp	r6, #7
 1934 00d8 DED1     		bne	.L89
 1935              	.LVL147:
 814:Src/app.c     ****     uint32_t color = (i != 0 && i != 2) ? UTIL_LCD_COLOR_RED : UTIL_LCD_COLOR_BLUE;
 1936              		.loc 1 814 17 is_stmt 0 discriminator 1 view .LVU611
 1937              	.LBE277:
 1938              	.LBE276:
 965:Src/app.c     ****   }
 1939              		.loc 1 965 5 is_stmt 1 view .LVU612
 1940              	.LBB280:
 1941              	.LBI280:
 882:Src/app.c     **** {
 1942              		.loc 1 882 13 view .LVU613
 1943              	.LBB281:
 884:Src/app.c     ****   int corners[4][2];
 1944              		.loc 1 884 3 view .LVU614
 885:Src/app.c     ****   int is_clamp;
 1945              		.loc 1 885 3 view .LVU615
 886:Src/app.c     ****   int i;
 1946              		.loc 1 886 3 view .LVU616
 887:Src/app.c     **** 
 1947              		.loc 1 887 3 view .LVU617
 890:Src/app.c     **** 
 1948              		.loc 1 890 3 view .LVU618
ARM GAS  /tmp/ccfH4MMM.s 			page 97


 1949              	.LBB282:
 1950              	.LBI282:
 839:Src/app.c     **** {
 1951              		.loc 1 839 13 view .LVU619
 1952              	.LBB283:
 841:Src/app.c     ****     {-roi->w / 2, -roi->h / 2},
 1953              		.loc 1 841 3 view .LVU620
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1954              		.loc 1 842 14 is_stmt 0 view .LVU621
 1955 00da F6EE006A 		vmov.f32	s13, #5.0e-1
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1956              		.loc 1 842 6 view .LVU622
 1957 00de D4ED097A 		vldr.32	s15, [r4, #36]
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1958              		.loc 1 842 19 view .LVU623
 1959 00e2 94ED0A7A 		vldr.32	s14, [r4, #40]
 1960              	.LBB284:
 1961              	.LBB285:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1962              		.loc 1 832 11 view .LVU624
 1963 00e6 94ED0B9A 		vldr.32	s18, [r4, #44]
 1964              	.LBE285:
 1965              	.LBE284:
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1966              		.loc 1 842 14 view .LVU625
 1967 00ea 67EEE67A 		vnmul.f32	s15, s15, s13
 1968              	.LVL148:
 842:Src/app.c     ****     { roi->w / 2, -roi->h / 2},
 1969              		.loc 1 842 27 view .LVU626
 1970 00ee 27EE667A 		vnmul.f32	s14, s14, s13
 1971              	.LVL149:
 1972              	.LBB291:
 1973              	.LBB286:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1974              		.loc 1 832 11 view .LVU627
 1975 00f2 B7EEC99A 		vcvt.f64.f32	d9, s18
 1976 00f6 B1EE676A 		vneg.f32	s12, s15
 1977              	.LVL150:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1978              		.loc 1 832 11 view .LVU628
 1979 00fa F1EE476A 		vneg.f32	s13, s14
 1980              	.LVL151:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1981              		.loc 1 832 11 view .LVU629
 1982              	.LBE286:
 1983              	.LBE291:
 847:Src/app.c     **** 
 1984              		.loc 1 847 3 is_stmt 1 view .LVU630
 849:Src/app.c     ****   /* rotate */
 1985              		.loc 1 849 3 view .LVU631
 1986              	.LBB292:
 1987              	.LBB287:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 1988              		.loc 1 832 11 is_stmt 0 view .LVU632
 1989 00fe B0EE490B 		vmov.f64	d0, d9
 1990              	.LBE287:
 1991              	.LBE292:
ARM GAS  /tmp/ccfH4MMM.s 			page 98


 849:Src/app.c     ****   /* rotate */
 1992              		.loc 1 849 3 view .LVU633
 1993 0102 CDED047A 		vstr.32	s15, [sp, #16]
 1994 0106 8DED057A 		vstr.32	s14, [sp, #20]
 1995 010a 8DED066A 		vstr.32	s12, [sp, #24]
 1996 010e 8DED077A 		vstr.32	s14, [sp, #28]
 1997 0112 8DED086A 		vstr.32	s12, [sp, #32]
 1998 0116 CDED096A 		vstr.32	s13, [sp, #36]
 1999 011a CDED0A7A 		vstr.32	s15, [sp, #40]
 2000 011e CDED0B6A 		vstr.32	s13, [sp, #44]
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2001              		.loc 1 851 3 is_stmt 1 view .LVU634
 2002              	.LVL152:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2003              		.loc 1 851 17 discriminator 1 view .LVU635
 2004              	.LBB293:
 2005              	.LBB288:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2006              		.loc 1 832 11 is_stmt 0 view .LVU636
 2007 0122 FFF7FEFF 		bl	cos
 2008              	.LVL153:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2009              		.loc 1 832 11 view .LVU637
 2010 0126 B0EE408B 		vmov.f64	d8, d0
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2011              		.loc 1 832 31 discriminator 1 view .LVU638
 2012 012a B0EE490B 		vmov.f64	d0, d9
 2013 012e FFF7FEFF 		bl	sin
 2014              	.LVL154:
 2015              	.LBE288:
 2016              	.LBE293:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2017              		.loc 1 851 10 view .LVU639
 2018 0132 4FF0040E 		mov	lr, #4
 2019 0136 0DF11009 		add	r9, sp, #16
 2020              	.LVL155:
 2021              	.LBB294:
 2022              	.LBB289:
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2023              		.loc 1 832 31 discriminator 1 view .LVU640
 2024 013a 4B46     		mov	r3, r9
 2025              	.LBE289:
 2026              	.LBE294:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2027              		.loc 1 851 10 view .LVU641
 2028 013c 4EF001E0 		dls	lr, lr
 2029              	.LVL156:
 2030              	.L90:
 852:Src/app.c     **** 
 2031              		.loc 1 852 5 is_stmt 1 view .LVU642
 2032              	.LBB295:
 2033              	.LBI284:
 827:Src/app.c     **** {
 2034              		.loc 1 827 13 view .LVU643
 2035              	.LBB290:
 829:Src/app.c     ****   float y = pt[1];
 2036              		.loc 1 829 3 view .LVU644
ARM GAS  /tmp/ccfH4MMM.s 			page 99


 830:Src/app.c     **** 
 2037              		.loc 1 830 3 view .LVU645
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2038              		.loc 1 832 3 view .LVU646
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2039              		.loc 1 832 45 is_stmt 0 discriminator 2 view .LVU647
 2040 0140 93ED017A 		vldr.32	s14, [r3, #4]
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2041              		.loc 1 832 25 discriminator 1 view .LVU648
 2042 0144 93ED005A 		vldr.32	s10, [r3]
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2043              		.loc 1 832 45 discriminator 2 view .LVU649
 2044 0148 B7EEC77A 		vcvt.f64.f32	d7, s14
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2045              		.loc 1 832 25 discriminator 1 view .LVU650
 2046 014c B7EEC55A 		vcvt.f64.f32	d5, s10
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2047              		.loc 1 832 29 discriminator 2 view .LVU651
 2048 0150 27EE406B 		vnmul.f64	d6, d7, d0
 833:Src/app.c     **** }
 2049              		.loc 1 833 45 discriminator 2 view .LVU652
 2050 0154 28EE077B 		vmul.f64	d7, d8, d7
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2051              		.loc 1 832 29 discriminator 2 view .LVU653
 2052 0158 A8EE056B 		vfma.f64	d6, d8, d5
 833:Src/app.c     **** }
 2053              		.loc 1 833 29 discriminator 2 view .LVU654
 2054 015c A5EE007B 		vfma.f64	d7, d5, d0
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2055              		.loc 1 832 29 discriminator 2 view .LVU655
 2056 0160 B7EEC66B 		vcvt.f32.f64	s12, d6
 833:Src/app.c     **** }
 2057              		.loc 1 833 29 discriminator 2 view .LVU656
 2058 0164 B7EEC77B 		vcvt.f32.f64	s14, d7
 832:Src/app.c     ****   pt[1] = sin(rotation) * x + cos(rotation) * y;
 2059              		.loc 1 832 29 discriminator 2 view .LVU657
 2060 0168 83ED006A 		vstr.32	s12, [r3]
 2061              	.LVL157:
 833:Src/app.c     **** }
 2062              		.loc 1 833 3 is_stmt 1 view .LVU658
 833:Src/app.c     **** }
 2063              		.loc 1 833 29 is_stmt 0 discriminator 2 view .LVU659
 2064 016c 83ED017A 		vstr.32	s14, [r3, #4]
 2065              	.LVL158:
 833:Src/app.c     **** }
 2066              		.loc 1 833 29 discriminator 2 view .LVU660
 2067              	.LBE290:
 2068              	.LBE295:
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2069              		.loc 1 851 23 is_stmt 1 discriminator 3 view .LVU661
 851:Src/app.c     ****     rotate_point(corners[i], roi->rotation);
 2070              		.loc 1 851 17 discriminator 1 view .LVU662
 2071 0170 0833     		adds	r3, r3, #8
 2072 0172 0FF01BC8 		le	lr, .L90
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2073              		.loc 1 855 10 is_stmt 0 view .LVU663
 2074 0176 4FF0040E 		mov	lr, #4
ARM GAS  /tmp/ccfH4MMM.s 			page 100


 856:Src/app.c     ****     corners[i][1] += roi->cy;
 2075              		.loc 1 856 25 view .LVU664
 2076 017a D4ED076A 		vldr.32	s13, [r4, #28]
 857:Src/app.c     ****   }
 2077              		.loc 1 857 25 view .LVU665
 2078 017e 94ED087A 		vldr.32	s14, [r4, #32]
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2079              		.loc 1 855 10 view .LVU666
 2080 0182 4EF001E0 		dls	lr, lr
 857:Src/app.c     ****   }
 2081              		.loc 1 857 25 view .LVU667
 2082 0186 04AB     		add	r3, sp, #16
 2083              	.L91:
 856:Src/app.c     ****     corners[i][1] += roi->cy;
 2084              		.loc 1 856 5 is_stmt 1 view .LVU668
 856:Src/app.c     ****     corners[i][1] += roi->cy;
 2085              		.loc 1 856 19 is_stmt 0 view .LVU669
 2086 0188 D3ED007A 		vldr.32	s15, [r3]
 2087 018c 77EEA67A 		vadd.f32	s15, s15, s13
 2088 0190 C3ED007A 		vstr.32	s15, [r3]
 857:Src/app.c     ****   }
 2089              		.loc 1 857 5 is_stmt 1 view .LVU670
 857:Src/app.c     ****   }
 2090              		.loc 1 857 19 is_stmt 0 view .LVU671
 2091 0194 D3ED017A 		vldr.32	s15, [r3, #4]
 2092 0198 77EE877A 		vadd.f32	s15, s15, s14
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2093              		.loc 1 855 17 discriminator 1 view .LVU672
 2094 019c 0833     		adds	r3, r3, #8
 857:Src/app.c     ****   }
 2095              		.loc 1 857 19 view .LVU673
 2096 019e 43ED017A 		vstr.32	s15, [r3, #-4]
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2097              		.loc 1 855 23 is_stmt 1 discriminator 3 view .LVU674
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2098              		.loc 1 855 17 discriminator 1 view .LVU675
 2099 01a2 0FF00FC8 		le	lr, .L91
 2100              	.LBE283:
 2101              	.LBE282:
 2102              	.LBB297:
 2103              	.LBB298:
 866:Src/app.c     ****   int i;
 2104              		.loc 1 866 7 is_stmt 0 view .LVU676
 2105 01a6 0026     		movs	r6, #0
 866:Src/app.c     ****   int i;
 2106              		.loc 1 866 7 view .LVU677
 2107 01a8 0CAF     		add	r7, sp, #48
 2108              	.LBE298:
 2109              	.LBE297:
 2110              	.LBB300:
 2111              	.LBB296:
 855:Src/app.c     ****     corners[i][0] += roi->cx;
 2112              		.loc 1 855 17 discriminator 1 view .LVU678
 2113 01aa B846     		mov	r8, r7
 2114              	.LBE296:
 2115              	.LBE300:
 2116              	.LBB301:
ARM GAS  /tmp/ccfH4MMM.s 			page 101


 2117              	.LBB299:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2118              		.loc 1 869 10 view .LVU679
 2119 01ac B246     		mov	r10, r6
 2120              	.LVL159:
 2121              	.L92:
 870:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 2122              		.loc 1 870 5 is_stmt 1 view .LVU680
 870:Src/app.c     ****     corners_out[i][1] = (int)corners_in[i][1];
 2123              		.loc 1 870 25 is_stmt 0 view .LVU681
 2124 01ae D9ED007A 		vldr.32	s15, [r9]
 2125 01b2 FDEEE77A 		vcvt.s32.f32	s15, s15
 2126 01b6 C8ED007A 		vstr.32	s15, [r8]	@ int
 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 2127              		.loc 1 871 5 is_stmt 1 view .LVU682
 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 2128              		.loc 1 871 25 is_stmt 0 view .LVU683
 2129 01ba D9ED017A 		vldr.32	s15, [r9, #4]
 2130 01be FDEEE77A 		vcvt.s32.f32	s15, s15
 2131 01c2 4146     		mov	r1, r8
 2132 01c4 17EE903A 		vmov	r3, s15	@ int
 872:Src/app.c     ****   }
 2133              		.loc 1 872 17 view .LVU684
 2134 01c8 4046     		mov	r0, r8
 871:Src/app.c     ****     is_clamp |= clamp_point(&corners_out[i][0], &corners_out[i][1]);
 2135              		.loc 1 871 25 view .LVU685
 2136 01ca 41F8043F 		str	r3, [r1, #4]!
 872:Src/app.c     ****   }
 2137              		.loc 1 872 5 is_stmt 1 view .LVU686
 872:Src/app.c     ****   }
 2138              		.loc 1 872 17 is_stmt 0 view .LVU687
 2139 01ce FFF7FEFF 		bl	clamp_point
 2140              	.LVL160:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2141              		.loc 1 869 23 discriminator 3 view .LVU688
 2142 01d2 0AF1010A 		add	r10, r10, #1
 2143              	.LVL161:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2144              		.loc 1 869 17 discriminator 1 view .LVU689
 2145 01d6 BAF1040F 		cmp	r10, #4
 872:Src/app.c     ****   }
 2146              		.loc 1 872 14 discriminator 1 view .LVU690
 2147 01da 46EA0006 		orr	r6, r6, r0
 2148              	.LVL162:
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2149              		.loc 1 869 23 is_stmt 1 discriminator 3 view .LVU691
 869:Src/app.c     ****     corners_out[i][0] = (int)corners_in[i][0];
 2150              		.loc 1 869 17 discriminator 1 view .LVU692
 2151 01de 09F10809 		add	r9, r9, #8
 2152 01e2 08F10808 		add	r8, r8, #8
 2153 01e6 E2D1     		bne	.L92
 875:Src/app.c     **** }
 2154              		.loc 1 875 3 view .LVU693
 2155              	.LVL163:
 875:Src/app.c     **** }
 2156              		.loc 1 875 3 is_stmt 0 view .LVU694
 2157              	.LBE299:
ARM GAS  /tmp/ccfH4MMM.s 			page 102


 2158              	.LBE301:
 894:Src/app.c     ****     return ;
 2159              		.loc 1 894 3 is_stmt 1 view .LVU695
 894:Src/app.c     ****     return ;
 2160              		.loc 1 894 6 is_stmt 0 view .LVU696
 2161 01e8 96B9     		cbnz	r6, .L87
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2162              		.loc 1 899 5 view .LVU697
 2163 01ea DFF84480 		ldr	r8, .L107
 2164              	.LVL164:
 2165              	.L93:
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2166              		.loc 1 899 5 is_stmt 1 view .LVU698
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2167              		.loc 1 899 64 is_stmt 0 view .LVU699
 2168 01ee 0136     		adds	r6, r6, #1
 2169              	.LVL165:
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2170              		.loc 1 899 98 view .LVU700
 2171 01f0 14AB     		add	r3, sp, #80
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2172              		.loc 1 899 69 view .LVU701
 2173 01f2 06F00302 		and	r2, r6, #3
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2174              		.loc 1 899 5 view .LVU702
 2175 01f6 CDF80080 		str	r8, [sp]
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2176              		.loc 1 899 98 view .LVU703
 2177 01fa 03EBC202 		add	r2, r3, r2, lsl #3
 899:Src/app.c     ****                       UTIL_LCD_COLOR_RED);
 2178              		.loc 1 899 5 view .LVU704
 2179 01fe 7968     		ldr	r1, [r7, #4]
 2180 0200 52E90823 		ldrd	r2, r3, [r2, #-32]
 2181 0204 57F8080B 		ldr	r0, [r7], #8
 2182 0208 FFF7FEFF 		bl	UTIL_LCD_DrawLine
 2183              	.LVL166:
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2184              		.loc 1 898 23 is_stmt 1 discriminator 3 view .LVU705
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2185              		.loc 1 898 17 discriminator 1 view .LVU706
 2186 020c 042E     		cmp	r6, #4
 2187 020e EED1     		bne	.L93
 2188              	.LVL167:
 2189              	.L87:
 898:Src/app.c     ****     UTIL_LCD_DrawLine(corners[i][0], corners[i][1], corners[(i + 1) % 4][0], corners[(i + 1) % 4][1
 2190              		.loc 1 898 17 is_stmt 0 discriminator 1 view .LVU707
 2191              	.LBE281:
 2192              	.LBE280:
 967:Src/app.c     ****     display_ld_hand(hand);
 2193              		.loc 1 967 3 is_stmt 1 view .LVU708
 967:Src/app.c     ****     display_ld_hand(hand);
 2194              		.loc 1 967 6 is_stmt 0 view .LVU709
 2195 0210 AB69     		ldr	r3, [r5, #24]
 2196 0212 3BB1     		cbz	r3, .L86
 968:Src/app.c     **** }
 2197              		.loc 1 968 5 is_stmt 1 view .LVU710
 2198 0214 2046     		mov	r0, r4
ARM GAS  /tmp/ccfH4MMM.s 			page 103


 969:Src/app.c     **** 
 2199              		.loc 1 969 1 is_stmt 0 view .LVU711
 2200 0216 14B0     		add	sp, sp, #80
 2201              		.cfi_remember_state
 2202              		.cfi_def_cfa_offset 48
 2203              		@ sp needed
 2204 0218 BDEC048B 		vldm	sp!, {d8-d9}
 2205              		.cfi_restore 82
 2206              		.cfi_restore 83
 2207              		.cfi_restore 80
 2208              		.cfi_restore 81
 2209              		.cfi_def_cfa_offset 32
 2210 021c BDE8F047 		pop	{r4, r5, r6, r7, r8, r9, r10, lr}
 2211              		.cfi_restore 14
 2212              		.cfi_restore 10
 2213              		.cfi_restore 9
 2214              		.cfi_restore 8
 2215              		.cfi_restore 7
 2216              		.cfi_restore 6
 2217              		.cfi_restore 5
 2218              		.cfi_restore 4
 2219              		.cfi_def_cfa_offset 0
 2220              	.LVL168:
 968:Src/app.c     **** }
 2221              		.loc 1 968 5 view .LVU712
 2222 0220 FFF7FEBF 		b	display_ld_hand
 2223              	.LVL169:
 2224              	.L86:
 2225              		.cfi_restore_state
 969:Src/app.c     **** 
 2226              		.loc 1 969 1 view .LVU713
 2227 0224 14B0     		add	sp, sp, #80
 2228              		.cfi_def_cfa_offset 48
 2229              		@ sp needed
 2230 0226 BDEC048B 		vldm	sp!, {d8-d9}
 2231              		.cfi_restore 82
 2232              		.cfi_restore 83
 2233              		.cfi_restore 80
 2234              		.cfi_restore 81
 2235              		.cfi_def_cfa_offset 32
 2236 022a BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2237              	.LVL170:
 2238              	.L108:
 969:Src/app.c     **** 
 2239              		.loc 1 969 1 view .LVU714
 2240 022e 00BF     		.align	2
 2241              	.L107:
 2242 0230 0000FFFF 		.word	-65536
 2243 0234 FF0000FF 		.word	-16776961
 2244              		.cfi_endproc
 2245              	.LFE7389:
 2247              		.global	__aeabi_ul2d
 2248              		.section	.rodata.dp_thread_fct.str1.1,"aMS",%progbits,1
 2249              	.LC12:
 2250 0000 43707520 		.ascii	"Cpu load\000"
 2250      6C6F6164 
 2250      00
ARM GAS  /tmp/ccfH4MMM.s 			page 104


 2251              	.LC13:
 2252 0009 20202025 		.ascii	"   %.1f%%\000"
 2252      2E316625 
 2252      2500
 2253              	.LC14:
 2254 0013 496E6665 		.ascii	"Inferences\000"
 2254      72656E63 
 2254      657300
 2255              	.LC15:
 2256 001e 20706420 		.ascii	" pd %2ums\000"
 2256      2532756D 
 2256      7300
 2257              	.LC16:
 2258 0028 20686C20 		.ascii	" hl %2ums\000"
 2258      2532756D 
 2258      7300
 2259              	.LC17:
 2260 0032 2020252E 		.ascii	"  %.1f FPS\000"
 2260      31662046 
 2260      505300
 2261              		.section	.text.dp_thread_fct,"ax",%progbits
 2262              		.align	1
 2263              		.syntax unified
 2264              		.thumb
 2265              		.thumb_func
 2267              	dp_thread_fct:
 2268              	.LVL171:
 2269              	.LFB7410:
1747:Src/app.c     ****   button_t ld_toggle_button;
 2270              		.loc 1 1747 1 is_stmt 1 view -0
 2271              		.cfi_startproc
 2272              		@ args = 0, pretend = 0, frame = 4616
 2273              		@ frame_needed = 0, uses_anonymous_args = 0
1748:Src/app.c     ****   button_t hd_toggle_button;
 2274              		.loc 1 1748 3 view .LVU716
1749:Src/app.c     ****   uint32_t disp_ms = 0;
 2275              		.loc 1 1749 3 view .LVU717
1750:Src/app.c     ****   display_info_t info;
 2276              		.loc 1 1750 3 view .LVU718
1751:Src/app.c     ****   uint32_t ts;
 2277              		.loc 1 1751 3 view .LVU719
1752:Src/app.c     ****   int ret;
 2278              		.loc 1 1752 3 view .LVU720
1753:Src/app.c     **** 
 2279              		.loc 1 1753 3 view .LVU721
1756:Src/app.c     ****   button_init(&hd_toggle_button, BUTTON_TAMP, on_pd_toggle_button_click, &disp);
 2280              		.loc 1 1756 3 view .LVU722
1747:Src/app.c     ****   button_t ld_toggle_button;
 2281              		.loc 1 1747 1 is_stmt 0 view .LVU723
 2282 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2283              		.cfi_def_cfa_offset 36
 2284              		.cfi_offset 4, -36
 2285              		.cfi_offset 5, -32
 2286              		.cfi_offset 6, -28
 2287              		.cfi_offset 7, -24
 2288              		.cfi_offset 8, -20
 2289              		.cfi_offset 9, -16
ARM GAS  /tmp/ccfH4MMM.s 			page 105


 2290              		.cfi_offset 10, -12
 2291              		.cfi_offset 11, -8
 2292              		.cfi_offset 14, -4
 2293 0004 2DED048B 		vpush.64	{d8, d9}
 2294              		.cfi_def_cfa_offset 52
 2295              		.cfi_offset 80, -52
 2296              		.cfi_offset 81, -48
 2297              		.cfi_offset 82, -44
 2298              		.cfi_offset 83, -40
 2299              	.LBB332:
 2300              	.LBB333:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2301              		.loc 1 492 9 view .LVU724
 2302 0008 0021     		movs	r1, #0
 2303              	.LBE333:
 2304              	.LBE332:
1747:Src/app.c     ****   button_t ld_toggle_button;
 2305              		.loc 1 1747 1 view .LVU725
 2306 000a ADF5905D 		sub	sp, sp, #4608
 2307              		.cfi_def_cfa_offset 4660
 2308              	.LBB337:
 2309              	.LBB334:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2310              		.loc 1 492 9 view .LVU726
 2311 000e 0846     		mov	r0, r1
 2312              	.LVL172:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2313              		.loc 1 492 9 view .LVU727
 2314              	.LBE334:
 2315              	.LBE337:
1747:Src/app.c     ****   button_t ld_toggle_button;
 2316              		.loc 1 1747 1 view .LVU728
 2317 0010 85B0     		sub	sp, sp, #20
 2318              		.cfi_def_cfa_offset 4680
 2319              	.LVL173:
 2320              	.LBB338:
 2321              	.LBI332:
 488:Src/app.c     **** {
 2322              		.loc 1 488 13 is_stmt 1 view .LVU729
 2323              	.LBB335:
 490:Src/app.c     **** 
 2324              		.loc 1 490 3 view .LVU730
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2325              		.loc 1 492 3 view .LVU731
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2326              		.loc 1 492 9 is_stmt 0 view .LVU732
 2327 0012 FFF7FEFF 		bl	BSP_PB_Init
 2328              	.LVL174:
 493:Src/app.c     **** 
 2329              		.loc 1 493 3 is_stmt 1 view .LVU733
 2330 0016 0146     		mov	r1, r0
 2331 0018 08B1     		cbz	r0, .L110
 2332              	.LVL175:
 2333              	.L111:
 493:Src/app.c     **** 
 2334              		.loc 1 493 3 is_stmt 0 view .LVU734
 2335 001a FFF7FEFF 		bl	button_init.part.0
ARM GAS  /tmp/ccfH4MMM.s 			page 106


 2336              	.LVL176:
 2337              	.L110:
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2338              		.loc 1 495 3 is_stmt 1 view .LVU735
 496:Src/app.c     ****   b->prev_state = 0;
 2339              		.loc 1 496 23 is_stmt 0 view .LVU736
 2340 001e 9A4A     		ldr	r2, .L127+8
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2341              		.loc 1 495 16 view .LVU737
 2342 0020 03AB     		add	r3, sp, #12
 2343              	.LVL177:
 498:Src/app.c     **** }
 2344              		.loc 1 498 14 view .LVU738
 2345 0022 9A4F     		ldr	r7, .L127+12
 497:Src/app.c     ****   b->cb_args = cb_args;
 2346              		.loc 1 497 17 view .LVU739
 2347 0024 C3E90102 		strd	r0, r2, [r3, #4]
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2348              		.loc 1 495 16 view .LVU740
 2349 0028 1870     		strb	r0, [r3]
 496:Src/app.c     ****   b->prev_state = 0;
 2350              		.loc 1 496 3 is_stmt 1 view .LVU741
 498:Src/app.c     **** }
 2351              		.loc 1 498 3 view .LVU742
 2352              	.LBE335:
 2353              	.LBE338:
 2354              	.LBB339:
 2355              	.LBB340:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2356              		.loc 1 492 9 is_stmt 0 view .LVU743
 2357 002a 0120     		movs	r0, #1
 2358              	.LVL178:
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2359              		.loc 1 492 9 view .LVU744
 2360              	.LBE340:
 2361              	.LBE339:
 2362              	.LBB344:
 2363              	.LBB336:
 498:Src/app.c     **** }
 2364              		.loc 1 498 14 view .LVU745
 2365 002c DF60     		str	r7, [r3, #12]
 2366              	.LVL179:
 498:Src/app.c     **** }
 2367              		.loc 1 498 14 view .LVU746
 2368              	.LBE336:
 2369              	.LBE344:
1757:Src/app.c     **** #else
 2370              		.loc 1 1757 3 is_stmt 1 view .LVU747
 2371              	.LBB345:
 2372              	.LBI339:
 488:Src/app.c     **** {
 2373              		.loc 1 488 13 view .LVU748
 2374              	.LBB341:
 490:Src/app.c     **** 
 2375              		.loc 1 490 3 view .LVU749
 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2376              		.loc 1 492 3 view .LVU750
ARM GAS  /tmp/ccfH4MMM.s 			page 107


 492:Src/app.c     ****   assert(ret == BSP_ERROR_NONE);
 2377              		.loc 1 492 9 is_stmt 0 view .LVU751
 2378 002e FFF7FEFF 		bl	BSP_PB_Init
 2379              	.LVL180:
 493:Src/app.c     **** 
 2380              		.loc 1 493 3 is_stmt 1 view .LVU752
 2381 0032 0028     		cmp	r0, #0
 2382 0034 F1D1     		bne	.L111
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2383              		.loc 1 495 3 view .LVU753
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2384              		.loc 1 495 16 is_stmt 0 view .LVU754
 2385 0036 0122     		movs	r2, #1
 2386              	.LBE341:
 2387              	.LBE345:
1750:Src/app.c     ****   display_info_t info;
 2388              		.loc 1 1750 12 view .LVU755
 2389 0038 0446     		mov	r4, r0
 2390              	.LBB346:
 2391              	.LBB347:
 2392              	.LBB348:
 2393              	.LBB349:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2394              		.loc 1 553 35 view .LVU756
 2395 003a 9FED919B 		vldr.64	d9, .L127
 2396              	.LBE349:
 2397              	.LBE348:
 2398              	.LBE347:
 2399              	.LBE346:
 2400              	.LBB361:
 2401              	.LBB342:
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2402              		.loc 1 495 16 view .LVU757
 2403 003e 8DF81C20 		strb	r2, [sp, #28]
 496:Src/app.c     ****   b->prev_state = 0;
 2404              		.loc 1 496 3 is_stmt 1 view .LVU758
 496:Src/app.c     ****   b->prev_state = 0;
 2405              		.loc 1 496 23 is_stmt 0 view .LVU759
 2406 0042 934A     		ldr	r2, .L127+16
 495:Src/app.c     ****   b->on_click_handler = on_click_handler;
 2407              		.loc 1 495 16 view .LVU760
 2408 0044 07AB     		add	r3, sp, #28
 2409              	.LVL181:
 497:Src/app.c     ****   b->cb_args = cb_args;
 2410              		.loc 1 497 17 view .LVU761
 2411 0046 C3E90102 		strd	r0, r2, [r3, #4]
 498:Src/app.c     **** }
 2412              		.loc 1 498 3 is_stmt 1 view .LVU762
 2413              	.LBE342:
 2414              	.LBE361:
 2415              	.LBB362:
 2416              	.LBB363:
1691:Src/app.c     ****   assert(ret == HAL_OK);
 2417              		.loc 1 1691 47 is_stmt 0 view .LVU763
 2418 004a DFF88C92 		ldr	r9, .L127+88
 2419              	.LBE363:
 2420              	.LBE362:
ARM GAS  /tmp/ccfH4MMM.s 			page 108


 2421              	.LBB369:
 2422              	.LBB343:
 498:Src/app.c     **** }
 2423              		.loc 1 498 14 view .LVU764
 2424 004e DF60     		str	r7, [r3, #12]
 2425              	.LVL182:
 2426              	.L121:
 498:Src/app.c     **** }
 2427              		.loc 1 498 14 view .LVU765
 2428              	.LBE343:
 2429              	.LBE369:
1762:Src/app.c     ****   {
 2430              		.loc 1 1762 3 is_stmt 1 view .LVU766
1764:Src/app.c     ****     assert(ret == pdTRUE);
 2431              		.loc 1 1764 5 view .LVU767
1764:Src/app.c     ****     assert(ret == pdTRUE);
 2432              		.loc 1 1764 11 is_stmt 0 view .LVU768
 2433 0050 4FF0FF31 		mov	r1, #-1
 2434 0054 3868     		ldr	r0, [r7]
 2435 0056 FFF7FEFF 		bl	xQueueSemaphoreTake
 2436              	.LVL183:
1765:Src/app.c     **** 
 2437              		.loc 1 1765 5 is_stmt 1 view .LVU769
 2438 005a 0128     		cmp	r0, #1
 2439 005c 06D0     		beq	.L112
1765:Src/app.c     **** 
 2440              		.loc 1 1765 5 is_stmt 0 discriminator 1 view .LVU770
 2441 005e 40F2E561 		movw	r1, #1765
 2442 0062 8C4B     		ldr	r3, .L127+20
 2443 0064 8C4A     		ldr	r2, .L127+24
 2444              	.LVL184:
 2445              	.L126:
1771:Src/app.c     ****     info = disp.info;
 2446              		.loc 1 1771 5 discriminator 1 view .LVU771
 2447 0066 8D48     		ldr	r0, .L127+28
 2448 0068 FFF7FEFF 		bl	__assert_func
 2449              	.LVL185:
 2450              	.L112:
1767:Src/app.c     ****     button_process(&hd_toggle_button);
 2451              		.loc 1 1767 5 is_stmt 1 view .LVU772
 2452 006c 03A8     		add	r0, sp, #12
 2453              	.LVL186:
1767:Src/app.c     ****     button_process(&hd_toggle_button);
 2454              		.loc 1 1767 5 is_stmt 0 view .LVU773
 2455 006e FFF7FEFF 		bl	button_process
 2456              	.LVL187:
1768:Src/app.c     **** 
 2457              		.loc 1 1768 5 is_stmt 1 view .LVU774
 2458 0072 07A8     		add	r0, sp, #28
 2459 0074 FFF7FEFF 		bl	button_process
 2460              	.LVL188:
1770:Src/app.c     ****     assert(ret == pdTRUE);
 2461              		.loc 1 1770 5 view .LVU775
1770:Src/app.c     ****     assert(ret == pdTRUE);
 2462              		.loc 1 1770 11 is_stmt 0 view .LVU776
 2463 0078 4FF0FF31 		mov	r1, #-1
 2464 007c 786D     		ldr	r0, [r7, #84]
ARM GAS  /tmp/ccfH4MMM.s 			page 109


 2465 007e FFF7FEFF 		bl	xQueueSemaphoreTake
 2466              	.LVL189:
1771:Src/app.c     ****     info = disp.info;
 2467              		.loc 1 1771 5 is_stmt 1 view .LVU777
 2468 0082 0128     		cmp	r0, #1
 2469 0084 04D0     		beq	.L113
1771:Src/app.c     ****     info = disp.info;
 2470              		.loc 1 1771 5 is_stmt 0 discriminator 1 view .LVU778
 2471 0086 40F2EB61 		movw	r1, #1771
 2472 008a 824B     		ldr	r3, .L127+20
 2473 008c 824A     		ldr	r2, .L127+24
 2474 008e EAE7     		b	.L126
 2475              	.L113:
1772:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2476              		.loc 1 1772 5 is_stmt 1 view .LVU779
1772:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2477              		.loc 1 1772 10 is_stmt 0 view .LVU780
 2478 0090 0BAE     		add	r6, sp, #44
 2479 0092 41F2E412 		movw	r2, #4580
 2480 0096 8249     		ldr	r1, .L127+32
 2481 0098 3046     		mov	r0, r6
 2482              	.LVL190:
1772:Src/app.c     ****     ret = xSemaphoreGive(disp.lock);
 2483              		.loc 1 1772 10 view .LVU781
 2484 009a FFF7FEFF 		bl	memcpy
 2485              	.LVL191:
1773:Src/app.c     ****     assert(ret == pdTRUE);
 2486              		.loc 1 1773 5 is_stmt 1 view .LVU782
1773:Src/app.c     ****     assert(ret == pdTRUE);
 2487              		.loc 1 1773 11 is_stmt 0 view .LVU783
 2488 009e 0023     		movs	r3, #0
 2489 00a0 786D     		ldr	r0, [r7, #84]
 2490 00a2 1A46     		mov	r2, r3
 2491 00a4 1946     		mov	r1, r3
 2492 00a6 FFF7FEFF 		bl	xQueueGenericSend
 2493              	.LVL192:
1774:Src/app.c     ****     info.disp_ms = disp_ms;
 2494              		.loc 1 1774 5 view .LVU784
 2495 00aa 0128     		cmp	r0, #1
1773:Src/app.c     ****     assert(ret == pdTRUE);
 2496              		.loc 1 1773 11 view .LVU785
 2497 00ac 0546     		mov	r5, r0
 2498              	.LVL193:
1774:Src/app.c     ****     info.disp_ms = disp_ms;
 2499              		.loc 1 1774 5 is_stmt 1 view .LVU786
 2500 00ae 04D0     		beq	.L114
1774:Src/app.c     ****     info.disp_ms = disp_ms;
 2501              		.loc 1 1774 5 is_stmt 0 discriminator 1 view .LVU787
 2502 00b0 40F2EE61 		movw	r1, #1774
 2503 00b4 774B     		ldr	r3, .L127+20
 2504 00b6 784A     		ldr	r2, .L127+24
 2505 00b8 D5E7     		b	.L126
 2506              	.L114:
1775:Src/app.c     **** 
 2507              		.loc 1 1775 5 is_stmt 1 view .LVU788
1775:Src/app.c     **** 
 2508              		.loc 1 1775 18 is_stmt 0 view .LVU789
ARM GAS  /tmp/ccfH4MMM.s 			page 110


 2509 00ba 7461     		str	r4, [r6, #20]
1777:Src/app.c     ****     dp_update_drawing_area();
 2510              		.loc 1 1777 5 is_stmt 1 view .LVU790
1777:Src/app.c     ****     dp_update_drawing_area();
 2511              		.loc 1 1777 10 is_stmt 0 view .LVU791
 2512 00bc FFF7FEFF 		bl	HAL_GetTick
 2513              	.LVL194:
1777:Src/app.c     ****     dp_update_drawing_area();
 2514              		.loc 1 1777 10 view .LVU792
 2515 00c0 8246     		mov	r10, r0
 2516              	.LVL195:
1778:Src/app.c     ****     Display_NetworkOutput(&info);
 2517              		.loc 1 1778 5 is_stmt 1 view .LVU793
 2518              	.LBB370:
 2519              	.LBI362:
1686:Src/app.c     **** {
 2520              		.loc 1 1686 13 view .LVU794
 2521              	.LBB368:
1688:Src/app.c     **** 
 2522              		.loc 1 1688 3 view .LVU795
1690:Src/app.c     ****   ret = SCRL_SetAddress_NoReload(lcd_fg_buffer[lcd_fg_buffer_rd_idx], SCRL_LAYER_1);
 2523              		.loc 1 1690 3 view .LVU796
 2524              	.LBB364:
 2525              	.LBI364:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 273:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 274:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 275:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 276:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Memory Barrier
 277:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
 278:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 279:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 280:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 281:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 282:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 283:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 284:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 285:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 286:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 287:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 288:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 289:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 290:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 291:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 292:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 293:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 294:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 295:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_bswap32(value);
 296:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 297:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 298:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 299:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 300:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 301:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 302:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 111


 305:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 306:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 307:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 308:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 309:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 310:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 311:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 312:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 313:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 314:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 315:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 316:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 317:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 318:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 320:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 321:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 322:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 323:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 324:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 325:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 326:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 327:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 328:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 329:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 330:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 331:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   int16_t result;
 332:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 333:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 334:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 335:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 336:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 337:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 338:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 339:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 340:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 341:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 342:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 343:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 344:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 345:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 346:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 347:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 348:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   op2 %= 32U;
 349:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (op2 == 0U)
 350:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 351:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     return op1;
 352:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 353:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 354:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 355:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 356:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 357:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 358:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Breakpoint
 359:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 360:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 361:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
ARM GAS  /tmp/ccfH4MMM.s 			page 112


 362:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 363:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 364:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 365:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 366:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 367:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 368:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Reverse bit order of value
 369:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 370:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 371:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Reversed value
 372:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 374:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 376:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 377:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 378:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 379:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 380:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 381:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 382:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
 383:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 384:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   result = value;                      /* r will be reversed bits of v; first get LSB of v */
 385:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   for (value >>= 1U; value != 0U; value >>= 1U)
 386:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 387:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     result <<= 1U;
 388:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     result |= value & 1U;
 389:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     s--;
 390:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 391:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   result <<= s;                        /* shift when v's highest bits are zero */
 392:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 393:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return result;
 394:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 395:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 396:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 398:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Count leading zeros
 399:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Counts the number of leading zeros of a data value.
 400:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to count the leading zeros
 401:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             number of leading zeros in value
 402:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 403:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t value)
 404:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 405:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Even though __builtin_clz produces a CLZ instruction on ARM, formally
 406:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      __builtin_clz(0) is undefined behaviour, so handle this case specially.
 407:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      This guarantees ARM-compatible results if happening to compile on a non-ARM
 408:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      target, and ensures the compiler doesn't decide to activate any
 409:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      optimisations using the logic "value was passed to __builtin_clz, so it
 410:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      is non-zero".
 411:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
 412:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      single CLZ instruction.
 413:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    */
 414:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (value == 0U)
 415:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 416:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     return 32U;
 417:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return __builtin_clz(value);
ARM GAS  /tmp/ccfH4MMM.s 			page 113


 419:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 420:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 424:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 426:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (8 bit)
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 8 bit value.
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 432:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 434:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 435:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 436:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 437:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 438:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 439:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 440:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 441:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 442:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 443:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 444:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);    /* Add explicit type cast here */
 445:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 446:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 447:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 448:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 449:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (16 bit)
 450:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 16 bit values.
 451:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 452:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 453:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 454:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDREXH(volatile uint16_t *addr)
 455:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 456:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 457:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 458:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 459:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
 460:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 461:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 462:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 463:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 464:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
 465:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 466:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);    /* Add explicit type cast here */
 467:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 468:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 469:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 470:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 471:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDR Exclusive (32 bit)
 472:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive LDR instruction for 32 bit values.
 473:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 474:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 475:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
ARM GAS  /tmp/ccfH4MMM.s 			page 114


 476:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
 477:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 478:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 479:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 480:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 481:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 482:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 483:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 484:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 485:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 486:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (8 bit)
 487:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 8 bit values.
 488:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 489:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 490:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 491:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 492:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 493:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
 494:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 495:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 496:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 497:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 498:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 499:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 500:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 501:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 502:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 503:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (16 bit)
 504:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 16 bit values.
 505:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 506:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 507:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 508:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 509:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 510:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
 511:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 512:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 513:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 514:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 515:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 516:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 517:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 518:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 519:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 520:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STR Exclusive (32 bit)
 521:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a exclusive STR instruction for 32 bit values.
 522:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 523:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 524:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 525:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 526:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 527:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
 528:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 529:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 530:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 531:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 532:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
ARM GAS  /tmp/ccfH4MMM.s 			page 115


 533:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 534:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 535:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 536:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 537:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Remove the exclusive lock
 538:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Removes the exclusive lock which is created by LDREX.
 539:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 540:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __CLREX(void)
 541:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 542:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("clrex" ::: "memory");
 543:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 544:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 545:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 546:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 547:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 548:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 549:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 550:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 551:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 552:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 553:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 554:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 555:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Signed Saturate
 556:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates a signed value.
 557:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG1  Value to be saturated
 558:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG2  Bit position to saturate to (1..32)
 559:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 560:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 561:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __SSAT(ARG1, ARG2) \
 562:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __extension__ \
 563:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** ({                          \
 564:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   int32_t __RES, __ARG1 = (ARG1); \
 565:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) : "cc" ); \
 566:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __RES; \
 567:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  })
 568:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 569:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 570:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 571:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Unsigned Saturate
 572:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates an unsigned value.
 573:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG1  Value to be saturated
 574:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  ARG2  Bit position to saturate to (0..31)
 575:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 576:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 577:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #define __USAT(ARG1, ARG2) \
 578:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __extension__ \
 579:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** ({                          \
 580:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t __RES, __ARG1 = (ARG1); \
 581:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) : "cc" ); \
 582:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __RES; \
 583:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  })
 584:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 585:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 586:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 587:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Rotate Right with Extend (32 bit)
 588:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Moves each bit of a bitstring right by one bit.
 589:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            The carry input is shifted in at the left end of the bitstring.
ARM GAS  /tmp/ccfH4MMM.s 			page 116


 590:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    value  Value to rotate
 591:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Rotated value
 592:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 593:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RRX(uint32_t value)
 594:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 595:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 596:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 597:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 598:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 599:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 600:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 601:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 602:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 603:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (8 bit)
 604:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 8 bit value.
 605:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 606:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 607:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 608:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDRBT(volatile uint8_t *ptr)
 609:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 610:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 611:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 612:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 613:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*ptr) );
 614:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 615:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 616:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 617:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 618:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
 619:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 620:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);    /* Add explicit type cast here */
 621:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 622:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 623:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 624:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 625:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (16 bit)
 626:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 16 bit values.
 627:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 628:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 629:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 630:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDRHT(volatile uint16_t *ptr)
 631:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 632:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 633:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 634:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 635:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*ptr) );
 636:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 637:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
 638:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****        accepted by assembler. So has to use following less efficient pattern.
 639:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     */
 640:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (ptr) : "memory" );
 641:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 642:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);    /* Add explicit type cast here */
 643:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 644:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 645:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 646:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
ARM GAS  /tmp/ccfH4MMM.s 			page 117


 647:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   LDRT Unprivileged (32 bit)
 648:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged LDRT instruction for 32 bit values.
 649:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 650:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 651:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 652:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDRT(volatile uint32_t *ptr)
 653:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 654:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 655:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 656:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*ptr) );
 657:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 658:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 659:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 660:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 661:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 662:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (8 bit)
 663:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 8 bit values.
 664:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 665:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 666:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 667:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRBT(uint8_t value, volatile uint8_t *ptr)
 668:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 669:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strbt %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
 670:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 671:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 672:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 673:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 674:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (16 bit)
 675:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 16 bit values.
 676:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 677:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 678:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 679:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRHT(uint16_t value, volatile uint16_t *ptr)
 680:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 681:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strht %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) );
 682:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 683:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 684:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 685:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 686:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   STRT Unprivileged (32 bit)
 687:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a Unprivileged STRT instruction for 32 bit values.
 688:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 689:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 690:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 691:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STRT(uint32_t value, volatile uint32_t *ptr)
 692:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 693:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("strt %1, %0" : "=Q" (*ptr) : "r" (value) );
 694:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 695:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 696:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #else  /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 697:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 698:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 699:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 700:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 701:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Signed Saturate
 702:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates a signed value.
 703:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to be saturated
ARM GAS  /tmp/ccfH4MMM.s 			page 118


 704:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    sat  Bit position to saturate to (1..32)
 705:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 706:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 707:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)
 708:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 709:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if ((sat >= 1U) && (sat <= 32U))
 710:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 711:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
 712:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const int32_t min = -1 - max ;
 713:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     if (val > max)
 714:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 715:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return max;
 716:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 717:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     else if (val < min)
 718:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 719:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return min;
 720:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 721:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 722:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return val;
 723:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 724:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 725:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 726:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Unsigned Saturate
 727:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Saturates an unsigned value.
 728:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to be saturated
 729:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    sat  Bit position to saturate to (0..31)
 730:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             Saturated value
 731:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 732:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)
 733:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 734:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   if (sat <= 31U)
 735:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   {
 736:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     const uint32_t max = ((1U << sat) - 1U);
 737:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     if (val > (int32_t)max)
 738:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 739:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return max;
 740:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 741:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     else if (val < 0)
 742:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     {
 743:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****       return 0U;
 744:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 745:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 746:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   return (uint32_t)val;
 747:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 748:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 749:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 750:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 751:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 752:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 753:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 754:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 755:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 756:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 757:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (8 bit)
 758:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAB instruction for 8 bit value.
 759:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 760:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
ARM GAS  /tmp/ccfH4MMM.s 			page 119


 761:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 762:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDAB(volatile uint8_t *ptr)
 763:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 764:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 765:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 766:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldab %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 767:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);
 768:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 769:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 770:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 771:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 772:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (16 bit)
 773:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAH instruction for 16 bit values.
 774:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 775:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 776:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 777:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDAH(volatile uint16_t *ptr)
 778:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 779:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 780:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 781:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldah %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 782:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);
 783:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 784:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 785:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 786:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 787:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire (32 bit)
 788:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDA instruction for 32 bit values.
 789:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 790:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 791:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 792:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDA(volatile uint32_t *ptr)
 793:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 794:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 795:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 796:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("lda %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 797:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 798:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 799:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 800:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 801:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 802:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (8 bit)
 803:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLB instruction for 8 bit values.
 804:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 805:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 806:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 807:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STLB(uint8_t value, volatile uint8_t *ptr)
 808:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 809:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlb %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 810:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 811:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 812:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 813:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 814:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (16 bit)
 815:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLH instruction for 16 bit values.
 816:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 817:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
ARM GAS  /tmp/ccfH4MMM.s 			page 120


 818:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 819:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STLH(uint16_t value, volatile uint16_t *ptr)
 820:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 821:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlh %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 822:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 823:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 824:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 825:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 826:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release (32 bit)
 827:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STL instruction for 32 bit values.
 828:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 829:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 830:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 831:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __STL(uint32_t value, volatile uint32_t *ptr)
 832:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 833:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stl %1, %0" : "=Q" (*ptr) : "r" ((uint32_t)value) : "memory" );
 834:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 835:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 836:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 837:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 838:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (8 bit)
 839:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAB exclusive instruction for 8 bit value.
 840:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 841:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return             value of type uint8_t at (*ptr)
 842:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 843:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint8_t __LDAEXB(volatile uint8_t *ptr)
 844:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 845:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 846:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 847:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaexb %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 848:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint8_t) result);
 849:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 850:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 851:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 852:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 853:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (16 bit)
 854:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDAH exclusive instruction for 16 bit values.
 855:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 856:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint16_t at (*ptr)
 857:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 858:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint16_t __LDAEXH(volatile uint16_t *ptr)
 859:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 860:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 861:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 862:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaexh %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 863:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return ((uint16_t) result);
 864:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 865:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 866:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 867:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 868:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Load-Acquire Exclusive (32 bit)
 869:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a LDA exclusive instruction for 32 bit values.
 870:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to data
 871:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return        value of type uint32_t at (*ptr)
 872:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 873:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __LDAEX(volatile uint32_t *ptr)
 874:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccfH4MMM.s 			page 121


 875:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t result;
 876:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 877:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("ldaex %0, %1" : "=r" (result) : "Q" (*ptr) : "memory" );
 878:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 879:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 880:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 881:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 882:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 883:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (8 bit)
 884:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLB exclusive instruction for 8 bit values.
 885:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 886:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 887:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 888:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 889:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 890:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEXB(uint8_t value, volatile uint8_t *ptr)
 891:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 892:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 893:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 894:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlexb %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "mem
 895:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 896:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 897:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 898:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 899:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 900:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (16 bit)
 901:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STLH exclusive instruction for 16 bit values.
 902:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 903:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 904:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 905:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 906:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 907:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEXH(uint16_t value, volatile uint16_t *ptr)
 908:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 909:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 910:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 911:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlexh %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "mem
 912:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 913:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 914:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 915:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 916:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 917:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Store-Release Exclusive (32 bit)
 918:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Executes a STL exclusive instruction for 32 bit values.
 919:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]  value  Value to store
 920:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    ptr  Pointer to location
 921:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          0  Function succeeded
 922:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \return          1  Function failed
 923:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 924:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __STLEX(uint32_t value, volatile uint32_t *ptr)
 925:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 926:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    uint32_t result;
 927:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 928:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    __ASM volatile ("stlex %0, %2, %1" : "=&r" (result), "=Q" (*ptr) : "r" ((uint32_t)value) : "memo
 929:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****    return(result);
 930:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 931:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccfH4MMM.s 			page 122


 932:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 933:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 934:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 935:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /*@}*/ /* end of group CMSIS_Core_InstructionInterface */
 936:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 937:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 938:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 939:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 940:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 941:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 942:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 943:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 944:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 945:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 946:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing special-purpose register PRIMASK.
 947:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 948:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 950:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 952:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 953:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 954:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 955:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 956:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 957:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
 958:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 959:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 960:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 2526              		.loc 4 960 27 view .LVU797
 2527              	.LBB365:
 961:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 962:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 2528              		.loc 4 962 3 view .LVU798
 2529              		.syntax unified
 2530              	@ 962 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2531 00c2 72B6     		cpsid i
 2532              	@ 0 "" 2
 2533              		.thumb
 2534              		.syntax unified
 2535              	.LBE365:
 2536              	.LBE364:
1691:Src/app.c     ****   assert(ret == HAL_OK);
 2537              		.loc 1 1691 3 view .LVU799
1691:Src/app.c     ****   assert(ret == HAL_OK);
 2538              		.loc 1 1691 47 is_stmt 0 view .LVU800
 2539 00c4 DFF81482 		ldr	r8, .L127+92
 2540 00c8 D9F80030 		ldr	r3, [r9]
1691:Src/app.c     ****   assert(ret == HAL_OK);
 2541              		.loc 1 1691 9 view .LVU801
 2542 00cc 7548     		ldr	r0, .L127+36
 2543              	.LVL196:
1691:Src/app.c     ****   assert(ret == HAL_OK);
 2544              		.loc 1 1691 9 view .LVU802
 2545 00ce 2946     		mov	r1, r5
 2546 00d0 00FB0380 		mla	r0, r0, r3, r8
 2547 00d4 FFF7FEFF 		bl	SCRL_SetAddress_NoReload
ARM GAS  /tmp/ccfH4MMM.s 			page 123


 2548              	.LVL197:
1692:Src/app.c     ****   __enable_irq();
 2549              		.loc 1 1692 3 is_stmt 1 view .LVU803
 2550 00d8 8346     		mov	fp, r0
 2551 00da 20B1     		cbz	r0, .L115
1692:Src/app.c     ****   __enable_irq();
 2552              		.loc 1 1692 3 is_stmt 0 discriminator 1 view .LVU804
 2553 00dc 40F29C61 		movw	r1, #1692
 2554 00e0 714B     		ldr	r3, .L127+40
 2555 00e2 724A     		ldr	r2, .L127+44
 2556 00e4 BFE7     		b	.L126
 2557              	.L115:
1693:Src/app.c     **** }
 2558              		.loc 1 1693 3 is_stmt 1 view .LVU805
 2559              	.LBB366:
 2560              	.LBI366:
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2561              		.loc 4 949 27 view .LVU806
 2562              	.LBB367:
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2563              		.loc 4 951 3 view .LVU807
 2564              		.syntax unified
 2565              	@ 951 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2566 00e6 62B6     		cpsie i
 2567              	@ 0 "" 2
 2568              	.LVL198:
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2569              		.loc 4 951 3 is_stmt 0 view .LVU808
 2570              		.thumb
 2571              		.syntax unified
 2572              	.LBE367:
 2573              	.LBE366:
 2574              	.LBE368:
 2575              	.LBE370:
1779:Src/app.c     ****     SCB_CleanDCache_by_Addr(lcd_fg_buffer[lcd_fg_buffer_rd_idx], LCD_FG_WIDTH * LCD_FG_HEIGHT* 2);
 2576              		.loc 1 1779 5 is_stmt 1 view .LVU809
 2577              	.LBB371:
 2578              	.LBI346:
 977:Src/app.c     **** {
 2579              		.loc 1 977 13 view .LVU810
 2580              	.LBB360:
 979:Src/app.c     ****   int line_nb = 0;
 2581              		.loc 1 979 3 view .LVU811
 980:Src/app.c     ****   float nn_fps;
 2582              		.loc 1 980 3 view .LVU812
 981:Src/app.c     ****   int i;
 2583              		.loc 1 981 3 view .LVU813
 982:Src/app.c     **** 
 2584              		.loc 1 982 3 view .LVU814
 985:Src/app.c     **** 
 2585              		.loc 1 985 3 view .LVU815
 2586              	.LBB352:
 2587              	.LBB353:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2588              		.loc 1 531 24 is_stmt 0 view .LVU816
 2589 00e8 714C     		ldr	r4, .L127+48
 2590              	.LVL199:
ARM GAS  /tmp/ccfH4MMM.s 			page 124


 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2591              		.loc 1 531 24 view .LVU817
 2592              	.LBE353:
 2593              	.LBE352:
 985:Src/app.c     **** 
 2594              		.loc 1 985 3 view .LVU818
 2595 00ea 4FF4F073 		mov	r3, #480
 2596 00ee 4FF44872 		mov	r2, #800
 2597 00f2 0146     		mov	r1, r0
 2598 00f4 0090     		str	r0, [sp]
 2599              	.LBB356:
 2600              	.LBB354:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2601              		.loc 1 531 24 view .LVU819
 2602 00f6 04F13805 		add	r5, r4, #56
 2603              	.LVL200:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2604              		.loc 1 531 24 view .LVU820
 2605 00fa 04F12006 		add	r6, r4, #32
 2606              	.LVL201:
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2607              		.loc 1 531 24 view .LVU821
 2608              	.LBE354:
 2609              	.LBE356:
 985:Src/app.c     **** 
 2610              		.loc 1 985 3 view .LVU822
 2611 00fe FFF7FEFF 		bl	UTIL_LCD_FillRect
 2612              	.LVL202:
 988:Src/app.c     ****   cpuload_get_info(&cpu_load, NULL, &cpu_load_one_second, NULL);
 2613              		.loc 1 988 3 is_stmt 1 view .LVU823
 2614              	.LBB357:
 2615              	.LBI352:
 527:Src/app.c     **** {
 2616              		.loc 1 527 13 view .LVU824
 2617              	.LBB355:
 529:Src/app.c     **** 
 2618              		.loc 1 529 3 view .LVU825
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2619              		.loc 1 531 3 view .LVU826
 531:Src/app.c     ****   cpu_load->history[0].total = portGET_RUN_TIME_COUNTER_VALUE();
 2620              		.loc 1 531 24 is_stmt 0 view .LVU827
 2621 0102 0FCE     		ldmia	r6!, {r0, r1, r2, r3}
 2622 0104 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 2623 0106 96E80300 		ldm	r6, {r0, r1}
 2624 010a 85E80300 		stm	r5, {r0, r1}
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2625              		.loc 1 532 3 is_stmt 1 view .LVU828
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2626              		.loc 1 532 32 is_stmt 0 view .LVU829
 2627 010e FFF7FEFF 		bl	TIM4_Get_Value
 2628              	.LVL203:
 2629 0112 0546     		mov	r5, r0
 532:Src/app.c     ****   cpu_load->history[0].thread = cpu_load->history[0].total - ulTaskGetIdleRunTimeCounter();
 2630              		.loc 1 532 30 discriminator 1 view .LVU830
 2631 0114 C4E9080B 		strd	r0, fp, [r4, #32]
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2632              		.loc 1 533 3 is_stmt 1 view .LVU831
ARM GAS  /tmp/ccfH4MMM.s 			page 125


 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2633              		.loc 1 533 62 is_stmt 0 view .LVU832
 2634 0118 FFF7FEFF 		bl	ulTaskGetIdleRunTimeCounter
 2635              	.LVL204:
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2636              		.loc 1 533 60 discriminator 1 view .LVU833
 2637 011c 2D1A     		subs	r5, r5, r0
 2638 011e 63EB0303 		sbc	r3, r3, r3
 533:Src/app.c     ****   cpu_load->history[0].tick = HAL_GetTick();
 2639              		.loc 1 533 31 discriminator 1 view .LVU834
 2640 0122 C4E90A53 		strd	r5, r3, [r4, #40]
 534:Src/app.c     **** 
 2641              		.loc 1 534 3 is_stmt 1 view .LVU835
 534:Src/app.c     **** 
 2642              		.loc 1 534 31 is_stmt 0 view .LVU836
 2643 0126 FFF7FEFF 		bl	HAL_GetTick
 2644              	.LVL205:
 536:Src/app.c     ****     return ;
 2645              		.loc 1 536 33 view .LVU837
 2646 012a A36C     		ldr	r3, [r4, #72]
 2647 012c 226E     		ldr	r2, [r4, #96]
 534:Src/app.c     **** 
 2648              		.loc 1 534 29 discriminator 1 view .LVU838
 2649 012e 2063     		str	r0, [r4, #48]
 536:Src/app.c     ****     return ;
 2650              		.loc 1 536 3 is_stmt 1 view .LVU839
 536:Src/app.c     ****     return ;
 2651              		.loc 1 536 33 is_stmt 0 view .LVU840
 2652 0130 9B1A     		subs	r3, r3, r2
 536:Src/app.c     ****     return ;
 2653              		.loc 1 536 6 view .LVU841
 2654 0132 B3F57A7F 		cmp	r3, #1000
 2655 0136 06D3     		bcc	.L116
 540:Src/app.c     **** }
 2656              		.loc 1 540 55 view .LVU842
 2657 0138 9022     		movs	r2, #144
 2658 013a 04F13801 		add	r1, r4, #56
 2659 013e 04F15000 		add	r0, r4, #80
 2660 0142 FFF7FEFF 		bl	memmove
 2661              	.LVL206:
 2662              	.L116:
 540:Src/app.c     **** }
 2663              		.loc 1 540 55 view .LVU843
 2664              	.LBE355:
 2665              	.LBE357:
 989:Src/app.c     **** 
 2666              		.loc 1 989 3 is_stmt 1 view .LVU844
 2667              	.LBB358:
 2668              	.LBI348:
 546:Src/app.c     ****                              float *cpu_load_last_five_seconds)
 2669              		.loc 1 546 13 view .LVU845
 2670              	.LBB350:
 549:Src/app.c     ****     *cpu_load_last = 100.0 * (cpu_load->history[0].thread - cpu_load->history[1].thread) /
 2671              		.loc 1 549 3 view .LVU846
 552:Src/app.c     ****     *cpu_load_last_second = 100.0 * (cpu_load->history[2].thread - cpu_load->history[3].thread) /
 2672              		.loc 1 552 3 view .LVU847
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
ARM GAS  /tmp/ccfH4MMM.s 			page 126


 2673              		.loc 1 553 5 view .LVU848
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2674              		.loc 1 553 66 is_stmt 0 view .LVU849
 2675 0146 D4E91C23 		ldrd	r2, r3, [r4, #112]
 2676 014a D4E91601 		ldrd	r0, r1, [r4, #88]
 2677 014e 801A     		subs	r0, r0, r2
 2678 0150 61EB0301 		sbc	r1, r1, r3
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2679              		.loc 1 553 35 view .LVU850
 2680 0154 FFF7FEFF 		bl	__aeabi_ul2d
 2681              	.LVL207:
 554:Src/app.c     ****   if (cpu_load_last_five_seconds)
 2682              		.loc 1 554 50 view .LVU851
 2683 0158 D4E91A32 		ldrd	r3, r2, [r4, #104]
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2684              		.loc 1 553 35 view .LVU852
 2685 015c 41EC180B 		vmov	d8, r0, r1
 554:Src/app.c     ****   if (cpu_load_last_five_seconds)
 2686              		.loc 1 554 50 view .LVU853
 2687 0160 D4E91401 		ldrd	r0, r1, [r4, #80]
 2688 0164 C01A     		subs	r0, r0, r3
 2689 0166 61EB0201 		sbc	r1, r1, r2
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2690              		.loc 1 553 97 view .LVU854
 2691 016a FFF7FEFF 		bl	__aeabi_ul2d
 2692              	.LVL208:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2693              		.loc 1 553 35 view .LVU855
 2694 016e 28EE098B 		vmul.f64	d8, d8, d9
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2695              		.loc 1 553 97 view .LVU856
 2696 0172 41EC160B 		vmov	d6, r0, r1
 2697 0176 88EE067B 		vdiv.f64	d7, d8, d6
 2698              	.LBE350:
 2699              	.LBE358:
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2700              		.loc 1 992 25 view .LVU857
 2701 017a 0BAC     		add	r4, sp, #44
 2702              	.LBB359:
 2703              	.LBB351:
 553:Src/app.c     ****                      (cpu_load->history[2].total - cpu_load->history[3].total);
 2704              		.loc 1 553 97 view .LVU858
 2705 017c B7EEC78B 		vcvt.f32.f64	s16, d7
 2706              	.LVL209:
 555:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 2707              		.loc 1 555 3 is_stmt 1 view .LVU859
 555:Src/app.c     ****     *cpu_load_last_five_seconds = 100.0 * (cpu_load->history[2].thread - cpu_load->history[7].threa
 2708              		.loc 1 555 3 is_stmt 0 view .LVU860
 2709              	.LBE351:
 2710              	.LBE359:
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2711              		.loc 1 992 3 is_stmt 1 view .LVU861
 992:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "Cpu load");
 2712              		.loc 1 992 10 is_stmt 0 view .LVU862
 2713 0180 D4ED007A 		vldr.32	s15, [r4]
 2714 0184 9FED4B7A 		vldr.32	s14, .L127+52
 2715 0188 C7EE278A 		vdiv.f32	s17, s14, s15
ARM GAS  /tmp/ccfH4MMM.s 			page 127


 2716              	.LVL210:
 993:Src/app.c     ****   line_nb += 1;
 2717              		.loc 1 993 3 is_stmt 1 view .LVU863
 993:Src/app.c     ****   line_nb += 1;
 2718              		.loc 1 993 26 is_stmt 0 view .LVU864
 2719 018c FFF7FEFF 		bl	UTIL_LCD_GetFont
 2720              	.LVL211:
 993:Src/app.c     ****   line_nb += 1;
 2721              		.loc 1 993 3 discriminator 1 view .LVU865
 2722 0190 0021     		movs	r1, #0
 2723 0192 0222     		movs	r2, #2
 2724 0194 0846     		mov	r0, r1
 2725 0196 484B     		ldr	r3, .L127+56
 2726 0198 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2727              	.LVL212:
 994:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "   %.1f%%", cpu_load_one_second);
 2728              		.loc 1 994 3 is_stmt 1 view .LVU866
 995:Src/app.c     ****   line_nb += 2;
 2729              		.loc 1 995 3 view .LVU867
 995:Src/app.c     ****   line_nb += 2;
 2730              		.loc 1 995 26 is_stmt 0 view .LVU868
 2731 019c FFF7FEFF 		bl	UTIL_LCD_GetFont
 2732              	.LVL213:
 995:Src/app.c     ****   line_nb += 2;
 2733              		.loc 1 995 3 discriminator 1 view .LVU869
 2734 01a0 B7EEC87A 		vcvt.f64.f32	d7, s16
 2735 01a4 C188     		ldrh	r1, [r0, #6]
 2736 01a6 0222     		movs	r2, #2
 2737 01a8 8DED007B 		vstr.64	d7, [sp]
 2738 01ac 434B     		ldr	r3, .L127+60
 2739 01ae 0020     		movs	r0, #0
 2740 01b0 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2741              	.LVL214:
 996:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Inferences");
 2742              		.loc 1 996 3 is_stmt 1 view .LVU870
 997:Src/app.c     ****   line_nb += 1;
 2743              		.loc 1 997 3 view .LVU871
 997:Src/app.c     ****   line_nb += 1;
 2744              		.loc 1 997 26 is_stmt 0 view .LVU872
 2745 01b4 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2746              	.LVL215:
 997:Src/app.c     ****   line_nb += 1;
 2747              		.loc 1 997 26 discriminator 1 view .LVU873
 2748 01b8 C188     		ldrh	r1, [r0, #6]
 997:Src/app.c     ****   line_nb += 1;
 2749              		.loc 1 997 3 discriminator 1 view .LVU874
 2750 01ba 0222     		movs	r2, #2
 2751 01bc 404B     		ldr	r3, .L127+64
 2752 01be 01EB4101 		add	r1, r1, r1, lsl #1
 2753 01c2 0020     		movs	r0, #0
 2754 01c4 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2755              	.LVL216:
 998:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " pd %2ums", info->pd_ms);
 2756              		.loc 1 998 3 is_stmt 1 view .LVU875
 999:Src/app.c     ****   line_nb += 1;
 2757              		.loc 1 999 3 view .LVU876
 999:Src/app.c     ****   line_nb += 1;
ARM GAS  /tmp/ccfH4MMM.s 			page 128


 2758              		.loc 1 999 26 is_stmt 0 view .LVU877
 2759 01c8 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2760              	.LVL217:
 999:Src/app.c     ****   line_nb += 1;
 2761              		.loc 1 999 3 discriminator 1 view .LVU878
 2762 01cc 0222     		movs	r2, #2
 999:Src/app.c     ****   line_nb += 1;
 2763              		.loc 1 999 26 discriminator 1 view .LVU879
 2764 01ce C188     		ldrh	r1, [r0, #6]
 999:Src/app.c     ****   line_nb += 1;
 2765              		.loc 1 999 3 discriminator 1 view .LVU880
 2766 01d0 6368     		ldr	r3, [r4, #4]
 2767 01d2 9140     		lsls	r1, r1, r2
 2768 01d4 0020     		movs	r0, #0
 2769 01d6 0093     		str	r3, [sp]
 2770 01d8 3A4B     		ldr	r3, .L127+68
 2771 01da FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2772              	.LVL218:
1000:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, " hl %2ums", info->hl_ms);
 2773              		.loc 1 1000 3 is_stmt 1 view .LVU881
1001:Src/app.c     ****   line_nb += 2;
 2774              		.loc 1 1001 3 view .LVU882
1001:Src/app.c     ****   line_nb += 2;
 2775              		.loc 1 1001 26 is_stmt 0 view .LVU883
 2776 01de FFF7FEFF 		bl	UTIL_LCD_GetFont
 2777              	.LVL219:
1001:Src/app.c     ****   line_nb += 2;
 2778              		.loc 1 1001 3 discriminator 1 view .LVU884
 2779 01e2 E368     		ldr	r3, [r4, #12]
1001:Src/app.c     ****   line_nb += 2;
 2780              		.loc 1 1001 26 discriminator 1 view .LVU885
 2781 01e4 C188     		ldrh	r1, [r0, #6]
1001:Src/app.c     ****   line_nb += 2;
 2782              		.loc 1 1001 3 discriminator 1 view .LVU886
 2783 01e6 0222     		movs	r2, #2
 2784 01e8 01EB8101 		add	r1, r1, r1, lsl #2
 2785 01ec 0020     		movs	r0, #0
 2786 01ee 0093     		str	r3, [sp]
 2787 01f0 354B     		ldr	r3, .L127+72
 2788 01f2 FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2789              	.LVL220:
1002:Src/app.c     ****   UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "  %.1f FPS", nn_fps);
 2790              		.loc 1 1002 3 is_stmt 1 view .LVU887
1003:Src/app.c     ****   line_nb += 2;
 2791              		.loc 1 1003 3 view .LVU888
1003:Src/app.c     ****   line_nb += 2;
 2792              		.loc 1 1003 26 is_stmt 0 view .LVU889
 2793 01f6 FFF7FEFF 		bl	UTIL_LCD_GetFont
 2794              	.LVL221:
1003:Src/app.c     ****   line_nb += 2;
 2795              		.loc 1 1003 3 discriminator 1 view .LVU890
 2796 01fa B7EEE87A 		vcvt.f64.f32	d7, s17
1003:Src/app.c     ****   line_nb += 2;
 2797              		.loc 1 1003 26 discriminator 1 view .LVU891
 2798 01fe C188     		ldrh	r1, [r0, #6]
1003:Src/app.c     ****   line_nb += 2;
 2799              		.loc 1 1003 3 discriminator 1 view .LVU892
ARM GAS  /tmp/ccfH4MMM.s 			page 129


 2800 0200 324B     		ldr	r3, .L127+76
 2801 0202 8DED007B 		vstr.64	d7, [sp]
 2802 0206 0222     		movs	r2, #2
 2803 0208 0020     		movs	r0, #0
 2804 020a C1EBC101 		rsb	r1, r1, r1, lsl #3
 2805 020e FFF7FEFF 		bl	UTIL_LCDEx_PrintfAt
 2806              	.LVL222:
1004:Src/app.c     ****   if (DBG_INFO) {
 2807              		.loc 1 1004 3 is_stmt 1 view .LVU893
1005:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb), RIGHT_MODE, "Display");
 2808              		.loc 1 1005 3 view .LVU894
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2809              		.loc 1 1013 3 view .LVU895
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2810              		.loc 1 1013 17 discriminator 1 view .LVU896
 2811 0212 236A     		ldr	r3, [r4, #32]
 2812 0214 002B     		cmp	r3, #0
 2813 0216 05DD     		ble	.L117
1014:Src/app.c     ****       display_hand(info, &info->hands[i]);
 2814              		.loc 1 1014 5 view .LVU897
1014:Src/app.c     ****       display_hand(info, &info->hands[i]);
 2815              		.loc 1 1014 8 is_stmt 0 view .LVU898
 2816 0218 E36A     		ldr	r3, [r4, #44]
 2817 021a 1BB1     		cbz	r3, .L117
1015:Src/app.c     ****   }
 2818              		.loc 1 1015 7 is_stmt 1 view .LVU899
 2819 021c 2046     		mov	r0, r4
 2820 021e 16A9     		add	r1, sp, #88
 2821 0220 FFF7FEFF 		bl	display_hand
 2822              	.LVL223:
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2823              		.loc 1 1013 38 discriminator 2 view .LVU900
1013:Src/app.c     ****     if (info->hands[i].is_valid)
 2824              		.loc 1 1013 17 discriminator 1 view .LVU901
 2825              	.L117:
1018:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
 2826              		.loc 1 1018 3 view .LVU902
1018:Src/app.c     ****     UTIL_LCDEx_PrintfAt(0, LINE(line_nb),  RIGHT_MODE, "pd : %5.1f %%", info->pd_max_prob * 100);
 2827              		.loc 1 1018 3 is_stmt 0 view .LVU903
 2828              	.LBE360:
 2829              	.LBE371:
1780:Src/app.c     ****     dp_commit_drawing_area();
 2830              		.loc 1 1780 5 is_stmt 1 view .LVU904
 2831              	.LBB372:
 2832              	.LBI372:
 375:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 376:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 377:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 378:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 379:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 380:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 381:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Clean by address
 382:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans D-Cache for the given address
 383:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is cleaned starting from a 32 byte aligned address in 32 byte granularity.
 384:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are cleaned.
 385:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address
 386:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
ARM GAS  /tmp/ccfH4MMM.s 			page 130


 387:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 388:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanDCache_by_Addr (volatile void *addr, int32_t dsize)
 2833              		.loc 3 388 27 view .LVU905
 389:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 390:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 391:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 2834              		.loc 3 391 5 view .LVU906
 2835              	.LBB373:
 392:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 2836              		.loc 3 392 8 view .LVU907
 2837              	.LBE373:
 2838              	.LBE372:
1780:Src/app.c     ****     dp_commit_drawing_area();
 2839              		.loc 1 1780 42 is_stmt 0 view .LVU908
 2840 0224 D9F80030 		ldr	r3, [r9]
 2841 0228 1E4A     		ldr	r2, .L127+36
 2842 022a 02FB0383 		mla	r3, r2, r3, r8
 2843              	.LVL224:
 2844              	.LBB381:
 2845              	.LBB380:
 393:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 2846              		.loc 3 393 7 is_stmt 1 view .LVU909
 394:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 395:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2847              		.loc 3 395 7 view .LVU910
 2848              	.LBB374:
 2849              	.LBI374:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2850              		.loc 4 269 27 view .LVU911
 2851              	.LBB375:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2852              		.loc 4 271 3 view .LVU912
 2853              		.syntax unified
 2854              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2855 022e BFF34F8F 		dsb 0xF
 2856              	@ 0 "" 2
 2857              		.thumb
 2858              		.syntax unified
 2859              	.LBE375:
 2860              	.LBE374:
 396:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 398:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 2861              		.loc 3 398 22 is_stmt 0 view .LVU913
 2862 0232 45F6C05E 		movw	lr, #24000
 2863 0236 4EF001E0 		dls	lr, lr
 2864 023a 254A     		ldr	r2, .L127+80
 2865              	.LVL225:
 2866              	.L119:
 397:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bi
 2867              		.loc 3 397 7 is_stmt 1 view .LVU914
 2868              		.loc 3 398 9 view .LVU915
 2869              		.loc 3 398 22 is_stmt 0 view .LVU916
 2870 023c C2F86832 		str	r3, [r2, #616]
 399:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr += __SCB_DCACHE_LINE_SIZE;
 2871              		.loc 3 399 9 is_stmt 1 view .LVU917
 2872              		.loc 3 399 17 is_stmt 0 view .LVU918
ARM GAS  /tmp/ccfH4MMM.s 			page 131


 2873 0240 2033     		adds	r3, r3, #32
 2874              	.LVL226:
 400:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -= __SCB_DCACHE_LINE_SIZE;
 2875              		.loc 3 400 9 is_stmt 1 view .LVU919
 401:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 2876              		.loc 3 401 25 discriminator 1 view .LVU920
 2877 0242 0FF005C8 		le	lr, .L119
 402:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 403:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 2878              		.loc 3 403 7 view .LVU921
 2879              	.LBB376:
 2880              	.LBI376:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2881              		.loc 4 269 27 view .LVU922
 2882              	.LBB377:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2883              		.loc 4 271 3 view .LVU923
 2884              		.syntax unified
 2885              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2886 0246 BFF34F8F 		dsb 0xF
 2887              	@ 0 "" 2
 2888              		.thumb
 2889              		.syntax unified
 2890              	.LBE377:
 2891              	.LBE376:
 404:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 2892              		.loc 3 404 7 view .LVU924
 2893              	.LBB378:
 2894              	.LBI378:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2895              		.loc 4 258 27 view .LVU925
 2896              	.LBB379:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2897              		.loc 4 260 3 view .LVU926
 2898              		.syntax unified
 2899              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2900 024a BFF36F8F 		isb 0xF
 2901              	@ 0 "" 2
 2902              	.LVL227:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2903              		.loc 4 260 3 is_stmt 0 view .LVU927
 2904              		.thumb
 2905              		.syntax unified
 2906              	.LBE379:
 2907              	.LBE378:
 2908              	.LBE380:
 2909              	.LBE381:
1781:Src/app.c     ****     disp_ms = HAL_GetTick() - ts;
 2910              		.loc 1 1781 5 is_stmt 1 view .LVU928
 2911              	.LBB382:
 2912              	.LBI382:
1700:Src/app.c     **** {
 2913              		.loc 1 1700 13 view .LVU929
 2914              	.LBB383:
1702:Src/app.c     **** 
 2915              		.loc 1 1702 3 view .LVU930
1704:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_1);
ARM GAS  /tmp/ccfH4MMM.s 			page 132


 2916              		.loc 1 1704 3 view .LVU931
 2917              	.LBB384:
 2918              	.LBI384:
 960:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2919              		.loc 4 960 27 view .LVU932
 2920              	.LBB385:
 2921              		.loc 4 962 3 view .LVU933
 2922              		.syntax unified
 2923              	@ 962 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2924 024e 72B6     		cpsid i
 2925              	@ 0 "" 2
 2926              		.thumb
 2927              		.syntax unified
 2928              	.LBE385:
 2929              	.LBE384:
1705:Src/app.c     ****   assert(ret == HAL_OK);
 2930              		.loc 1 1705 3 view .LVU934
1705:Src/app.c     ****   assert(ret == HAL_OK);
 2931              		.loc 1 1705 9 is_stmt 0 view .LVU935
 2932 0250 0120     		movs	r0, #1
 2933 0252 FFF7FEFF 		bl	SCRL_ReloadLayer
 2934              	.LVL228:
1706:Src/app.c     ****   __enable_irq();
 2935              		.loc 1 1706 3 is_stmt 1 view .LVU936
 2936 0256 20B1     		cbz	r0, .L120
1706:Src/app.c     ****   __enable_irq();
 2937              		.loc 1 1706 3 is_stmt 0 discriminator 1 view .LVU937
 2938 0258 40F2AA61 		movw	r1, #1706
 2939 025c 124B     		ldr	r3, .L127+40
 2940 025e 1D4A     		ldr	r2, .L127+84
 2941 0260 01E7     		b	.L126
 2942              	.L120:
1707:Src/app.c     ****   lcd_fg_buffer_rd_idx = 1 - lcd_fg_buffer_rd_idx;
 2943              		.loc 1 1707 3 is_stmt 1 view .LVU938
 2944              	.LBB386:
 2945              	.LBI386:
 949:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 2946              		.loc 4 949 27 view .LVU939
 2947              	.LBB387:
 951:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 2948              		.loc 4 951 3 view .LVU940
 2949              		.syntax unified
 2950              	@ 951 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 2951 0262 62B6     		cpsie i
 2952              	@ 0 "" 2
 2953              		.thumb
 2954              		.syntax unified
 2955              	.LBE387:
 2956              	.LBE386:
1708:Src/app.c     **** }
 2957              		.loc 1 1708 3 view .LVU941
1708:Src/app.c     **** }
 2958              		.loc 1 1708 28 is_stmt 0 view .LVU942
 2959 0264 D9F80030 		ldr	r3, [r9]
 2960 0268 C3F10103 		rsb	r3, r3, #1
1708:Src/app.c     **** }
 2961              		.loc 1 1708 24 view .LVU943
ARM GAS  /tmp/ccfH4MMM.s 			page 133


 2962 026c C9F80030 		str	r3, [r9]
 2963              	.LVL229:
1708:Src/app.c     **** }
 2964              		.loc 1 1708 24 view .LVU944
 2965              	.LBE383:
 2966              	.LBE382:
1782:Src/app.c     ****   }
 2967              		.loc 1 1782 5 is_stmt 1 view .LVU945
1782:Src/app.c     ****   }
 2968              		.loc 1 1782 15 is_stmt 0 view .LVU946
 2969 0270 FFF7FEFF 		bl	HAL_GetTick
 2970              	.LVL230:
1782:Src/app.c     ****   }
 2971              		.loc 1 1782 13 discriminator 1 view .LVU947
 2972 0274 A0EB0A04 		sub	r4, r0, r10
 2973              	.LVL231:
1762:Src/app.c     ****   {
 2974              		.loc 1 1762 9 is_stmt 1 view .LVU948
1764:Src/app.c     ****     assert(ret == pdTRUE);
 2975              		.loc 1 1764 9 is_stmt 0 view .LVU949
 2976 0278 EAE6     		b	.L121
 2977              	.L128:
 2978 027a 00BFAFF3 		.align	3
 2978      0080
 2979              	.L127:
 2980 0280 00000000 		.word	0
 2981 0284 00005940 		.word	1079574528
 2982 0288 00000000 		.word	on_ld_toggle_button_click
 2983 028c 00000000 		.word	disp
 2984 0290 00000000 		.word	on_pd_toggle_button_click
 2985 0294 00000000 		.word	.LC1
 2986 0298 00000000 		.word	__func__.16
 2987 029c 0E000000 		.word	.LC2
 2988 02a0 A8000000 		.word	disp+168
 2989 02a4 00B80B00 		.word	768000
 2990 02a8 2F000000 		.word	.LC7
 2991 02ac 00000000 		.word	__func__.12
 2992 02b0 00000000 		.word	cpu_load
 2993 02b4 00007A44 		.word	1148846080
 2994 02b8 00000000 		.word	.LC12
 2995 02bc 09000000 		.word	.LC13
 2996 02c0 13000000 		.word	.LC14
 2997 02c4 1E000000 		.word	.LC15
 2998 02c8 28000000 		.word	.LC16
 2999 02cc 32000000 		.word	.LC17
 3000 02d0 00ED00E0 		.word	-536810240
 3001 02d4 00000000 		.word	__func__.11
 3002 02d8 00000000 		.word	lcd_fg_buffer_rd_idx
 3003 02dc 00181500 		.word	lcd_fg_buffer
 3004              		.cfi_endproc
 3005              	.LFE7410:
 3007              		.section	.rodata.app_run.str1.1,"aMS",%progbits,1
 3008              	.LC18:
 3009 0000 496E6974 		.ascii	"Init application\000"
 3009      20617070 
 3009      6C696361 
 3009      74696F6E 
ARM GAS  /tmp/ccfH4MMM.s 			page 134


 3009      00
 3010              	.LC19:
 3011 0011 72657420 		.ascii	"ret == 0\000"
 3011      3D3D2030 
 3011      00
 3012              	.LC20:
 3013 001a 6973705F 		.ascii	"isp_sem\000"
 3013      73656D00 
 3014              	.LC21:
 3015 0022 64697370 		.ascii	"disp.update\000"
 3015      2E757064 
 3015      61746500 
 3016              	.LC22:
 3017 002e 64697370 		.ascii	"disp.lock\000"
 3017      2E6C6F63 
 3017      6B00
 3018              	.LC23:
 3019 0038 6E6E00   		.ascii	"nn\000"
 3020              	.LC24:
 3021 003b 68646C20 		.ascii	"hdl != NULL\000"
 3021      213D204E 
 3021      554C4C00 
 3022              	.LC25:
 3023 0047 647000   		.ascii	"dp\000"
 3024              	.LC26:
 3025 004a 69737000 		.ascii	"isp\000"
 3026              		.section	.text.app_run,"ax",%progbits
 3027              		.align	1
 3028              		.global	app_run
 3029              		.syntax unified
 3030              		.thumb
 3031              		.thumb_func
 3033              	app_run:
 3034              	.LFB7413:
1800:Src/app.c     ****   }
1801:Src/app.c     **** }
1802:Src/app.c     **** 
1803:Src/app.c     **** /**
1804:Src/app.c     ****  * @brief Initializes the display controller (SCRL) and graphics library (UTIL_LCD).
1805:Src/app.c     ****  * @details Configures the two screen layers: Layer 0 for the background video and
1806:Src/app.c     ****  * Layer 1 for the transparent UI overlay.
1807:Src/app.c     ****  */
1808:Src/app.c     **** static void Display_init()
1809:Src/app.c     **** {
1810:Src/app.c     ****   SCRL_LayerConfig layers_config[2] = {
1811:Src/app.c     ****     {
1812:Src/app.c     ****       .origin = {lcd_bg_area.X0, lcd_bg_area.Y0},
1813:Src/app.c     ****       .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
1814:Src/app.c     ****       .format = SCRL_ARGB8888,
1815:Src/app.c     ****       .address = lcd_bg_buffer[lcd_bg_buffer_disp_idx],
1816:Src/app.c     ****     },
1817:Src/app.c     ****     {
1818:Src/app.c     ****       .origin = {lcd_fg_area.X0, lcd_fg_area.Y0},
1819:Src/app.c     ****       .size = {lcd_fg_area.XSize, lcd_fg_area.YSize},
1820:Src/app.c     ****       .format = SCRL_ARGB4444,
1821:Src/app.c     ****       .address = lcd_fg_buffer[1],
1822:Src/app.c     ****     },
ARM GAS  /tmp/ccfH4MMM.s 			page 135


1823:Src/app.c     ****   };
1824:Src/app.c     ****   SCRL_ScreenConfig screen_config = {
1825:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
1826:Src/app.c     **** #ifdef SCR_LIB_USE_SPI
1827:Src/app.c     ****     .format = SCRL_RGB565,
1828:Src/app.c     **** #else
1829:Src/app.c     ****      .format = SCRL_YUV422, /* Use SCRL_RGB565 if host support this format to reduce cpu load */
1830:Src/app.c     **** #endif
1831:Src/app.c     ****     .address = screen_buffer,
1832:Src/app.c     ****     .fps = CAMERA_FPS,
1833:Src/app.c     ****   };
1834:Src/app.c     ****   int ret;
1835:Src/app.c     **** 
1836:Src/app.c     ****   ret = SCRL_Init((SCRL_LayerConfig *[2]){&layers_config[0], &layers_config[1]}, &screen_config);
1837:Src/app.c     ****   assert(ret == 0);
1838:Src/app.c     **** 
1839:Src/app.c     ****   UTIL_LCD_SetLayer(SCRL_LAYER_1);
1840:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
1841:Src/app.c     ****   UTIL_LCD_SetFont(&LCD_FONT);
1842:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
1843:Src/app.c     **** }
1844:Src/app.c     **** 
1845:Src/app.c     **** /**
1846:Src/app.c     ****  * @brief Main application entry point.
1847:Src/app.c     ****  * @details Initializes all hardware, software modules, and RTOS components,
1848:Src/app.c     ****  * then creates the three main application threads.
1849:Src/app.c     ****  */
1850:Src/app.c     **** void app_run()
1851:Src/app.c     **** {
 3035              		.loc 1 1851 1 is_stmt 1 view -0
 3036              		.cfi_startproc
 3037              		@ args = 0, pretend = 0, frame = 56
 3038              		@ frame_needed = 0, uses_anonymous_args = 0
1852:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 3039              		.loc 1 1852 3 view .LVU951
 3040              	.LVL232:
1853:Src/app.c     ****   UBaseType_t dp_priority = FREERTOS_PRIORITY(-2);
 3041              		.loc 1 1853 3 view .LVU952
1854:Src/app.c     ****   UBaseType_t nn_priority = FREERTOS_PRIORITY(1);
 3042              		.loc 1 1854 3 view .LVU953
1855:Src/app.c     ****   TaskHandle_t hdl;
 3043              		.loc 1 1855 3 view .LVU954
1856:Src/app.c     ****   int ret;
 3044              		.loc 1 1856 3 view .LVU955
1857:Src/app.c     **** 
1858:Src/app.c     ****   printf("Init application\n");
 3045              		.loc 1 1858 3 view .LVU956
1851:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 3046              		.loc 1 1851 1 is_stmt 0 view .LVU957
 3047 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 3048              		.cfi_def_cfa_offset 28
 3049              		.cfi_offset 4, -28
 3050              		.cfi_offset 5, -24
 3051              		.cfi_offset 6, -20
 3052              		.cfi_offset 7, -16
 3053              		.cfi_offset 8, -12
 3054              		.cfi_offset 9, -8
ARM GAS  /tmp/ccfH4MMM.s 			page 136


 3055              		.cfi_offset 14, -4
1859:Src/app.c     ****   /* Enable DWT so DWT_CYCCNT works when debugger not attached */
1860:Src/app.c     ****   CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 3056              		.loc 1 1860 12 view .LVU958
 3057 0004 854D     		ldr	r5, .L149
1851:Src/app.c     ****   UBaseType_t isp_priority = FREERTOS_PRIORITY(2);
 3058              		.loc 1 1851 1 view .LVU959
 3059 0006 93B0     		sub	sp, sp, #76
 3060              		.cfi_def_cfa_offset 104
1858:Src/app.c     ****   /* Enable DWT so DWT_CYCCNT works when debugger not attached */
 3061              		.loc 1 1858 3 view .LVU960
 3062 0008 8548     		ldr	r0, .L149+4
 3063 000a FFF7FEFF 		bl	puts
 3064              	.LVL233:
 3065              		.loc 1 1860 3 is_stmt 1 view .LVU961
 3066              		.loc 1 1860 12 is_stmt 0 view .LVU962
 3067 000e D5F8FC30 		ldr	r3, [r5, #252]
1861:Src/app.c     **** 
1862:Src/app.c     ****   /* screen init */
1863:Src/app.c     ****   memset(lcd_bg_buffer, 0, sizeof(lcd_bg_buffer));
 3068              		.loc 1 1863 3 view .LVU963
 3069 0012 844C     		ldr	r4, .L149+8
1860:Src/app.c     **** 
 3070              		.loc 1 1860 20 view .LVU964
 3071 0014 43F08073 		orr	r3, r3, #16777216
 3072              		.loc 1 1863 3 view .LVU965
 3073 0018 0021     		movs	r1, #0
 3074 001a 2046     		mov	r0, r4
 3075 001c 824A     		ldr	r2, .L149+12
1860:Src/app.c     **** 
 3076              		.loc 1 1860 20 view .LVU966
 3077 001e C5F8FC30 		str	r3, [r5, #252]
 3078              		.loc 1 1863 3 is_stmt 1 view .LVU967
 3079 0022 FFF7FEFF 		bl	memset
 3080              	.LVL234:
1864:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(lcd_bg_buffer, sizeof(lcd_bg_buffer)));
 3081              		.loc 1 1864 3 view .LVU968
 3082              		.loc 1 1864 3 view .LVU969
 3083              		.loc 1 1864 3 discriminator 1 view .LVU970
 3084              	.LBB410:
 3085              	.LBI410:
 405:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     }
 406:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #endif
 407:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** }
 408:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 409:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 410:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** /**
 411:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \brief   D-Cache Clean and Invalidate by address
 412:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \details Cleans and invalidates D_Cache for the given address
 413:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache is cleaned and invalidated starting from a 32 byte aligned address in 32 byte gr
 414:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****            D-Cache memory blocks which are part of given address + given size are cleaned and inval
 415:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   addr    address (aligned to 32-byte boundary)
 416:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   \param[in]   dsize   size of memory block (in number of bytes)
 417:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** */
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** __STATIC_FORCEINLINE void SCB_CleanInvalidateDCache_by_Addr (volatile void *addr, int32_t dsize)
 3086              		.loc 3 418 27 view .LVU971
 419:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
ARM GAS  /tmp/ccfH4MMM.s 			page 137


 420:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****   #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****     if ( dsize > 0 ) {
 3087              		.loc 3 421 5 view .LVU972
 3088              	.LBB411:
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 3089              		.loc 3 422 8 view .LVU973
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 3090              		.loc 3 423 7 view .LVU974
 424:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 3091              		.loc 3 425 7 view .LVU975
 3092              	.LBB412:
 3093              	.LBI412:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3094              		.loc 4 269 27 view .LVU976
 3095              	.LBB413:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3096              		.loc 4 271 3 view .LVU977
 3097              		.syntax unified
 3098              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3099 0026 BFF34F8F 		dsb 0xF
 3100              	@ 0 "" 2
 3101              		.thumb
 3102              		.syntax unified
 3103              	.LBE413:
 3104              	.LBE412:
 426:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       do {
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 3105              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU978
 3106 002a DFF880E2 		ldr	lr, .L149+144
 3107              	.LBB415:
 3108              	.LBB414:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 3109              		.loc 4 272 1 view .LVU979
 3110 002e 0023     		movs	r3, #0
 3111              	.LBE414:
 3112              	.LBE415:
 3113              		.loc 3 431 25 discriminator 1 view .LVU980
 3114 0030 4EF001E0 		dls	lr, lr
 3115              	.LVL235:
 3116              	.L130:
 3117              		.loc 3 431 25 discriminator 1 view .LVU981
 3118 0034 E218     		adds	r2, r4, r3
 3119              	.LVL236:
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 3120              		.loc 3 427 7 is_stmt 1 view .LVU982
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3121              		.loc 3 428 9 view .LVU983
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3122              		.loc 3 428 23 is_stmt 0 view .LVU984
 3123 0036 C5F87022 		str	r2, [r5, #624]
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 3124              		.loc 3 429 9 is_stmt 1 view .LVU985
ARM GAS  /tmp/ccfH4MMM.s 			page 138


 3125              	.LVL237:
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 3126              		.loc 3 430 9 view .LVU986
 3127              		.loc 3 431 25 discriminator 1 view .LVU987
 3128 003a 2033     		adds	r3, r3, #32
 3129              	.LVL238:
 3130              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU988
 3131 003c 0FF007C0 		le	lr, .L130
 432:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __DSB();
 3132              		.loc 3 433 7 is_stmt 1 view .LVU989
 3133              	.LBB416:
 3134              	.LBI416:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3135              		.loc 4 269 27 view .LVU990
 3136              	.LBB417:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3137              		.loc 4 271 3 view .LVU991
 3138              		.syntax unified
 3139              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3140 0040 BFF34F8F 		dsb 0xF
 3141              	@ 0 "" 2
 3142              		.thumb
 3143              		.syntax unified
 3144              	.LBE417:
 3145              	.LBE416:
 434:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 3146              		.loc 3 434 7 view .LVU992
 3147              	.LBB418:
 3148              	.LBI418:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3149              		.loc 4 258 27 view .LVU993
 3150              	.LBB419:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3151              		.loc 4 260 3 view .LVU994
 3152              		.syntax unified
 3153              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3154 0044 BFF36F8F 		isb 0xF
 3155              	@ 0 "" 2
 3156              	.LVL239:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3157              		.loc 4 260 3 is_stmt 0 view .LVU995
 3158              		.thumb
 3159              		.syntax unified
 3160              	.LBE419:
 3161              	.LBE418:
 3162              	.LBE411:
 3163              	.LBE410:
 3164              		.loc 1 1864 3 is_stmt 1 discriminator 3 view .LVU996
1865:Src/app.c     ****   memset(lcd_fg_buffer, 0, sizeof(lcd_fg_buffer));
 3165              		.loc 1 1865 3 view .LVU997
 3166 0048 784D     		ldr	r5, .L149+16
 3167 004a 0021     		movs	r1, #0
 3168 004c 2846     		mov	r0, r5
 3169 004e 784A     		ldr	r2, .L149+20
 3170 0050 FFF7FEFF 		bl	memset
 3171              	.LVL240:
ARM GAS  /tmp/ccfH4MMM.s 			page 139


1866:Src/app.c     ****   CACHE_OP(SCB_CleanInvalidateDCache_by_Addr(lcd_fg_buffer, sizeof(lcd_fg_buffer)));
 3172              		.loc 1 1866 3 view .LVU998
 3173              		.loc 1 1866 3 view .LVU999
 3174              		.loc 1 1866 3 discriminator 1 view .LVU1000
 3175              	.LBB420:
 3176              	.LBI420:
 418:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** {
 3177              		.loc 3 418 27 view .LVU1001
 421:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****        int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
 3178              		.loc 3 421 5 view .LVU1002
 3179              	.LBB421:
 422:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
 3180              		.loc 3 422 8 view .LVU1003
 423:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3181              		.loc 3 423 7 view .LVU1004
 425:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3182              		.loc 3 425 7 view .LVU1005
 3183              	.LBB422:
 3184              	.LBI422:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3185              		.loc 4 269 27 view .LVU1006
 3186              	.LBB423:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3187              		.loc 4 271 3 view .LVU1007
 3188              		.syntax unified
 3189              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3190 0054 BFF34F8F 		dsb 0xF
 3191              	@ 0 "" 2
 3192              		.thumb
 3193              		.syntax unified
 3194              	.LBE423:
 3195              	.LBE422:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3196              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU1008
 3197 0058 4BF6803E 		movw	lr, #48000
 3198              	.LBB425:
 3199              	.LBB424:
 272:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** 
 3200              		.loc 4 272 1 view .LVU1009
 3201 005c 0023     		movs	r3, #0
 3202              	.LBE424:
 3203              	.LBE425:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3204              		.loc 3 431 25 discriminator 1 view .LVU1010
 3205 005e 4EF001E0 		dls	lr, lr
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3206              		.loc 3 428 23 view .LVU1011
 3207 0062 6E4A     		ldr	r2, .L149
 3208              	.LVL241:
 3209              	.L131:
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3210              		.loc 3 428 23 view .LVU1012
 3211 0064 E918     		adds	r1, r5, r3
 3212              	.LVL242:
 427:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         SCB->DCCIMVAC = op_addr;            /* register accepts only 32byte aligned values, only bi
 3213              		.loc 3 427 7 is_stmt 1 view .LVU1013
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
ARM GAS  /tmp/ccfH4MMM.s 			page 140


 3214              		.loc 3 428 9 view .LVU1014
 428:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_addr +=          __SCB_DCACHE_LINE_SIZE;
 3215              		.loc 3 428 23 is_stmt 0 view .LVU1015
 3216 0066 C2F87012 		str	r1, [r2, #624]
 429:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****         op_size -=          __SCB_DCACHE_LINE_SIZE;
 3217              		.loc 3 429 9 is_stmt 1 view .LVU1016
 3218              	.LVL243:
 430:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       } while ( op_size > 0 );
 3219              		.loc 3 430 9 view .LVU1017
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3220              		.loc 3 431 25 discriminator 1 view .LVU1018
 3221 006a 2033     		adds	r3, r3, #32
 3222              	.LVL244:
 431:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h **** 
 3223              		.loc 3 431 25 is_stmt 0 discriminator 1 view .LVU1019
 3224 006c 0FF007C0 		le	lr, .L131
 433:STM32Cube_FW_N6/Drivers/CMSIS/Include/cachel1_armv7.h ****       __ISB();
 3225              		.loc 3 433 7 is_stmt 1 view .LVU1020
 3226              	.LBB426:
 3227              	.LBI426:
 269:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3228              		.loc 4 269 27 view .LVU1021
 3229              	.LBB427:
 271:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3230              		.loc 4 271 3 view .LVU1022
 3231              		.syntax unified
 3232              	@ 271 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3233 0070 BFF34F8F 		dsb 0xF
 3234              	@ 0 "" 2
 3235              		.thumb
 3236              		.syntax unified
 3237              	.LBE427:
 3238              	.LBE426:
 3239              		.loc 3 434 7 view .LVU1023
 3240              	.LBB428:
 3241              	.LBI428:
 258:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** {
 3242              		.loc 4 258 27 view .LVU1024
 3243              	.LBB429:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3244              		.loc 4 260 3 view .LVU1025
 3245              		.syntax unified
 3246              	@ 260 "STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h" 1
 3247 0074 BFF36F8F 		isb 0xF
 3248              	@ 0 "" 2
 3249              	.LVL245:
 260:STM32Cube_FW_N6/Drivers/CMSIS/Include/cmsis_gcc.h **** }
 3250              		.loc 4 260 3 is_stmt 0 view .LVU1026
 3251              		.thumb
 3252              		.syntax unified
 3253              	.LBE429:
 3254              	.LBE428:
 3255              	.LBE421:
 3256              	.LBE420:
 3257              		.loc 1 1866 3 is_stmt 1 discriminator 3 view .LVU1027
1867:Src/app.c     ****   Display_init();
 3258              		.loc 1 1867 3 view .LVU1028
ARM GAS  /tmp/ccfH4MMM.s 			page 141


 3259              	.LBB430:
 3260              	.LBI430:
1808:Src/app.c     **** {
 3261              		.loc 1 1808 13 view .LVU1029
 3262              	.LBB431:
1810:Src/app.c     ****     {
 3263              		.loc 1 1810 3 view .LVU1030
1810:Src/app.c     ****     {
 3264              		.loc 1 1810 20 is_stmt 0 view .LVU1031
 3265 0078 0320     		movs	r0, #3
 3266 007a 0021     		movs	r1, #0
 3267 007c 0126     		movs	r6, #1
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3268              		.loc 1 1824 21 view .LVU1032
 3269 007e 0227     		movs	r7, #2
 3270 0080 4FF01E09 		mov	r9, #30
1810:Src/app.c     ****     {
 3271              		.loc 1 1810 20 view .LVU1033
 3272 0084 8DF83000 		strb	r0, [sp, #48]
1815:Src/app.c     ****     },
 3273              		.loc 1 1815 31 view .LVU1034
 3274 0088 6A48     		ldr	r0, .L149+24
1810:Src/app.c     ****     {
 3275              		.loc 1 1810 20 view .LVU1035
 3276 008a 6B4A     		ldr	r2, .L149+28
1815:Src/app.c     ****     },
 3277              		.loc 1 1815 18 view .LVU1036
 3278 008c 0068     		ldr	r0, [r0]
1810:Src/app.c     ****     {
 3279              		.loc 1 1810 20 view .LVU1037
 3280 008e CDE90A12 		strd	r1, r2, [sp, #40]
1815:Src/app.c     ****     },
 3281              		.loc 1 1815 18 view .LVU1038
 3282 0092 03FB0044 		mla	r4, r3, r0, r4
1810:Src/app.c     ****     {
 3283              		.loc 1 1810 20 view .LVU1039
 3284 0096 694B     		ldr	r3, .L149+32
 3285 0098 CDE90D41 		strd	r4, r1, [sp, #52]
 3286 009c 1193     		str	r3, [sp, #68]
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3287              		.loc 1 1824 3 is_stmt 1 view .LVU1040
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3288              		.loc 1 1824 21 is_stmt 0 view .LVU1041
 3289 009e 684B     		ldr	r3, .L149+36
1836:Src/app.c     ****   assert(ret == 0);
 3290              		.loc 1 1836 9 view .LVU1042
 3291 00a0 06A9     		add	r1, sp, #24
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3292              		.loc 1 1824 21 view .LVU1043
 3293 00a2 0893     		str	r3, [sp, #32]
1836:Src/app.c     ****   assert(ret == 0);
 3294              		.loc 1 1836 42 view .LVU1044
 3295 00a4 0AAB     		add	r3, sp, #40
 3296 00a6 0493     		str	r3, [sp, #16]
1836:Src/app.c     ****   assert(ret == 0);
 3297              		.loc 1 1836 9 view .LVU1045
 3298 00a8 04A8     		add	r0, sp, #16
ARM GAS  /tmp/ccfH4MMM.s 			page 142


1836:Src/app.c     ****   assert(ret == 0);
 3299              		.loc 1 1836 42 view .LVU1046
 3300 00aa 0EAB     		add	r3, sp, #56
1810:Src/app.c     ****     {
 3301              		.loc 1 1810 20 view .LVU1047
 3302 00ac 0F92     		str	r2, [sp, #60]
 3303 00ae 8DF84060 		strb	r6, [sp, #64]
1824:Src/app.c     ****     .size = {lcd_bg_area.XSize, lcd_bg_area.YSize},
 3304              		.loc 1 1824 21 view .LVU1048
 3305 00b2 0692     		str	r2, [sp, #24]
 3306 00b4 8DF81C70 		strb	r7, [sp, #28]
 3307 00b8 ADF82490 		strh	r9, [sp, #36]	@ movhi
1834:Src/app.c     **** 
 3308              		.loc 1 1834 3 is_stmt 1 view .LVU1049
1836:Src/app.c     ****   assert(ret == 0);
 3309              		.loc 1 1836 3 view .LVU1050
1836:Src/app.c     ****   assert(ret == 0);
 3310              		.loc 1 1836 42 is_stmt 0 view .LVU1051
 3311 00bc 0593     		str	r3, [sp, #20]
1836:Src/app.c     ****   assert(ret == 0);
 3312              		.loc 1 1836 9 view .LVU1052
 3313 00be FFF7FEFF 		bl	SCRL_Init
 3314              	.LVL246:
1837:Src/app.c     **** 
 3315              		.loc 1 1837 3 is_stmt 1 view .LVU1053
 3316 00c2 0446     		mov	r4, r0
 3317 00c4 30B1     		cbz	r0, .L132
1837:Src/app.c     **** 
 3318              		.loc 1 1837 3 is_stmt 0 discriminator 1 view .LVU1054
 3319 00c6 40F22D71 		movw	r1, #1837
 3320 00ca 5E4B     		ldr	r3, .L149+40
 3321 00cc 5E4A     		ldr	r2, .L149+44
 3322              	.LVL247:
 3323              	.L148:
1837:Src/app.c     **** 
 3324              		.loc 1 1837 3 discriminator 1 view .LVU1055
 3325              	.LBE431:
 3326              	.LBE430:
1868:Src/app.c     **** 
1869:Src/app.c     ****   /* create buffer queues */
1870:Src/app.c     ****   ret = bqueue_init(&nn_input_queue, 2, (uint8_t *[2]){nn_input_buffers[0], nn_input_buffers[1]});
1871:Src/app.c     ****   assert(ret == 0);
 3327              		.loc 1 1871 3 discriminator 1 view .LVU1056
 3328 00ce 5F48     		ldr	r0, .L149+48
 3329 00d0 FFF7FEFF 		bl	__assert_func
 3330              	.LVL248:
 3331              	.L132:
 3332              	.LBB434:
 3333              	.LBB432:
1839:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
 3334              		.loc 1 1839 3 is_stmt 1 view .LVU1057
 3335 00d4 3046     		mov	r0, r6
 3336              	.LVL249:
1839:Src/app.c     ****   UTIL_LCD_Clear(UTIL_LCD_COLOR_TRANSPARENT);
 3337              		.loc 1 1839 3 is_stmt 0 view .LVU1058
 3338 00d6 FFF7FEFF 		bl	UTIL_LCD_SetLayer
 3339              	.LVL250:
ARM GAS  /tmp/ccfH4MMM.s 			page 143


1840:Src/app.c     ****   UTIL_LCD_SetFont(&LCD_FONT);
 3340              		.loc 1 1840 3 is_stmt 1 view .LVU1059
 3341 00da 2046     		mov	r0, r4
 3342 00dc FFF7FEFF 		bl	UTIL_LCD_Clear
 3343              	.LVL251:
1841:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
 3344              		.loc 1 1841 3 view .LVU1060
 3345              	.LBE432:
 3346              	.LBE434:
 3347              	.LBB435:
 3348              	.LBB436:
 572:Src/app.c     ****   if (!bq->free)
 3349              		.loc 1 572 14 is_stmt 0 view .LVU1061
 3350 00e0 DFF8CC81 		ldr	r8, .L149+148
 3351              	.LBE436:
 3352              	.LBE435:
 3353              	.LBB441:
 3354              	.LBB433:
1841:Src/app.c     ****   UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
 3355              		.loc 1 1841 3 view .LVU1062
 3356 00e4 5A48     		ldr	r0, .L149+52
 3357 00e6 FFF7FEFF 		bl	UTIL_LCD_SetFont
 3358              	.LVL252:
1842:Src/app.c     **** }
 3359              		.loc 1 1842 3 is_stmt 1 view .LVU1063
 3360 00ea 4FF0FF30 		mov	r0, #-1
 3361 00ee FFF7FEFF 		bl	UTIL_LCD_SetTextColor
 3362              	.LVL253:
1842:Src/app.c     **** }
 3363              		.loc 1 1842 3 is_stmt 0 view .LVU1064
 3364              	.LBE433:
 3365              	.LBE441:
1870:Src/app.c     ****   assert(ret == 0);
 3366              		.loc 1 1870 3 is_stmt 1 view .LVU1065
 3367              	.LBB442:
 3368              	.LBI435:
 565:Src/app.c     **** {
 3369              		.loc 1 565 12 view .LVU1066
 3370              	.LBB437:
 567:Src/app.c     **** 
 3371              		.loc 1 567 3 view .LVU1067
 569:Src/app.c     ****     return -1;
 3372              		.loc 1 569 3 view .LVU1068
 572:Src/app.c     ****   if (!bq->free)
 3373              		.loc 1 572 3 view .LVU1069
 572:Src/app.c     ****   if (!bq->free)
 3374              		.loc 1 572 14 is_stmt 0 view .LVU1070
 3375 00f2 4246     		mov	r2, r8
 3376 00f4 3946     		mov	r1, r7
 3377 00f6 3846     		mov	r0, r7
 3378 00f8 FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3379              	.LVL254:
 572:Src/app.c     ****   if (!bq->free)
 3380              		.loc 1 572 12 discriminator 1 view .LVU1071
 3381 00fc A8F10405 		sub	r5, r8, #4
 3382 0100 48F8040C 		str	r0, [r8, #-4]
 573:Src/app.c     ****     goto free_sem_error;
ARM GAS  /tmp/ccfH4MMM.s 			page 144


 3383              		.loc 1 573 3 is_stmt 1 view .LVU1072
 573:Src/app.c     ****     goto free_sem_error;
 3384              		.loc 1 573 6 is_stmt 0 view .LVU1073
 3385 0104 58B1     		cbz	r0, .L133
 575:Src/app.c     ****   if (!bq->ready)
 3386              		.loc 1 575 3 is_stmt 1 view .LVU1074
 575:Src/app.c     ****   if (!bq->ready)
 3387              		.loc 1 575 15 is_stmt 0 view .LVU1075
 3388 0106 2146     		mov	r1, r4
 3389 0108 3846     		mov	r0, r7
 3390 010a 08F15402 		add	r2, r8, #84
 3391 010e FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3392              	.LVL255:
 575:Src/app.c     ****   if (!bq->ready)
 3393              		.loc 1 575 13 discriminator 1 view .LVU1076
 3394 0112 6865     		str	r0, [r5, #84]
 576:Src/app.c     ****     goto ready_sem_error;
 3395              		.loc 1 576 3 is_stmt 1 view .LVU1077
 576:Src/app.c     ****     goto ready_sem_error;
 3396              		.loc 1 576 6 is_stmt 0 view .LVU1078
 3397 0114 40B9     		cbnz	r0, .L134
 577:Src/app.c     **** 
 3398              		.loc 1 577 5 is_stmt 1 view .LVU1079
 3399              	.LDL1:
 590:Src/app.c     **** free_sem_error:
 3400              		.loc 1 590 3 view .LVU1080
 3401 0116 58F8040C 		ldr	r0, [r8, #-4]
 3402 011a FFF7FEFF 		bl	vQueueDelete
 3403              	.LVL256:
 590:Src/app.c     **** free_sem_error:
 3404              		.loc 1 590 3 is_stmt 0 view .LVU1081
 3405              	.LBE437:
 3406              	.LBE442:
 3407              		.loc 1 1871 3 is_stmt 1 view .LVU1082
 3408              	.L133:
 3409              		.loc 1 1871 3 is_stmt 0 discriminator 1 view .LVU1083
 3410 011e 40F24F71 		movw	r1, #1871
 3411 0122 484B     		ldr	r3, .L149+40
 3412 0124 4B4A     		ldr	r2, .L149+56
 3413 0126 D2E7     		b	.L148
 3414              	.LVL257:
 3415              	.L134:
 3416              	.LBB443:
 3417              	.LBB438:
 579:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 3418              		.loc 1 579 3 is_stmt 1 view .LVU1084
 582:Src/app.c     ****   }
 3419              		.loc 1 582 20 is_stmt 0 view .LVU1085
 3420 0128 4B4B     		ldr	r3, .L149+60
 3421              	.LBE438:
 3422              	.LBE443:
 3423              	.LBB444:
 3424              	.LBB445:
 520:Src/app.c     **** }
 3425              		.loc 1 520 3 view .LVU1086
 3426 012a E022     		movs	r2, #224
 3427 012c 2146     		mov	r1, r4
ARM GAS  /tmp/ccfH4MMM.s 			page 145


 3428              	.LBE445:
 3429              	.LBE444:
 3430              	.LBB448:
 3431              	.LBB439:
 582:Src/app.c     ****   }
 3432              		.loc 1 582 20 view .LVU1087
 3433 012e C5F8AC30 		str	r3, [r5, #172]
 3434              	.LBE439:
 3435              	.LBE448:
 3436              	.LBB449:
 3437              	.LBB446:
 520:Src/app.c     **** }
 3438              		.loc 1 520 3 view .LVU1088
 3439 0132 4A48     		ldr	r0, .L149+64
 3440              	.LBE446:
 3441              	.LBE449:
 3442              	.LBB450:
 3443              	.LBB440:
 582:Src/app.c     ****   }
 3444              		.loc 1 582 20 view .LVU1089
 3445 0134 03F59623 		add	r3, r3, #307200
 584:Src/app.c     ****   bq->ready_idx = 0;
 3446              		.loc 1 584 16 view .LVU1090
 3447 0138 C5E92C34 		strd	r3, r4, [r5, #176]
 579:Src/app.c     ****   for (i = 0; i < buffer_nb; i++) {
 3448              		.loc 1 579 17 view .LVU1091
 3449 013c C5F8A870 		str	r7, [r5, #168]
 580:Src/app.c     ****     assert(buffers[i]);
 3450              		.loc 1 580 3 is_stmt 1 view .LVU1092
 3451              	.LVL258:
 580:Src/app.c     ****     assert(buffers[i]);
 3452              		.loc 1 580 17 discriminator 1 view .LVU1093
 581:Src/app.c     ****     bq->buffers[i] = buffers[i];
 3453              		.loc 1 581 5 view .LVU1094
 582:Src/app.c     ****   }
 3454              		.loc 1 582 5 view .LVU1095
 580:Src/app.c     ****     assert(buffers[i]);
 3455              		.loc 1 580 31 discriminator 2 view .LVU1096
 580:Src/app.c     ****     assert(buffers[i]);
 3456              		.loc 1 580 17 discriminator 1 view .LVU1097
 581:Src/app.c     ****     bq->buffers[i] = buffers[i];
 3457              		.loc 1 581 5 view .LVU1098
 582:Src/app.c     ****   }
 3458              		.loc 1 582 5 view .LVU1099
 585:Src/app.c     **** 
 3459              		.loc 1 585 3 view .LVU1100
 585:Src/app.c     **** 
 3460              		.loc 1 585 17 is_stmt 0 view .LVU1101
 3461 0140 C5F8B840 		str	r4, [r5, #184]
 587:Src/app.c     **** 
 3462              		.loc 1 587 3 is_stmt 1 view .LVU1102
 3463              	.LVL259:
 587:Src/app.c     **** 
 3464              		.loc 1 587 3 is_stmt 0 view .LVU1103
 3465              	.LBE440:
 3466              	.LBE450:
 3467              		.loc 1 1871 3 is_stmt 1 view .LVU1104
ARM GAS  /tmp/ccfH4MMM.s 			page 146


1872:Src/app.c     **** 
1873:Src/app.c     ****   cpuload_init(&cpu_load);
 3468              		.loc 1 1873 3 view .LVU1105
 3469              	.LBB451:
 3470              	.LBI444:
 518:Src/app.c     **** {
 3471              		.loc 1 518 13 view .LVU1106
 3472              	.LBB447:
 520:Src/app.c     **** }
 3473              		.loc 1 520 3 view .LVU1107
 3474 0144 FFF7FEFF 		bl	memset
 3475              	.LVL260:
 520:Src/app.c     **** }
 3476              		.loc 1 520 3 is_stmt 0 view .LVU1108
 3477              	.LBE447:
 3478              	.LBE451:
1874:Src/app.c     **** 
1875:Src/app.c     ****   /*** Camera Init ************************************************************/  
1876:Src/app.c     ****   CAM_Init();
 3479              		.loc 1 1876 3 is_stmt 1 view .LVU1109
 3480 0148 FFF7FEFF 		bl	CAM_Init
 3481              	.LVL261:
1877:Src/app.c     **** 
1878:Src/app.c     ****   /* sems + mutex init */
1879:Src/app.c     ****   isp_sem = xSemaphoreCreateCountingStatic(1, 0, &isp_sem_buffer);
 3482              		.loc 1 1879 3 view .LVU1110
 3483              		.loc 1 1879 13 is_stmt 0 view .LVU1111
 3484 014c 2146     		mov	r1, r4
 3485 014e 3046     		mov	r0, r6
 3486 0150 434A     		ldr	r2, .L149+68
 3487 0152 FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3488              	.LVL262:
 3489              		.loc 1 1879 11 discriminator 1 view .LVU1112
 3490 0156 434B     		ldr	r3, .L149+72
 3491 0158 1860     		str	r0, [r3]
1880:Src/app.c     ****   assert(isp_sem);
 3492              		.loc 1 1880 3 is_stmt 1 view .LVU1113
 3493 015a 20B9     		cbnz	r0, .L147
 3494              		.loc 1 1880 3 is_stmt 0 discriminator 1 view .LVU1114
 3495 015c 4FF4EB61 		mov	r1, #1880
 3496 0160 414B     		ldr	r3, .L149+76
 3497 0162 3C4A     		ldr	r2, .L149+56
 3498 0164 B3E7     		b	.L148
 3499              	.L147:
1881:Src/app.c     ****   disp.update = xSemaphoreCreateCountingStatic(1, 0, &disp.update_buffer);
 3500              		.loc 1 1881 3 is_stmt 1 view .LVU1115
 3501              		.loc 1 1881 17 is_stmt 0 view .LVU1116
 3502 0166 414D     		ldr	r5, .L149+80
 3503 0168 2146     		mov	r1, r4
 3504 016a 2A46     		mov	r2, r5
 3505 016c 3046     		mov	r0, r6
 3506 016e FFF7FEFF 		bl	xQueueCreateCountingSemaphoreStatic
 3507              	.LVL263:
 3508              		.loc 1 1881 15 discriminator 1 view .LVU1117
 3509 0172 2F1F     		subs	r7, r5, #4
 3510 0174 45F8040C 		str	r0, [r5, #-4]
1882:Src/app.c     ****   assert(disp.update);
ARM GAS  /tmp/ccfH4MMM.s 			page 147


 3511              		.loc 1 1882 3 is_stmt 1 view .LVU1118
 3512 0178 20B9     		cbnz	r0, .L137
 3513              		.loc 1 1882 3 is_stmt 0 discriminator 1 view .LVU1119
 3514 017a 40F25A71 		movw	r1, #1882
 3515 017e 3C4B     		ldr	r3, .L149+84
 3516 0180 344A     		ldr	r2, .L149+56
 3517 0182 A4E7     		b	.L148
 3518              	.L137:
1883:Src/app.c     ****   disp.lock = xSemaphoreCreateMutexStatic(&disp.lock_buffer);
 3519              		.loc 1 1883 3 is_stmt 1 view .LVU1120
 3520              		.loc 1 1883 15 is_stmt 0 view .LVU1121
 3521 0184 3046     		mov	r0, r6
 3522 0186 05F15401 		add	r1, r5, #84
 3523 018a FFF7FEFF 		bl	xQueueCreateMutexStatic
 3524              	.LVL264:
 3525              		.loc 1 1883 13 discriminator 1 view .LVU1122
 3526 018e 7865     		str	r0, [r7, #84]
1884:Src/app.c     ****   assert(disp.lock);
 3527              		.loc 1 1884 3 is_stmt 1 view .LVU1123
 3528 0190 20B9     		cbnz	r0, .L138
 3529              		.loc 1 1884 3 is_stmt 0 discriminator 1 view .LVU1124
 3530 0192 40F25C71 		movw	r1, #1884
 3531 0196 374B     		ldr	r3, .L149+88
 3532 0198 2E4A     		ldr	r2, .L149+56
 3533 019a 98E7     		b	.L148
 3534              	.L138:
1885:Src/app.c     **** 
1886:Src/app.c     ****   /* Start LCD Display camera pipe stream */
1887:Src/app.c     ****   CAM_DisplayPipe_Start(lcd_bg_buffer[0], CMW_MODE_CONTINUOUS);
 3535              		.loc 1 1887 3 is_stmt 1 view .LVU1125
 3536 019c 2146     		mov	r1, r4
 3537 019e 2148     		ldr	r0, .L149+8
 3538 01a0 FFF7FEFF 		bl	CAM_DisplayPipe_Start
 3539              	.LVL265:
1888:Src/app.c     **** 
1889:Src/app.c     ****   /* threads init */
1890:Src/app.c     ****   hdl = xTaskCreateStatic(nn_thread_fct, "nn", configMINIMAL_STACK_SIZE * 2, NULL, nn_priority, nn_
 3540              		.loc 1 1890 3 view .LVU1126
 3541              		.loc 1 1890 9 is_stmt 0 view .LVU1127
 3542 01a4 344B     		ldr	r3, .L149+92
 3543 01a6 4FF40062 		mov	r2, #2048
 3544 01aa 0293     		str	r3, [sp, #8]
 3545 01ac 334B     		ldr	r3, .L149+96
 3546 01ae 3449     		ldr	r1, .L149+100
 3547 01b0 0193     		str	r3, [sp, #4]
 3548 01b2 1D23     		movs	r3, #29
 3549 01b4 3348     		ldr	r0, .L149+104
 3550 01b6 0093     		str	r3, [sp]
 3551 01b8 2346     		mov	r3, r4
 3552 01ba FFF7FEFF 		bl	xTaskCreateStatic
 3553              	.LVL266:
1891:Src/app.c     ****                           &nn_thread);
1892:Src/app.c     ****   assert(hdl != NULL);
 3554              		.loc 1 1892 3 is_stmt 1 view .LVU1128
 3555 01be 20B9     		cbnz	r0, .L139
 3556              		.loc 1 1892 3 is_stmt 0 discriminator 1 view .LVU1129
 3557 01c0 40F26471 		movw	r1, #1892
ARM GAS  /tmp/ccfH4MMM.s 			page 148


 3558 01c4 304B     		ldr	r3, .L149+108
 3559 01c6 234A     		ldr	r2, .L149+56
 3560 01c8 81E7     		b	.L148
 3561              	.L139:
1893:Src/app.c     ****   hdl = xTaskCreateStatic(dp_thread_fct, "dp", configMINIMAL_STACK_SIZE * 2, NULL, dp_priority, dp_
 3562              		.loc 1 1893 3 is_stmt 1 view .LVU1130
 3563              		.loc 1 1893 9 is_stmt 0 view .LVU1131
 3564 01ca 304B     		ldr	r3, .L149+112
 3565 01cc 4FF40062 		mov	r2, #2048
 3566 01d0 0293     		str	r3, [sp, #8]
 3567 01d2 2F4B     		ldr	r3, .L149+116
 3568 01d4 2F49     		ldr	r1, .L149+120
 3569 01d6 0193     		str	r3, [sp, #4]
 3570 01d8 1A23     		movs	r3, #26
 3571 01da 2F48     		ldr	r0, .L149+124
 3572              	.LVL267:
 3573              		.loc 1 1893 9 view .LVU1132
 3574 01dc 0093     		str	r3, [sp]
 3575 01de 2346     		mov	r3, r4
 3576 01e0 FFF7FEFF 		bl	xTaskCreateStatic
 3577              	.LVL268:
1894:Src/app.c     ****                           &dp_thread);
1895:Src/app.c     ****   assert(hdl != NULL);
 3578              		.loc 1 1895 3 is_stmt 1 view .LVU1133
 3579 01e4 20B9     		cbnz	r0, .L140
 3580              		.loc 1 1895 3 is_stmt 0 discriminator 1 view .LVU1134
 3581 01e6 40F26771 		movw	r1, #1895
 3582 01ea 274B     		ldr	r3, .L149+108
 3583 01ec 194A     		ldr	r2, .L149+56
 3584 01ee 6EE7     		b	.L148
 3585              	.L140:
1896:Src/app.c     ****   hdl = xTaskCreateStatic(isp_thread_fct, "isp", configMINIMAL_STACK_SIZE * 2, NULL, isp_priority, 
 3586              		.loc 1 1896 3 is_stmt 1 view .LVU1135
 3587              		.loc 1 1896 9 is_stmt 0 view .LVU1136
 3588 01f0 2A4B     		ldr	r3, .L149+128
 3589 01f2 4FF40062 		mov	r2, #2048
 3590 01f6 0293     		str	r3, [sp, #8]
 3591 01f8 294B     		ldr	r3, .L149+132
 3592 01fa 2A49     		ldr	r1, .L149+136
 3593 01fc CDE90093 		strd	r9, r3, [sp]
 3594 0200 2948     		ldr	r0, .L149+140
 3595              	.LVL269:
 3596              		.loc 1 1896 9 view .LVU1137
 3597 0202 2346     		mov	r3, r4
 3598 0204 FFF7FEFF 		bl	xTaskCreateStatic
 3599              	.LVL270:
1897:Src/app.c     ****                           &isp_thread);
1898:Src/app.c     ****   assert(hdl != NULL);
 3600              		.loc 1 1898 3 is_stmt 1 view .LVU1138
 3601 0208 20B9     		cbnz	r0, .L129
 3602              		.loc 1 1898 3 is_stmt 0 discriminator 1 view .LVU1139
 3603 020a 40F26A71 		movw	r1, #1898
 3604 020e 1E4B     		ldr	r3, .L149+108
 3605 0210 104A     		ldr	r2, .L149+56
 3606 0212 5CE7     		b	.L148
 3607              	.L129:
1899:Src/app.c     **** }
ARM GAS  /tmp/ccfH4MMM.s 			page 149


 3608              		.loc 1 1899 1 view .LVU1140
 3609 0214 13B0     		add	sp, sp, #76
 3610              		.cfi_def_cfa_offset 28
 3611              		@ sp needed
 3612 0216 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3613              	.L150:
 3614 021a 00BF     		.align	2
 3615              	.L149:
 3616 021c 00ED00E0 		.word	-536810240
 3617 0220 00000000 		.word	.LC18
 3618 0224 00882C00 		.word	lcd_bg_buffer
 3619 0228 00C05D00 		.word	6144000
 3620 022c 00181500 		.word	lcd_fg_buffer
 3621 0230 00701700 		.word	1536000
 3622 0234 00000000 		.word	lcd_bg_buffer_disp_idx
 3623 0238 2003E001 		.word	31458080
 3624 023c 00D02000 		.word	lcd_fg_buffer+768000
 3625 0240 00600900 		.word	screen_buffer
 3626 0244 11000000 		.word	.LC19
 3627 0248 00000000 		.word	__func__.5
 3628 024c 0E000000 		.word	.LC2
 3629 0250 00000000 		.word	Font20
 3630 0254 00000000 		.word	__func__.18
 3631 0258 00000000 		.word	nn_input_buffers
 3632 025c 00000000 		.word	cpu_load
 3633 0260 00000000 		.word	isp_sem_buffer
 3634 0264 00000000 		.word	isp_sem
 3635 0268 1A000000 		.word	.LC20
 3636 026c 04000000 		.word	disp+4
 3637 0270 22000000 		.word	.LC21
 3638 0274 2E000000 		.word	.LC22
 3639 0278 00000000 		.word	nn_thread
 3640 027c 00000000 		.word	nn_thread_stack
 3641 0280 38000000 		.word	.LC23
 3642 0284 00000000 		.word	nn_thread_fct
 3643 0288 3B000000 		.word	.LC24
 3644 028c 00000000 		.word	dp_thread
 3645 0290 00000000 		.word	dp_thread_stack
 3646 0294 47000000 		.word	.LC25
 3647 0298 00000000 		.word	dp_thread_fct
 3648 029c 00000000 		.word	isp_thread
 3649 02a0 00000000 		.word	isp_thread_stack
 3650 02a4 4A000000 		.word	.LC26
 3651 02a8 00000000 		.word	isp_thread_fct
 3652 02ac 00EE0200 		.word	192000
 3653 02b0 04000000 		.word	nn_input_queue+4
 3654              		.cfi_endproc
 3655              	.LFE7413:
 3657              		.section	.text.CMW_CAMERA_PIPE_FrameEventCallback,"ax",%progbits
 3658              		.align	1
 3659              		.global	CMW_CAMERA_PIPE_FrameEventCallback
 3660              		.syntax unified
 3661              		.thumb
 3662              		.thumb_func
 3664              	CMW_CAMERA_PIPE_FrameEventCallback:
 3665              	.LVL271:
 3666              	.LFB7414:
ARM GAS  /tmp/ccfH4MMM.s 			page 150


1900:Src/app.c     **** 
1901:Src/app.c     **** /**
1902:Src/app.c     ****  * @brief System-level callback registered with the camera driver for frame events.
1903:Src/app.c     ****  * @details This function is called from an Interrupt Service Routine (ISR) and
1904:Src/app.c     ****  * routes the event to the appropriate application-level handler.
1905:Src/app.c     ****  */
1906:Src/app.c     **** int CMW_CAMERA_PIPE_FrameEventCallback(uint32_t pipe)
1907:Src/app.c     **** {
 3667              		.loc 1 1907 1 is_stmt 1 view -0
 3668              		.cfi_startproc
 3669              		@ args = 0, pretend = 0, frame = 8
 3670              		@ frame_needed = 0, uses_anonymous_args = 0
1908:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3671              		.loc 1 1908 3 view .LVU1142
 3672              		.loc 1 1908 6 is_stmt 0 view .LVU1143
 3673 0000 0128     		cmp	r0, #1
1907:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3674              		.loc 1 1907 1 view .LVU1144
 3675 0002 2DE9F347 		push	{r0, r1, r4, r5, r6, r7, r8, r9, r10, lr}
 3676              		.cfi_def_cfa_offset 40
 3677              		.cfi_offset 4, -32
 3678              		.cfi_offset 5, -28
 3679              		.cfi_offset 6, -24
 3680              		.cfi_offset 7, -20
 3681              		.cfi_offset 8, -16
 3682              		.cfi_offset 9, -12
 3683              		.cfi_offset 10, -8
 3684              		.cfi_offset 14, -4
1907:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 3685              		.loc 1 1907 1 view .LVU1145
 3686 0006 0646     		mov	r6, r0
 3687              		.loc 1 1908 6 view .LVU1146
 3688 0008 50D1     		bne	.L152
1909:Src/app.c     ****     app_main_pipe_frame_event();
 3689              		.loc 1 1909 5 is_stmt 1 view .LVU1147
 3690              	.LBB462:
 3691              	.LBI462:
 689:Src/app.c     **** {
 3692              		.loc 1 689 13 view .LVU1148
 3693              	.LBB463:
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3694              		.loc 1 692 3 view .LVU1149
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3695              		.loc 1 692 47 is_stmt 0 view .LVU1150
 3696 000a 514F     		ldr	r7, .L178
 693:Src/app.c     ****   int ret;
 3697              		.loc 1 693 47 view .LVU1151
 3698 000c DFF87081 		ldr	r8, .L178+48
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3699              		.loc 1 692 47 view .LVU1152
 3700 0010 3D68     		ldr	r5, [r7]
 693:Src/app.c     ****   int ret;
 3701              		.loc 1 693 47 view .LVU1153
 3702 0012 D8F80040 		ldr	r4, [r8]
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3703              		.loc 1 692 47 view .LVU1154
 3704 0016 0135     		adds	r5, r5, #1
ARM GAS  /tmp/ccfH4MMM.s 			page 151


 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3705              		.loc 1 692 7 view .LVU1155
 3706 0018 6B42     		rsbs	r3, r5, #0
 3707 001a 03F00303 		and	r3, r3, #3
 693:Src/app.c     ****   int ret;
 3708              		.loc 1 693 47 view .LVU1156
 3709 001e 04F10104 		add	r4, r4, #1
 692:Src/app.c     ****   int next_capt_idx = (lcd_bg_buffer_capt_idx + 1) % DISPLAY_BUFFER_NB;
 3710              		.loc 1 692 7 view .LVU1157
 3711 0022 05F00305 		and	r5, r5, #3
 3712 0026 55EA43B5 		csneg	r5, r5, r3, mi
 3713              	.LVL272:
 693:Src/app.c     ****   int ret;
 3714              		.loc 1 693 3 is_stmt 1 view .LVU1158
 693:Src/app.c     ****   int ret;
 3715              		.loc 1 693 7 is_stmt 0 view .LVU1159
 3716 002a 6342     		rsbs	r3, r4, #0
 3717 002c 03F00303 		and	r3, r3, #3
 698:Src/app.c     ****   assert(ret == HAL_OK);
 3718              		.loc 1 698 78 view .LVU1160
 3719 0030 DFF850A1 		ldr	r10, .L178+52
 3720 0034 DFF85091 		ldr	r9, .L178+56
 693:Src/app.c     ****   int ret;
 3721              		.loc 1 693 7 view .LVU1161
 3722 0038 04F00304 		and	r4, r4, #3
 3723 003c 54EA43B4 		csneg	r4, r4, r3, mi
 3724              	.LVL273:
 694:Src/app.c     **** 
 3725              		.loc 1 694 3 is_stmt 1 view .LVU1162
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3726              		.loc 1 697 3 view .LVU1163
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3727              		.loc 1 697 9 is_stmt 0 view .LVU1164
 3728 0040 FFF7FEFF 		bl	CMW_CAMERA_GetDCMIPPHandle
 3729              	.LVL274:
 697:Src/app.c     ****                                          DCMIPP_MEMORY_ADDRESS_0, (uint32_t) lcd_bg_buffer[next_cap
 3730              		.loc 1 697 9 view .LVU1165
 3731 0044 3146     		mov	r1, r6
 3732 0046 0022     		movs	r2, #0
 3733 0048 0AFB0493 		mla	r3, r10, r4, r9
 3734 004c FFF7FEFF 		bl	HAL_DCMIPP_PIPE_SetMemoryAddress
 3735              	.LVL275:
 699:Src/app.c     **** 
 3736              		.loc 1 699 3 is_stmt 1 view .LVU1166
 3737 0050 0146     		mov	r1, r0
 3738 0052 30B1     		cbz	r0, .L153
 699:Src/app.c     **** 
 3739              		.loc 1 699 3 is_stmt 0 discriminator 1 view .LVU1167
 3740 0054 40F2BB21 		movw	r1, #699
 3741 0058 3E4B     		ldr	r3, .L178+4
 3742 005a 3F4A     		ldr	r2, .L178+8
 3743              	.LVL276:
 3744              	.L177:
 3745              	.LBB464:
 3746              	.LBB465:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3747              		.loc 1 675 3 discriminator 1 view .LVU1168
ARM GAS  /tmp/ccfH4MMM.s 			page 152


 3748 005c 3F48     		ldr	r0, .L178+12
 3749 005e FFF7FEFF 		bl	__assert_func
 3750              	.LVL277:
 3751              	.L153:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3752              		.loc 1 675 3 discriminator 1 view .LVU1169
 3753              	.LBE465:
 3754              	.LBE464:
 702:Src/app.c     ****   lcd_bg_buffer_disp_idx = next_disp_idx;
 3755              		.loc 1 702 3 is_stmt 1 view .LVU1170
 3756              	.LBB467:
 3757              	.LBI464:
 670:Src/app.c     **** {
 3758              		.loc 1 670 13 view .LVU1171
 3759              	.LBB466:
 672:Src/app.c     **** 
 3760              		.loc 1 672 3 view .LVU1172
 674:Src/app.c     ****   assert(ret == 0);
 3761              		.loc 1 674 3 view .LVU1173
 674:Src/app.c     ****   assert(ret == 0);
 3762              		.loc 1 674 9 is_stmt 0 view .LVU1174
 3763 0062 0AFB0590 		mla	r0, r10, r5, r9
 3764              	.LVL278:
 674:Src/app.c     ****   assert(ret == 0);
 3765              		.loc 1 674 9 view .LVU1175
 3766 0066 FFF7FEFF 		bl	SCRL_SetAddress_NoReload
 3767              	.LVL279:
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3768              		.loc 1 675 3 is_stmt 1 view .LVU1176
 3769 006a 20B1     		cbz	r0, .L154
 675:Src/app.c     ****   ret = SCRL_ReloadLayer(SCRL_LAYER_0);
 3770              		.loc 1 675 3 is_stmt 0 discriminator 1 view .LVU1177
 3771 006c 40F2A321 		movw	r1, #675
 3772 0070 3B4B     		ldr	r3, .L178+16
 3773 0072 3C4A     		ldr	r2, .L178+20
 3774 0074 F2E7     		b	.L177
 3775              	.L154:
 676:Src/app.c     ****   assert(ret == 0);
 3776              		.loc 1 676 3 is_stmt 1 view .LVU1178
 676:Src/app.c     ****   assert(ret == 0);
 3777              		.loc 1 676 9 is_stmt 0 view .LVU1179
 3778 0076 FFF7FEFF 		bl	SCRL_ReloadLayer
 3779              	.LVL280:
 677:Src/app.c     **** 
 3780              		.loc 1 677 3 is_stmt 1 view .LVU1180
 3781 007a 20B1     		cbz	r0, .L155
 677:Src/app.c     **** 
 3782              		.loc 1 677 3 is_stmt 0 discriminator 1 view .LVU1181
 3783 007c 40F2A521 		movw	r1, #677
 3784 0080 374B     		ldr	r3, .L178+16
 3785 0082 384A     		ldr	r2, .L178+20
 3786 0084 EAE7     		b	.L177
 3787              	.L155:
 679:Src/app.c     ****   assert(ret == 0);
 3788              		.loc 1 679 3 is_stmt 1 view .LVU1182
 679:Src/app.c     ****   assert(ret == 0);
 3789              		.loc 1 679 9 is_stmt 0 view .LVU1183
ARM GAS  /tmp/ccfH4MMM.s 			page 153


 3790 0086 FFF7FEFF 		bl	SRCL_Update
 3791              	.LVL281:
 680:Src/app.c     **** }
 3792              		.loc 1 680 3 is_stmt 1 view .LVU1184
 3793 008a 20B1     		cbz	r0, .L156
 680:Src/app.c     **** }
 3794              		.loc 1 680 3 is_stmt 0 discriminator 1 view .LVU1185
 3795 008c 4FF42A71 		mov	r1, #680
 3796 0090 334B     		ldr	r3, .L178+16
 3797 0092 344A     		ldr	r2, .L178+20
 3798 0094 E2E7     		b	.L177
 3799              	.L156:
 3800              	.LVL282:
 680:Src/app.c     **** }
 3801              		.loc 1 680 3 discriminator 1 view .LVU1186
 3802              	.LBE466:
 3803              	.LBE467:
 703:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 3804              		.loc 1 703 3 is_stmt 1 view .LVU1187
 706:Src/app.c     **** }
 3805              		.loc 1 706 17 is_stmt 0 view .LVU1188
 3806 0096 344A     		ldr	r2, .L178+24
 703:Src/app.c     ****   lcd_bg_buffer_capt_idx = next_capt_idx;
 3807              		.loc 1 703 26 view .LVU1189
 3808 0098 3D60     		str	r5, [r7]
 704:Src/app.c     **** 
 3809              		.loc 1 704 3 is_stmt 1 view .LVU1190
 706:Src/app.c     **** }
 3810              		.loc 1 706 17 is_stmt 0 view .LVU1191
 3811 009a 1368     		ldr	r3, [r2]
 704:Src/app.c     **** 
 3812              		.loc 1 704 26 view .LVU1192
 3813 009c C8F80040 		str	r4, [r8]
 706:Src/app.c     **** }
 3814              		.loc 1 706 3 is_stmt 1 view .LVU1193
 706:Src/app.c     **** }
 3815              		.loc 1 706 17 is_stmt 0 view .LVU1194
 3816 00a0 0133     		adds	r3, r3, #1
 3817 00a2 1360     		str	r3, [r2]
 3818              	.LVL283:
 3819              	.L157:
 706:Src/app.c     **** }
 3820              		.loc 1 706 17 view .LVU1195
 3821              	.LBE463:
 3822              	.LBE462:
1910:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
1911:Src/app.c     ****     app_ancillary_pipe_frame_event();
1912:Src/app.c     **** 
1913:Src/app.c     ****   return HAL_OK;
 3823              		.loc 1 1913 3 is_stmt 1 view .LVU1196
1914:Src/app.c     **** }
 3824              		.loc 1 1914 1 is_stmt 0 view .LVU1197
 3825 00a4 0020     		movs	r0, #0
 3826 00a6 02B0     		add	sp, sp, #8
 3827              		.cfi_remember_state
 3828              		.cfi_def_cfa_offset 32
 3829              		@ sp needed
ARM GAS  /tmp/ccfH4MMM.s 			page 154


 3830 00a8 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3831              	.LVL284:
 3832              	.L152:
 3833              		.cfi_restore_state
1910:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
 3834              		.loc 1 1910 8 is_stmt 1 view .LVU1198
1910:Src/app.c     ****   else if (pipe == DCMIPP_PIPE2)
 3835              		.loc 1 1910 11 is_stmt 0 view .LVU1199
 3836 00ac 0228     		cmp	r0, #2
 3837 00ae F9D1     		bne	.L157
1911:Src/app.c     **** 
 3838              		.loc 1 1911 5 is_stmt 1 view .LVU1200
 3839              	.LBB468:
 3840              	.LBI468:
 714:Src/app.c     **** {
 3841              		.loc 1 714 13 view .LVU1201
 3842              	.LBB469:
 716:Src/app.c     ****   int ret;
 3843              		.loc 1 716 3 view .LVU1202
 717:Src/app.c     **** 
 3844              		.loc 1 717 3 view .LVU1203
 719:Src/app.c     ****   if (next_buffer) {
 3845              		.loc 1 719 3 view .LVU1204
 3846              	.LBB470:
 3847              	.LBI470:
 600:Src/app.c     **** {
 3848              		.loc 1 600 17 view .LVU1205
 3849              	.LVL285:
 3850              	.LBB471:
 602:Src/app.c     ****   int ret;
 3851              		.loc 1 602 3 view .LVU1206
 603:Src/app.c     **** 
 3852              		.loc 1 603 3 view .LVU1207
 605:Src/app.c     ****   if (ret == pdFALSE)
 3853              		.loc 1 605 3 view .LVU1208
 605:Src/app.c     ****   if (ret == pdFALSE)
 3854              		.loc 1 605 9 is_stmt 0 view .LVU1209
 3855 00b0 2E4C     		ldr	r4, .L178+28
 605:Src/app.c     ****   if (ret == pdFALSE)
 3856              		.loc 1 605 9 discriminator 4 view .LVU1210
 3857 00b2 0021     		movs	r1, #0
 3858 00b4 2068     		ldr	r0, [r4]
 3859              	.LVL286:
 605:Src/app.c     ****   if (ret == pdFALSE)
 3860              		.loc 1 605 9 discriminator 4 view .LVU1211
 3861 00b6 FFF7FEFF 		bl	xQueueSemaphoreTake
 3862              	.LVL287:
 606:Src/app.c     ****     return NULL;
 3863              		.loc 1 606 3 is_stmt 1 view .LVU1212
 606:Src/app.c     ****     return NULL;
 3864              		.loc 1 606 6 is_stmt 0 view .LVU1213
 3865 00ba 0028     		cmp	r0, #0
 3866 00bc F2D0     		beq	.L157
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3867              		.loc 1 609 3 is_stmt 1 view .LVU1214
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3868              		.loc 1 609 23 is_stmt 0 view .LVU1215
ARM GAS  /tmp/ccfH4MMM.s 			page 155


 3869 00be D4F8B420 		ldr	r2, [r4, #180]
 609:Src/app.c     ****   bq->free_idx = (bq->free_idx + 1) % bq->buffer_nb;
 3870              		.loc 1 609 7 view .LVU1216
 3871 00c2 04EB8203 		add	r3, r4, r2, lsl #2
 3872 00c6 D3F8AC50 		ldr	r5, [r3, #172]
 3873              	.LVL288:
 610:Src/app.c     **** 
 3874              		.loc 1 610 3 is_stmt 1 view .LVU1217
 610:Src/app.c     **** 
 3875              		.loc 1 610 37 is_stmt 0 view .LVU1218
 3876 00ca D4F8A830 		ldr	r3, [r4, #168]
 610:Src/app.c     **** 
 3877              		.loc 1 610 32 view .LVU1219
 3878 00ce 0132     		adds	r2, r2, #1
 610:Src/app.c     **** 
 3879              		.loc 1 610 37 view .LVU1220
 3880 00d0 92FBF3F1 		sdiv	r1, r2, r3
 3881 00d4 03FB1122 		mls	r2, r3, r1, r2
 610:Src/app.c     **** 
 3882              		.loc 1 610 16 view .LVU1221
 3883 00d8 C4F8B420 		str	r2, [r4, #180]
 612:Src/app.c     **** }
 3884              		.loc 1 612 3 is_stmt 1 view .LVU1222
 3885              	.LVL289:
 612:Src/app.c     **** }
 3886              		.loc 1 612 3 is_stmt 0 view .LVU1223
 3887              	.LBE471:
 3888              	.LBE470:
 720:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 3889              		.loc 1 720 3 is_stmt 1 view .LVU1224
 720:Src/app.c     ****     ret = HAL_DCMIPP_PIPE_SetMemoryAddress(CMW_CAMERA_GetDCMIPPHandle(), DCMIPP_PIPE2,
 3890              		.loc 1 720 6 is_stmt 0 view .LVU1225
 3891 00dc 002D     		cmp	r5, #0
 3892 00de E1D0     		beq	.L157
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3893              		.loc 1 721 5 is_stmt 1 view .LVU1226
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3894              		.loc 1 721 11 is_stmt 0 view .LVU1227
 3895 00e0 FFF7FEFF 		bl	CMW_CAMERA_GetDCMIPPHandle
 3896              	.LVL290:
 721:Src/app.c     ****                                            DCMIPP_MEMORY_ADDRESS_0, (uint32_t) next_buffer);
 3897              		.loc 1 721 11 discriminator 1 view .LVU1228
 3898 00e4 2B46     		mov	r3, r5
 3899 00e6 0022     		movs	r2, #0
 3900 00e8 3146     		mov	r1, r6
 3901 00ea FFF7FEFF 		bl	HAL_DCMIPP_PIPE_SetMemoryAddress
 3902              	.LVL291:
 723:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 3903              		.loc 1 723 5 is_stmt 1 view .LVU1229
 3904 00ee 20B1     		cbz	r0, .L160
 723:Src/app.c     ****     /* minus 1 since app_main_pipe_frame_event occur before app_ancillary_pipe_frame_event() */
 3905              		.loc 1 723 5 is_stmt 0 discriminator 1 view .LVU1230
 3906 00f0 40F2D321 		movw	r1, #723
 3907 00f4 174B     		ldr	r3, .L178+4
 3908 00f6 1E4A     		ldr	r2, .L178+32
 3909 00f8 B0E7     		b	.L177
 3910              	.L160:
ARM GAS  /tmp/ccfH4MMM.s 			page 156


 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3911              		.loc 1 725 5 is_stmt 1 view .LVU1231
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3912              		.loc 1 725 48 is_stmt 0 view .LVU1232
 3913 00fa 1B4B     		ldr	r3, .L178+24
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3914              		.loc 1 725 31 view .LVU1233
 3915 00fc 1D4A     		ldr	r2, .L178+36
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3916              		.loc 1 725 48 view .LVU1234
 3917 00fe 1B68     		ldr	r3, [r3]
 3918              	.LBB472:
 3919              	.LBB473:
 651:Src/app.c     ****   int ret;
 3920              		.loc 1 651 14 view .LVU1235
 3921 0100 0190     		str	r0, [sp, #4]
 3922              	.LBE473:
 3923              	.LBE472:
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3924              		.loc 1 725 48 view .LVU1236
 3925 0102 013B     		subs	r3, r3, #1
 725:Src/app.c     ****     bqueue_put_ready(&nn_input_queue);     /* Put the buffer into the 'ready' queue so the NN task 
 3926              		.loc 1 725 31 view .LVU1237
 3927 0104 1360     		str	r3, [r2]
 726:Src/app.c     ****   }
 3928              		.loc 1 726 5 is_stmt 1 view .LVU1238
 3929              	.LBB475:
 3930              	.LBI472:
 649:Src/app.c     **** {
 3931              		.loc 1 649 13 view .LVU1239
 3932              	.LVL292:
 3933              	.LBB474:
 651:Src/app.c     ****   int ret;
 3934              		.loc 1 651 3 view .LVU1240
 652:Src/app.c     **** 
 3935              		.loc 1 652 3 view .LVU1241
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3936              		.loc 1 654 3 view .LVU1242
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3937              		.loc 1 654 7 is_stmt 0 view .LVU1243
 3938 0106 FFF7FEFF 		bl	xPortIsInsideInterrupt
 3939              	.LVL293:
 654:Src/app.c     ****     ret = xSemaphoreGiveFromISR(bq->ready, &xHigherPriorityTaskWoken);
 3940              		.loc 1 654 6 discriminator 1 view .LVU1244
 3941 010a 0346     		mov	r3, r0
 3942 010c A0B1     		cbz	r0, .L161
 655:Src/app.c     ****     assert(ret == pdTRUE);
 3943              		.loc 1 655 5 is_stmt 1 view .LVU1245
 655:Src/app.c     ****     assert(ret == pdTRUE);
 3944              		.loc 1 655 11 is_stmt 0 view .LVU1246
 3945 010e 606D     		ldr	r0, [r4, #84]
 3946 0110 01A9     		add	r1, sp, #4
 3947 0112 FFF7FEFF 		bl	xQueueGiveFromISR
 3948              	.LVL294:
 656:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3949              		.loc 1 656 5 is_stmt 1 view .LVU1247
 3950 0116 0128     		cmp	r0, #1
ARM GAS  /tmp/ccfH4MMM.s 			page 157


 3951 0118 04D0     		beq	.L162
 656:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 3952              		.loc 1 656 5 is_stmt 0 discriminator 1 view .LVU1248
 3953 011a 4FF42471 		mov	r1, #656
 3954 011e 164B     		ldr	r3, .L178+40
 3955 0120 164A     		ldr	r2, .L178+44
 3956 0122 9BE7     		b	.L177
 3957              	.L162:
 657:Src/app.c     ****   } else {
 3958              		.loc 1 657 5 is_stmt 1 view .LVU1249
 657:Src/app.c     ****   } else {
 3959              		.loc 1 657 5 view .LVU1250
 3960 0124 019B     		ldr	r3, [sp, #4]
 3961 0126 002B     		cmp	r3, #0
 3962 0128 BCD0     		beq	.L157
 657:Src/app.c     ****   } else {
 3963              		.loc 1 657 5 discriminator 1 view .LVU1251
 3964 012a 4FF0E023 		mov	r3, #-536813568
 3965 012e 4FF08052 		mov	r2, #268435456
 3966 0132 C3F8042D 		str	r2, [r3, #3332]
 3967 0136 B5E7     		b	.L157
 3968              	.LVL295:
 3969              	.L161:
 659:Src/app.c     ****     assert(ret == pdTRUE);
 3970              		.loc 1 659 5 view .LVU1252
 659:Src/app.c     ****     assert(ret == pdTRUE);
 3971              		.loc 1 659 11 is_stmt 0 view .LVU1253
 3972 0138 0246     		mov	r2, r0
 3973 013a 0146     		mov	r1, r0
 3974 013c 606D     		ldr	r0, [r4, #84]
 3975 013e FFF7FEFF 		bl	xQueueGenericSend
 3976              	.LVL296:
 660:Src/app.c     ****   }
 3977              		.loc 1 660 5 is_stmt 1 view .LVU1254
 3978 0142 0128     		cmp	r0, #1
 3979 0144 AED0     		beq	.L157
 660:Src/app.c     ****   }
 3980              		.loc 1 660 5 is_stmt 0 discriminator 1 view .LVU1255
 3981 0146 4FF42571 		mov	r1, #660
 3982 014a 0B4B     		ldr	r3, .L178+40
 3983 014c 0B4A     		ldr	r2, .L178+44
 3984 014e 85E7     		b	.L177
 3985              	.L179:
 3986              		.align	2
 3987              	.L178:
 3988 0150 00000000 		.word	lcd_bg_buffer_disp_idx
 3989 0154 2F000000 		.word	.LC7
 3990 0158 00000000 		.word	__func__.3
 3991 015c 0E000000 		.word	.LC2
 3992 0160 11000000 		.word	.LC19
 3993 0164 00000000 		.word	__func__.2
 3994 0168 00000000 		.word	frame_event_nb
 3995 016c 00000000 		.word	nn_input_queue
 3996 0170 00000000 		.word	__func__.1
 3997 0174 00000000 		.word	frame_event_nb_for_resize
 3998 0178 00000000 		.word	.LC1
 3999 017c 00000000 		.word	__func__.0
ARM GAS  /tmp/ccfH4MMM.s 			page 158


 4000 0180 00000000 		.word	lcd_bg_buffer_capt_idx
 4001 0184 00701700 		.word	1536000
 4002 0188 00882C00 		.word	lcd_bg_buffer
 4003              	.LBE474:
 4004              	.LBE475:
 4005              	.LBE469:
 4006              	.LBE468:
 4007              		.cfi_endproc
 4008              	.LFE7414:
 4010              		.section	.text.CMW_CAMERA_PIPE_VsyncEventCallback,"ax",%progbits
 4011              		.align	1
 4012              		.global	CMW_CAMERA_PIPE_VsyncEventCallback
 4013              		.syntax unified
 4014              		.thumb
 4015              		.thumb_func
 4017              	CMW_CAMERA_PIPE_VsyncEventCallback:
 4018              	.LVL297:
 4019              	.LFB7415:
1915:Src/app.c     **** 
1916:Src/app.c     **** /**
1917:Src/app.c     ****  * @brief System-level callback for VSYNC events.
1918:Src/app.c     ****  */
1919:Src/app.c     **** int CMW_CAMERA_PIPE_VsyncEventCallback(uint32_t pipe)
1920:Src/app.c     **** {
 4020              		.loc 1 1920 1 is_stmt 1 view -0
 4021              		.cfi_startproc
 4022              		@ args = 0, pretend = 0, frame = 8
 4023              		@ frame_needed = 0, uses_anonymous_args = 0
1921:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 4024              		.loc 1 1921 3 view .LVU1257
 4025              		.loc 1 1921 6 is_stmt 0 view .LVU1258
 4026 0000 0128     		cmp	r0, #1
1920:Src/app.c     ****   if (pipe == DCMIPP_PIPE1)
 4027              		.loc 1 1920 1 view .LVU1259
 4028 0002 07B5     		push	{r0, r1, r2, lr}
 4029              		.cfi_def_cfa_offset 16
 4030              		.cfi_offset 14, -4
 4031              		.loc 1 1921 6 view .LVU1260
 4032 0004 10D1     		bne	.L181
1922:Src/app.c     ****     app_main_pipe_vsync_event();
 4033              		.loc 1 1922 5 is_stmt 1 view .LVU1261
 4034              	.LBB478:
 4035              	.LBI478:
 736:Src/app.c     **** {
 4036              		.loc 1 736 13 view .LVU1262
 4037              	.LBB479:
 738:Src/app.c     ****   int ret;
 4038              		.loc 1 738 3 view .LVU1263
 738:Src/app.c     ****   int ret;
 4039              		.loc 1 738 14 is_stmt 0 view .LVU1264
 4040 0006 0023     		movs	r3, #0
 4041 0008 0193     		str	r3, [sp, #4]
 739:Src/app.c     **** 
 4042              		.loc 1 739 3 is_stmt 1 view .LVU1265
 741:Src/app.c     ****   if (ret == pdTRUE)
 4043              		.loc 1 741 3 view .LVU1266
 741:Src/app.c     ****   if (ret == pdTRUE)
ARM GAS  /tmp/ccfH4MMM.s 			page 159


 4044              		.loc 1 741 9 is_stmt 0 view .LVU1267
 4045 000a 094B     		ldr	r3, .L186
 4046 000c 01A9     		add	r1, sp, #4
 4047 000e 1868     		ldr	r0, [r3]
 4048              	.LVL298:
 741:Src/app.c     ****   if (ret == pdTRUE)
 4049              		.loc 1 741 9 view .LVU1268
 4050 0010 FFF7FEFF 		bl	xQueueGiveFromISR
 4051              	.LVL299:
 742:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 4052              		.loc 1 742 3 is_stmt 1 view .LVU1269
 742:Src/app.c     ****     portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
 4053              		.loc 1 742 6 is_stmt 0 view .LVU1270
 4054 0014 0128     		cmp	r0, #1
 4055 0016 07D1     		bne	.L181
 743:Src/app.c     **** }
 4056              		.loc 1 743 5 is_stmt 1 view .LVU1271
 743:Src/app.c     **** }
 4057              		.loc 1 743 5 view .LVU1272
 4058 0018 019B     		ldr	r3, [sp, #4]
 4059 001a 2BB1     		cbz	r3, .L181
 743:Src/app.c     **** }
 4060              		.loc 1 743 5 discriminator 1 view .LVU1273
 4061 001c 4FF0E023 		mov	r3, #-536813568
 4062 0020 4FF08052 		mov	r2, #268435456
 4063 0024 C3F8042D 		str	r2, [r3, #3332]
 743:Src/app.c     **** }
 4064              		.loc 1 743 5 discriminator 3 view .LVU1274
 4065              	.LVL300:
 4066              	.L181:
 743:Src/app.c     **** }
 4067              		.loc 1 743 5 is_stmt 0 discriminator 3 view .LVU1275
 4068              	.LBE479:
 4069              	.LBE478:
1923:Src/app.c     **** 
1924:Src/app.c     ****   return HAL_OK;
 4070              		.loc 1 1924 3 is_stmt 1 view .LVU1276
1925:Src/app.c     **** }
 4071              		.loc 1 1925 1 is_stmt 0 view .LVU1277
 4072 0028 0020     		movs	r0, #0
 4073 002a 03B0     		add	sp, sp, #12
 4074              		.cfi_def_cfa_offset 4
 4075              		@ sp needed
 4076 002c 5DF804FB 		ldr	pc, [sp], #4
 4077              	.L187:
 4078              		.align	2
 4079              	.L186:
 4080 0030 00000000 		.word	isp_sem
 4081              		.cfi_endproc
 4082              	.LFE7415:
 4084              		.section	.rodata.__func__.0,"a"
 4087              	__func__.0:
 4088 0000 62717565 		.ascii	"bqueue_put_ready\000"
 4088      75655F70 
 4088      75745F72 
 4088      65616479 
 4088      00
ARM GAS  /tmp/ccfH4MMM.s 			page 160


 4089              		.section	.rodata.__func__.1,"a"
 4092              	__func__.1:
 4093 0000 6170705F 		.ascii	"app_ancillary_pipe_frame_event\000"
 4093      616E6369 
 4093      6C6C6172 
 4093      795F7069 
 4093      70655F66 
 4094              		.section	.rodata.__func__.2,"a"
 4097              	__func__.2:
 4098 0000 72656C6F 		.ascii	"reload_bg_layer\000"
 4098      61645F62 
 4098      675F6C61 
 4098      79657200 
 4099              		.section	.rodata.__func__.3,"a"
 4102              	__func__.3:
 4103 0000 6170705F 		.ascii	"app_main_pipe_frame_event\000"
 4103      6D61696E 
 4103      5F706970 
 4103      655F6672 
 4103      616D655F 
 4104              		.section	.rodata.__func__.5,"a"
 4107              	__func__.5:
 4108 0000 44697370 		.ascii	"Display_init\000"
 4108      6C61795F 
 4108      696E6974 
 4108      00
 4109              		.section	.rodata.__func__.6,"a"
 4112              	__func__.6:
 4113 0000 62717565 		.ascii	"bqueue_put_free\000"
 4113      75655F70 
 4113      75745F66 
 4113      72656500 
 4114              		.section	.rodata.__func__.7,"a"
 4117              	__func__.7:
 4118 0000 796F6C6F 		.ascii	"yolo_detector_run\000"
 4118      5F646574 
 4118      6563746F 
 4118      725F7275 
 4118      6E00
 4119              		.section	.rodata.__func__.8,"a"
 4122              	__func__.8:
 4123 0000 62717565 		.ascii	"bqueue_get_ready\000"
 4123      75655F67 
 4123      65745F72 
 4123      65616479 
 4123      00
 4124              		.section	.rodata.__func__.9,"a"
 4127              	__func__.9:
 4128 0000 6170705F 		.ascii	"app_rot_init\000"
 4128      726F745F 
 4128      696E6974 
 4128      00
 4129              		.section	.rodata.__func__.10,"a"
 4132              	__func__.10:
 4133 0000 6E6E5F74 		.ascii	"nn_thread_fct\000"
 4133      68726561 
 4133      645F6663 
ARM GAS  /tmp/ccfH4MMM.s 			page 161


 4133      7400
 4134              		.section	.rodata.__func__.11,"a"
 4137              	__func__.11:
 4138 0000 64705F63 		.ascii	"dp_commit_drawing_area\000"
 4138      6F6D6D69 
 4138      745F6472 
 4138      6177696E 
 4138      675F6172 
 4139              		.section	.rodata.__func__.12,"a"
 4142              	__func__.12:
 4143 0000 64705F75 		.ascii	"dp_update_drawing_area\000"
 4143      70646174 
 4143      655F6472 
 4143      6177696E 
 4143      675F6172 
 4144              		.section	.rodata.__func__.13,"a"
 4147              	__func__.13:
 4148 0000 62757474 		.ascii	"button_init\000"
 4148      6F6E5F69 
 4148      6E697400 
 4149              		.section	.rodata.__func__.14,"a"
 4152              	__func__.14:
 4153 0000 6F6E5F6C 		.ascii	"on_ld_toggle_button_click\000"
 4153      645F746F 
 4153      67676C65 
 4153      5F627574 
 4153      746F6E5F 
 4154              		.section	.rodata.__func__.15,"a"
 4157              	__func__.15:
 4158 0000 6F6E5F70 		.ascii	"on_pd_toggle_button_click\000"
 4158      645F746F 
 4158      67676C65 
 4158      5F627574 
 4158      746F6E5F 
 4159              		.section	.rodata.__func__.16,"a"
 4162              	__func__.16:
 4163 0000 64705F74 		.ascii	"dp_thread_fct\000"
 4163      68726561 
 4163      645F6663 
 4163      7400
 4164              		.section	.rodata.__func__.17,"a"
 4167              	__func__.17:
 4168 0000 6973705F 		.ascii	"isp_thread_fct\000"
 4168      74687265 
 4168      61645F66 
 4168      637400
 4169              		.section	.rodata.__func__.18,"a"
 4172              	__func__.18:
 4173 0000 6170705F 		.ascii	"app_run\000"
 4173      72756E00 
 4174              		.section	.bss.cl,"aw",%nobits
 4175              		.align	2
 4178              	cl:
 4179 0000 00000000 		.space	60
 4179      00000000 
 4179      00000000 
 4179      00000000 
ARM GAS  /tmp/ccfH4MMM.s 			page 162


 4179      00000000 
 4180              		.section	.bss.hgfxmmu,"aw",%nobits
 4181              		.align	2
 4184              	hgfxmmu:
 4185 0000 00000000 		.space	48
 4185      00000000 
 4185      00000000 
 4185      00000000 
 4185      00000000 
 4186              		.section	.bss.isp_sem_buffer,"aw",%nobits
 4187              		.align	2
 4190              	isp_sem_buffer:
 4191 0000 00000000 		.space	80
 4191      00000000 
 4191      00000000 
 4191      00000000 
 4191      00000000 
 4192              		.section	.bss.isp_sem,"aw",%nobits
 4193              		.align	2
 4196              	isp_sem:
 4197 0000 00000000 		.space	4
 4198              		.section	.bss.isp_thread_stack,"aw",%nobits
 4199              		.align	2
 4202              	isp_thread_stack:
 4203 0000 00000000 		.space	8192
 4203      00000000 
 4203      00000000 
 4203      00000000 
 4203      00000000 
 4204              		.section	.bss.isp_thread,"aw",%nobits
 4205              		.align	2
 4208              	isp_thread:
 4209 0000 00000000 		.space	96
 4209      00000000 
 4209      00000000 
 4209      00000000 
 4209      00000000 
 4210              		.section	.bss.dp_thread_stack,"aw",%nobits
 4211              		.align	2
 4214              	dp_thread_stack:
 4215 0000 00000000 		.space	8192
 4215      00000000 
 4215      00000000 
 4215      00000000 
 4215      00000000 
 4216              		.section	.bss.dp_thread,"aw",%nobits
 4217              		.align	2
 4220              	dp_thread:
 4221 0000 00000000 		.space	96
 4221      00000000 
 4221      00000000 
 4221      00000000 
 4221      00000000 
 4222              		.section	.bss.nn_thread_stack,"aw",%nobits
 4223              		.align	2
 4226              	nn_thread_stack:
 4227 0000 00000000 		.space	8192
ARM GAS  /tmp/ccfH4MMM.s 			page 163


 4227      00000000 
 4227      00000000 
 4227      00000000 
 4227      00000000 
 4228              		.section	.bss.nn_thread,"aw",%nobits
 4229              		.align	2
 4232              	nn_thread:
 4233 0000 00000000 		.space	96
 4233      00000000 
 4233      00000000 
 4233      00000000 
 4233      00000000 
 4234              		.section	.bss.nn_input_queue,"aw",%nobits
 4235              		.align	2
 4238              	nn_input_queue:
 4239 0000 00000000 		.space	188
 4239      00000000 
 4239      00000000 
 4239      00000000 
 4239      00000000 
 4240              		.section	.psram_bss,"aw"
 4241              		.align	5
 4244              	nn_input_buffers:
 4245 0000 00000000 		.space	614400
 4245      00000000 
 4245      00000000 
 4245      00000000 
 4245      00000000 
 4246              		.section	.bss.frame_event_nb_for_resize,"aw",%nobits
 4247              		.align	2
 4250              	frame_event_nb_for_resize:
 4251 0000 00000000 		.space	4
 4252              		.section	.bss.frame_event_nb,"aw",%nobits
 4253              		.align	2
 4256              	frame_event_nb:
 4257 0000 00000000 		.space	4
 4258              		.section	.data.NN_Instance_yolo_detector,"aw"
 4259              		.align	2
 4262              	NN_Instance_yolo_detector:
 4263 0000 00000000 		.word	NN_Interface_yolo_detector
 4264 0004 00000000 		.word	0
 4265 0008 00000000 		.space	40
 4265      00000000 
 4265      00000000 
 4265      00000000 
 4265      00000000 
 4266              		.section	.rodata.str1.1,"aMS",%progbits,1
 4267              	.LC27:
 4268 0000 796F6C6F 		.ascii	"yolo_detector\000"
 4268      5F646574 
 4268      6563746F 
 4268      7200
 4269              		.section	.rodata.NN_Interface_yolo_detector,"a"
 4270              		.align	2
 4273              	NN_Interface_yolo_detector:
 4274 0000 00000000 		.word	.LC27
 4275 0004 00000000 		.word	LL_ATON_EC_Network_Init_yolo_detector
ARM GAS  /tmp/ccfH4MMM.s 			page 164


 4276 0008 00000000 		.word	LL_ATON_EC_Inference_Init_yolo_detector
 4277 000c 00000000 		.word	LL_ATON_Set_User_Input_Buffer_yolo_detector
 4278 0010 00000000 		.word	LL_ATON_Get_User_Input_Buffer_yolo_detector
 4279 0014 00000000 		.word	LL_ATON_Set_User_Output_Buffer_yolo_detector
 4280 0018 00000000 		.word	LL_ATON_Get_User_Output_Buffer_yolo_detector
 4281 001c 00000000 		.word	LL_ATON_EpochBlockItems_yolo_detector
 4282 0020 00000000 		.word	LL_ATON_Output_Buffers_Info_yolo_detector
 4283 0024 00000000 		.word	LL_ATON_Input_Buffers_Info_yolo_detector
 4284 0028 00000000 		.word	LL_ATON_Internal_Buffers_Info_yolo_detector
 4285              		.section	.psram_bss
 4286              		.align	5
 4289              	screen_buffer:
 4290 96000 00000000 		.space	768000
 4290      00000000 
 4290      00000000 
 4290      00000000 
 4290      00000000 
 4291              		.section	.bss.cpu_load,"aw",%nobits
 4292              		.align	3
 4295              	cpu_load:
 4296 0000 00000000 		.space	224
 4296      00000000 
 4296      00000000 
 4296      00000000 
 4296      00000000 
 4297              		.section	.data.disp,"aw"
 4298              		.align	2
 4301              	disp:
 4302 0000 00000000 		.space	168
 4302      00000000 
 4302      00000000 
 4302      00000000 
 4302      00000000 
 4303 00a8 00000000 		.space	24
 4303      00000000 
 4303      00000000 
 4303      00000000 
 4303      00000000 
 4304 00c0 01000000 		.word	1
 4305 00c4 00000000 		.word	0
 4306 00c8 00000000 		.space	4548
 4306      00000000 
 4306      00000000 
 4306      00000000 
 4306      00000000 
 4307              		.section	.bss.lcd_fg_buffer_rd_idx,"aw",%nobits
 4308              		.align	2
 4311              	lcd_fg_buffer_rd_idx:
 4312 0000 00000000 		.space	4
 4313              		.section	.psram_bss
 4314              		.align	5
 4317              	lcd_fg_buffer:
 4318 151800 00000000 		.space	1536000
 4318      00000000 
 4318      00000000 
 4318      00000000 
 4318      00000000 
ARM GAS  /tmp/ccfH4MMM.s 			page 165


 4319              		.section	.bss.lcd_bg_buffer_capt_idx,"aw",%nobits
 4320              		.align	2
 4323              	lcd_bg_buffer_capt_idx:
 4324 0000 00000000 		.space	4
 4325              		.section	.data.lcd_bg_buffer_disp_idx,"aw"
 4326              		.align	2
 4329              	lcd_bg_buffer_disp_idx:
 4330 0000 01000000 		.word	1
 4331              		.section	.psram_bss
 4332              		.align	5
 4335              	lcd_bg_buffer:
 4336 2c8800 00000000 		.space	6144000
 4336      00000000 
 4336      00000000 
 4336      00000000 
 4336      00000000 
 4337              		.text
 4338              	.Letext0:
 4339              		.file 5 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4340              		.file 6 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4341              		.file 7 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4342              		.file 8 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4343              		.file 9 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/od_pp_output_if.h"
 4344              		.file 10 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/od_yolov8_pp_if.h"
 4345              		.file 11 "Lib/lib_vision_models_pp/lib_vision_models_pp/Inc/pd_pp_output_if.h"
 4346              		.file 12 "STM32Cube_FW_N6/Drivers/CMSIS/Include/core_cm55.h"
 4347              		.file 13 "STM32Cube_FW_N6/Drivers/CMSIS/Device/ST/STM32N6xx/Include/stm32n657xx.h"
 4348              		.file 14 "STM32Cube_FW_N6/Drivers/CMSIS/Device/ST/STM32N6xx/Include/stm32n6xx.h"
 4349              		.file 15 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_def.h"
 4350              		.file 16 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_gpio.h"
 4351              		.file 17 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_dcmipp.h"
 4352              		.file 18 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal_gfxmmu.h"
 4353              		.file 19 "Inc/ld.h"
 4354              		.file 20 "Lib/FreeRTOS/Source/include/projdefs.h"
 4355              		.file 21 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 4356              		.file 22 "Lib/FreeRTOS/Source/include/FreeRTOS.h"
 4357              		.file 23 "Lib/FreeRTOS/Source/include/task.h"
 4358              		.file 24 "Lib/FreeRTOS/Source/include/queue.h"
 4359              		.file 25 "Lib/FreeRTOS/Source/include/semphr.h"
 4360              		.file 26 "Lib/screenl/Inc/scrl.h"
 4361              		.file 27 "STM32Cube_FW_N6/Drivers/BSP/STM32N6570-DK/stm32n6570_discovery.h"
 4362              		.file 28 "STM32Cube_FW_N6/Utilities/lcd/../Fonts/fonts.h"
 4363              		.file 29 "STM32Cube_FW_N6/Utilities/lcd/stm32_lcd.h"
 4364              		.file 30 "Lib/NemaGFX/include/nema_hal.h"
 4365              		.file 31 "Lib/NemaGFX/include/nema_cmdlist.h"
 4366              		.file 32 "Lib/Camera_Middleware/cmw_camera.h"
 4367              		.file 33 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4368              		.file 34 "Lib/ai-postprocessing-wrapper/app_postprocess.h"
 4369              		.file 35 "Lib/AI_Runtime/Npu/ll_aton/ll_aton_runtime.h"
 4370              		.file 36 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4371              		.file 37 "Lib/NemaGFX/include/nema_graphics.h"
 4372              		.file 38 "Lib/NemaGFX/include/nema_error.h"
 4373              		.file 39 "Inc/app_cam.h"
 4374              		.file 40 "Inc/FreeRTOSConfig.h"
 4375              		.file 41 "Inc/stm32_lcd_ex.h"
 4376              		.file 42 "STM32Cube_FW_N6/Drivers/STM32N6xx_HAL_Driver/Inc/stm32n6xx_hal.h"
 4377              		.file 43 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
ARM GAS  /tmp/ccfH4MMM.s 			page 166


 4378              		.file 44 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4379              		.file 45 "<built-in>"
ARM GAS  /tmp/ccfH4MMM.s 			page 167


DEFINED SYMBOLS
                            *ABS*:00000000 app.c
     /tmp/ccfH4MMM.s:26     .text.clamp_point:00000000 $t
     /tmp/ccfH4MMM.s:31     .text.clamp_point:00000000 clamp_point
     /tmp/ccfH4MMM.s:117    .text.isp_thread_fct:00000000 $t
     /tmp/ccfH4MMM.s:122    .text.isp_thread_fct:00000000 isp_thread_fct
     /tmp/ccfH4MMM.s:168    .text.isp_thread_fct:00000028 $d
     /tmp/ccfH4MMM.s:4196   .bss.isp_sem:00000000 isp_sem
     /tmp/ccfH4MMM.s:4167   .rodata.__func__.17:00000000 __func__.17
     /tmp/ccfH4MMM.s:176    .text.on_pd_toggle_button_click:00000000 $t
     /tmp/ccfH4MMM.s:181    .text.on_pd_toggle_button_click:00000000 on_pd_toggle_button_click
     /tmp/ccfH4MMM.s:255    .text.on_pd_toggle_button_click:0000004c $d
     /tmp/ccfH4MMM.s:4157   .rodata.__func__.15:00000000 __func__.15
     /tmp/ccfH4MMM.s:262    .text.on_ld_toggle_button_click:00000000 $t
     /tmp/ccfH4MMM.s:267    .text.on_ld_toggle_button_click:00000000 on_ld_toggle_button_click
     /tmp/ccfH4MMM.s:341    .text.on_ld_toggle_button_click:0000004c $d
     /tmp/ccfH4MMM.s:4152   .rodata.__func__.14:00000000 __func__.14
     /tmp/ccfH4MMM.s:348    .text.button_process:00000000 $t
     /tmp/ccfH4MMM.s:353    .text.button_process:00000000 button_process
     /tmp/ccfH4MMM.s:411    .text.button_init.part.0:00000000 $t
     /tmp/ccfH4MMM.s:416    .text.button_init.part.0:00000000 button_init.part.0
     /tmp/ccfH4MMM.s:439    .text.button_init.part.0:00000010 $d
     /tmp/ccfH4MMM.s:4147   .rodata.__func__.13:00000000 __func__.13
     /tmp/ccfH4MMM.s:446    .text.display_ld_hand:00000000 $t
     /tmp/ccfH4MMM.s:451    .text.display_ld_hand:00000000 display_ld_hand
     /tmp/ccfH4MMM.s:768    .text.display_ld_hand:00000164 $d
     /tmp/ccfH4MMM.s:790    .text.nn_thread_fct:00000000 $t
     /tmp/ccfH4MMM.s:795    .text.nn_thread_fct:00000000 nn_thread_fct
     /tmp/ccfH4MMM.s:1694   .text.nn_thread_fct:00000304 $d
     /tmp/ccfH4MMM.s:4127   .rodata.__func__.9:00000000 __func__.9
     /tmp/ccfH4MMM.s:4184   .bss.hgfxmmu:00000000 hgfxmmu
     /tmp/ccfH4MMM.s:4178   .bss.cl:00000000 cl
     /tmp/ccfH4MMM.s:4238   .bss.nn_input_queue:00000000 nn_input_queue
     /tmp/ccfH4MMM.s:4132   .rodata.__func__.10:00000000 __func__.10
     /tmp/ccfH4MMM.s:4122   .rodata.__func__.8:00000000 __func__.8
     /tmp/ccfH4MMM.s:4117   .rodata.__func__.7:00000000 __func__.7
     /tmp/ccfH4MMM.s:4112   .rodata.__func__.6:00000000 __func__.6
     /tmp/ccfH4MMM.s:4301   .data.disp:00000000 disp
     /tmp/ccfH4MMM.s:4250   .bss.frame_event_nb_for_resize:00000000 frame_event_nb_for_resize
     /tmp/ccfH4MMM.s:4262   .data.NN_Instance_yolo_detector:00000000 NN_Instance_yolo_detector
     /tmp/ccfH4MMM.s:1722   .text.nn_thread_fct:0000036c $t
     /tmp/ccfH4MMM.s:1742   .text.display_hand:00000000 $t
     /tmp/ccfH4MMM.s:1748   .text.display_hand:00000000 display_hand
     /tmp/ccfH4MMM.s:2242   .text.display_hand:00000230 $d
     /tmp/ccfH4MMM.s:2262   .text.dp_thread_fct:00000000 $t
     /tmp/ccfH4MMM.s:2267   .text.dp_thread_fct:00000000 dp_thread_fct
     /tmp/ccfH4MMM.s:2980   .text.dp_thread_fct:00000280 $d
     /tmp/ccfH4MMM.s:4162   .rodata.__func__.16:00000000 __func__.16
     /tmp/ccfH4MMM.s:4142   .rodata.__func__.12:00000000 __func__.12
     /tmp/ccfH4MMM.s:4295   .bss.cpu_load:00000000 cpu_load
     /tmp/ccfH4MMM.s:4137   .rodata.__func__.11:00000000 __func__.11
     /tmp/ccfH4MMM.s:4311   .bss.lcd_fg_buffer_rd_idx:00000000 lcd_fg_buffer_rd_idx
     /tmp/ccfH4MMM.s:4317   .psram_bss:00151800 lcd_fg_buffer
     /tmp/ccfH4MMM.s:3027   .text.app_run:00000000 $t
     /tmp/ccfH4MMM.s:3033   .text.app_run:00000000 app_run
     /tmp/ccfH4MMM.s:3616   .text.app_run:0000021c $d
     /tmp/ccfH4MMM.s:4335   .psram_bss:002c8800 lcd_bg_buffer
ARM GAS  /tmp/ccfH4MMM.s 			page 168


     /tmp/ccfH4MMM.s:4329   .data.lcd_bg_buffer_disp_idx:00000000 lcd_bg_buffer_disp_idx
     /tmp/ccfH4MMM.s:4289   .psram_bss:00096000 screen_buffer
     /tmp/ccfH4MMM.s:4107   .rodata.__func__.5:00000000 __func__.5
     /tmp/ccfH4MMM.s:4172   .rodata.__func__.18:00000000 __func__.18
     /tmp/ccfH4MMM.s:4244   .psram_bss:00000000 nn_input_buffers
     /tmp/ccfH4MMM.s:4190   .bss.isp_sem_buffer:00000000 isp_sem_buffer
     /tmp/ccfH4MMM.s:4232   .bss.nn_thread:00000000 nn_thread
     /tmp/ccfH4MMM.s:4226   .bss.nn_thread_stack:00000000 nn_thread_stack
     /tmp/ccfH4MMM.s:4220   .bss.dp_thread:00000000 dp_thread
     /tmp/ccfH4MMM.s:4214   .bss.dp_thread_stack:00000000 dp_thread_stack
     /tmp/ccfH4MMM.s:4208   .bss.isp_thread:00000000 isp_thread
     /tmp/ccfH4MMM.s:4202   .bss.isp_thread_stack:00000000 isp_thread_stack
     /tmp/ccfH4MMM.s:3658   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000000 $t
     /tmp/ccfH4MMM.s:3664   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000000 CMW_CAMERA_PIPE_FrameEventCallback
     /tmp/ccfH4MMM.s:3988   .text.CMW_CAMERA_PIPE_FrameEventCallback:00000150 $d
     /tmp/ccfH4MMM.s:4102   .rodata.__func__.3:00000000 __func__.3
     /tmp/ccfH4MMM.s:4097   .rodata.__func__.2:00000000 __func__.2
     /tmp/ccfH4MMM.s:4256   .bss.frame_event_nb:00000000 frame_event_nb
     /tmp/ccfH4MMM.s:4092   .rodata.__func__.1:00000000 __func__.1
     /tmp/ccfH4MMM.s:4087   .rodata.__func__.0:00000000 __func__.0
     /tmp/ccfH4MMM.s:4323   .bss.lcd_bg_buffer_capt_idx:00000000 lcd_bg_buffer_capt_idx
     /tmp/ccfH4MMM.s:4011   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000000 $t
     /tmp/ccfH4MMM.s:4017   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000000 CMW_CAMERA_PIPE_VsyncEventCallback
     /tmp/ccfH4MMM.s:4080   .text.CMW_CAMERA_PIPE_VsyncEventCallback:00000030 $d
     /tmp/ccfH4MMM.s:4175   .bss.cl:00000000 $d
     /tmp/ccfH4MMM.s:4181   .bss.hgfxmmu:00000000 $d
     /tmp/ccfH4MMM.s:4187   .bss.isp_sem_buffer:00000000 $d
     /tmp/ccfH4MMM.s:4193   .bss.isp_sem:00000000 $d
     /tmp/ccfH4MMM.s:4199   .bss.isp_thread_stack:00000000 $d
     /tmp/ccfH4MMM.s:4205   .bss.isp_thread:00000000 $d
     /tmp/ccfH4MMM.s:4211   .bss.dp_thread_stack:00000000 $d
     /tmp/ccfH4MMM.s:4217   .bss.dp_thread:00000000 $d
     /tmp/ccfH4MMM.s:4223   .bss.nn_thread_stack:00000000 $d
     /tmp/ccfH4MMM.s:4229   .bss.nn_thread:00000000 $d
     /tmp/ccfH4MMM.s:4235   .bss.nn_input_queue:00000000 $d
     /tmp/ccfH4MMM.s:4241   .psram_bss:00000000 $d
     /tmp/ccfH4MMM.s:4247   .bss.frame_event_nb_for_resize:00000000 $d
     /tmp/ccfH4MMM.s:4253   .bss.frame_event_nb:00000000 $d
     /tmp/ccfH4MMM.s:4259   .data.NN_Instance_yolo_detector:00000000 $d
     /tmp/ccfH4MMM.s:4273   .rodata.NN_Interface_yolo_detector:00000000 NN_Interface_yolo_detector
     /tmp/ccfH4MMM.s:4270   .rodata.NN_Interface_yolo_detector:00000000 $d
     /tmp/ccfH4MMM.s:4292   .bss.cpu_load:00000000 $d
     /tmp/ccfH4MMM.s:4298   .data.disp:00000000 $d
     /tmp/ccfH4MMM.s:4308   .bss.lcd_fg_buffer_rd_idx:00000000 $d
     /tmp/ccfH4MMM.s:4320   .bss.lcd_bg_buffer_capt_idx:00000000 $d
     /tmp/ccfH4MMM.s:4326   .data.lcd_bg_buffer_disp_idx:00000000 $d
                           .group:00000000 wm4.0.c552ae9005b0f2cca11872fae5d4b7f2
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.features.h.33.e0c9f337c65cb9f22ed5f23d082bc78b
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.cmsis_gcc.h.26.7a5fd1a99dbedde687044a4433ab3e15
                           .group:00000000 wm4.newlib.h.7.591ac1bd65c1f5b34864757667a05252
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
ARM GAS  /tmp/ccfH4MMM.s 			page 169


                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stddef.h.39.0dc9006b34572d4d9cae4c8b422c4971
                           .group:00000000 wm4.cdefs.h.49.70fc7af612f78ddcace70fdd90b5623b
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4.math.h.13.47cfc34cae8a1153323939c4d32cf7c2
                           .group:00000000 wm4.float.h.29.0e9d9baf95ec39f9555dc80c6e28186b
                           .group:00000000 wm4.syslimits.h.34.de5cbd310098bc5895998b6bde577ed2
                           .group:00000000 wm4.limits.h.9.70fb0ada6f71b16202a66baaa6d8ea70
                           .group:00000000 wm4.limits.h.60.56a1ae353e2028a24298ec6463b8b593
                           .group:00000000 wm4.arm_math_types.h.94.a6c8422e2657ad4cd95bd8be69ba02aa
                           .group:00000000 wm4.stdbool.h.29.c08aa3eec75cf5b9b5003883f43253f0
                           .group:00000000 wm4.arm_mve.h.38.47b22bbd301ce82bc6dafd1a387f65a3
                           .group:00000000 wm4.arm_math_types.h.559.cab78f278b684a3ea2271947c7aea680
                           .group:00000000 wm4.arm_math_memory.h.28.fe8a81c6a9ac13061a5f748732089249
                           .group:00000000 wm4.none.h.185.db055cca83e83f96d8d0bb450fbdf4bb
                           .group:00000000 wm4.utils.h.27.57524573fe37b04009eecf3582a4c591
                           .group:00000000 wm4.fast_math_functions.h.28.8eb7477260c1d6b62047c49a01c4cbaa
                           .group:00000000 wm4.controller_functions.h.28.7bed7d7a726df2f65b8a3d89cff01247
                           .group:00000000 wm4.filtering_functions.h.46.6cf1424fb1f86d5f9958d208b83340a1
                           .group:00000000 wm4.postprocess_conf.h.22.0bc4dded16386cef3ff1f911e754ba56
                           .group:00000000 wm4.app.h.24.7f6e7e8163dd6f9007a01e8730a64482
                           .group:00000000 wm4.stdio.h.27.3fc80220048df77954e38daec3bb9670
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.stdio.h.47.dc31ec4674d7bcb103c9f08809549f45
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.87.a1e20d2651f9bfb66e51bfbe849db00a
                           .group:00000000 wm4.app_cam.h.19.2495a46447d71a1025370e29864418f5
                           .group:00000000 wm4.app_config.h.19.88dee04c97f3e42d3acfeeca22b174e5
                           .group:00000000 wm4.od_pp_output_if.h.11.62a3da738caf687aa42d96759c237b2c
                           .group:00000000 wm4.mpe_pp_output_if.h.11.db0dd5ceb87072354c56b51e8f9b2a0d
                           .group:00000000 wm4.pd_pp_output_if.h.19.b7de9bd1876930668a82409743b6dbf4
                           .group:00000000 wm4.spe_pp_output_if.h.11.7212d2990e83c8afeadfa97fa05d17c4
                           .group:00000000 wm4.iseg_pp_output_if.h.11.94ad86e1bcba0c03902fb099324716f2
                           .group:00000000 wm4.sseg_pp_output_if.h.11.caf00fb1ae24f8dc9c80bee7827b96f2
                           .group:00000000 wm4.app_postprocess.h.46.5719832142b7cbde626021bdb2b1e6d5
                           .group:00000000 wm4.isp_conf.h.21.bfb1d020517608810095aa56acf25d1e
                           .group:00000000 wm4.stm32n6xx_hal_conf.h.21.004a06df6e15ac197e03f723792da58a
                           .group:00000000 wm4.arm_cmse.h.103.a0d15a79c4c9a67da8d5831704d7248e
                           .group:00000000 wm4.stm32n6xx.h.34.80585dd08aa426c932f6311fdb7386da
                           .group:00000000 wm4.stm32n657xx.h.26.acd272cb67318cc1a4791ce2f0720ca6
                           .group:00000000 wm4.cmsis_version.h.32.0ac195c83bb4537824e6ad1c47474b79
                           .group:00000000 wm4.core_cm55.h.68.832d5cf835639cc0d28219c3d2867330
                           .group:00000000 wm4.core_cm55.h.196.52e437a270752da561676e507b35baeb
                           .group:00000000 wm4.mpu_armv8.h.32.9d72426c8e2b47753456dcb84802c5b3
                           .group:00000000 wm4.pmu_armv8.h.32.eaa95f88a71b29390b135fd81c071b6b
                           .group:00000000 wm4.core_cm55.h.4411.860dad8650880893dd57b815844f7186
                           .group:00000000 wm4.cachel1_armv7.h.32.abd77761a989e008b0c60891114a33c7
                           .group:00000000 wm4.stm32n657xx.h.575.1c2a5e6bedffc6f9083dcc857bc6d09d
                           .group:00000000 wm4.stm32n6xx.h.114.5cf793d8af485e14f110e3e24bde1aa5
                           .group:00000000 wm4.stm32_hal_legacy.h.22.87fb12bf5a1a1e00fc134f22bc9aa8c4
ARM GAS  /tmp/ccfH4MMM.s 			page 170


                           .group:00000000 wm4.stm32n6xx_hal_def.h.63.3a8f01490e8852464e9fcb69092e9c75
                           .group:00000000 wm4.stm32n6xx_ll_bus.h.38.2366a295ee4cdb04833997d3787fcd2d
                           .group:00000000 wm4.stm32n6xx_ll_rcc.h.21.002e22a16fd7f67dde6dce41e8ba9620
                           .group:00000000 wm4.stm32n6xx_hal_rcc.h.194.1cb1283e40f9bebcd3fba2a9a961838e
                           .group:00000000 wm4.stm32n6xx_hal_rcc_ex.h.21.79aa32178dfef625fbd20d362449acfa
                           .group:00000000 wm4.stm32n6xx_hal_rcc.h.4359.3f0b7ad33826d95438602c9aebc08af9
                           .group:00000000 wm4.stm32n6xx_hal_gpio.h.21.89d54af663b98eb8fc098192053f7eeb
                           .group:00000000 wm4.stm32n6xx_hal_gpio_ex.h.22.4acb2e3511a98bb48b81cfc8e09fd59e
                           .group:00000000 wm4.stm32n6xx_hal_rif.h.21.424d0bafb874a777dee3742a22e13037
                           .group:00000000 wm4.stm32n6xx_hal_dma.h.21.61e48c5c2e8d25d22177834b232fe45c
                           .group:00000000 wm4.stm32n6xx_hal_dma_ex.h.21.66e597beb090a165329d6ccf665e41bc
                           .group:00000000 wm4.stm32n6xx_hal_dma.h.1020.87e2180c009560b617c1f8208140c950
                           .group:00000000 wm4.stm32n6xx_hal_cortex.h.21.f493623cc58f9454ab4eae41e395c5cc
                           .group:00000000 wm4.stm32n6xx_hal_bsec.h.21.61b309e67dd810e28897a01b1b21a97f
                           .group:00000000 wm4.stm32n6xx_hal_dcmipp.h.21.f538bfd785c6469670251ac9bc7af55d
                           .group:00000000 wm4.stm32n6xx_hal_dma2d.h.21.75c8d46cdbb72970123b3f34ae2043d7
                           .group:00000000 wm4.stm32n6xx_hal_exti.h.21.fda87e715ea6b98239ec30171d1df594
                           .group:00000000 wm4.stm32n6xx_hal_gfxmmu.h.21.9784a9103143d48bd3c37389d0e0b8e6
                           .group:00000000 wm4.stm32n6xx_hal_i2c.h.21.3f483626ff64c5bf027265bb2e1d1331
                           .group:00000000 wm4.stm32n6xx_hal_i2c_ex.h.21.79e9196c22282cdaf6b4047893638c45
                           .group:00000000 wm4.stm32n6xx_hal_i2c.h.741.1084702632703acc669e4282b3043372
                           .group:00000000 wm4.stm32n6xx_hal_icache.h.21.194b4ec6e76f32b14f65c85616854850
                           .group:00000000 wm4.stm32n6xx_hal_ltdc.h.21.ae1eb09930e7e550e48e418ac5849e4d
                           .group:00000000 wm4.stm32n6xx_hal_ltdc.h.1002.b13ede7fc94ed5ad1c6768a157d2149a
                           .group:00000000 wm4.stm32n6xx_ll_usb.h.21.d518a5d97876c2ff49040c20a2c4a120
                           .group:00000000 wm4.stm32n6xx_hal_pcd.h.155.27040aac6844effe2af8c180caf1dd2e
                           .group:00000000 wm4.stm32n6xx_hal_pwr.h.21.cdb73e4869c3fed3fc84f901ec0e5f0a
                           .group:00000000 wm4.stm32n6xx_hal_pwr_ex.h.21.1a673224a58b0c1e5fad8eeda6514208
                           .group:00000000 wm4.stm32n6xx_hal_ramcfg.h.21.a62dfbb4d2c14e9a8c634a215e37bd3d
                           .group:00000000 wm4.stm32n6xx_hal_spi.h.21.9f810303326e2d91749800e9911f8e4d
                           .group:00000000 wm4.stm32n6xx_hal_spi.h.906.93ec0695066db4253cdbcb7d84358a0b
                           .group:00000000 wm4.stm32n6xx_hal_tim.h.21.839dd2b2a70382fb2c44f8f293a84d5f
                           .group:00000000 wm4.stm32n6xx_hal_tim_ex.h.21.e372d5ac63c13441211ea4ecbd353150
                           .group:00000000 wm4.stm32n6xx_hal_uart.h.21.230f549bfa0d5ebfd77bfb311b2aca15
                           .group:00000000 wm4.stm32n6xx_hal_uart_ex.h.21.a0d5511e1d0703b7b5278c8f5472b96d
                           .group:00000000 wm4.stm32n6xx_hal_xspi.h.21.e17898be2073b6b6b19faf30b4e304e9
                           .group:00000000 wm4.stm32n6xx_hal_cacheaxi.h.21.7c3375b7903ec42376e4883320997f74
                           .group:00000000 wm4.stm32n6xx_hal_gpu2d.h.21.48d0249122abad294a630c39cc4ebaed
                           .group:00000000 wm4.stm32n6xx_hal.h.81.5e59143eba07faca3e9aeaa5470826c8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.isp_core.h.109.be5387f515355b6edcb70af2607f9a68
                           .group:00000000 wm4.ld.h.19.0265bc80a0b44244ca0b5cbb3eb7cf16
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.assert.h.11.d99a111e320bc5106fc4046225782672
                           .group:00000000 wm4.ll_aton_config.h.20.79eb8be0291ee9086e6be08969d61846
                           .group:00000000 wm4.ll_aton_attributes.h.20.d1fce4a2519a8c4442db76dcb52b420f
                           .group:00000000 wm4.errno.h.2.ba016d646105af6cad23be83630b6a3f
                           .group:00000000 wm4.errno.h.9.ae5ea2b0ff9ea6e39e585807e35200d3
                           .group:00000000 wm4.ll_aton_util.h.34.9098eaa90d3d72b819973556e3e5fe44
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.FreeRTOSConfig.h.59.0e97f89e6eb1b28c12ea610dd500bb25
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
ARM GAS  /tmp/ccfH4MMM.s 			page 171


                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.queue.h.68.219f47fba8b59640449b84d04c5bd6d8
                           .group:00000000 wm4.semphr.h.40.c1a9c6f5bf0feb4da0b6a45d234a79d0
                           .group:00000000 wm4.ll_aton_platform.h.20.06ded592ee586a6abb6019a90ebd54df
                           .group:00000000 wm4.ll_aton_platform.h.288.664a74b8c5792a861b3d52bd39f4a693
                           .group:00000000 wm4.ATON.h.19.cf7dff4c0f1bfe90e42066f604751dc7
                           .group:00000000 wm4.ll_aton_rcompat.h.22.b2bd0d777466a5ac720f3b2429c5fea7
                           .group:00000000 wm4.ll_aton_platform.h.383.f09ccd502bb682b863f991d963ee7462
                           .group:00000000 wm4.ll_aton_osal_freertos.h.62.85a065f77def7f6fef26149f92fe1378
                           .group:00000000 wm4.ll_aton_osal.h.116.bc018513feb9b28713cf2afc78ec679b
                           .group:00000000 wm4.ll_aton_rt_user_api.h.71.e6b7f8d03b2c998f838260ad3cb6cd40
                           .group:00000000 wm4.cmw_errno.h.21.91021ac9b2627a1ce6b8517d105715d1
                           .group:00000000 wm4.stm32n6570_discovery_conf.h.21.f52c8202689527a3dc0d9c6cba9c0416
                           .group:00000000 wm4.stm32n6570_discovery_errno.h.22.80e523b09444a11ebe4b6e24ae914f0e
                           .group:00000000 wm4.stm32n6570_discovery_bus.h.62.3b5b2c6837f7adeb489604fa214cd371
                           .group:00000000 wm4.cmw_camera.h.33.b34cbb506ffb5bbc0bae0cee9fc48966
                           .group:00000000 wm4.stm32n6570_discovery.h.25.5fc3699797f7c334a2e25a2a6a563b07
                           .group:00000000 wm4.lcd.h.21.98701c105e66fef2e089854e5bc0fe32
                           .group:00000000 wm4.stm32_lcd.h.55.1a04e503950bf34ef3721d2ebb9542fc
                           .group:00000000 wm4.stm32_lcd_ex.h.21.eaf9c9c1000e162e58259e027110f2f5
                           .group:00000000 wm4.utils.h.19.2f7e4a8a839d9215c56961f5a9914d6d
                           .group:00000000 wm4.nema_sys_defs.h.24.0b35b5138cb9b4a3130f5d424bc2bcc0
                           .group:00000000 wm4.nema_hal.h.193.74a3b292db2bcbda0132dae40ae0f4e5
                           .group:00000000 wm4.nema_cmdlist.h.30.a652eb980f08f0ed22ad00119d504926
                           .group:00000000 wm4.nema_graphics.h.61.b3907f86eccb4e55a4b69e8aebdd3657
                           .group:00000000 wm4.nema_blender.h.30.fb13cc9231bd108bca212984b3a891e0
                           .group:00000000 wm4.nema_math.h.30.ef7265c89982f7dae18e3ec2d7f3d003
                           .group:00000000 wm4.nema_version.h.35.6aae27202c190348dff84b89d4c12df7
                           .group:00000000 wm4.nema_error.h.29.50848ed81d21ff4ae4b870fae3681118

UNDEFINED SYMBOLS
xQueueSemaphoreTake
__assert_func
CAM_IspUpdate
xQueueGenericSend
BSP_PB_GetState
cos
sin
UTIL_LCD_FillCircle
UTIL_LCD_DrawLine
ld_bindings_idx
memset
puts
nema_init
nema_get_error
nema_ext_hold_enable
nema_ext_hold_irq_enable
nema_get_sw_device_name
printf
HAL_GFXMMU_Init
HAL_GFXMMU_ConfigPacking
ARM GAS  /tmp/ccfH4MMM.s 			page 172


nema_cl_create_sized
nema_cl_bind_circular
LL_ATON_Output_Buffers_Info_yolo_detector
LL_ATON_Input_Buffers_Info_yolo_detector
app_postprocess_init
HAL_GetTick
CAM_NNPipe_Start
LL_ATON_Set_User_Input_Buffer_yolo_detector
LL_ATON_RT_Main
app_postprocess_run
UTIL_LCD_DrawRect
__aeabi_ul2d
BSP_PB_Init
memcpy
SCRL_SetAddress_NoReload
UTIL_LCD_FillRect
TIM4_Get_Value
ulTaskGetIdleRunTimeCounter
memmove
UTIL_LCD_GetFont
UTIL_LCDEx_PrintfAt
SCRL_ReloadLayer
SCRL_Init
UTIL_LCD_SetLayer
UTIL_LCD_Clear
UTIL_LCD_SetFont
UTIL_LCD_SetTextColor
xQueueCreateCountingSemaphoreStatic
vQueueDelete
CAM_Init
xQueueCreateMutexStatic
CAM_DisplayPipe_Start
xTaskCreateStatic
Font20
CMW_CAMERA_GetDCMIPPHandle
HAL_DCMIPP_PIPE_SetMemoryAddress
SRCL_Update
xPortIsInsideInterrupt
xQueueGiveFromISR
LL_ATON_EC_Network_Init_yolo_detector
LL_ATON_EC_Inference_Init_yolo_detector
LL_ATON_Get_User_Input_Buffer_yolo_detector
LL_ATON_Set_User_Output_Buffer_yolo_detector
LL_ATON_Get_User_Output_Buffer_yolo_detector
LL_ATON_EpochBlockItems_yolo_detector
LL_ATON_Internal_Buffers_Info_yolo_detector
